'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*!
 Stencil Mock Doc v2.9.0 | MIT Licensed | https://stenciljs.com
 */
const CONTENT_REF_ID = 'r';
const ORG_LOCATION_ID = 'o';
const SLOT_NODE_ID = 's';
const TEXT_NODE_ID = 't';
const XLINK_NS = 'http://www.w3.org/1999/xlink';

const attrHandler = {
  get(obj, prop) {
    if (prop in obj) {
      return obj[prop];
    }
    if (typeof prop !== 'symbol' && !isNaN(prop)) {
      return obj.__items[prop];
    }
    return undefined;
  },
};
const createAttributeProxy = caseInsensitive => new Proxy(new MockAttributeMap(caseInsensitive), attrHandler);
class MockAttributeMap {
  constructor(caseInsensitive = false) {
    this.caseInsensitive = caseInsensitive;
    this.__items = [];
  }
  get length() {
    return this.__items.length;
  }
  item(index) {
    return this.__items[index] || null;
  }
  setNamedItem(attr) {
    attr.namespaceURI = null;
    this.setNamedItemNS(attr);
  }
  setNamedItemNS(attr) {
    if (attr != null && attr.value != null) {
      attr.value = String(attr.value);
    }
    const existingAttr = this.__items.find(a => a.name === attr.name && a.namespaceURI === attr.namespaceURI);
    if (existingAttr != null) {
      existingAttr.value = attr.value;
    } else {
      this.__items.push(attr);
    }
  }
  getNamedItem(attrName) {
    if (this.caseInsensitive) {
      attrName = attrName.toLowerCase();
    }
    return this.getNamedItemNS(null, attrName);
  }
  getNamedItemNS(namespaceURI, attrName) {
    namespaceURI = getNamespaceURI(namespaceURI);
    return this.__items.find(attr => attr.name === attrName && getNamespaceURI(attr.namespaceURI) === namespaceURI) || null;
  }
  removeNamedItem(attr) {
    this.removeNamedItemNS(attr);
  }
  removeNamedItemNS(attr) {
    for (let i = 0, ii = this.__items.length; i < ii; i++) {
      if (this.__items[i].name === attr.name && this.__items[i].namespaceURI === attr.namespaceURI) {
        this.__items.splice(i, 1);
        break;
      }
    }
  }
  [Symbol.iterator]() {
    let i = 0;
    return {
      next: () => ({
        done: i === this.length,
        value: this.item(i++),
      }),
    };
  }
  get [Symbol.toStringTag]() {
    return 'MockAttributeMap';
  }
}
function getNamespaceURI(namespaceURI) {
  return namespaceURI === XLINK_NS ? null : namespaceURI;
}
function cloneAttributes(srcAttrs, sortByName = false) {
  const dstAttrs = new MockAttributeMap(srcAttrs.caseInsensitive);
  if (srcAttrs != null) {
    const attrLen = srcAttrs.length;
    if (sortByName && attrLen > 1) {
      const sortedAttrs = [];
      for (let i = 0; i < attrLen; i++) {
        const srcAttr = srcAttrs.item(i);
        const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
        sortedAttrs.push(dstAttr);
      }
      sortedAttrs.sort(sortAttributes).forEach(attr => {
        dstAttrs.setNamedItemNS(attr);
      });
    } else {
      for (let i = 0; i < attrLen; i++) {
        const srcAttr = srcAttrs.item(i);
        const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
        dstAttrs.setNamedItemNS(dstAttr);
      }
    }
  }
  return dstAttrs;
}
function sortAttributes(a, b) {
  if (a.name < b.name) return -1;
  if (a.name > b.name) return 1;
  return 0;
}
class MockAttr {
  constructor(attrName, attrValue, namespaceURI = null) {
    this._name = attrName;
    this._value = String(attrValue);
    this._namespaceURI = namespaceURI;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = String(value);
  }
  get nodeName() {
    return this._name;
  }
  set nodeName(value) {
    this._name = value;
  }
  get nodeValue() {
    return this._value;
  }
  set nodeValue(value) {
    this._value = String(value);
  }
  get namespaceURI() {
    return this._namespaceURI;
  }
  set namespaceURI(namespaceURI) {
    this._namespaceURI = namespaceURI;
  }
}

class MockCustomElementRegistry {
  constructor(win) {
    this.win = win;
  }
  define(tagName, cstr, options) {
    if (tagName.toLowerCase() !== tagName) {
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': "${tagName}" is not a valid custom element name`);
    }
    if (this.__registry == null) {
      this.__registry = new Map();
    }
    this.__registry.set(tagName, { cstr, options });
    if (this.__whenDefined != null) {
      const whenDefinedResolveFns = this.__whenDefined.get(tagName);
      if (whenDefinedResolveFns != null) {
        whenDefinedResolveFns.forEach(whenDefinedResolveFn => {
          whenDefinedResolveFn();
        });
        whenDefinedResolveFns.length = 0;
        this.__whenDefined.delete(tagName);
      }
    }
    const doc = this.win.document;
    if (doc != null) {
      const hosts = doc.querySelectorAll(tagName);
      hosts.forEach(host => {
        if (upgradedElements.has(host) === false) {
          tempDisableCallbacks.add(doc);
          const upgradedCmp = createCustomElement(this, doc, tagName);
          for (let i = 0; i < host.childNodes.length; i++) {
            const childNode = host.childNodes[i];
            childNode.remove();
            upgradedCmp.appendChild(childNode);
          }
          tempDisableCallbacks.delete(doc);
          if (proxyElements.has(host)) {
            proxyElements.set(host, upgradedCmp);
          }
        }
        fireConnectedCallback(host);
      });
    }
  }
  get(tagName) {
    if (this.__registry != null) {
      const def = this.__registry.get(tagName.toLowerCase());
      if (def != null) {
        return def.cstr;
      }
    }
    return undefined;
  }
  upgrade(_rootNode) {
    //
  }
  clear() {
    if (this.__registry != null) {
      this.__registry.clear();
    }
    if (this.__whenDefined != null) {
      this.__whenDefined.clear();
    }
  }
  whenDefined(tagName) {
    tagName = tagName.toLowerCase();
    if (this.__registry != null && this.__registry.has(tagName) === true) {
      return Promise.resolve();
    }
    return new Promise(resolve => {
      if (this.__whenDefined == null) {
        this.__whenDefined = new Map();
      }
      let whenDefinedResolveFns = this.__whenDefined.get(tagName);
      if (whenDefinedResolveFns == null) {
        whenDefinedResolveFns = [];
        this.__whenDefined.set(tagName, whenDefinedResolveFns);
      }
      whenDefinedResolveFns.push(resolve);
    });
  }
}
function createCustomElement(customElements, ownerDocument, tagName) {
  const Cstr = customElements.get(tagName);
  if (Cstr != null) {
    const cmp = new Cstr(ownerDocument);
    cmp.nodeName = tagName.toUpperCase();
    upgradedElements.add(cmp);
    return cmp;
  }
  const host = new Proxy(
    {},
    {
      get(obj, prop) {
        const elm = proxyElements.get(host);
        if (elm != null) {
          return elm[prop];
        }
        return obj[prop];
      },
      set(obj, prop, val) {
        const elm = proxyElements.get(host);
        if (elm != null) {
          elm[prop] = val;
        } else {
          obj[prop] = val;
        }
        return true;
      },
      has(obj, prop) {
        const elm = proxyElements.get(host);
        if (prop in elm) {
          return true;
        }
        if (prop in obj) {
          return true;
        }
        return false;
      },
    },
  );
  const elm = new MockHTMLElement(ownerDocument, tagName);
  proxyElements.set(host, elm);
  return host;
}
const proxyElements = new WeakMap();
const upgradedElements = new WeakSet();
function connectNode(ownerDocument, node) {
  node.ownerDocument = ownerDocument;
  if (node.nodeType === 1 /* ELEMENT_NODE */) {
    if (ownerDocument != null && node.nodeName.includes('-')) {
      const win = ownerDocument.defaultView;
      if (win != null && typeof node.connectedCallback === 'function' && node.isConnected) {
        fireConnectedCallback(node);
      }
      const shadowRoot = node.shadowRoot;
      if (shadowRoot != null) {
        shadowRoot.childNodes.forEach(childNode => {
          connectNode(ownerDocument, childNode);
        });
      }
    }
    node.childNodes.forEach(childNode => {
      connectNode(ownerDocument, childNode);
    });
  } else {
    node.childNodes.forEach(childNode => {
      childNode.ownerDocument = ownerDocument;
    });
  }
}
function fireConnectedCallback(node) {
  if (typeof node.connectedCallback === 'function') {
    if (tempDisableCallbacks.has(node.ownerDocument) === false) {
      try {
        node.connectedCallback();
      } catch (e) {
        console.error(e);
      }
    }
  }
}
function disconnectNode(node) {
  if (node.nodeType === 1 /* ELEMENT_NODE */) {
    if (node.nodeName.includes('-') === true && typeof node.disconnectedCallback === 'function') {
      if (tempDisableCallbacks.has(node.ownerDocument) === false) {
        try {
          node.disconnectedCallback();
        } catch (e) {
          console.error(e);
        }
      }
    }
    node.childNodes.forEach(disconnectNode);
  }
}
function attributeChanged(node, attrName, oldValue, newValue) {
  attrName = attrName.toLowerCase();
  const observedAttributes = node.constructor.observedAttributes;
  if (Array.isArray(observedAttributes) === true && observedAttributes.some(obs => obs.toLowerCase() === attrName) === true) {
    try {
      node.attributeChangedCallback(attrName, oldValue, newValue);
    } catch (e) {
      console.error(e);
    }
  }
}
function checkAttributeChanged(node) {
  return node.nodeName.includes('-') === true && typeof node.attributeChangedCallback === 'function';
}
const tempDisableCallbacks = new Set();

function dataset(elm) {
  const ds = {};
  const attributes = elm.attributes;
  const attrLen = attributes.length;
  for (let i = 0; i < attrLen; i++) {
    const attr = attributes.item(i);
    const nodeName = attr.nodeName;
    if (nodeName.startsWith('data-')) {
      ds[dashToPascalCase(nodeName)] = attr.nodeValue;
    }
  }
  return new Proxy(ds, {
    get(_obj, camelCaseProp) {
      return ds[camelCaseProp];
    },
    set(_obj, camelCaseProp, value) {
      const dataAttr = toDataAttribute(camelCaseProp);
      elm.setAttribute(dataAttr, value);
      return true;
    },
  });
}
function toDataAttribute(str) {
  return (
    'data-' +
    String(str)
      .replace(/([A-Z0-9])/g, g => ' ' + g[0])
      .trim()
      .replace(/ /g, '-')
      .toLowerCase()
  );
}
function dashToPascalCase(str) {
  str = String(str).substr(5);
  return str
    .split('-')
    .map((segment, index) => {
      if (index === 0) {
        return segment.charAt(0).toLowerCase() + segment.slice(1);
      }
      return segment.charAt(0).toUpperCase() + segment.slice(1);
    })
    .join('');
}

// Sizzle 2.3.6
const Sizzle = (function () {
  const window = {
    document: {
      createElement() {
        return {};
      },
      nodeType: 9,
      documentElement: {
        nodeType: 1,
        nodeName: 'HTML',
      },
    },
  };
  const module = { exports: {} };

  /*! Sizzle v2.3.6 | (c) JS Foundation and other contributors | js.foundation */
  !(function (e) {
    var t,
      n,
      r,
      i,
      o,
      u,
      l,
      a,
      c,
      s,
      d,
      f,
      p,
      h,
      g,
      m,
      y,
      v,
      w,
      b = 'sizzle' + 1 * new Date(),
      N = e.document,
      C = 0,
      x = 0,
      E = ae(),
      A = ae(),
      S = ae(),
      D = ae(),
      T = function (e, t) {
        return e === t && (d = !0), 0;
      },
      L = {}.hasOwnProperty,
      q = [],
      I = q.pop,
      B = q.push,
      R = q.push,
      $ = q.slice,
      k = function (e, t) {
        for (var n = 0, r = e.length; n < r; n++) if (e[n] === t) return n;
        return -1;
      },
      H = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',
      M = '[\\x20\\t\\r\\n\\f]',
      P = '(?:\\\\[\\da-fA-F]{1,6}' + M + '?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+',
      z = '\\[' + M + '*(' + P + ')(?:' + M + '*([*^$|!~]?=)' + M + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + P + '))|)' + M + '*\\]',
      F = ':(' + P + ')(?:\\(((\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|' + z + ')*)|.*)\\)|)',
      O = new RegExp(M + '+', 'g'),
      j = new RegExp('^' + M + '+|((?:^|[^\\\\])(?:\\\\.)*)' + M + '+$', 'g'),
      G = new RegExp('^' + M + '*,' + M + '*'),
      U = new RegExp('^' + M + '*([>+~]|' + M + ')' + M + '*'),
      V = new RegExp(M + '|>'),
      X = new RegExp(F),
      J = new RegExp('^' + P + '$'),
      K = {
        ID: new RegExp('^#(' + P + ')'),
        CLASS: new RegExp('^\\.(' + P + ')'),
        TAG: new RegExp('^(' + P + '|[*])'),
        ATTR: new RegExp('^' + z),
        PSEUDO: new RegExp('^' + F),
        CHILD: new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + M + '*(even|odd|(([+-]|)(\\d*)n|)' + M + '*(?:([+-]|)' + M + '*(\\d+)|))' + M + '*\\)|)', 'i'),
        bool: new RegExp('^(?:' + H + ')$', 'i'),
        needsContext: new RegExp('^' + M + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + M + '*((?:-\\d)?\\d*)' + M + '*\\)|)(?=[^-]|$)', 'i'),
      },
      Q = /HTML$/i,
      W = /^(?:input|select|textarea|button)$/i,
      Y = /^h\d$/i,
      Z = /^[^{]+\{\s*\[native \w/,
      _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
      ee = /[+~]/,
      te = new RegExp('\\\\[\\da-fA-F]{1,6}' + M + '?|\\\\([^\\r\\n\\f])', 'g'),
      ne = function (e, t) {
        var n = '0x' + e.slice(1) - 65536;
        return t || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode((n >> 10) | 55296, (1023 & n) | 56320));
      },
      re = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
      ie = function (e, t) {
        return t ? ('\0' === e ? '\ufffd' : e.slice(0, -1) + '\\' + e.charCodeAt(e.length - 1).toString(16) + ' ') : '\\' + e;
      },
      oe = function () {
        f();
      },
      ue = ve(
        function (e) {
          return !0 === e.disabled && 'fieldset' === e.nodeName.toLowerCase();
        },
        { dir: 'parentNode', next: 'legend' },
      );
    try {
      R.apply((q = $.call(N.childNodes)), N.childNodes), q[N.childNodes.length].nodeType;
    } catch (e) {
      R = {
        apply: q.length
          ? function (e, t) {
              B.apply(e, $.call(t));
            }
          : function (e, t) {
              var n = e.length,
                r = 0;
              while ((e[n++] = t[r++]));
              e.length = n - 1;
            },
      };
    }
    function le(e, t, r, i) {
      var o,
        l,
        c,
        s,
        d,
        h,
        y,
        v = t && t.ownerDocument,
        N = t ? t.nodeType : 9;
      if (((r = r || []), 'string' != typeof e || !e || (1 !== N && 9 !== N && 11 !== N))) return r;
      if (!i && (f(t), (t = t || p), g)) {
        if (11 !== N && (d = _.exec(e)))
          if ((o = d[1])) {
            if (9 === N) {
              if (!(c = t.getElementById(o))) return r;
              if (c.id === o) return r.push(c), r;
            } else if (v && (c = v.getElementById(o)) && w(t, c) && c.id === o) return r.push(c), r;
          } else {
            if (d[2]) return R.apply(r, t.getElementsByTagName(e)), r;
            if ((o = d[3]) && n.getElementsByClassName && t.getElementsByClassName) return R.apply(r, t.getElementsByClassName(o)), r;
          }
        if (n.qsa && !D[e + ' '] && (!m || !m.test(e)) && (1 !== N || 'object' !== t.nodeName.toLowerCase())) {
          if (((y = e), (v = t), 1 === N && (V.test(e) || U.test(e)))) {
            ((v = (ee.test(e) && ge(t.parentNode)) || t) === t && n.scope) || ((s = t.getAttribute('id')) ? (s = s.replace(re, ie)) : t.setAttribute('id', (s = b))),
              (l = (h = u(e)).length);
            while (l--) h[l] = (s ? '#' + s : ':scope') + ' ' + ye(h[l]);
            y = h.join(',');
          }
          try {
            return R.apply(r, v.querySelectorAll(y)), r;
          } catch (t) {
            D(e, !0);
          } finally {
            s === b && t.removeAttribute('id');
          }
        }
      }
      return a(e.replace(j, '$1'), t, r, i);
    }
    function ae() {
      var e = [];
      function t(n, i) {
        return e.push(n + ' ') > r.cacheLength && delete t[e.shift()], (t[n + ' '] = i);
      }
      return t;
    }
    function ce(e) {
      return (e[b] = !0), e;
    }
    function se(e) {
      var t = p.createElement('fieldset');
      try {
        return !!e(t);
      } catch (e) {
        return !1;
      } finally {
        t.parentNode && t.parentNode.removeChild(t), (t = null);
      }
    }
    function de(e, t) {
      var n = e.split('|'),
        i = n.length;
      while (i--) r.attrHandle[n[i]] = t;
    }
    function fe(e, t) {
      var n = t && e,
        r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
      if (r) return r;
      if (n) while ((n = n.nextSibling)) if (n === t) return -1;
      return e ? 1 : -1;
    }
    function pe(e) {
      return function (t) {
        return 'form' in t
          ? t.parentNode && !1 === t.disabled
            ? 'label' in t
              ? 'label' in t.parentNode
                ? t.parentNode.disabled === e
                : t.disabled === e
              : t.isDisabled === e || (t.isDisabled !== !e && ue(t) === e)
            : t.disabled === e
          : 'label' in t && t.disabled === e;
      };
    }
    function he(e) {
      return ce(function (t) {
        return (
          (t = +t),
          ce(function (n, r) {
            var i,
              o = e([], n.length, t),
              u = o.length;
            while (u--) n[(i = o[u])] && (n[i] = !(r[i] = n[i]));
          })
        );
      });
    }
    function ge(e) {
      return e && void 0 !== e.getElementsByTagName && e;
    }
    (n = le.support = {}),
      (o = le.isXML =
        function (e) {
          var t = e && e.namespaceURI,
            n = e && (e.ownerDocument || e).documentElement;
          return !Q.test(t || (n && n.nodeName) || 'HTML');
        }),
      (f = le.setDocument =
        function (e) {
          var t,
            i,
            u = e ? e.ownerDocument || e : N;
          return u != p && 9 === u.nodeType && u.documentElement
            ? ((p = u),
              (h = p.documentElement),
              (g = !o(p)),
              N != p && (i = p.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener('unload', oe, !1) : i.attachEvent && i.attachEvent('onunload', oe)),
              (n.scope = se(function (e) {
                return h.appendChild(e).appendChild(p.createElement('div')), void 0 !== e.querySelectorAll && !e.querySelectorAll(':scope fieldset div').length;
              })),
              (n.attributes = se(function (e) {
                return (e.className = 'i'), !e.getAttribute('className');
              })),
              (n.getElementsByTagName = se(function (e) {
                return e.appendChild(p.createComment('')), !e.getElementsByTagName('*').length;
              })),
              (n.getElementsByClassName = Z.test(p.getElementsByClassName)),
              (n.getById = se(function (e) {
                return (h.appendChild(e).id = b), !p.getElementsByName || !p.getElementsByName(b).length;
              })),
              n.getById
                ? ((r.filter.ID = function (e) {
                    var t = e.replace(te, ne);
                    return function (e) {
                      return e.getAttribute('id') === t;
                    };
                  }),
                  (r.find.ID = function (e, t) {
                    if (void 0 !== t.getElementById && g) {
                      var n = t.getElementById(e);
                      return n ? [n] : [];
                    }
                  }))
                : ((r.filter.ID = function (e) {
                    var t = e.replace(te, ne);
                    return function (e) {
                      var n = void 0 !== e.getAttributeNode && e.getAttributeNode('id');
                      return n && n.value === t;
                    };
                  }),
                  (r.find.ID = function (e, t) {
                    if (void 0 !== t.getElementById && g) {
                      var n,
                        r,
                        i,
                        o = t.getElementById(e);
                      if (o) {
                        if ((n = o.getAttributeNode('id')) && n.value === e) return [o];
                        (i = t.getElementsByName(e)), (r = 0);
                        while ((o = i[r++])) if ((n = o.getAttributeNode('id')) && n.value === e) return [o];
                      }
                      return [];
                    }
                  })),
              (r.find.TAG = n.getElementsByTagName
                ? function (e, t) {
                    return void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0;
                  }
                : function (e, t) {
                    var n,
                      r = [],
                      i = 0,
                      o = t.getElementsByTagName(e);
                    if ('*' === e) {
                      while ((n = o[i++])) 1 === n.nodeType && r.push(n);
                      return r;
                    }
                    return o;
                  }),
              (r.find.CLASS =
                n.getElementsByClassName &&
                function (e, t) {
                  if (void 0 !== t.getElementsByClassName && g) return t.getElementsByClassName(e);
                }),
              (y = []),
              (m = []),
              (n.qsa = Z.test(p.querySelectorAll)) &&
                (se(function (e) {
                  var t;
                  (h.appendChild(e).innerHTML = "<a id='" + b + "'></a><select id='" + b + "-\r\\' msallowcapture=''><option selected=''></option></select>"),
                    e.querySelectorAll("[msallowcapture^='']").length && m.push('[*^$]=' + M + '*(?:\'\'|"")'),
                    e.querySelectorAll('[selected]').length || m.push('\\[' + M + '*(?:value|' + H + ')'),
                    e.querySelectorAll('[id~=' + b + '-]').length || m.push('~='),
                    (t = p.createElement('input')).setAttribute('name', ''),
                    e.appendChild(t),
                    e.querySelectorAll("[name='']").length || m.push('\\[' + M + '*name' + M + '*=' + M + '*(?:\'\'|"")'),
                    e.querySelectorAll(':checked').length || m.push(':checked'),
                    e.querySelectorAll('a#' + b + '+*').length || m.push('.#.+[+~]'),
                    e.querySelectorAll('\\\f'),
                    m.push('[\\r\\n\\f]');
                }),
                se(function (e) {
                  e.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                  var t = p.createElement('input');
                  t.setAttribute('type', 'hidden'),
                    e.appendChild(t).setAttribute('name', 'D'),
                    e.querySelectorAll('[name=d]').length && m.push('name' + M + '*[*^$|!~]?='),
                    2 !== e.querySelectorAll(':enabled').length && m.push(':enabled', ':disabled'),
                    (h.appendChild(e).disabled = !0),
                    2 !== e.querySelectorAll(':disabled').length && m.push(':enabled', ':disabled'),
                    e.querySelectorAll('*,:x'),
                    m.push(',.*:');
                })),
              (n.matchesSelector = Z.test((v = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector))) &&
                se(function (e) {
                  (n.disconnectedMatch = v.call(e, '*')), v.call(e, "[s!='']:x"), y.push('!=', F);
                }),
              (m = m.length && new RegExp(m.join('|'))),
              (y = y.length && new RegExp(y.join('|'))),
              (t = Z.test(h.compareDocumentPosition)),
              (w =
                t || Z.test(h.contains)
                  ? function (e, t) {
                      var n = 9 === e.nodeType ? e.documentElement : e,
                        r = t && t.parentNode;
                      return e === r || !(!r || 1 !== r.nodeType || !(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r)));
                    }
                  : function (e, t) {
                      if (t) while ((t = t.parentNode)) if (t === e) return !0;
                      return !1;
                    }),
              (T = t
                ? function (e, t) {
                    if (e === t) return (d = !0), 0;
                    var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
                    return (
                      r ||
                      (1 & (r = (e.ownerDocument || e) == (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1) || (!n.sortDetached && t.compareDocumentPosition(e) === r)
                        ? e == p || (e.ownerDocument == N && w(N, e))
                          ? -1
                          : t == p || (t.ownerDocument == N && w(N, t))
                          ? 1
                          : s
                          ? k(s, e) - k(s, t)
                          : 0
                        : 4 & r
                        ? -1
                        : 1)
                    );
                  }
                : function (e, t) {
                    if (e === t) return (d = !0), 0;
                    var n,
                      r = 0,
                      i = e.parentNode,
                      o = t.parentNode,
                      u = [e],
                      l = [t];
                    if (!i || !o) return e == p ? -1 : t == p ? 1 : i ? -1 : o ? 1 : s ? k(s, e) - k(s, t) : 0;
                    if (i === o) return fe(e, t);
                    n = e;
                    while ((n = n.parentNode)) u.unshift(n);
                    n = t;
                    while ((n = n.parentNode)) l.unshift(n);
                    while (u[r] === l[r]) r++;
                    return r ? fe(u[r], l[r]) : u[r] == N ? -1 : l[r] == N ? 1 : 0;
                  }),
              p)
            : p;
        }),
      (le.matches = function (e, t) {
        return le(e, null, null, t);
      }),
      (le.matchesSelector = function (e, t) {
        if ((f(e), n.matchesSelector && g && !D[t + ' '] && (!y || !y.test(t)) && (!m || !m.test(t))))
          try {
            var r = v.call(e, t);
            if (r || n.disconnectedMatch || (e.document && 11 !== e.document.nodeType)) return r;
          } catch (e) {
            D(t, !0);
          }
        return le(t, p, null, [e]).length > 0;
      }),
      (le.contains = function (e, t) {
        return (e.ownerDocument || e) != p && f(e), w(e, t);
      }),
      (le.attr = function (e, t) {
        (e.ownerDocument || e) != p && f(e);
        var i = r.attrHandle[t.toLowerCase()],
          o = i && L.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !g) : void 0;
        return void 0 !== o ? o : n.attributes || !g ? e.getAttribute(t) : (o = e.getAttributeNode(t)) && o.specified ? o.value : null;
      }),
      (le.escape = function (e) {
        return (e + '').replace(re, ie);
      }),
      (le.error = function (e) {
        throw new Error('Syntax error, unrecognized expression: ' + e);
      }),
      (le.uniqueSort = function (e) {
        var t,
          r = [],
          i = 0,
          o = 0;
        if (((d = !n.detectDuplicates), (s = !n.sortStable && e.slice(0)), e.sort(T), d)) {
          while ((t = e[o++])) t === e[o] && (i = r.push(o));
          while (i--) e.splice(r[i], 1);
        }
        return (s = null), e;
      }),
      (i = le.getText =
        function (e) {
          var t,
            n = '',
            r = 0,
            o = e.nodeType;
          if (o) {
            if (1 === o || 9 === o || 11 === o) {
              if ('string' == typeof e.textContent) return e.textContent;
              for (e = e.firstChild; e; e = e.nextSibling) n += i(e);
            } else if (3 === o || 4 === o) return e.nodeValue;
          } else while ((t = e[r++])) n += i(t);
          return n;
        }),
      ((r = le.selectors =
        {
          cacheLength: 50,
          createPseudo: ce,
          match: K,
          attrHandle: {},
          find: {},
          relative: { '>': { dir: 'parentNode', first: !0 }, ' ': { dir: 'parentNode' }, '+': { dir: 'previousSibling', first: !0 }, '~': { dir: 'previousSibling' } },
          preFilter: {
            ATTR: function (e) {
              return (e[1] = e[1].replace(te, ne)), (e[3] = (e[3] || e[4] || e[5] || '').replace(te, ne)), '~=' === e[2] && (e[3] = ' ' + e[3] + ' '), e.slice(0, 4);
            },
            CHILD: function (e) {
              return (
                (e[1] = e[1].toLowerCase()),
                'nth' === e[1].slice(0, 3)
                  ? (e[3] || le.error(e[0]), (e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ('even' === e[3] || 'odd' === e[3]))), (e[5] = +(e[7] + e[8] || 'odd' === e[3])))
                  : e[3] && le.error(e[0]),
                e
              );
            },
            PSEUDO: function (e) {
              var t,
                n = !e[6] && e[2];
              return K.CHILD.test(e[0])
                ? null
                : (e[3]
                    ? (e[2] = e[4] || e[5] || '')
                    : n && X.test(n) && (t = u(n, !0)) && (t = n.indexOf(')', n.length - t) - n.length) && ((e[0] = e[0].slice(0, t)), (e[2] = n.slice(0, t))),
                  e.slice(0, 3));
            },
          },
          filter: {
            TAG: function (e) {
              var t = e.replace(te, ne).toLowerCase();
              return '*' === e
                ? function () {
                    return !0;
                  }
                : function (e) {
                    return e.nodeName && e.nodeName.toLowerCase() === t;
                  };
            },
            CLASS: function (e) {
              var t = E[e + ' '];
              return (
                t ||
                ((t = new RegExp('(^|' + M + ')' + e + '(' + M + '|$)')) &&
                  E(e, function (e) {
                    return t.test(('string' == typeof e.className && e.className) || (void 0 !== e.getAttribute && e.getAttribute('class')) || '');
                  }))
              );
            },
            ATTR: function (e, t, n) {
              return function (r) {
                var i = le.attr(r, e);
                return null == i
                  ? '!=' === t
                  : !t ||
                      ((i += ''),
                      '=' === t
                        ? i === n
                        : '!=' === t
                        ? i !== n
                        : '^=' === t
                        ? n && 0 === i.indexOf(n)
                        : '*=' === t
                        ? n && i.indexOf(n) > -1
                        : '$=' === t
                        ? n && i.slice(-n.length) === n
                        : '~=' === t
                        ? (' ' + i.replace(O, ' ') + ' ').indexOf(n) > -1
                        : '|=' === t && (i === n || i.slice(0, n.length + 1) === n + '-'));
              };
            },
            CHILD: function (e, t, n, r, i) {
              var o = 'nth' !== e.slice(0, 3),
                u = 'last' !== e.slice(-4),
                l = 'of-type' === t;
              return 1 === r && 0 === i
                ? function (e) {
                    return !!e.parentNode;
                  }
                : function (t, n, a) {
                    var c,
                      s,
                      d,
                      f,
                      p,
                      h,
                      g = o !== u ? 'nextSibling' : 'previousSibling',
                      m = t.parentNode,
                      y = l && t.nodeName.toLowerCase(),
                      v = !a && !l,
                      w = !1;
                    if (m) {
                      if (o) {
                        while (g) {
                          f = t;
                          while ((f = f[g])) if (l ? f.nodeName.toLowerCase() === y : 1 === f.nodeType) return !1;
                          h = g = 'only' === e && !h && 'nextSibling';
                        }
                        return !0;
                      }
                      if (((h = [u ? m.firstChild : m.lastChild]), u && v)) {
                        (w = (p = (c = (s = (d = (f = m)[b] || (f[b] = {}))[f.uniqueID] || (d[f.uniqueID] = {}))[e] || [])[0] === C && c[1]) && c[2]), (f = p && m.childNodes[p]);
                        while ((f = (++p && f && f[g]) || (w = p = 0) || h.pop()))
                          if (1 === f.nodeType && ++w && f === t) {
                            s[e] = [C, p, w];
                            break;
                          }
                      } else if ((v && (w = p = (c = (s = (d = (f = t)[b] || (f[b] = {}))[f.uniqueID] || (d[f.uniqueID] = {}))[e] || [])[0] === C && c[1]), !1 === w))
                        while ((f = (++p && f && f[g]) || (w = p = 0) || h.pop()))
                          if (
                            (l ? f.nodeName.toLowerCase() === y : 1 === f.nodeType) &&
                            ++w &&
                            (v && ((s = (d = f[b] || (f[b] = {}))[f.uniqueID] || (d[f.uniqueID] = {}))[e] = [C, w]), f === t)
                          )
                            break;
                      return (w -= i) === r || (w % r == 0 && w / r >= 0);
                    }
                  };
            },
            PSEUDO: function (e, t) {
              var n,
                i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || le.error('unsupported pseudo: ' + e);
              return i[b]
                ? i(t)
                : i.length > 1
                ? ((n = [e, e, '', t]),
                  r.setFilters.hasOwnProperty(e.toLowerCase())
                    ? ce(function (e, n) {
                        var r,
                          o = i(e, t),
                          u = o.length;
                        while (u--) e[(r = k(e, o[u]))] = !(n[r] = o[u]);
                      })
                    : function (e) {
                        return i(e, 0, n);
                      })
                : i;
            },
          },
          pseudos: {
            not: ce(function (e) {
              var t = [],
                n = [],
                r = l(e.replace(j, '$1'));
              return r[b]
                ? ce(function (e, t, n, i) {
                    var o,
                      u = r(e, null, i, []),
                      l = e.length;
                    while (l--) (o = u[l]) && (e[l] = !(t[l] = o));
                  })
                : function (e, i, o) {
                    return (t[0] = e), r(t, null, o, n), (t[0] = null), !n.pop();
                  };
            }),
            has: ce(function (e) {
              return function (t) {
                return le(e, t).length > 0;
              };
            }),
            contains: ce(function (e) {
              return (
                (e = e.replace(te, ne)),
                function (t) {
                  return (t.textContent || i(t)).indexOf(e) > -1;
                }
              );
            }),
            lang: ce(function (e) {
              return (
                J.test(e || '') || le.error('unsupported lang: ' + e),
                (e = e.replace(te, ne).toLowerCase()),
                function (t) {
                  var n;
                  do {
                    if ((n = g ? t.lang : t.getAttribute('xml:lang') || t.getAttribute('lang'))) return (n = n.toLowerCase()) === e || 0 === n.indexOf(e + '-');
                  } while ((t = t.parentNode) && 1 === t.nodeType);
                  return !1;
                }
              );
            }),
            target: function (t) {
              var n = e.location && e.location.hash;
              return n && n.slice(1) === t.id;
            },
            root: function (e) {
              return e === h;
            },
            focus: function (e) {
              return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
            },
            enabled: pe(!1),
            disabled: pe(!0),
            checked: function (e) {
              var t = e.nodeName.toLowerCase();
              return ('input' === t && !!e.checked) || ('option' === t && !!e.selected);
            },
            selected: function (e) {
              return e.parentNode && e.parentNode.selectedIndex, !0 === e.selected;
            },
            empty: function (e) {
              for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
              return !0;
            },
            parent: function (e) {
              return !r.pseudos.empty(e);
            },
            header: function (e) {
              return Y.test(e.nodeName);
            },
            input: function (e) {
              return W.test(e.nodeName);
            },
            button: function (e) {
              var t = e.nodeName.toLowerCase();
              return ('input' === t && 'button' === e.type) || 'button' === t;
            },
            text: function (e) {
              var t;
              return 'input' === e.nodeName.toLowerCase() && 'text' === e.type && (null == (t = e.getAttribute('type')) || 'text' === t.toLowerCase());
            },
            first: he(function () {
              return [0];
            }),
            last: he(function (e, t) {
              return [t - 1];
            }),
            eq: he(function (e, t, n) {
              return [n < 0 ? n + t : n];
            }),
            even: he(function (e, t) {
              for (var n = 0; n < t; n += 2) e.push(n);
              return e;
            }),
            odd: he(function (e, t) {
              for (var n = 1; n < t; n += 2) e.push(n);
              return e;
            }),
            lt: he(function (e, t, n) {
              for (var r = n < 0 ? n + t : n > t ? t : n; --r >= 0; ) e.push(r);
              return e;
            }),
            gt: he(function (e, t, n) {
              for (var r = n < 0 ? n + t : n; ++r < t; ) e.push(r);
              return e;
            }),
          },
        }).pseudos.nth = r.pseudos.eq);
    for (t in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 })
      r.pseudos[t] = (function (e) {
        return function (t) {
          return 'input' === t.nodeName.toLowerCase() && t.type === e;
        };
      })(t);
    for (t in { submit: !0, reset: !0 })
      r.pseudos[t] = (function (e) {
        return function (t) {
          var n = t.nodeName.toLowerCase();
          return ('input' === n || 'button' === n) && t.type === e;
        };
      })(t);
    function me() {}
    (me.prototype = r.filters = r.pseudos),
      (r.setFilters = new me()),
      (u = le.tokenize =
        function (e, t) {
          var n,
            i,
            o,
            u,
            l,
            a,
            c,
            s = A[e + ' '];
          if (s) return t ? 0 : s.slice(0);
          (l = e), (a = []), (c = r.preFilter);
          while (l) {
            (n && !(i = G.exec(l))) || (i && (l = l.slice(i[0].length) || l), a.push((o = []))),
              (n = !1),
              (i = U.exec(l)) && ((n = i.shift()), o.push({ value: n, type: i[0].replace(j, ' ') }), (l = l.slice(n.length)));
            for (u in r.filter) !(i = K[u].exec(l)) || (c[u] && !(i = c[u](i))) || ((n = i.shift()), o.push({ value: n, type: u, matches: i }), (l = l.slice(n.length)));
            if (!n) break;
          }
          return t ? l.length : l ? le.error(e) : A(e, a).slice(0);
        });
    function ye(e) {
      for (var t = 0, n = e.length, r = ''; t < n; t++) r += e[t].value;
      return r;
    }
    function ve(e, t, n) {
      var r = t.dir,
        i = t.next,
        o = i || r,
        u = n && 'parentNode' === o,
        l = x++;
      return t.first
        ? function (t, n, i) {
            while ((t = t[r])) if (1 === t.nodeType || u) return e(t, n, i);
            return !1;
          }
        : function (t, n, a) {
            var c,
              s,
              d,
              f = [C, l];
            if (a) {
              while ((t = t[r])) if ((1 === t.nodeType || u) && e(t, n, a)) return !0;
            } else
              while ((t = t[r]))
                if (1 === t.nodeType || u)
                  if (((d = t[b] || (t[b] = {})), (s = d[t.uniqueID] || (d[t.uniqueID] = {})), i && i === t.nodeName.toLowerCase())) t = t[r] || t;
                  else {
                    if ((c = s[o]) && c[0] === C && c[1] === l) return (f[2] = c[2]);
                    if (((s[o] = f), (f[2] = e(t, n, a)))) return !0;
                  }
            return !1;
          };
    }
    function we(e) {
      return e.length > 1
        ? function (t, n, r) {
            var i = e.length;
            while (i--) if (!e[i](t, n, r)) return !1;
            return !0;
          }
        : e[0];
    }
    function be(e, t, n) {
      for (var r = 0, i = t.length; r < i; r++) le(e, t[r], n);
      return n;
    }
    function Ne(e, t, n, r, i) {
      for (var o, u = [], l = 0, a = e.length, c = null != t; l < a; l++) (o = e[l]) && ((n && !n(o, r, i)) || (u.push(o), c && t.push(l)));
      return u;
    }
    function Ce(e, t, n, r, i, o) {
      return (
        r && !r[b] && (r = Ce(r)),
        i && !i[b] && (i = Ce(i, o)),
        ce(function (o, u, l, a) {
          var c,
            s,
            d,
            f = [],
            p = [],
            h = u.length,
            g = o || be(t || '*', l.nodeType ? [l] : l, []),
            m = !e || (!o && t) ? g : Ne(g, f, e, l, a),
            y = n ? (i || (o ? e : h || r) ? [] : u) : m;
          if ((n && n(m, y, l, a), r)) {
            (c = Ne(y, p)), r(c, [], l, a), (s = c.length);
            while (s--) (d = c[s]) && (y[p[s]] = !(m[p[s]] = d));
          }
          if (o) {
            if (i || e) {
              if (i) {
                (c = []), (s = y.length);
                while (s--) (d = y[s]) && c.push((m[s] = d));
                i(null, (y = []), c, a);
              }
              s = y.length;
              while (s--) (d = y[s]) && (c = i ? k(o, d) : f[s]) > -1 && (o[c] = !(u[c] = d));
            }
          } else (y = Ne(y === u ? y.splice(h, y.length) : y)), i ? i(null, u, y, a) : R.apply(u, y);
        })
      );
    }
    function xe(e) {
      for (
        var t,
          n,
          i,
          o = e.length,
          u = r.relative[e[0].type],
          l = u || r.relative[' '],
          a = u ? 1 : 0,
          s = ve(
            function (e) {
              return e === t;
            },
            l,
            !0,
          ),
          d = ve(
            function (e) {
              return k(t, e) > -1;
            },
            l,
            !0,
          ),
          f = [
            function (e, n, r) {
              var i = (!u && (r || n !== c)) || ((t = n).nodeType ? s(e, n, r) : d(e, n, r));
              return (t = null), i;
            },
          ];
        a < o;
        a++
      )
        if ((n = r.relative[e[a].type])) f = [ve(we(f), n)];
        else {
          if ((n = r.filter[e[a].type].apply(null, e[a].matches))[b]) {
            for (i = ++a; i < o; i++) if (r.relative[e[i].type]) break;
            return Ce(
              a > 1 && we(f),
              a > 1 && ye(e.slice(0, a - 1).concat({ value: ' ' === e[a - 2].type ? '*' : '' })).replace(j, '$1'),
              n,
              a < i && xe(e.slice(a, i)),
              i < o && xe((e = e.slice(i))),
              i < o && ye(e),
            );
          }
          f.push(n);
        }
      return we(f);
    }
    function Ee(e, t) {
      var n = t.length > 0,
        i = e.length > 0,
        o = function (o, u, l, a, s) {
          var d,
            h,
            m,
            y = 0,
            v = '0',
            w = o && [],
            b = [],
            N = c,
            x = o || (i && r.find.TAG('*', s)),
            E = (C += null == N ? 1 : Math.random() || 0.1),
            A = x.length;
          for (s && (c = u == p || u || s); v !== A && null != (d = x[v]); v++) {
            if (i && d) {
              (h = 0), u || d.ownerDocument == p || (f(d), (l = !g));
              while ((m = e[h++]))
                if (m(d, u || p, l)) {
                  a.push(d);
                  break;
                }
              s && (C = E);
            }
            n && ((d = !m && d) && y--, o && w.push(d));
          }
          if (((y += v), n && v !== y)) {
            h = 0;
            while ((m = t[h++])) m(w, b, u, l);
            if (o) {
              if (y > 0) while (v--) w[v] || b[v] || (b[v] = I.call(a));
              b = Ne(b);
            }
            R.apply(a, b), s && !o && b.length > 0 && y + t.length > 1 && le.uniqueSort(a);
          }
          return s && ((C = E), (c = N)), w;
        };
      return n ? ce(o) : o;
    }
    (l = le.compile =
      function (e, t) {
        var n,
          r = [],
          i = [],
          o = S[e + ' '];
        if (!o) {
          t || (t = u(e)), (n = t.length);
          while (n--) (o = xe(t[n]))[b] ? r.push(o) : i.push(o);
          (o = S(e, Ee(i, r))).selector = e;
        }
        return o;
      }),
      (a = le.select =
        function (e, t, n, i) {
          var o,
            a,
            c,
            s,
            d,
            f = 'function' == typeof e && e,
            p = !i && u((e = f.selector || e));
          if (((n = n || []), 1 === p.length)) {
            if ((a = p[0] = p[0].slice(0)).length > 2 && 'ID' === (c = a[0]).type && 9 === t.nodeType && g && r.relative[a[1].type]) {
              if (!(t = (r.find.ID(c.matches[0].replace(te, ne), t) || [])[0])) return n;
              f && (t = t.parentNode), (e = e.slice(a.shift().value.length));
            }
            o = K.needsContext.test(e) ? 0 : a.length;
            while (o--) {
              if (((c = a[o]), r.relative[(s = c.type)])) break;
              if ((d = r.find[s]) && (i = d(c.matches[0].replace(te, ne), (ee.test(a[0].type) && ge(t.parentNode)) || t))) {
                if ((a.splice(o, 1), !(e = i.length && ye(a)))) return R.apply(n, i), n;
                break;
              }
            }
          }
          return (f || l(e, p))(i, t, !g, n, !t || (ee.test(e) && ge(t.parentNode)) || t), n;
        }),
      (n.sortStable = b.split('').sort(T).join('') === b),
      (n.detectDuplicates = !!d),
      f(),
      (n.sortDetached = se(function (e) {
        return 1 & e.compareDocumentPosition(p.createElement('fieldset'));
      })),
      se(function (e) {
        return (e.innerHTML = "<a href='#'></a>"), '#' === e.firstChild.getAttribute('href');
      }) ||
        de('type|href|height|width', function (e, t, n) {
          if (!n) return e.getAttribute(t, 'type' === t.toLowerCase() ? 1 : 2);
        }),
      (n.attributes &&
        se(function (e) {
          return (e.innerHTML = '<input/>'), e.firstChild.setAttribute('value', ''), '' === e.firstChild.getAttribute('value');
        })) ||
        de('value', function (e, t, n) {
          if (!n && 'input' === e.nodeName.toLowerCase()) return e.defaultValue;
        }),
      se(function (e) {
        return null == e.getAttribute('disabled');
      }) ||
        de(H, function (e, t, n) {
          var r;
          if (!n) return !0 === e[t] ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value : null;
        });
    var Ae = e.Sizzle;
    (le.noConflict = function () {
      return e.Sizzle === le && (e.Sizzle = Ae), le;
    }),
      'function' == typeof define && define.amd
        ? define(function () {
            return le;
          })
        : 'undefined' != typeof module && module.exports
        ? (module.exports = le)
        : (e.Sizzle = le);
  })(window);
  //# sourceMappingURL=sizzle.min.map

  return module.exports;
})();

function matches(selector, elm) {
  const r = Sizzle.matches(selector, [elm]);
  return r.length > 0;
}
function selectOne(selector, elm) {
  const r = Sizzle(selector, elm);
  return r[0] || null;
}
function selectAll(selector, elm) {
  return Sizzle(selector, elm);
}

class MockClassList {
  constructor(elm) {
    this.elm = elm;
  }
  add(...classNames) {
    const clsNames = getItems(this.elm);
    let updated = false;
    classNames.forEach(className => {
      className = String(className);
      validateClass(className);
      if (clsNames.includes(className) === false) {
        clsNames.push(className);
        updated = true;
      }
    });
    if (updated) {
      this.elm.setAttributeNS(null, 'class', clsNames.join(' '));
    }
  }
  remove(...classNames) {
    const clsNames = getItems(this.elm);
    let updated = false;
    classNames.forEach(className => {
      className = String(className);
      validateClass(className);
      const index = clsNames.indexOf(className);
      if (index > -1) {
        clsNames.splice(index, 1);
        updated = true;
      }
    });
    if (updated) {
      this.elm.setAttributeNS(null, 'class', clsNames.filter(c => c.length > 0).join(' '));
    }
  }
  contains(className) {
    className = String(className);
    return getItems(this.elm).includes(className);
  }
  toggle(className) {
    className = String(className);
    if (this.contains(className) === true) {
      this.remove(className);
    } else {
      this.add(className);
    }
  }
  get length() {
    return getItems(this.elm).length;
  }
  item(index) {
    return getItems(this.elm)[index];
  }
  toString() {
    return getItems(this.elm).join(' ');
  }
}
function validateClass(className) {
  if (className === '') {
    throw new Error('The token provided must not be empty.');
  }
  if (/\s/.test(className)) {
    throw new Error(`The token provided ('${className}') contains HTML space characters, which are not valid in tokens.`);
  }
}
function getItems(elm) {
  const className = elm.getAttribute('class');
  if (typeof className === 'string' && className.length > 0) {
    return className
      .trim()
      .split(' ')
      .filter(c => c.length > 0);
  }
  return [];
}

class MockCSSStyleDeclaration {
  constructor() {
    this._styles = new Map();
  }
  setProperty(prop, value) {
    prop = jsCaseToCssCase(prop);
    if (value == null || value === '') {
      this._styles.delete(prop);
    } else {
      this._styles.set(prop, String(value));
    }
  }
  getPropertyValue(prop) {
    prop = jsCaseToCssCase(prop);
    return String(this._styles.get(prop) || '');
  }
  removeProperty(prop) {
    prop = jsCaseToCssCase(prop);
    this._styles.delete(prop);
  }
  get length() {
    return this._styles.size;
  }
  get cssText() {
    const cssText = [];
    this._styles.forEach((value, prop) => {
      cssText.push(`${prop}: ${value};`);
    });
    return cssText.join(' ').trim();
  }
  set cssText(cssText) {
    if (cssText == null || cssText === '') {
      this._styles.clear();
      return;
    }
    cssText.split(';').forEach(rule => {
      rule = rule.trim();
      if (rule.length > 0) {
        const splt = rule.split(':');
        if (splt.length > 1) {
          const prop = splt[0].trim();
          const value = splt[1].trim();
          if (prop !== '' && value !== '') {
            this._styles.set(jsCaseToCssCase(prop), value);
          }
        }
      }
    });
  }
}
function createCSSStyleDeclaration() {
  return new Proxy(new MockCSSStyleDeclaration(), cssProxyHandler);
}
const cssProxyHandler = {
  get(cssStyle, prop) {
    if (prop in cssStyle) {
      return cssStyle[prop];
    }
    prop = cssCaseToJsCase(prop);
    return cssStyle.getPropertyValue(prop);
  },
  set(cssStyle, prop, value) {
    if (prop in cssStyle) {
      cssStyle[prop] = value;
    } else {
      cssStyle.setProperty(prop, value);
    }
    return true;
  },
};
function cssCaseToJsCase(str) {
  // font-size to fontSize
  if (str.length > 1 && str.includes('-') === true) {
    str = str
      .toLowerCase()
      .split('-')
      .map(segment => segment.charAt(0).toUpperCase() + segment.slice(1))
      .join('');
    str = str.substr(0, 1).toLowerCase() + str.substr(1);
  }
  return str;
}
function jsCaseToCssCase(str) {
  // fontSize to font-size
  if (str.length > 1 && str.includes('-') === false && /[A-Z]/.test(str) === true) {
    str = str
      .replace(/([A-Z])/g, g => ' ' + g[0])
      .trim()
      .replace(/ /g, '-')
      .toLowerCase();
  }
  return str;
}

class MockEvent {
  constructor(type, eventInitDict) {
    this.bubbles = false;
    this.cancelBubble = false;
    this.cancelable = false;
    this.composed = false;
    this.currentTarget = null;
    this.defaultPrevented = false;
    this.srcElement = null;
    this.target = null;
    if (typeof type !== 'string') {
      throw new Error(`Event type required`);
    }
    this.type = type;
    this.timeStamp = Date.now();
    if (eventInitDict != null) {
      Object.assign(this, eventInitDict);
    }
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
  stopPropagation() {
    this.cancelBubble = true;
  }
  stopImmediatePropagation() {
    this.cancelBubble = true;
  }
}
class MockCustomEvent extends MockEvent {
  constructor(type, customEventInitDic) {
    super(type);
    this.detail = null;
    if (customEventInitDic != null) {
      Object.assign(this, customEventInitDic);
    }
  }
}
class MockKeyboardEvent extends MockEvent {
  constructor(type, keyboardEventInitDic) {
    super(type);
    this.code = '';
    this.key = '';
    this.altKey = false;
    this.ctrlKey = false;
    this.metaKey = false;
    this.shiftKey = false;
    this.location = 0;
    this.repeat = false;
    if (keyboardEventInitDic != null) {
      Object.assign(this, keyboardEventInitDic);
    }
  }
}
class MockMouseEvent extends MockEvent {
  constructor(type, mouseEventInitDic) {
    super(type);
    this.screenX = 0;
    this.screenY = 0;
    this.clientX = 0;
    this.clientY = 0;
    this.ctrlKey = false;
    this.shiftKey = false;
    this.altKey = false;
    this.metaKey = false;
    this.button = 0;
    this.buttons = 0;
    this.relatedTarget = null;
    if (mouseEventInitDic != null) {
      Object.assign(this, mouseEventInitDic);
    }
  }
}
class MockEventListener {
  constructor(type, handler) {
    this.type = type;
    this.handler = handler;
  }
}
function addEventListener(elm, type, handler) {
  const target = elm;
  if (target.__listeners == null) {
    target.__listeners = [];
  }
  target.__listeners.push(new MockEventListener(type, handler));
}
function removeEventListener(elm, type, handler) {
  const target = elm;
  if (target != null && Array.isArray(target.__listeners) === true) {
    const elmListener = target.__listeners.find(e => e.type === type && e.handler === handler);
    if (elmListener != null) {
      const index = target.__listeners.indexOf(elmListener);
      target.__listeners.splice(index, 1);
    }
  }
}
function resetEventListeners(target) {
  if (target != null && target.__listeners != null) {
    target.__listeners = null;
  }
}
function triggerEventListener(elm, ev) {
  if (elm == null || ev.cancelBubble === true) {
    return;
  }
  const target = elm;
  ev.currentTarget = elm;
  if (Array.isArray(target.__listeners) === true) {
    const listeners = target.__listeners.filter(e => e.type === ev.type);
    listeners.forEach(listener => {
      try {
        listener.handler.call(target, ev);
      } catch (err) {
        console.error(err);
      }
    });
  }
  if (ev.bubbles === false) {
    return;
  }
  if (elm.nodeName === '#document' /* DOCUMENT_NODE */) {
    triggerEventListener(elm.defaultView, ev);
  } else {
    triggerEventListener(elm.parentElement, ev);
  }
}
function dispatchEvent(currentTarget, ev) {
  ev.target = currentTarget;
  triggerEventListener(currentTarget, ev);
  return true;
}

function serializeNodeToHtml(elm, opts = {}) {
  const output = {
    currentLineWidth: 0,
    indent: 0,
    isWithinBody: false,
    text: [],
  };
  if (opts.prettyHtml) {
    if (typeof opts.indentSpaces !== 'number') {
      opts.indentSpaces = 2;
    }
    if (typeof opts.newLines !== 'boolean') {
      opts.newLines = true;
    }
    opts.approximateLineWidth = -1;
  } else {
    opts.prettyHtml = false;
    if (typeof opts.newLines !== 'boolean') {
      opts.newLines = false;
    }
    if (typeof opts.indentSpaces !== 'number') {
      opts.indentSpaces = 0;
    }
  }
  if (typeof opts.approximateLineWidth !== 'number') {
    opts.approximateLineWidth = -1;
  }
  if (typeof opts.removeEmptyAttributes !== 'boolean') {
    opts.removeEmptyAttributes = true;
  }
  if (typeof opts.removeAttributeQuotes !== 'boolean') {
    opts.removeAttributeQuotes = false;
  }
  if (typeof opts.removeBooleanAttributeQuotes !== 'boolean') {
    opts.removeBooleanAttributeQuotes = false;
  }
  if (typeof opts.removeHtmlComments !== 'boolean') {
    opts.removeHtmlComments = false;
  }
  if (typeof opts.serializeShadowRoot !== 'boolean') {
    opts.serializeShadowRoot = false;
  }
  if (opts.outerHtml) {
    serializeToHtml(elm, opts, output, false);
  } else {
    for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
      serializeToHtml(elm.childNodes[i], opts, output, false);
    }
  }
  if (output.text[0] === '\n') {
    output.text.shift();
  }
  if (output.text[output.text.length - 1] === '\n') {
    output.text.pop();
  }
  return output.text.join('');
}
function serializeToHtml(node, opts, output, isShadowRoot) {
  if (node.nodeType === 1 /* ELEMENT_NODE */ || isShadowRoot) {
    const tagName = isShadowRoot ? 'mock:shadow-root' : getTagName(node);
    if (tagName === 'body') {
      output.isWithinBody = true;
    }
    const ignoreTag = opts.excludeTags != null && opts.excludeTags.includes(tagName);
    if (ignoreTag === false) {
      const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
      if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
        output.text.push('\n');
        output.currentLineWidth = 0;
      }
      if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
        for (let i = 0; i < output.indent; i++) {
          output.text.push(' ');
        }
        output.currentLineWidth += output.indent;
      }
      output.text.push('<' + tagName);
      output.currentLineWidth += tagName.length + 1;
      const attrsLength = node.attributes.length;
      const attributes = opts.prettyHtml && attrsLength > 1 ? cloneAttributes(node.attributes, true) : node.attributes;
      for (let i = 0; i < attrsLength; i++) {
        const attr = attributes.item(i);
        const attrName = attr.name;
        if (attrName === 'style') {
          continue;
        }
        let attrValue = attr.value;
        if (opts.removeEmptyAttributes && attrValue === '' && REMOVE_EMPTY_ATTR.has(attrName)) {
          continue;
        }
        const attrNamespaceURI = attr.namespaceURI;
        if (attrNamespaceURI == null) {
          output.currentLineWidth += attrName.length + 1;
          if (opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
            output.text.push('\n' + attrName);
            output.currentLineWidth = 0;
          } else {
            output.text.push(' ' + attrName);
          }
        } else if (attrNamespaceURI === 'http://www.w3.org/XML/1998/namespace') {
          output.text.push(' xml:' + attrName);
          output.currentLineWidth += attrName.length + 5;
        } else if (attrNamespaceURI === 'http://www.w3.org/2000/xmlns/') {
          if (attrName !== 'xmlns') {
            output.text.push(' xmlns:' + attrName);
            output.currentLineWidth += attrName.length + 7;
          } else {
            output.text.push(' ' + attrName);
            output.currentLineWidth += attrName.length + 1;
          }
        } else if (attrNamespaceURI === XLINK_NS) {
          output.text.push(' xlink:' + attrName);
          output.currentLineWidth += attrName.length + 7;
        } else {
          output.text.push(' ' + attrNamespaceURI + ':' + attrName);
          output.currentLineWidth += attrNamespaceURI.length + attrName.length + 2;
        }
        if (opts.prettyHtml && attrName === 'class') {
          attrValue = attr.value = attrValue
            .split(' ')
            .filter(t => t !== '')
            .sort()
            .join(' ')
            .trim();
        }
        if (attrValue === '') {
          if (opts.removeBooleanAttributeQuotes && BOOLEAN_ATTR.has(attrName)) {
            continue;
          }
          if (opts.removeEmptyAttributes && attrName.startsWith('data-')) {
            continue;
          }
        }
        if (opts.removeAttributeQuotes && CAN_REMOVE_ATTR_QUOTES.test(attrValue)) {
          output.text.push('=' + escapeString(attrValue, true));
          output.currentLineWidth += attrValue.length + 1;
        } else {
          output.text.push('="' + escapeString(attrValue, true) + '"');
          output.currentLineWidth += attrValue.length + 3;
        }
      }
      if (node.hasAttribute('style')) {
        const cssText = node.style.cssText;
        if (opts.approximateLineWidth > 0 && output.currentLineWidth + cssText.length + 10 > opts.approximateLineWidth) {
          output.text.push(`\nstyle="${cssText}">`);
          output.currentLineWidth = 0;
        } else {
          output.text.push(` style="${cssText}">`);
          output.currentLineWidth += cssText.length + 10;
        }
      } else {
        output.text.push('>');
        output.currentLineWidth += 1;
      }
    }
    if (EMPTY_ELEMENTS.has(tagName) === false) {
      if (opts.serializeShadowRoot && node.shadowRoot != null) {
        output.indent = output.indent + opts.indentSpaces;
        serializeToHtml(node.shadowRoot, opts, output, true);
        output.indent = output.indent - opts.indentSpaces;
        if (
          opts.newLines &&
          (node.childNodes.length === 0 || (node.childNodes.length === 1 && node.childNodes[0].nodeType === 3 /* TEXT_NODE */ && node.childNodes[0].nodeValue.trim() === ''))
        ) {
          output.text.push('\n');
          output.currentLineWidth = 0;
          for (let i = 0; i < output.indent; i++) {
            output.text.push(' ');
          }
          output.currentLineWidth += output.indent;
        }
      }
      if (opts.excludeTagContent == null || opts.excludeTagContent.includes(tagName) === false) {
        const childNodes = tagName === 'template' ? node.content.childNodes : node.childNodes;
        const childNodeLength = childNodes.length;
        if (childNodeLength > 0) {
          if (childNodeLength === 1 && childNodes[0].nodeType === 3 /* TEXT_NODE */ && (typeof childNodes[0].nodeValue !== 'string' || childNodes[0].nodeValue.trim() === ''));
          else {
            const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
            if (!isWithinWhitespaceSensitiveNode && opts.indentSpaces > 0 && ignoreTag === false) {
              output.indent = output.indent + opts.indentSpaces;
            }
            for (let i = 0; i < childNodeLength; i++) {
              serializeToHtml(childNodes[i], opts, output, false);
            }
            if (ignoreTag === false) {
              if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
                output.text.push('\n');
                output.currentLineWidth = 0;
              }
              if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
                output.indent = output.indent - opts.indentSpaces;
                for (let i = 0; i < output.indent; i++) {
                  output.text.push(' ');
                }
                output.currentLineWidth += output.indent;
              }
            }
          }
        }
        if (ignoreTag === false) {
          output.text.push('</' + tagName + '>');
          output.currentLineWidth += tagName.length + 3;
        }
      }
    }
    if (opts.approximateLineWidth > 0 && STRUCTURE_ELEMENTS.has(tagName)) {
      output.text.push('\n');
      output.currentLineWidth = 0;
    }
    if (tagName === 'body') {
      output.isWithinBody = false;
    }
  } else if (node.nodeType === 3 /* TEXT_NODE */) {
    let textContent = node.nodeValue;
    if (typeof textContent === 'string') {
      const trimmedTextContent = textContent.trim();
      if (trimmedTextContent === '') {
        // this text node is whitespace only
        if (isWithinWhitespaceSensitive(node)) {
          // whitespace matters within this element
          // just add the exact text we were given
          output.text.push(textContent);
          output.currentLineWidth += textContent.length;
        } else if (opts.approximateLineWidth > 0 && !output.isWithinBody);
        else if (!opts.prettyHtml) {
          // this text node is only whitespace, and it's not
          // within a whitespace sensitive element like <pre> or <code>
          // so replace the entire white space with a single new line
          output.currentLineWidth += 1;
          if (opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
            // good enough for a new line
            // for perf these are all just estimates
            // we don't care to ensure exact line lengths
            output.text.push('\n');
            output.currentLineWidth = 0;
          } else {
            // let's keep it all on the same line yet
            output.text.push(' ');
          }
        }
      } else {
        // this text node has text content
        const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 || opts.prettyHtml ? isWithinWhitespaceSensitive(node) : false;
        if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
          output.text.push('\n');
          output.currentLineWidth = 0;
        }
        if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
          for (let i = 0; i < output.indent; i++) {
            output.text.push(' ');
          }
          output.currentLineWidth += output.indent;
        }
        let textContentLength = textContent.length;
        if (textContentLength > 0) {
          // this text node has text content
          const parentTagName = node.parentNode != null && node.parentNode.nodeType === 1 /* ELEMENT_NODE */ ? node.parentNode.nodeName : null;
          if (NON_ESCAPABLE_CONTENT.has(parentTagName)) {
            // this text node cannot have its content escaped since it's going
            // into an element like <style> or <script>
            if (isWithinWhitespaceSensitive(node)) {
              output.text.push(textContent);
            } else {
              output.text.push(trimmedTextContent);
              textContentLength = trimmedTextContent.length;
            }
            output.currentLineWidth += textContentLength;
          } else {
            // this text node is going into a normal element and html can be escaped
            if (opts.prettyHtml && !isWithinWhitespaceSensitiveNode) {
              // pretty print the text node
              output.text.push(escapeString(textContent.replace(/\s\s+/g, ' ').trim(), false));
              output.currentLineWidth += textContentLength;
            } else {
              // not pretty printing the text node
              if (isWithinWhitespaceSensitive(node)) {
                output.currentLineWidth += textContentLength;
              } else {
                // this element is not a whitespace sensitive one, like <pre> or <code> so
                // any whitespace at the start and end can be cleaned up to just be one space
                if (/\s/.test(textContent.charAt(0))) {
                  textContent = ' ' + textContent.trimLeft();
                }
                textContentLength = textContent.length;
                if (textContentLength > 1) {
                  if (/\s/.test(textContent.charAt(textContentLength - 1))) {
                    if (opts.approximateLineWidth > 0 && output.currentLineWidth + textContentLength > opts.approximateLineWidth) {
                      textContent = textContent.trimRight() + '\n';
                      output.currentLineWidth = 0;
                    } else {
                      textContent = textContent.trimRight() + ' ';
                    }
                  }
                }
                output.currentLineWidth += textContentLength;
              }
              output.text.push(escapeString(textContent, false));
            }
          }
        }
      }
    }
  } else if (node.nodeType === 8 /* COMMENT_NODE */) {
    const nodeValue = node.nodeValue;
    if (opts.removeHtmlComments) {
      const isHydrateAnnotation =
        nodeValue.startsWith(CONTENT_REF_ID + '.') ||
        nodeValue.startsWith(ORG_LOCATION_ID + '.') ||
        nodeValue.startsWith(SLOT_NODE_ID + '.') ||
        nodeValue.startsWith(TEXT_NODE_ID + '.');
      if (!isHydrateAnnotation) {
        return;
      }
    }
    const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
    if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
      output.text.push('\n');
      output.currentLineWidth = 0;
    }
    if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
      for (let i = 0; i < output.indent; i++) {
        output.text.push(' ');
      }
      output.currentLineWidth += output.indent;
    }
    output.text.push('<!--' + nodeValue + '-->');
    output.currentLineWidth += nodeValue.length + 7;
  } else if (node.nodeType === 10 /* DOCUMENT_TYPE_NODE */) {
    output.text.push('<!doctype html>');
  }
}
const AMP_REGEX = /&/g;
const NBSP_REGEX = /\u00a0/g;
const DOUBLE_QUOTE_REGEX = /"/g;
const LT_REGEX = /</g;
const GT_REGEX = />/g;
const CAN_REMOVE_ATTR_QUOTES = /^[^ \t\n\f\r"'`=<>\/\\-]+$/;
function getTagName(element) {
  if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
    return element.nodeName.toLowerCase();
  } else {
    return element.nodeName;
  }
}
function escapeString(str, attrMode) {
  str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');
  if (attrMode) {
    return str.replace(DOUBLE_QUOTE_REGEX, '&quot;');
  }
  return str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');
}
function isWithinWhitespaceSensitive(node) {
  while (node != null) {
    if (WHITESPACE_SENSITIVE.has(node.nodeName)) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
/*@__PURE__*/ const NON_ESCAPABLE_CONTENT = new Set(['STYLE', 'SCRIPT', 'IFRAME', 'NOSCRIPT', 'XMP', 'NOEMBED', 'NOFRAMES', 'PLAINTEXT']);
/*@__PURE__*/ const WHITESPACE_SENSITIVE = new Set(['CODE', 'OUTPUT', 'PLAINTEXT', 'PRE', 'SCRIPT', 'TEMPLATE', 'TEXTAREA']);
/*@__PURE__*/ const EMPTY_ELEMENTS = new Set([
  'area',
  'base',
  'basefont',
  'bgsound',
  'br',
  'col',
  'embed',
  'frame',
  'hr',
  'img',
  'input',
  'keygen',
  'link',
  'meta',
  'param',
  'source',
  'trace',
  'wbr',
]);
/*@__PURE__*/ const REMOVE_EMPTY_ATTR = new Set(['class', 'dir', 'id', 'lang', 'name', 'title']);
/*@__PURE__*/ const BOOLEAN_ATTR = new Set([
  'allowfullscreen',
  'async',
  'autofocus',
  'autoplay',
  'checked',
  'compact',
  'controls',
  'declare',
  'default',
  'defaultchecked',
  'defaultmuted',
  'defaultselected',
  'defer',
  'disabled',
  'enabled',
  'formnovalidate',
  'hidden',
  'indeterminate',
  'inert',
  'ismap',
  'itemscope',
  'loop',
  'multiple',
  'muted',
  'nohref',
  'nomodule',
  'noresize',
  'noshade',
  'novalidate',
  'nowrap',
  'open',
  'pauseonexit',
  'readonly',
  'required',
  'reversed',
  'scoped',
  'seamless',
  'selected',
  'sortable',
  'truespeed',
  'typemustmatch',
  'visible',
]);
/*@__PURE__*/ const STRUCTURE_ELEMENTS = new Set(['html', 'body', 'head', 'iframe', 'meta', 'link', 'base', 'title', 'script', 'style']);

// Parse5 6.0.1
const e = (function (e) {
  const t = [
    65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895,
    786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111,
  ];
  var n = '�',
    s = {
      EOF: -1,
      NULL: 0,
      TABULATION: 9,
      CARRIAGE_RETURN: 13,
      LINE_FEED: 10,
      FORM_FEED: 12,
      SPACE: 32,
      EXCLAMATION_MARK: 33,
      QUOTATION_MARK: 34,
      NUMBER_SIGN: 35,
      AMPERSAND: 38,
      APOSTROPHE: 39,
      HYPHEN_MINUS: 45,
      SOLIDUS: 47,
      DIGIT_0: 48,
      DIGIT_9: 57,
      SEMICOLON: 59,
      LESS_THAN_SIGN: 60,
      EQUALS_SIGN: 61,
      GREATER_THAN_SIGN: 62,
      QUESTION_MARK: 63,
      LATIN_CAPITAL_A: 65,
      LATIN_CAPITAL_F: 70,
      LATIN_CAPITAL_X: 88,
      LATIN_CAPITAL_Z: 90,
      RIGHT_SQUARE_BRACKET: 93,
      GRAVE_ACCENT: 96,
      LATIN_SMALL_A: 97,
      LATIN_SMALL_F: 102,
      LATIN_SMALL_X: 120,
      LATIN_SMALL_Z: 122,
      REPLACEMENT_CHARACTER: 65533,
    },
    r = function (e) {
      return e >= 55296 && e <= 57343;
    },
    i = function (e) {
      return (32 !== e && 10 !== e && 13 !== e && 9 !== e && 12 !== e && e >= 1 && e <= 31) || (e >= 127 && e <= 159);
    },
    o = function (e) {
      return (e >= 64976 && e <= 65007) || t.indexOf(e) > -1;
    },
    a = 'unexpected-null-character',
    T = 'invalid-first-character-of-tag-name',
    E = 'missing-semicolon-after-character-reference',
    h = 'eof-before-tag-name',
    c = 'eof-in-tag',
    _ = 'missing-whitespace-after-doctype-public-keyword',
    l = 'missing-whitespace-between-doctype-public-and-system-identifiers',
    m = 'missing-whitespace-after-doctype-system-keyword',
    p = 'missing-quote-before-doctype-public-identifier',
    A = 'missing-quote-before-doctype-system-identifier',
    u = 'missing-doctype-public-identifier',
    N = 'missing-doctype-system-identifier',
    d = 'abrupt-doctype-public-identifier',
    C = 'abrupt-doctype-system-identifier',
    O = 'eof-in-script-html-comment-like-text',
    f = 'eof-in-doctype',
    S = 'abrupt-closing-of-empty-comment',
    R = 'eof-in-comment',
    I = 'absence-of-digits-in-numeric-character-reference',
    L = 'end-tag-without-matching-open-element',
    k = 'misplaced-start-tag-for-head-element';
  const M = s;
  var g = new Uint16Array([
    4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
    110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987, 2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106,
    5512, 5728, 6117, 6274, 6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386, 11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666,
    18166, 18611, 19004, 19095, 19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222,
    226, 242, 256, 266, 283, 294, 108, 105, 103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1, 59, 167, 1, 193, 114, 101, 118, 101, 59, 1,
    258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1, 59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208, 1, 192, 112, 104, 97, 59, 1,
    913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112, 232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110,
    59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115, 272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1, 59, 292,
    1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115, 117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97,
    115, 104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1, 1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110,
    111, 117, 108, 108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349, 56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112,
    101, 113, 59, 1, 8782, 4, 14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542, 547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121,
    59, 1, 1063, 80, 89, 5, 169, 1, 59, 454, 1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478, 1, 8914, 116, 97, 108, 68, 105, 102,
    102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111, 110, 59, 1, 268, 100, 105,
    108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105, 110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59, 1, 184, 116, 101,
    114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99, 108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115, 59, 1,
    8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115, 623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101,
    103, 114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1,
    8217, 4, 4, 108, 110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868, 4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59,
    1, 8801, 110, 116, 59, 1, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742, 745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720,
    110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799,
    99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59, 67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 834, 850, 855, 860, 865, 888,
    903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1, 8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99, 121, 59, 1, 1039, 4, 3, 103,
    114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044, 108, 4, 2, 59,
    116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97, 102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84, 950,
    957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105,
    108, 100, 101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59,
    3, 55349, 56635, 4, 3, 59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784, 98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082,
    1101, 1189, 1211, 1236, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089, 1092, 59, 1, 168, 110, 65, 114, 114, 111,
    119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102, 116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1,
    8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149, 1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 65, 114, 114,
    111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658, 101, 101, 59,
    1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59,
    1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114, 111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65,
    114, 114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86, 1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1,
    10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1, 8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86,
    1362, 1373, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641, 97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399,
    1401, 1, 8868, 114, 114, 111, 119, 59, 1, 8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479, 114, 111, 107, 59, 1, 272, 4, 16, 78, 84,
    97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650, 1664, 1668, 1677, 71, 59, 1,
    330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201, 1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99, 5, 202, 1, 59,
    1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114, 97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97, 112,
    1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113,
    117, 97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3, 55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640,
    108, 4, 2, 59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59,
    1, 10867, 97, 59, 1, 919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519,
    4, 5, 99, 102, 105, 111, 115, 1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100, 4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83,
    113, 117, 97, 114, 101, 59, 1, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117, 1770, 1775, 1781, 102, 59, 3, 55349,
    56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1822,
    1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984, 99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1, 915, 59, 1, 988,
    114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100, 105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3, 55349,
    56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69, 70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76,
    1925, 1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807, 114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108,
    97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349, 56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005,
    2012, 2026, 2032, 2036, 2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1, 711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460,
    108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2,
    99, 116, 2079, 2083, 114, 59, 1, 8459, 114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109, 112, 59, 1, 8782, 113, 117, 97, 108, 59, 1,
    8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245, 2307, 2329, 2334, 2341, 99, 121, 59,
    1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025, 99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206, 1, 59, 2184, 1, 206, 59,
    1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101, 5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103, 2225, 2229, 114,
    59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59, 1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265,
    2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105, 98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109,
    101, 115, 59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349, 56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1,
    296, 4, 2, 107, 109, 2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115, 117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383,
    114, 99, 59, 1, 308, 59, 1, 1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114, 59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107,
    99, 121, 59, 1, 1028, 4, 7, 72, 74, 97, 99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121, 59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2,
    101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310, 59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349, 56486, 4, 11, 74, 84, 97, 99, 101,
    102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585, 2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99, 109, 110, 112, 114,
    2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59, 1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4, 3, 97,
    101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59, 1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114,
    2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59,
    66, 82, 2644, 2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117,
    119, 2679, 2692, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116,
    111, 114, 4, 2, 59, 66, 2721, 2723, 1, 8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65, 86, 2745, 2752, 114, 114, 111, 119, 59, 1,
    8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2, 101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119, 59, 1, 8612, 101, 99, 116, 111,
    114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4, 3, 68, 84, 86, 2829,
    2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863, 2865, 1,
    8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1, 8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114,
    114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962, 2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108,
    108, 69, 113, 117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105,
    108, 100, 101, 59, 1, 8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3,
    110, 112, 119, 3019, 3110, 3115, 103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104,
    116, 65, 114, 114, 111, 119, 59, 1, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079, 3086, 114, 114, 111, 119, 59, 1, 10232,
    105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643, 101, 114, 4, 2, 76, 82, 3123,
    3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114, 59, 1, 8466, 59,
    1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1,
    1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105, 110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108,
    117, 115, 59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427,
    4120, 4126, 4137, 99, 121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114, 111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053,
    4, 3, 103, 115, 119, 3314, 3380, 3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2,
    99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101, 59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8203, 116, 101,
    100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810, 76, 105, 110, 101, 59,
    1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444, 3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101,
    59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988,
    4, 2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59, 1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97,
    114, 59, 1, 8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97, 108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770,
    824, 105, 115, 116, 115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602, 3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59,
    1, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115, 59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97,
    108, 59, 3, 10878, 824, 105, 108, 100, 101, 59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3, 8782, 824, 113, 117, 97, 108, 59, 3,
    8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3, 10703, 824, 113, 117, 97,
    108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741, 3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114, 59, 1, 8824, 101,
    115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795, 3812,
    114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3,
    59, 69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114,
    115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3,
    10704, 824, 113, 117, 97, 108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933, 3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847,
    824, 113, 117, 97, 108, 59, 1, 8930, 101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1, 8931, 4, 3, 98, 99, 112, 3981, 4e3, 4045, 115,
    101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834, 8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015, 4017, 4025, 4037, 1, 8833, 113, 117, 97,
    108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4, 2, 59, 69, 4056, 4059, 3, 8835,
    8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4, 4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108, 108, 69, 113, 117,
    97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5, 209, 1,
    59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316,
    4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2, 105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108,
    97, 99, 59, 1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97, 101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937,
    99, 114, 111, 110, 59, 1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272, 4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1,
    8220, 117, 111, 116, 101, 59, 1, 8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216, 1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323,
    4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213, 101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354, 4380, 4, 2, 97, 114, 4360, 4364, 114,
    59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1, 9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4, 9, 97, 99, 102, 104, 105,
    108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471, 4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595, 105, 59, 1, 934,
    59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112, 4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4, 4, 59,
    101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69, 83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110,
    116, 69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4, 2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111,
    110, 4, 2, 59, 97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349, 56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79,
    84, 5, 34, 1, 59, 4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4, 12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117,
    4636, 4642, 4650, 4681, 4704, 4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648, 1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117,
    116, 101, 59, 1, 340, 103, 59, 1, 10219, 114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695, 4701, 114, 111, 110, 59, 1, 344, 100, 105,
    108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710, 4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101, 109, 101, 110, 116, 59, 1,
    8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59, 1, 929, 103,
    104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912, 4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59,
    1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103,
    59, 1, 8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114,
    59, 1, 10589, 101, 99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111, 114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65,
    86, 4927, 4929, 4936, 1, 8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883,
    97, 114, 59, 1, 10704, 113, 117, 97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99,
    116, 111, 114, 59, 1, 10588, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4, 2, 59, 66, 5033, 5035, 1, 8640, 97,
    114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2, 112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1, 10608, 105, 103, 104, 116,
    97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091, 114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13, 72, 79, 97, 99,
    102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198, 5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1, 1065,
    121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59, 97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352,
    100, 105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114, 116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114,
    111, 119, 59, 1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593,
    103, 109, 97, 59, 1, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114, 117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4,
    4, 59, 73, 83, 85, 5306, 5308, 5322, 5367, 1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98, 112, 5329, 5347, 115, 101, 116, 4, 2, 59,
    69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1, 8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1, 8850, 110, 105, 111, 110, 59, 1,
    8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4, 4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4, 2, 59, 69, 5411,
    5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108, 59, 1,
    10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59, 1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507,
    1, 8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839, 101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115,
    5536, 5546, 5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222, 65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1,
    1035, 121, 59, 1, 1062, 4, 2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111, 110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1,
    1058, 114, 59, 3, 55349, 56599, 4, 2, 101, 105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1, 920, 4, 2, 99, 110, 5637, 5647, 107,
    83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99, 101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113, 117, 97, 108, 59, 1,
    8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100, 101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1, 8411, 4, 2,
    99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14, 97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823,
    5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117, 116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99,
    105, 114, 59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2, 105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059,
    98, 108, 97, 99, 59, 1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114, 59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66,
    80, 5866, 5892, 4, 2, 97, 114, 5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105,
    115, 59, 1, 9181, 111, 110, 4, 2, 59, 80, 5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1, 370, 102, 59, 3, 55349, 56652, 4, 8, 65,
    68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996, 6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593, 97, 114, 59, 1, 10514, 111, 119,
    110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10606, 101, 101, 4, 2, 59,
    65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114, 111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76, 82, 6052,
    6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933,
    105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109, 108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118,
    6137, 6143, 6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987, 121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59,
    1, 10982, 4, 2, 101, 114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4, 2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76,
    83, 84, 6209, 6214, 6220, 6231, 97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1, 10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104,
    105, 110, 83, 112, 97, 99, 101, 59, 1, 8202, 114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100, 97, 115, 104, 59, 1, 8874, 4, 5, 99,
    101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105, 114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3, 55349, 56654, 99, 114, 59, 3,
    55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339, 114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349, 56499, 4, 9, 65, 73,
    85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410, 6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116, 101, 5,
    221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1, 1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500,
    109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477, 6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97,
    121, 6463, 6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483, 6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97,
    59, 1, 918, 114, 59, 1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550,
    6561, 6568, 6612, 6622, 6634, 6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59, 6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6,
    59, 69, 100, 105, 117, 121, 6582, 6584, 6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598, 1, 226, 116, 101, 5, 180, 1, 59, 6607, 1,
    180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59, 6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5, 224, 1, 59, 6643, 1, 224, 4, 2,
    101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121, 109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99, 108, 6684, 6688, 114,
    59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100, 103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100, 59, 1,
    10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101, 108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660,
    101, 59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102, 103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1,
    10665, 59, 1, 10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59, 118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59,
    1, 10653, 4, 2, 112, 116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112, 6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7,
    59, 69, 97, 101, 105, 111, 112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1, 10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114,
    111, 120, 4, 2, 59, 101, 6917, 6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116, 121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59,
    1, 42, 109, 112, 4, 2, 59, 101, 6957, 6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5, 228, 1, 59, 6981, 1, 228, 4, 2, 99, 105,
    6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755, 110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 7036, 7041, 7119,
    7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786, 7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112, 115, 7058, 7064, 7073,
    7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1, 1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59, 1, 8909, 4,
    2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113, 7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107, 59,
    1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111, 59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115,
    4, 2, 59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1, 1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59,
    1, 946, 59, 1, 8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117, 118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105,
    117, 7249, 7253, 7258, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281, 111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753,
    105, 109, 101, 115, 59, 1, 10754, 4, 2, 113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110, 103, 108, 101, 4, 2, 100, 117, 7318, 7324,
    111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112, 108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114, 111, 119, 59, 1, 10509, 4, 3,
    97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107, 4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117, 97, 114, 101, 59,
    1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411, 7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103, 104, 116,
    59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451, 59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485,
    4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4, 4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2,
    59, 116, 7510, 7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655,
    7660, 7682, 7708, 7715, 7721, 7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1, 9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583,
    7585, 7588, 7591, 7594, 1, 9552, 59, 1, 9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616, 59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59,
    1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635, 7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1, 9579, 59, 1, 9570, 59, 1, 9567,
    111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673, 7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117, 7694, 7696, 7699, 7702,
    7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524, 105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864, 4, 4, 76, 82,
    108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1, 9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474,
    59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109, 101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5,
    166, 1, 59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503, 109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1,
    8909, 108, 4, 3, 59, 98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109, 7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59,
    1, 8226, 112, 4, 3, 59, 69, 101, 7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4, 15, 97, 99, 100, 101, 102, 104, 105, 108, 111,
    114, 115, 116, 117, 119, 121, 7942, 8021, 8075, 8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114, 7950, 7956, 8007, 117, 116, 101, 59,
    1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977, 7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97, 117, 7990, 7994, 112,
    59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745, 65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117, 8031, 8046,
    8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269, 100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115, 8069,
    8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088, 8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5,
    162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608, 4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109,
    8146, 8148, 1, 10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115, 8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3,
    59, 101, 108, 8187, 8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4, 2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103,
    104, 116, 59, 1, 8635, 4, 5, 82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1, 8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1,
    8861, 59, 1, 8791, 110, 105, 110, 116, 59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117, 8288, 8290, 1, 9827, 105, 116, 59, 1,
    9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400, 111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788, 4, 2, 109, 112, 8332, 8344,
    97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102, 108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110, 116, 59, 1, 8705,
    101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388, 8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412, 8417, 59,
    3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114, 59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4,
    2, 99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469, 8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1,
    10962, 100, 111, 116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697, 8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552,
    59, 1, 10549, 4, 2, 112, 115, 8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1, 8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115,
    8564, 8566, 8573, 8587, 8592, 8596, 1, 8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59, 1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1,
    10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114, 118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121, 4, 3, 101, 118, 119, 8632, 8651,
    8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1, 8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101, 110, 5, 164, 1, 59,
    8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690, 101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100, 59, 1,
    8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1, 8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104,
    105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930, 8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114,
    59, 1, 8659, 97, 114, 59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224, 101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59,
    118, 8816, 8818, 1, 8208, 59, 1, 8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2, 97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271,
    59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864, 8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116, 115, 101, 113, 59, 1, 10871, 4, 3,
    103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1, 176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115, 104, 116, 59, 1, 10623,
    59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643, 59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111, 115, 8965,
    8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116, 59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4,
    3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247, 110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1,
    1106, 99, 4, 2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116, 117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102,
    59, 3, 55349, 56661, 4, 5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102, 9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59,
    1, 8760, 108, 117, 115, 59, 1, 8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160,
    9172, 114, 114, 111, 119, 59, 1, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 9184, 9190, 101, 102, 116, 59, 1,
    8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99, 9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1, 8991, 111, 112, 59, 1, 8972,
    4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245, 59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100, 114, 9264, 9269,
    111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662, 4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108, 101,
    59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1, 10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115,
    116, 117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755, 9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871,
    116, 59, 1, 8785, 4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1, 10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111,
    110, 59, 1, 283, 114, 4, 2, 59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1, 1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114,
    9453, 9458, 111, 116, 59, 1, 8786, 59, 3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59, 9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1,
    10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108, 115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4, 2, 59, 100, 9524, 9526, 1,
    10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544, 9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116, 59, 1, 8709, 59, 1,
    8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1, 8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2, 103, 112,
    9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115, 9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1,
    10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013, 4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114,
    99, 59, 1, 8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116, 4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59,
    1, 10901, 4, 3, 97, 101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68, 9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108,
    59, 1, 10725, 4, 2, 68, 97, 9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783, 9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59,
    1, 8770, 4, 2, 97, 104, 9798, 9801, 59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820, 1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112,
    9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59, 1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 1,
    8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111, 112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108, 108, 105, 110, 103, 100,
    111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108, 101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2, 105, 108,
    9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108, 105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984,
    116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2, 112, 114, 1e4, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108,
    108, 59, 1, 8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1, 10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6,
    49, 50, 51, 52, 53, 55, 10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086, 10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1,
    8531, 5, 188, 1, 59, 10091, 1, 188, 59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534, 4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190,
    1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540, 53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108, 59, 1, 8260, 119, 110, 59, 1, 8994,
    99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268, 10273, 10358, 10363,
    10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59, 108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116, 101, 59,
    1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114, 101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075,
    111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1, 8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110,
    116, 59, 1, 10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111, 116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342,
    1, 10882, 59, 1, 10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349, 56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101,
    108, 59, 1, 8503, 99, 121, 59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1, 10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416,
    10419, 10434, 10453, 59, 1, 8809, 112, 4, 2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442, 1, 10888, 4, 2, 59, 113, 10448, 10450,
    1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102, 59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458, 109, 4, 3, 59, 101, 108,
    10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6, 59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105, 10520, 10523,
    59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1, 10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579, 10599,
    10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1, 10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923,
    108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2, 101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3,
    8809, 65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724, 10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108,
    109, 114, 10668, 10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459, 4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99,
    119, 10703, 10705, 10710, 1, 8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4, 3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115,
    4, 2, 59, 117, 10741, 10743, 1, 9829, 105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3, 55349, 56613, 115, 4, 2, 101, 119, 10772, 10779,
    97, 114, 111, 119, 59, 1, 10533, 97, 114, 111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114, 114, 59, 1, 8703, 116, 104, 116, 59, 1,
    8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8618, 102, 59, 3, 55349, 56665,
    98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863, 10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2, 98, 112, 10881, 10887,
    117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99, 101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977, 10990,
    11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116, 101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114,
    99, 5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99, 108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660,
    59, 3, 55349, 56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013, 11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59,
    1, 10764, 116, 59, 1, 8749, 102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111, 112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061,
    11065, 11088, 114, 59, 1, 299, 4, 3, 101, 108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1, 8465, 104, 59, 1, 305, 102, 59, 1, 8887,
    101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116, 11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59, 116, 11129, 11131, 1, 8734, 105,
    101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99, 101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103, 114, 11167, 11173, 101,
    114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107, 59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211, 11216, 121, 59, 1,
    1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114, 111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105, 11243,
    11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266, 11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279,
    1, 8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1, 297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59,
    11316, 1, 239, 4, 6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121, 11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349,
    56615, 97, 116, 104, 59, 1, 567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511, 114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4,
    8, 97, 99, 102, 103, 104, 106, 111, 115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118, 11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121,
    11424, 11430, 100, 105, 108, 59, 1, 311, 59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093, 99, 121, 59, 1, 1116, 112, 102, 59, 3,
    55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 11515, 11538,
    11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171, 12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114, 116, 11523,
    11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523, 97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59,
    1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606, 11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118,
    59, 1, 10676, 114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617, 11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117,
    111, 5, 171, 1, 59, 11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673, 11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663,
    11665, 1, 8676, 115, 59, 1, 10527, 115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1, 10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702,
    11704, 11709, 1, 10923, 105, 108, 59, 1, 10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729, 11734, 11739, 114, 114, 59, 1, 10508, 114,
    107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99, 4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1, 10635, 108, 4, 2, 100, 117, 11774,
    11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121, 11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108, 59, 1, 316, 108, 59,
    1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828, 11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1, 8222, 4, 2,
    100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1, 10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1, 8804,
    116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111, 119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111,
    111, 110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97,
    104, 115, 11959, 11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97,
    114, 114, 111, 119, 59, 1, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115, 12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97,
    110, 116, 59, 1, 10877, 4, 5, 59, 99, 100, 103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59, 111, 12057, 12059, 1, 10879, 4, 2, 59,
    114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59, 101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095, 12103, 12108, 12126, 12131, 112,
    112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113, 4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114, 59, 1, 8822, 105, 109,
    59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116, 59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1, 8822, 59, 1,
    10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1, 8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59, 1,
    1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59, 1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105,
    59, 1, 9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97, 12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115,
    12285, 12288, 12303, 12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889, 4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317,
    12319, 1, 10887, 59, 1, 8808, 105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421, 12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351,
    12355, 103, 59, 1, 10220, 114, 59, 1, 8701, 114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2, 97, 114, 12382, 12389, 114, 114, 111,
    119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10230,
    112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101, 102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458, 12462, 114, 59, 1,
    10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59, 1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59, 101, 102,
    12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4, 2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535,
    12540, 12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4, 2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59,
    1, 8895, 4, 6, 97, 99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249, 114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103,
    12606, 12608, 12611, 1, 8818, 59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630, 12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1,
    322, 5, 60, 8, 59, 99, 100, 104, 105, 108, 113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668, 12671, 59, 1, 10918, 114, 59, 1,
    10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907, 109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4, 2, 80, 105, 12711, 12716,
    97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1, 9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1, 10570, 104, 97,
    114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113, 59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110,
    111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025, 13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819,
    12827, 12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4, 2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115,
    12855, 12857, 1, 8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110, 59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107,
    101, 114, 59, 1, 9646, 4, 2, 111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101,
    59, 1, 8737, 114, 59, 3, 55349, 56618, 111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1, 181, 4, 4, 59, 97, 99, 100, 12964, 12966,
    12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105, 114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995, 12997, 13e3, 1, 8722, 59, 1,
    8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2, 99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723, 4, 2, 100, 112,
    13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1, 8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3, 59,
    108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59, 1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108,
    109, 111, 112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414, 13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855,
    13936, 13995, 14214, 14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158, 13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116,
    13173, 13200, 13204, 102, 116, 4, 2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2,
    59, 118, 13210, 13213, 3, 8810, 8402, 59, 3, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235, 13241, 97, 115, 104, 59, 1, 8879, 97,
    115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116, 13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59, 3, 8736, 8402, 4, 5, 59, 69,
    105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3, 10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4, 2, 59, 97, 13316,
    13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4, 2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352, 13355,
    3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391, 13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105,
    108, 59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112, 59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100,
    113, 115, 120, 13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2, 104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460,
    13462, 1, 8599, 119, 59, 1, 8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489, 97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115,
    116, 4, 2, 59, 115, 13503, 13505, 1, 8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563, 13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115,
    13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115, 13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3, 10878, 824, 105, 109, 59, 1,
    8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3, 65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59, 1, 10994, 4, 3, 59,
    115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1, 8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116, 13647,
    13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114, 114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725,
    1, 8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1,
    8816, 59, 3, 8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824, 59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1,
    8814, 105, 4, 2, 59, 101, 13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102, 59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787,
    13789, 13829, 1, 172, 110, 4, 4, 59, 69, 100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824, 4, 3, 97, 98, 99, 13820, 13823, 13826, 59,
    1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59, 118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958, 59, 1, 8957, 4, 3, 97, 111, 114,
    13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874, 13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3, 8706, 824, 108, 105,
    110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832, 117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931, 1, 8832,
    113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114, 59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824,
    59, 3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101, 13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117,
    14011, 14036, 14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1, 8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515,
    111, 114, 116, 4, 2, 109, 112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109, 4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113,
    14075, 14077, 1, 8772, 59, 1, 8772, 105, 100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1, 8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112,
    14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124, 14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141, 14144, 3, 8834, 8402, 113, 4,
    2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2, 59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183, 14187, 14190, 1,
    8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201, 3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105, 108,
    114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236, 1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269,
    101, 102, 116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59, 101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293,
    1, 957, 4, 3, 59, 101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72, 97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349,
    14355, 14369, 14376, 14408, 14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115, 104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59,
    3, 8805, 8402, 59, 3, 62, 8402, 110, 102, 105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59, 3, 8804, 8402, 4, 2, 59, 114, 14399,
    14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2, 65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59, 3, 8764, 8402, 4, 3, 65,
    97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104, 114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598, 101, 97, 114,
    59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111, 112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657,
    14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115, 14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2,
    105, 121, 14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1, 1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591,
    115, 104, 59, 1, 8861, 108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684, 108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105,
    114, 59, 1, 10687, 59, 3, 55349, 56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59, 14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109,
    14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937, 110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1, 8634, 4, 2, 105, 114, 14683, 14687,
    114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101, 59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103, 97, 59, 1, 969, 4, 3,
    99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1, 10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759, 14764, 114,
    59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100, 105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1,
    8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111, 14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59,
    14829, 1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59, 1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97,
    115, 104, 5, 248, 1, 59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1, 59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1,
    8855, 115, 59, 1, 10806, 109, 108, 5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105, 108, 109, 111, 114, 115, 117, 14948, 14992, 14996,
    15033, 15038, 15068, 15090, 15189, 15192, 15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182, 2, 59, 108, 14968, 14970, 1, 182, 108,
    101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986, 109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112, 116, 15009, 15014, 15019,
    15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108, 59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105, 109, 111, 15046,
    15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116, 59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104, 102,
    111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107, 15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463,
    115, 4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168, 15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59,
    1, 10786, 4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59, 15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177,
    4, 3, 105, 112, 117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673, 110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101,
    105, 110, 111, 115, 117, 15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931, 112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99,
    15264, 15266, 1, 10927, 4, 6, 59, 97, 99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120, 59, 1, 10935, 117, 114, 108, 121, 101, 113,
    59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101, 115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105, 109, 59, 1, 8936, 105, 109, 59, 1,
    8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59, 1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109, 59, 1, 8936, 4, 3, 100,
    102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386, 15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1, 8979, 4, 2,
    59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101, 108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99,
    115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485, 15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349,
    56674, 114, 105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520, 15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115,
    59, 1, 8461, 110, 116, 59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1, 59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101,
    102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977, 16001, 16039, 16183, 16204, 16222, 16228, 16285,
    16312, 16318, 16363, 16408, 16416, 4, 3, 97, 114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1, 10524, 97, 114, 114, 59, 1, 10511, 97,
    114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114, 116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3, 8765, 817, 116, 101, 59, 1,
    341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675, 103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1, 10661, 101, 59, 1,
    10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754, 15758,
    15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115, 59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59,
    1, 10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781, 105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115,
    59, 1, 8474, 4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2, 97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125,
    59, 1, 93, 4, 2, 101, 115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1, 10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114,
    111, 110, 59, 1, 345, 4, 2, 100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088, 4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927,
    97, 59, 1, 10551, 100, 104, 97, 114, 59, 1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3, 97, 99, 103, 15939, 15966, 15970, 108,
    4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1, 8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174, 1, 59, 15975, 1, 174, 4,
    3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621, 111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100, 117, 16014,
    16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59, 118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4,
    6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119, 4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112,
    111, 111, 110, 4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4, 2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97,
    114, 112, 111, 111, 110, 115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101,
    101, 116, 105, 109, 101, 115, 59, 1, 8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97, 104, 109, 16191, 16196, 16201, 114, 114, 59, 1,
    8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111, 117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100, 59, 1, 10990, 4, 4, 97, 98, 112,
    116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244, 16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265, 16269, 16273, 114, 59, 1,
    10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101, 115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116, 59, 1, 10644,
    111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99, 104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519, 59,
    1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1, 8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908,
    109, 101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59, 1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114,
    59, 1, 10600, 59, 1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687,
    16746, 16844, 16850, 16924, 16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113, 117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105,
    110, 112, 115, 121, 16494, 16496, 16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114, 16505, 16508, 59, 1, 10936, 111, 110, 59, 1,
    353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524, 16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547, 16551, 59, 1, 10934, 112, 59, 1,
    10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1, 10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587, 1, 8901, 59, 1, 8865,
    59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634, 16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59, 1,
    10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640, 1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665,
    110, 117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3, 55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702,
    16716, 16739, 114, 112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116, 4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114,
    97, 108, 108, 101, 108, 59, 1, 8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118, 16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1,
    962, 4, 8, 59, 100, 101, 103, 108, 110, 112, 114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858, 4, 2, 59, 113, 16801, 16803, 1, 8771,
    59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59, 1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115, 59, 1, 10788, 97, 114,
    114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116, 16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110, 117, 115,
    59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2, 100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922,
    4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938, 16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59,
    97, 16952, 16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985, 101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824,
    59, 1, 8741, 4, 3, 99, 115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011, 1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022,
    17024, 1, 8852, 59, 3, 8852, 65024, 117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1, 8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1,
    8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115, 17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848, 113, 59, 1, 8850, 4, 3, 59, 97, 102,
    17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106, 17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109, 116, 17131, 17136, 17142,
    17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105, 108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59, 102, 17167,
    17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4, 2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981,
    115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69, 100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267,
    17279, 17285, 17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838, 111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101,
    17273, 17276, 59, 1, 10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105, 117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308,
    17310, 17322, 1, 8834, 113, 4, 2, 59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842, 59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112,
    17345, 17348, 59, 1, 10965, 59, 1, 10963, 99, 4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112, 114, 111, 120, 59, 1, 10936, 117,
    114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4, 3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1, 10934, 105, 109, 59,
    1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478, 17481,
    17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178, 1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111,
    115, 17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839, 111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185,
    98, 59, 1, 10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545, 59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105,
    117, 17562, 17598, 17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580, 17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595,
    1, 8843, 59, 1, 10956, 109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110, 17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2,
    104, 114, 17634, 17638, 107, 59, 1, 10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538, 108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4,
    13, 97, 98, 99, 100, 101, 102, 104, 105, 111, 112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957, 17964, 18090, 18122, 4, 2, 114, 117,
    17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964, 114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357, 100, 105, 108, 59, 1, 355, 59,
    1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981, 114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114, 116, 17770, 17786,
    101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756, 97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2, 99, 110,
    17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776, 105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1,
    8776, 105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868, 17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884,
    17886, 17898, 1, 215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749, 4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4,
    59, 98, 99, 102, 17927, 17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111, 17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97,
    59, 1, 10537, 114, 105, 109, 101, 59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100, 101, 109, 112, 115, 116, 17993, 18051, 18056,
    18059, 18066, 18072, 18076, 110, 103, 108, 101, 4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59, 1, 9663, 101, 102, 116, 4, 2, 59,
    101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796, 105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1, 9708, 59, 1, 8796, 105,
    110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1, 10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116, 18098, 18111,
    18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121, 59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812,
    104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97,
    98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250, 18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504,
    18547, 18553, 18584, 18603, 114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5, 250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2,
    99, 101, 18241, 18245, 121, 59, 1, 1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1, 251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276,
    18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99, 59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622, 59, 3, 55349, 56626, 114, 97,
    118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325, 18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4, 2, 99, 116, 18349,
    18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365, 1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385,
    18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111, 110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117,
    18427, 18434, 18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114,
    18457, 18463, 101, 102, 116, 59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108, 18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110,
    59, 1, 965, 112, 97, 114, 114, 111, 119, 115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114, 110, 4, 2, 59, 101, 18526, 18528, 1,
    8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103, 59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561, 18566, 18572, 111, 116,
    59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579, 18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252, 1, 59, 18601,
    1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857,
    18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2, 59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2,
    110, 114, 18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695, 18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59,
    1, 1013, 97, 112, 112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728, 18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111,
    59, 1, 8733, 4, 2, 59, 104, 18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1, 962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110,
    101, 113, 4, 2, 59, 113, 18784, 18787, 3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803, 18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4,
    2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1, 977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882, 105, 103, 104, 116, 59, 1, 8883,
    121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108, 114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1, 8891, 113, 59, 1, 8794,
    108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59, 1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98, 112, 18923,
    18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114, 111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3,
    55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955, 65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59,
    3, 8843, 65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020, 19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2,
    100, 105, 19032, 19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052, 1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3,
    55349, 56628, 112, 102, 59, 3, 55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768, 99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102,
    104, 105, 108, 109, 110, 111, 114, 115, 117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252, 19269, 19286, 19291, 4, 3, 97, 105, 117,
    19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97, 19163, 19168, 114, 114, 59,
    1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182, 19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1, 8955, 4, 3,
    100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221, 19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65,
    97, 19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263, 114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275,
    19281, 108, 117, 115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335,
    19349, 19357, 19362, 19367, 19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1, 1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1,
    375, 59, 1, 1099, 110, 5, 165, 1, 59, 19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682, 99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109,
    19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1, 59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441, 19446, 19462, 19467, 19472,
    19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121, 19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116, 19452, 19458,
    116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121, 59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59, 3,
    55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204,
  ]);
  const P = s,
    H = {
      DASH_DASH_STRING: [45, 45],
      DOCTYPE_STRING: [68, 79, 67, 84, 89, 80, 69],
      CDATA_START_STRING: [91, 67, 68, 65, 84, 65, 91],
      SCRIPT_STRING: [115, 99, 114, 105, 112, 116],
      PUBLIC_STRING: [80, 85, 66, 76, 73, 67],
      SYSTEM_STRING: [83, 89, 83, 84, 69, 77],
    },
    D = {
      128: 8364,
      130: 8218,
      131: 402,
      132: 8222,
      133: 8230,
      134: 8224,
      135: 8225,
      136: 710,
      137: 8240,
      138: 352,
      139: 8249,
      140: 338,
      142: 381,
      145: 8216,
      146: 8217,
      147: 8220,
      148: 8221,
      149: 8226,
      150: 8211,
      151: 8212,
      152: 732,
      153: 8482,
      154: 353,
      155: 8250,
      156: 339,
      158: 382,
      159: 376,
    },
    F = 'DATA_STATE',
    U = 'RCDATA_STATE',
    G = 'RAWTEXT_STATE',
    B = 'SCRIPT_DATA_STATE',
    K = 'PLAINTEXT_STATE',
    b = 'TAG_OPEN_STATE',
    x = 'END_TAG_OPEN_STATE',
    y = 'TAG_NAME_STATE',
    v = 'RCDATA_LESS_THAN_SIGN_STATE',
    Y = 'RCDATA_END_TAG_OPEN_STATE',
    w = 'RCDATA_END_TAG_NAME_STATE',
    Q = 'RAWTEXT_LESS_THAN_SIGN_STATE',
    X = 'RAWTEXT_END_TAG_OPEN_STATE',
    W = 'RAWTEXT_END_TAG_NAME_STATE',
    V = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE',
    j = 'SCRIPT_DATA_END_TAG_OPEN_STATE',
    z = 'SCRIPT_DATA_END_TAG_NAME_STATE',
    q = 'SCRIPT_DATA_ESCAPE_START_STATE',
    J = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE',
    Z = 'SCRIPT_DATA_ESCAPED_STATE',
    $ = 'SCRIPT_DATA_ESCAPED_DASH_STATE',
    ee = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE',
    te = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE',
    ne = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE',
    se = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE',
    re = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE',
    ie = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE',
    oe = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE',
    ae = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE',
    Te = 'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE',
    Ee = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE',
    he = 'BEFORE_ATTRIBUTE_NAME_STATE',
    ce = 'ATTRIBUTE_NAME_STATE',
    _e = 'AFTER_ATTRIBUTE_NAME_STATE',
    le = 'BEFORE_ATTRIBUTE_VALUE_STATE',
    me = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE',
    pe = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE',
    Ae = 'ATTRIBUTE_VALUE_UNQUOTED_STATE',
    ue = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE',
    Ne = 'SELF_CLOSING_START_TAG_STATE',
    de = 'BOGUS_COMMENT_STATE',
    Ce = 'MARKUP_DECLARATION_OPEN_STATE',
    Oe = 'COMMENT_START_STATE',
    fe = 'COMMENT_START_DASH_STATE',
    Se = 'COMMENT_STATE',
    Re = 'COMMENT_LESS_THAN_SIGN_STATE',
    Ie = 'COMMENT_LESS_THAN_SIGN_BANG_STATE',
    Le = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE',
    ke = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE',
    Me = 'COMMENT_END_DASH_STATE',
    ge = 'COMMENT_END_STATE',
    Pe = 'COMMENT_END_BANG_STATE',
    He = 'DOCTYPE_STATE',
    De = 'BEFORE_DOCTYPE_NAME_STATE',
    Fe = 'DOCTYPE_NAME_STATE',
    Ue = 'AFTER_DOCTYPE_NAME_STATE',
    Ge = 'AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE',
    Be = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE',
    Ke = 'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE',
    be = 'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE',
    xe = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE',
    ye = 'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE',
    ve = 'AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE',
    Ye = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE',
    we = 'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE',
    Qe = 'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE',
    Xe = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE',
    We = 'BOGUS_DOCTYPE_STATE',
    Ve = 'CDATA_SECTION_STATE',
    je = 'CDATA_SECTION_BRACKET_STATE',
    ze = 'CDATA_SECTION_END_STATE',
    qe = 'CHARACTER_REFERENCE_STATE',
    Je = 'NAMED_CHARACTER_REFERENCE_STATE',
    Ze = 'AMBIGUOS_AMPERSAND_STATE',
    $e = 'NUMERIC_CHARACTER_REFERENCE_STATE',
    et = 'HEXADEMICAL_CHARACTER_REFERENCE_START_STATE',
    tt = 'DECIMAL_CHARACTER_REFERENCE_START_STATE',
    nt = 'HEXADEMICAL_CHARACTER_REFERENCE_STATE',
    st = 'DECIMAL_CHARACTER_REFERENCE_STATE',
    rt = 'NUMERIC_CHARACTER_REFERENCE_END_STATE';
  function it(e) {
    return e === P.SPACE || e === P.LINE_FEED || e === P.TABULATION || e === P.FORM_FEED;
  }
  function ot(e) {
    return e >= P.DIGIT_0 && e <= P.DIGIT_9;
  }
  function at(e) {
    return e >= P.LATIN_CAPITAL_A && e <= P.LATIN_CAPITAL_Z;
  }
  function Tt(e) {
    return e >= P.LATIN_SMALL_A && e <= P.LATIN_SMALL_Z;
  }
  function Et(e) {
    return Tt(e) || at(e);
  }
  function ht(e) {
    return Et(e) || ot(e);
  }
  function ct(e) {
    return e >= P.LATIN_CAPITAL_A && e <= P.LATIN_CAPITAL_F;
  }
  function _t(e) {
    return e >= P.LATIN_SMALL_A && e <= P.LATIN_SMALL_F;
  }
  function lt(e) {
    return e + 32;
  }
  function mt(e) {
    return e <= 65535 ? String.fromCharCode(e) : ((e -= 65536), String.fromCharCode(((e >>> 10) & 1023) | 55296) + String.fromCharCode(56320 | (1023 & e)));
  }
  function pt(e) {
    return String.fromCharCode(lt(e));
  }
  function At(e, t) {
    const n = g[++e];
    let s = ++e,
      r = s + n - 1;
    for (; s <= r; ) {
      const e = (s + r) >>> 1,
        i = g[e];
      if (i < t) s = e + 1;
      else {
        if (!(i > t)) return g[e + n];
        r = e - 1;
      }
    }
    return -1;
  }
  class ut {
    constructor() {
      (this.preprocessor = new (class {
        constructor() {
          (this.html = null),
            (this.pos = -1),
            (this.lastGapPos = -1),
            (this.lastCharPos = -1),
            (this.gapStack = []),
            (this.skipNextNewLine = !1),
            (this.lastChunkWritten = !1),
            (this.endOfChunkHit = !1),
            (this.bufferWaterline = 65536);
        }
        _err() {}
        _addGap() {
          this.gapStack.push(this.lastGapPos), (this.lastGapPos = this.pos);
        }
        _processSurrogate(e) {
          if (this.pos !== this.lastCharPos) {
            const t = this.html.charCodeAt(this.pos + 1);
            if (
              (function (e) {
                return e >= 56320 && e <= 57343;
              })(t)
            )
              return this.pos++, this._addGap(), 1024 * (e - 55296) + 9216 + t;
          } else if (!this.lastChunkWritten) return (this.endOfChunkHit = !0), M.EOF;
          return this._err('surrogate-in-input-stream'), e;
        }
        dropParsedChunk() {
          this.pos > this.bufferWaterline &&
            ((this.lastCharPos -= this.pos), (this.html = this.html.substring(this.pos)), (this.pos = 0), (this.lastGapPos = -1), (this.gapStack = []));
        }
        write(e, t) {
          this.html ? (this.html += e) : (this.html = e), (this.lastCharPos = this.html.length - 1), (this.endOfChunkHit = !1), (this.lastChunkWritten = t);
        }
        insertHtmlAtCurrentPos(e) {
          (this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1, this.html.length)),
            (this.lastCharPos = this.html.length - 1),
            (this.endOfChunkHit = !1);
        }
        advance() {
          if ((this.pos++, this.pos > this.lastCharPos)) return (this.endOfChunkHit = !this.lastChunkWritten), M.EOF;
          let e = this.html.charCodeAt(this.pos);
          return this.skipNextNewLine && e === M.LINE_FEED
            ? ((this.skipNextNewLine = !1), this._addGap(), this.advance())
            : e === M.CARRIAGE_RETURN
            ? ((this.skipNextNewLine = !0), M.LINE_FEED)
            : ((this.skipNextNewLine = !1),
              r(e) && (e = this._processSurrogate(e)),
              (e > 31 && e < 127) || e === M.LINE_FEED || e === M.CARRIAGE_RETURN || (e > 159 && e < 64976) || this._checkForProblematicCharacters(e),
              e);
        }
        _checkForProblematicCharacters(e) {
          i(e) ? this._err('control-character-in-input-stream') : o(e) && this._err('noncharacter-in-input-stream');
        }
        retreat() {
          this.pos === this.lastGapPos && ((this.lastGapPos = this.gapStack.pop()), this.pos--), this.pos--;
        }
      })()),
        (this.tokenQueue = []),
        (this.allowCDATA = !1),
        (this.state = F),
        (this.returnState = ''),
        (this.charRefCode = -1),
        (this.tempBuff = []),
        (this.lastStartTagName = ''),
        (this.consumedAfterSnapshot = -1),
        (this.active = !1),
        (this.currentCharacterToken = null),
        (this.currentToken = null),
        (this.currentAttr = null);
    }
    _err() {}
    _errOnNextCodePoint(e) {
      this._consume(), this._err(e), this._unconsume();
    }
    getNextToken() {
      for (; !this.tokenQueue.length && this.active; ) {
        this.consumedAfterSnapshot = 0;
        const e = this._consume();
        this._ensureHibernation() || this[this.state](e);
      }
      return this.tokenQueue.shift();
    }
    write(e, t) {
      (this.active = !0), this.preprocessor.write(e, t);
    }
    insertHtmlAtCurrentPos(e) {
      (this.active = !0), this.preprocessor.insertHtmlAtCurrentPos(e);
    }
    _ensureHibernation() {
      if (this.preprocessor.endOfChunkHit) {
        for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) this.preprocessor.retreat();
        return (this.active = !1), this.tokenQueue.push({ type: ut.HIBERNATION_TOKEN }), !0;
      }
      return !1;
    }
    _consume() {
      return this.consumedAfterSnapshot++, this.preprocessor.advance();
    }
    _unconsume() {
      this.consumedAfterSnapshot--, this.preprocessor.retreat();
    }
    _reconsumeInState(e) {
      (this.state = e), this._unconsume();
    }
    _consumeSequenceIfMatch(e, t, n) {
      let s = 0,
        r = !0;
      const i = e.length;
      let o,
        a = 0,
        T = t;
      for (; a < i; a++) {
        if ((a > 0 && ((T = this._consume()), s++), T === P.EOF)) {
          r = !1;
          break;
        }
        if (((o = e[a]), T !== o && (n || T !== lt(o)))) {
          r = !1;
          break;
        }
      }
      if (!r) for (; s--; ) this._unconsume();
      return r;
    }
    _isTempBufferEqualToScriptString() {
      if (this.tempBuff.length !== H.SCRIPT_STRING.length) return !1;
      for (let e = 0; e < this.tempBuff.length; e++) if (this.tempBuff[e] !== H.SCRIPT_STRING[e]) return !1;
      return !0;
    }
    _createStartTagToken() {
      this.currentToken = { type: ut.START_TAG_TOKEN, tagName: '', selfClosing: !1, ackSelfClosing: !1, attrs: [] };
    }
    _createEndTagToken() {
      this.currentToken = { type: ut.END_TAG_TOKEN, tagName: '', selfClosing: !1, attrs: [] };
    }
    _createCommentToken() {
      this.currentToken = { type: ut.COMMENT_TOKEN, data: '' };
    }
    _createDoctypeToken(e) {
      this.currentToken = { type: ut.DOCTYPE_TOKEN, name: e, forceQuirks: !1, publicId: null, systemId: null };
    }
    _createCharacterToken(e, t) {
      this.currentCharacterToken = { type: e, chars: t };
    }
    _createEOFToken() {
      this.currentToken = { type: ut.EOF_TOKEN };
    }
    _createAttr(e) {
      this.currentAttr = { name: e, value: '' };
    }
    _leaveAttrName(e) {
      null === ut.getTokenAttr(this.currentToken, this.currentAttr.name) ? this.currentToken.attrs.push(this.currentAttr) : this._err('duplicate-attribute'), (this.state = e);
    }
    _leaveAttrValue(e) {
      this.state = e;
    }
    _emitCurrentToken() {
      this._emitCurrentCharacterToken();
      const e = this.currentToken;
      (this.currentToken = null),
        e.type === ut.START_TAG_TOKEN
          ? (this.lastStartTagName = e.tagName)
          : e.type === ut.END_TAG_TOKEN && (e.attrs.length > 0 && this._err('end-tag-with-attributes'), e.selfClosing && this._err('end-tag-with-trailing-solidus')),
        this.tokenQueue.push(e);
    }
    _emitCurrentCharacterToken() {
      this.currentCharacterToken && (this.tokenQueue.push(this.currentCharacterToken), (this.currentCharacterToken = null));
    }
    _emitEOFToken() {
      this._createEOFToken(), this._emitCurrentToken();
    }
    _appendCharToCurrentCharacterToken(e, t) {
      this.currentCharacterToken && this.currentCharacterToken.type !== e && this._emitCurrentCharacterToken(),
        this.currentCharacterToken ? (this.currentCharacterToken.chars += t) : this._createCharacterToken(e, t);
    }
    _emitCodePoint(e) {
      let t = ut.CHARACTER_TOKEN;
      it(e) ? (t = ut.WHITESPACE_CHARACTER_TOKEN) : e === P.NULL && (t = ut.NULL_CHARACTER_TOKEN), this._appendCharToCurrentCharacterToken(t, mt(e));
    }
    _emitSeveralCodePoints(e) {
      for (let t = 0; t < e.length; t++) this._emitCodePoint(e[t]);
    }
    _emitChars(e) {
      this._appendCharToCurrentCharacterToken(ut.CHARACTER_TOKEN, e);
    }
    _matchNamedCharacterReference(e) {
      let t = null,
        n = 1,
        s = At(0, e);
      for (this.tempBuff.push(e); s > -1; ) {
        const e = g[s],
          r = e < 7;
        r && 1 & e && ((t = 2 & e ? [g[++s], g[++s]] : [g[++s]]), (n = 0));
        const i = this._consume();
        if ((this.tempBuff.push(i), n++, i === P.EOF)) break;
        s = r ? (4 & e ? At(s, i) : -1) : i === e ? ++s : -1;
      }
      for (; n--; ) this.tempBuff.pop(), this._unconsume();
      return t;
    }
    _isCharacterReferenceInAttribute() {
      return this.returnState === me || this.returnState === pe || this.returnState === Ae;
    }
    _isCharacterReferenceAttributeQuirk(e) {
      if (!e && this._isCharacterReferenceInAttribute()) {
        const e = this._consume();
        return this._unconsume(), e === P.EQUALS_SIGN || ht(e);
      }
      return !1;
    }
    _flushCodePointsConsumedAsCharacterReference() {
      if (this._isCharacterReferenceInAttribute()) for (let e = 0; e < this.tempBuff.length; e++) this.currentAttr.value += mt(this.tempBuff[e]);
      else this._emitSeveralCodePoints(this.tempBuff);
      this.tempBuff = [];
    }
    [F](e) {
      this.preprocessor.dropParsedChunk(),
        e === P.LESS_THAN_SIGN
          ? (this.state = b)
          : e === P.AMPERSAND
          ? ((this.returnState = F), (this.state = qe))
          : e === P.NULL
          ? (this._err(a), this._emitCodePoint(e))
          : e === P.EOF
          ? this._emitEOFToken()
          : this._emitCodePoint(e);
    }
    [U](e) {
      this.preprocessor.dropParsedChunk(),
        e === P.AMPERSAND
          ? ((this.returnState = U), (this.state = qe))
          : e === P.LESS_THAN_SIGN
          ? (this.state = v)
          : e === P.NULL
          ? (this._err(a), this._emitChars(n))
          : e === P.EOF
          ? this._emitEOFToken()
          : this._emitCodePoint(e);
    }
    [G](e) {
      this.preprocessor.dropParsedChunk(),
        e === P.LESS_THAN_SIGN ? (this.state = Q) : e === P.NULL ? (this._err(a), this._emitChars(n)) : e === P.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
    }
    [B](e) {
      this.preprocessor.dropParsedChunk(),
        e === P.LESS_THAN_SIGN ? (this.state = V) : e === P.NULL ? (this._err(a), this._emitChars(n)) : e === P.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
    }
    [K](e) {
      this.preprocessor.dropParsedChunk(), e === P.NULL ? (this._err(a), this._emitChars(n)) : e === P.EOF ? this._emitEOFToken() : this._emitCodePoint(e);
    }
    [b](e) {
      e === P.EXCLAMATION_MARK
        ? (this.state = Ce)
        : e === P.SOLIDUS
        ? (this.state = x)
        : Et(e)
        ? (this._createStartTagToken(), this._reconsumeInState(y))
        : e === P.QUESTION_MARK
        ? (this._err('unexpected-question-mark-instead-of-tag-name'), this._createCommentToken(), this._reconsumeInState(de))
        : e === P.EOF
        ? (this._err(h), this._emitChars('<'), this._emitEOFToken())
        : (this._err(T), this._emitChars('<'), this._reconsumeInState(F));
    }
    [x](e) {
      Et(e)
        ? (this._createEndTagToken(), this._reconsumeInState(y))
        : e === P.GREATER_THAN_SIGN
        ? (this._err('missing-end-tag-name'), (this.state = F))
        : e === P.EOF
        ? (this._err(h), this._emitChars('</'), this._emitEOFToken())
        : (this._err(T), this._createCommentToken(), this._reconsumeInState(de));
    }
    [y](e) {
      it(e)
        ? (this.state = he)
        : e === P.SOLIDUS
        ? (this.state = Ne)
        : e === P.GREATER_THAN_SIGN
        ? ((this.state = F), this._emitCurrentToken())
        : at(e)
        ? (this.currentToken.tagName += pt(e))
        : e === P.NULL
        ? (this._err(a), (this.currentToken.tagName += n))
        : e === P.EOF
        ? (this._err(c), this._emitEOFToken())
        : (this.currentToken.tagName += mt(e));
    }
    [v](e) {
      e === P.SOLIDUS ? ((this.tempBuff = []), (this.state = Y)) : (this._emitChars('<'), this._reconsumeInState(U));
    }
    [Y](e) {
      Et(e) ? (this._createEndTagToken(), this._reconsumeInState(w)) : (this._emitChars('</'), this._reconsumeInState(U));
    }
    [w](e) {
      if (at(e)) (this.currentToken.tagName += pt(e)), this.tempBuff.push(e);
      else if (Tt(e)) (this.currentToken.tagName += mt(e)), this.tempBuff.push(e);
      else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (it(e)) return void (this.state = he);
          if (e === P.SOLIDUS) return void (this.state = Ne);
          if (e === P.GREATER_THAN_SIGN) return (this.state = F), void this._emitCurrentToken();
        }
        this._emitChars('</'), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(U);
      }
    }
    [Q](e) {
      e === P.SOLIDUS ? ((this.tempBuff = []), (this.state = X)) : (this._emitChars('<'), this._reconsumeInState(G));
    }
    [X](e) {
      Et(e) ? (this._createEndTagToken(), this._reconsumeInState(W)) : (this._emitChars('</'), this._reconsumeInState(G));
    }
    [W](e) {
      if (at(e)) (this.currentToken.tagName += pt(e)), this.tempBuff.push(e);
      else if (Tt(e)) (this.currentToken.tagName += mt(e)), this.tempBuff.push(e);
      else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (it(e)) return void (this.state = he);
          if (e === P.SOLIDUS) return void (this.state = Ne);
          if (e === P.GREATER_THAN_SIGN) return this._emitCurrentToken(), void (this.state = F);
        }
        this._emitChars('</'), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(G);
      }
    }
    [V](e) {
      e === P.SOLIDUS
        ? ((this.tempBuff = []), (this.state = j))
        : e === P.EXCLAMATION_MARK
        ? ((this.state = q), this._emitChars('<!'))
        : (this._emitChars('<'), this._reconsumeInState(B));
    }
    [j](e) {
      Et(e) ? (this._createEndTagToken(), this._reconsumeInState(z)) : (this._emitChars('</'), this._reconsumeInState(B));
    }
    [z](e) {
      if (at(e)) (this.currentToken.tagName += pt(e)), this.tempBuff.push(e);
      else if (Tt(e)) (this.currentToken.tagName += mt(e)), this.tempBuff.push(e);
      else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (it(e)) return void (this.state = he);
          if (e === P.SOLIDUS) return void (this.state = Ne);
          if (e === P.GREATER_THAN_SIGN) return this._emitCurrentToken(), void (this.state = F);
        }
        this._emitChars('</'), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(B);
      }
    }
    [q](e) {
      e === P.HYPHEN_MINUS ? ((this.state = J), this._emitChars('-')) : this._reconsumeInState(B);
    }
    [J](e) {
      e === P.HYPHEN_MINUS ? ((this.state = ee), this._emitChars('-')) : this._reconsumeInState(B);
    }
    [Z](e) {
      e === P.HYPHEN_MINUS
        ? ((this.state = $), this._emitChars('-'))
        : e === P.LESS_THAN_SIGN
        ? (this.state = te)
        : e === P.NULL
        ? (this._err(a), this._emitChars(n))
        : e === P.EOF
        ? (this._err(O), this._emitEOFToken())
        : this._emitCodePoint(e);
    }
    [$](e) {
      e === P.HYPHEN_MINUS
        ? ((this.state = ee), this._emitChars('-'))
        : e === P.LESS_THAN_SIGN
        ? (this.state = te)
        : e === P.NULL
        ? (this._err(a), (this.state = Z), this._emitChars(n))
        : e === P.EOF
        ? (this._err(O), this._emitEOFToken())
        : ((this.state = Z), this._emitCodePoint(e));
    }
    [ee](e) {
      e === P.HYPHEN_MINUS
        ? this._emitChars('-')
        : e === P.LESS_THAN_SIGN
        ? (this.state = te)
        : e === P.GREATER_THAN_SIGN
        ? ((this.state = B), this._emitChars('>'))
        : e === P.NULL
        ? (this._err(a), (this.state = Z), this._emitChars(n))
        : e === P.EOF
        ? (this._err(O), this._emitEOFToken())
        : ((this.state = Z), this._emitCodePoint(e));
    }
    [te](e) {
      e === P.SOLIDUS
        ? ((this.tempBuff = []), (this.state = ne))
        : Et(e)
        ? ((this.tempBuff = []), this._emitChars('<'), this._reconsumeInState(re))
        : (this._emitChars('<'), this._reconsumeInState(Z));
    }
    [ne](e) {
      Et(e) ? (this._createEndTagToken(), this._reconsumeInState(se)) : (this._emitChars('</'), this._reconsumeInState(Z));
    }
    [se](e) {
      if (at(e)) (this.currentToken.tagName += pt(e)), this.tempBuff.push(e);
      else if (Tt(e)) (this.currentToken.tagName += mt(e)), this.tempBuff.push(e);
      else {
        if (this.lastStartTagName === this.currentToken.tagName) {
          if (it(e)) return void (this.state = he);
          if (e === P.SOLIDUS) return void (this.state = Ne);
          if (e === P.GREATER_THAN_SIGN) return this._emitCurrentToken(), void (this.state = F);
        }
        this._emitChars('</'), this._emitSeveralCodePoints(this.tempBuff), this._reconsumeInState(Z);
      }
    }
    [re](e) {
      it(e) || e === P.SOLIDUS || e === P.GREATER_THAN_SIGN
        ? ((this.state = this._isTempBufferEqualToScriptString() ? ie : Z), this._emitCodePoint(e))
        : at(e)
        ? (this.tempBuff.push(lt(e)), this._emitCodePoint(e))
        : Tt(e)
        ? (this.tempBuff.push(e), this._emitCodePoint(e))
        : this._reconsumeInState(Z);
    }
    [ie](e) {
      e === P.HYPHEN_MINUS
        ? ((this.state = oe), this._emitChars('-'))
        : e === P.LESS_THAN_SIGN
        ? ((this.state = Te), this._emitChars('<'))
        : e === P.NULL
        ? (this._err(a), this._emitChars(n))
        : e === P.EOF
        ? (this._err(O), this._emitEOFToken())
        : this._emitCodePoint(e);
    }
    [oe](e) {
      e === P.HYPHEN_MINUS
        ? ((this.state = ae), this._emitChars('-'))
        : e === P.LESS_THAN_SIGN
        ? ((this.state = Te), this._emitChars('<'))
        : e === P.NULL
        ? (this._err(a), (this.state = ie), this._emitChars(n))
        : e === P.EOF
        ? (this._err(O), this._emitEOFToken())
        : ((this.state = ie), this._emitCodePoint(e));
    }
    [ae](e) {
      e === P.HYPHEN_MINUS
        ? this._emitChars('-')
        : e === P.LESS_THAN_SIGN
        ? ((this.state = Te), this._emitChars('<'))
        : e === P.GREATER_THAN_SIGN
        ? ((this.state = B), this._emitChars('>'))
        : e === P.NULL
        ? (this._err(a), (this.state = ie), this._emitChars(n))
        : e === P.EOF
        ? (this._err(O), this._emitEOFToken())
        : ((this.state = ie), this._emitCodePoint(e));
    }
    [Te](e) {
      e === P.SOLIDUS ? ((this.tempBuff = []), (this.state = Ee), this._emitChars('/')) : this._reconsumeInState(ie);
    }
    [Ee](e) {
      it(e) || e === P.SOLIDUS || e === P.GREATER_THAN_SIGN
        ? ((this.state = this._isTempBufferEqualToScriptString() ? Z : ie), this._emitCodePoint(e))
        : at(e)
        ? (this.tempBuff.push(lt(e)), this._emitCodePoint(e))
        : Tt(e)
        ? (this.tempBuff.push(e), this._emitCodePoint(e))
        : this._reconsumeInState(ie);
    }
    [he](e) {
      it(e) ||
        (e === P.SOLIDUS || e === P.GREATER_THAN_SIGN || e === P.EOF
          ? this._reconsumeInState(_e)
          : e === P.EQUALS_SIGN
          ? (this._err('unexpected-equals-sign-before-attribute-name'), this._createAttr('='), (this.state = ce))
          : (this._createAttr(''), this._reconsumeInState(ce)));
    }
    [ce](e) {
      it(e) || e === P.SOLIDUS || e === P.GREATER_THAN_SIGN || e === P.EOF
        ? (this._leaveAttrName(_e), this._unconsume())
        : e === P.EQUALS_SIGN
        ? this._leaveAttrName(le)
        : at(e)
        ? (this.currentAttr.name += pt(e))
        : e === P.QUOTATION_MARK || e === P.APOSTROPHE || e === P.LESS_THAN_SIGN
        ? (this._err('unexpected-character-in-attribute-name'), (this.currentAttr.name += mt(e)))
        : e === P.NULL
        ? (this._err(a), (this.currentAttr.name += n))
        : (this.currentAttr.name += mt(e));
    }
    [_e](e) {
      it(e) ||
        (e === P.SOLIDUS
          ? (this.state = Ne)
          : e === P.EQUALS_SIGN
          ? (this.state = le)
          : e === P.GREATER_THAN_SIGN
          ? ((this.state = F), this._emitCurrentToken())
          : e === P.EOF
          ? (this._err(c), this._emitEOFToken())
          : (this._createAttr(''), this._reconsumeInState(ce)));
    }
    [le](e) {
      it(e) ||
        (e === P.QUOTATION_MARK
          ? (this.state = me)
          : e === P.APOSTROPHE
          ? (this.state = pe)
          : e === P.GREATER_THAN_SIGN
          ? (this._err('missing-attribute-value'), (this.state = F), this._emitCurrentToken())
          : this._reconsumeInState(Ae));
    }
    [me](e) {
      e === P.QUOTATION_MARK
        ? (this.state = ue)
        : e === P.AMPERSAND
        ? ((this.returnState = me), (this.state = qe))
        : e === P.NULL
        ? (this._err(a), (this.currentAttr.value += n))
        : e === P.EOF
        ? (this._err(c), this._emitEOFToken())
        : (this.currentAttr.value += mt(e));
    }
    [pe](e) {
      e === P.APOSTROPHE
        ? (this.state = ue)
        : e === P.AMPERSAND
        ? ((this.returnState = pe), (this.state = qe))
        : e === P.NULL
        ? (this._err(a), (this.currentAttr.value += n))
        : e === P.EOF
        ? (this._err(c), this._emitEOFToken())
        : (this.currentAttr.value += mt(e));
    }
    [Ae](e) {
      it(e)
        ? this._leaveAttrValue(he)
        : e === P.AMPERSAND
        ? ((this.returnState = Ae), (this.state = qe))
        : e === P.GREATER_THAN_SIGN
        ? (this._leaveAttrValue(F), this._emitCurrentToken())
        : e === P.NULL
        ? (this._err(a), (this.currentAttr.value += n))
        : e === P.QUOTATION_MARK || e === P.APOSTROPHE || e === P.LESS_THAN_SIGN || e === P.EQUALS_SIGN || e === P.GRAVE_ACCENT
        ? (this._err('unexpected-character-in-unquoted-attribute-value'), (this.currentAttr.value += mt(e)))
        : e === P.EOF
        ? (this._err(c), this._emitEOFToken())
        : (this.currentAttr.value += mt(e));
    }
    [ue](e) {
      it(e)
        ? this._leaveAttrValue(he)
        : e === P.SOLIDUS
        ? this._leaveAttrValue(Ne)
        : e === P.GREATER_THAN_SIGN
        ? (this._leaveAttrValue(F), this._emitCurrentToken())
        : e === P.EOF
        ? (this._err(c), this._emitEOFToken())
        : (this._err('missing-whitespace-between-attributes'), this._reconsumeInState(he));
    }
    [Ne](e) {
      e === P.GREATER_THAN_SIGN
        ? ((this.currentToken.selfClosing = !0), (this.state = F), this._emitCurrentToken())
        : e === P.EOF
        ? (this._err(c), this._emitEOFToken())
        : (this._err('unexpected-solidus-in-tag'), this._reconsumeInState(he));
    }
    [de](e) {
      e === P.GREATER_THAN_SIGN
        ? ((this.state = F), this._emitCurrentToken())
        : e === P.EOF
        ? (this._emitCurrentToken(), this._emitEOFToken())
        : e === P.NULL
        ? (this._err(a), (this.currentToken.data += n))
        : (this.currentToken.data += mt(e));
    }
    [Ce](e) {
      this._consumeSequenceIfMatch(H.DASH_DASH_STRING, e, !0)
        ? (this._createCommentToken(), (this.state = Oe))
        : this._consumeSequenceIfMatch(H.DOCTYPE_STRING, e, !1)
        ? (this.state = He)
        : this._consumeSequenceIfMatch(H.CDATA_START_STRING, e, !0)
        ? this.allowCDATA
          ? (this.state = Ve)
          : (this._err('cdata-in-html-content'), this._createCommentToken(), (this.currentToken.data = '[CDATA['), (this.state = de))
        : this._ensureHibernation() || (this._err('incorrectly-opened-comment'), this._createCommentToken(), this._reconsumeInState(de));
    }
    [Oe](e) {
      e === P.HYPHEN_MINUS ? (this.state = fe) : e === P.GREATER_THAN_SIGN ? (this._err(S), (this.state = F), this._emitCurrentToken()) : this._reconsumeInState(Se);
    }
    [fe](e) {
      e === P.HYPHEN_MINUS
        ? (this.state = ge)
        : e === P.GREATER_THAN_SIGN
        ? (this._err(S), (this.state = F), this._emitCurrentToken())
        : e === P.EOF
        ? (this._err(R), this._emitCurrentToken(), this._emitEOFToken())
        : ((this.currentToken.data += '-'), this._reconsumeInState(Se));
    }
    [Se](e) {
      e === P.HYPHEN_MINUS
        ? (this.state = Me)
        : e === P.LESS_THAN_SIGN
        ? ((this.currentToken.data += '<'), (this.state = Re))
        : e === P.NULL
        ? (this._err(a), (this.currentToken.data += n))
        : e === P.EOF
        ? (this._err(R), this._emitCurrentToken(), this._emitEOFToken())
        : (this.currentToken.data += mt(e));
    }
    [Re](e) {
      e === P.EXCLAMATION_MARK ? ((this.currentToken.data += '!'), (this.state = Ie)) : e === P.LESS_THAN_SIGN ? (this.currentToken.data += '!') : this._reconsumeInState(Se);
    }
    [Ie](e) {
      e === P.HYPHEN_MINUS ? (this.state = Le) : this._reconsumeInState(Se);
    }
    [Le](e) {
      e === P.HYPHEN_MINUS ? (this.state = ke) : this._reconsumeInState(Me);
    }
    [ke](e) {
      e !== P.GREATER_THAN_SIGN && e !== P.EOF && this._err('nested-comment'), this._reconsumeInState(ge);
    }
    [Me](e) {
      e === P.HYPHEN_MINUS
        ? (this.state = ge)
        : e === P.EOF
        ? (this._err(R), this._emitCurrentToken(), this._emitEOFToken())
        : ((this.currentToken.data += '-'), this._reconsumeInState(Se));
    }
    [ge](e) {
      e === P.GREATER_THAN_SIGN
        ? ((this.state = F), this._emitCurrentToken())
        : e === P.EXCLAMATION_MARK
        ? (this.state = Pe)
        : e === P.HYPHEN_MINUS
        ? (this.currentToken.data += '-')
        : e === P.EOF
        ? (this._err(R), this._emitCurrentToken(), this._emitEOFToken())
        : ((this.currentToken.data += '--'), this._reconsumeInState(Se));
    }
    [Pe](e) {
      e === P.HYPHEN_MINUS
        ? ((this.currentToken.data += '--!'), (this.state = Me))
        : e === P.GREATER_THAN_SIGN
        ? (this._err('incorrectly-closed-comment'), (this.state = F), this._emitCurrentToken())
        : e === P.EOF
        ? (this._err(R), this._emitCurrentToken(), this._emitEOFToken())
        : ((this.currentToken.data += '--!'), this._reconsumeInState(Se));
    }
    [He](e) {
      it(e)
        ? (this.state = De)
        : e === P.GREATER_THAN_SIGN
        ? this._reconsumeInState(De)
        : e === P.EOF
        ? (this._err(f), this._createDoctypeToken(null), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
        : (this._err('missing-whitespace-before-doctype-name'), this._reconsumeInState(De));
    }
    [De](e) {
      it(e) ||
        (at(e)
          ? (this._createDoctypeToken(pt(e)), (this.state = Fe))
          : e === P.NULL
          ? (this._err(a), this._createDoctypeToken(n), (this.state = Fe))
          : e === P.GREATER_THAN_SIGN
          ? (this._err('missing-doctype-name'), this._createDoctypeToken(null), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), (this.state = F))
          : e === P.EOF
          ? (this._err(f), this._createDoctypeToken(null), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
          : (this._createDoctypeToken(mt(e)), (this.state = Fe)));
    }
    [Fe](e) {
      it(e)
        ? (this.state = Ue)
        : e === P.GREATER_THAN_SIGN
        ? ((this.state = F), this._emitCurrentToken())
        : at(e)
        ? (this.currentToken.name += pt(e))
        : e === P.NULL
        ? (this._err(a), (this.currentToken.name += n))
        : e === P.EOF
        ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
        : (this.currentToken.name += mt(e));
    }
    [Ue](e) {
      it(e) ||
        (e === P.GREATER_THAN_SIGN
          ? ((this.state = F), this._emitCurrentToken())
          : e === P.EOF
          ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
          : this._consumeSequenceIfMatch(H.PUBLIC_STRING, e, !1)
          ? (this.state = Ge)
          : this._consumeSequenceIfMatch(H.SYSTEM_STRING, e, !1)
          ? (this.state = ve)
          : this._ensureHibernation() || (this._err('invalid-character-sequence-after-doctype-name'), (this.currentToken.forceQuirks = !0), this._reconsumeInState(We)));
    }
    [Ge](e) {
      it(e)
        ? (this.state = Be)
        : e === P.QUOTATION_MARK
        ? (this._err(_), (this.currentToken.publicId = ''), (this.state = Ke))
        : e === P.APOSTROPHE
        ? (this._err(_), (this.currentToken.publicId = ''), (this.state = be))
        : e === P.GREATER_THAN_SIGN
        ? (this._err(u), (this.currentToken.forceQuirks = !0), (this.state = F), this._emitCurrentToken())
        : e === P.EOF
        ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
        : (this._err(p), (this.currentToken.forceQuirks = !0), this._reconsumeInState(We));
    }
    [Be](e) {
      it(e) ||
        (e === P.QUOTATION_MARK
          ? ((this.currentToken.publicId = ''), (this.state = Ke))
          : e === P.APOSTROPHE
          ? ((this.currentToken.publicId = ''), (this.state = be))
          : e === P.GREATER_THAN_SIGN
          ? (this._err(u), (this.currentToken.forceQuirks = !0), (this.state = F), this._emitCurrentToken())
          : e === P.EOF
          ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
          : (this._err(p), (this.currentToken.forceQuirks = !0), this._reconsumeInState(We)));
    }
    [Ke](e) {
      e === P.QUOTATION_MARK
        ? (this.state = xe)
        : e === P.NULL
        ? (this._err(a), (this.currentToken.publicId += n))
        : e === P.GREATER_THAN_SIGN
        ? (this._err(d), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), (this.state = F))
        : e === P.EOF
        ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
        : (this.currentToken.publicId += mt(e));
    }
    [be](e) {
      e === P.APOSTROPHE
        ? (this.state = xe)
        : e === P.NULL
        ? (this._err(a), (this.currentToken.publicId += n))
        : e === P.GREATER_THAN_SIGN
        ? (this._err(d), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), (this.state = F))
        : e === P.EOF
        ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
        : (this.currentToken.publicId += mt(e));
    }
    [xe](e) {
      it(e)
        ? (this.state = ye)
        : e === P.GREATER_THAN_SIGN
        ? ((this.state = F), this._emitCurrentToken())
        : e === P.QUOTATION_MARK
        ? (this._err(l), (this.currentToken.systemId = ''), (this.state = we))
        : e === P.APOSTROPHE
        ? (this._err(l), (this.currentToken.systemId = ''), (this.state = Qe))
        : e === P.EOF
        ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
        : (this._err(A), (this.currentToken.forceQuirks = !0), this._reconsumeInState(We));
    }
    [ye](e) {
      it(e) ||
        (e === P.GREATER_THAN_SIGN
          ? (this._emitCurrentToken(), (this.state = F))
          : e === P.QUOTATION_MARK
          ? ((this.currentToken.systemId = ''), (this.state = we))
          : e === P.APOSTROPHE
          ? ((this.currentToken.systemId = ''), (this.state = Qe))
          : e === P.EOF
          ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
          : (this._err(A), (this.currentToken.forceQuirks = !0), this._reconsumeInState(We)));
    }
    [ve](e) {
      it(e)
        ? (this.state = Ye)
        : e === P.QUOTATION_MARK
        ? (this._err(m), (this.currentToken.systemId = ''), (this.state = we))
        : e === P.APOSTROPHE
        ? (this._err(m), (this.currentToken.systemId = ''), (this.state = Qe))
        : e === P.GREATER_THAN_SIGN
        ? (this._err(N), (this.currentToken.forceQuirks = !0), (this.state = F), this._emitCurrentToken())
        : e === P.EOF
        ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
        : (this._err(A), (this.currentToken.forceQuirks = !0), this._reconsumeInState(We));
    }
    [Ye](e) {
      it(e) ||
        (e === P.QUOTATION_MARK
          ? ((this.currentToken.systemId = ''), (this.state = we))
          : e === P.APOSTROPHE
          ? ((this.currentToken.systemId = ''), (this.state = Qe))
          : e === P.GREATER_THAN_SIGN
          ? (this._err(N), (this.currentToken.forceQuirks = !0), (this.state = F), this._emitCurrentToken())
          : e === P.EOF
          ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
          : (this._err(A), (this.currentToken.forceQuirks = !0), this._reconsumeInState(We)));
    }
    [we](e) {
      e === P.QUOTATION_MARK
        ? (this.state = Xe)
        : e === P.NULL
        ? (this._err(a), (this.currentToken.systemId += n))
        : e === P.GREATER_THAN_SIGN
        ? (this._err(C), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), (this.state = F))
        : e === P.EOF
        ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
        : (this.currentToken.systemId += mt(e));
    }
    [Qe](e) {
      e === P.APOSTROPHE
        ? (this.state = Xe)
        : e === P.NULL
        ? (this._err(a), (this.currentToken.systemId += n))
        : e === P.GREATER_THAN_SIGN
        ? (this._err(C), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), (this.state = F))
        : e === P.EOF
        ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
        : (this.currentToken.systemId += mt(e));
    }
    [Xe](e) {
      it(e) ||
        (e === P.GREATER_THAN_SIGN
          ? (this._emitCurrentToken(), (this.state = F))
          : e === P.EOF
          ? (this._err(f), (this.currentToken.forceQuirks = !0), this._emitCurrentToken(), this._emitEOFToken())
          : (this._err('unexpected-character-after-doctype-system-identifier'), this._reconsumeInState(We)));
    }
    [We](e) {
      e === P.GREATER_THAN_SIGN ? (this._emitCurrentToken(), (this.state = F)) : e === P.NULL ? this._err(a) : e === P.EOF && (this._emitCurrentToken(), this._emitEOFToken());
    }
    [Ve](e) {
      e === P.RIGHT_SQUARE_BRACKET ? (this.state = je) : e === P.EOF ? (this._err('eof-in-cdata'), this._emitEOFToken()) : this._emitCodePoint(e);
    }
    [je](e) {
      e === P.RIGHT_SQUARE_BRACKET ? (this.state = ze) : (this._emitChars(']'), this._reconsumeInState(Ve));
    }
    [ze](e) {
      e === P.GREATER_THAN_SIGN ? (this.state = F) : e === P.RIGHT_SQUARE_BRACKET ? this._emitChars(']') : (this._emitChars(']]'), this._reconsumeInState(Ve));
    }
    [qe](e) {
      (this.tempBuff = [P.AMPERSAND]),
        e === P.NUMBER_SIGN
          ? (this.tempBuff.push(e), (this.state = $e))
          : ht(e)
          ? this._reconsumeInState(Je)
          : (this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState));
    }
    [Je](e) {
      const t = this._matchNamedCharacterReference(e);
      if (this._ensureHibernation()) this.tempBuff = [P.AMPERSAND];
      else if (t) {
        const e = this.tempBuff[this.tempBuff.length - 1] === P.SEMICOLON;
        this._isCharacterReferenceAttributeQuirk(e) || (e || this._errOnNextCodePoint(E), (this.tempBuff = t)),
          this._flushCodePointsConsumedAsCharacterReference(),
          (this.state = this.returnState);
      } else this._flushCodePointsConsumedAsCharacterReference(), (this.state = Ze);
    }
    [Ze](e) {
      ht(e)
        ? this._isCharacterReferenceInAttribute()
          ? (this.currentAttr.value += mt(e))
          : this._emitCodePoint(e)
        : (e === P.SEMICOLON && this._err('unknown-named-character-reference'), this._reconsumeInState(this.returnState));
    }
    [$e](e) {
      (this.charRefCode = 0), e === P.LATIN_SMALL_X || e === P.LATIN_CAPITAL_X ? (this.tempBuff.push(e), (this.state = et)) : this._reconsumeInState(tt);
    }
    [et](e) {
      !(function (e) {
        return ot(e) || ct(e) || _t(e);
      })(e)
        ? (this._err(I), this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState))
        : this._reconsumeInState(nt);
    }
    [tt](e) {
      ot(e) ? this._reconsumeInState(st) : (this._err(I), this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState));
    }
    [nt](e) {
      ct(e)
        ? (this.charRefCode = 16 * this.charRefCode + e - 55)
        : _t(e)
        ? (this.charRefCode = 16 * this.charRefCode + e - 87)
        : ot(e)
        ? (this.charRefCode = 16 * this.charRefCode + e - 48)
        : e === P.SEMICOLON
        ? (this.state = rt)
        : (this._err(E), this._reconsumeInState(rt));
    }
    [st](e) {
      ot(e) ? (this.charRefCode = 10 * this.charRefCode + e - 48) : e === P.SEMICOLON ? (this.state = rt) : (this._err(E), this._reconsumeInState(rt));
    }
    [rt]() {
      if (this.charRefCode === P.NULL) this._err('null-character-reference'), (this.charRefCode = P.REPLACEMENT_CHARACTER);
      else if (this.charRefCode > 1114111) this._err('character-reference-outside-unicode-range'), (this.charRefCode = P.REPLACEMENT_CHARACTER);
      else if (r(this.charRefCode)) this._err('surrogate-character-reference'), (this.charRefCode = P.REPLACEMENT_CHARACTER);
      else if (o(this.charRefCode)) this._err('noncharacter-character-reference');
      else if (i(this.charRefCode) || this.charRefCode === P.CARRIAGE_RETURN) {
        this._err('control-character-reference');
        const e = D[this.charRefCode];
        e && (this.charRefCode = e);
      }
      (this.tempBuff = [this.charRefCode]), this._flushCodePointsConsumedAsCharacterReference(), this._reconsumeInState(this.returnState);
    }
  }
  (ut.CHARACTER_TOKEN = 'CHARACTER_TOKEN'),
    (ut.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN'),
    (ut.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN'),
    (ut.START_TAG_TOKEN = 'START_TAG_TOKEN'),
    (ut.END_TAG_TOKEN = 'END_TAG_TOKEN'),
    (ut.COMMENT_TOKEN = 'COMMENT_TOKEN'),
    (ut.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN'),
    (ut.EOF_TOKEN = 'EOF_TOKEN'),
    (ut.HIBERNATION_TOKEN = 'HIBERNATION_TOKEN'),
    (ut.MODE = { DATA: F, RCDATA: U, RAWTEXT: G, SCRIPT_DATA: B, PLAINTEXT: K }),
    (ut.getTokenAttr = function (e, t) {
      for (let n = e.attrs.length - 1; n >= 0; n--) if (e.attrs[n].name === t) return e.attrs[n].value;
      return null;
    });
  var Nt = ut;
  function dt(e, t, n) {
    return (
      e(
        (n = {
          path: t,
          exports: {},
          require: function (e, t) {
            return (function () {
              throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
            })(null == t && n.path);
          },
        }),
        n.exports,
      ),
      n.exports
    );
  }
  var Ct = dt(function (e, t) {
    const n = (t.NAMESPACES = {
      HTML: 'http://www.w3.org/1999/xhtml',
      MATHML: 'http://www.w3.org/1998/Math/MathML',
      SVG: 'http://www.w3.org/2000/svg',
      XLINK: 'http://www.w3.org/1999/xlink',
      XML: 'http://www.w3.org/XML/1998/namespace',
      XMLNS: 'http://www.w3.org/2000/xmlns/',
    });
    (t.ATTRS = { TYPE: 'type', ACTION: 'action', ENCODING: 'encoding', PROMPT: 'prompt', NAME: 'name', COLOR: 'color', FACE: 'face', SIZE: 'size' }),
      (t.DOCUMENT_MODE = { NO_QUIRKS: 'no-quirks', QUIRKS: 'quirks', LIMITED_QUIRKS: 'limited-quirks' });
    const s = (t.TAG_NAMES = {
      A: 'a',
      ADDRESS: 'address',
      ANNOTATION_XML: 'annotation-xml',
      APPLET: 'applet',
      AREA: 'area',
      ARTICLE: 'article',
      ASIDE: 'aside',
      B: 'b',
      BASE: 'base',
      BASEFONT: 'basefont',
      BGSOUND: 'bgsound',
      BIG: 'big',
      BLOCKQUOTE: 'blockquote',
      BODY: 'body',
      BR: 'br',
      BUTTON: 'button',
      CAPTION: 'caption',
      CENTER: 'center',
      CODE: 'code',
      COL: 'col',
      COLGROUP: 'colgroup',
      DD: 'dd',
      DESC: 'desc',
      DETAILS: 'details',
      DIALOG: 'dialog',
      DIR: 'dir',
      DIV: 'div',
      DL: 'dl',
      DT: 'dt',
      EM: 'em',
      EMBED: 'embed',
      FIELDSET: 'fieldset',
      FIGCAPTION: 'figcaption',
      FIGURE: 'figure',
      FONT: 'font',
      FOOTER: 'footer',
      FOREIGN_OBJECT: 'foreignObject',
      FORM: 'form',
      FRAME: 'frame',
      FRAMESET: 'frameset',
      H1: 'h1',
      H2: 'h2',
      H3: 'h3',
      H4: 'h4',
      H5: 'h5',
      H6: 'h6',
      HEAD: 'head',
      HEADER: 'header',
      HGROUP: 'hgroup',
      HR: 'hr',
      HTML: 'html',
      I: 'i',
      IMG: 'img',
      IMAGE: 'image',
      INPUT: 'input',
      IFRAME: 'iframe',
      KEYGEN: 'keygen',
      LABEL: 'label',
      LI: 'li',
      LINK: 'link',
      LISTING: 'listing',
      MAIN: 'main',
      MALIGNMARK: 'malignmark',
      MARQUEE: 'marquee',
      MATH: 'math',
      MENU: 'menu',
      META: 'meta',
      MGLYPH: 'mglyph',
      MI: 'mi',
      MO: 'mo',
      MN: 'mn',
      MS: 'ms',
      MTEXT: 'mtext',
      NAV: 'nav',
      NOBR: 'nobr',
      NOFRAMES: 'noframes',
      NOEMBED: 'noembed',
      NOSCRIPT: 'noscript',
      OBJECT: 'object',
      OL: 'ol',
      OPTGROUP: 'optgroup',
      OPTION: 'option',
      P: 'p',
      PARAM: 'param',
      PLAINTEXT: 'plaintext',
      PRE: 'pre',
      RB: 'rb',
      RP: 'rp',
      RT: 'rt',
      RTC: 'rtc',
      RUBY: 'ruby',
      S: 's',
      SCRIPT: 'script',
      SECTION: 'section',
      SELECT: 'select',
      SOURCE: 'source',
      SMALL: 'small',
      SPAN: 'span',
      STRIKE: 'strike',
      STRONG: 'strong',
      STYLE: 'style',
      SUB: 'sub',
      SUMMARY: 'summary',
      SUP: 'sup',
      TABLE: 'table',
      TBODY: 'tbody',
      TEMPLATE: 'template',
      TEXTAREA: 'textarea',
      TFOOT: 'tfoot',
      TD: 'td',
      TH: 'th',
      THEAD: 'thead',
      TITLE: 'title',
      TR: 'tr',
      TRACK: 'track',
      TT: 'tt',
      U: 'u',
      UL: 'ul',
      SVG: 'svg',
      VAR: 'var',
      WBR: 'wbr',
      XMP: 'xmp',
    });
    t.SPECIAL_ELEMENTS = {
      [n.HTML]: {
        [s.ADDRESS]: !0,
        [s.APPLET]: !0,
        [s.AREA]: !0,
        [s.ARTICLE]: !0,
        [s.ASIDE]: !0,
        [s.BASE]: !0,
        [s.BASEFONT]: !0,
        [s.BGSOUND]: !0,
        [s.BLOCKQUOTE]: !0,
        [s.BODY]: !0,
        [s.BR]: !0,
        [s.BUTTON]: !0,
        [s.CAPTION]: !0,
        [s.CENTER]: !0,
        [s.COL]: !0,
        [s.COLGROUP]: !0,
        [s.DD]: !0,
        [s.DETAILS]: !0,
        [s.DIR]: !0,
        [s.DIV]: !0,
        [s.DL]: !0,
        [s.DT]: !0,
        [s.EMBED]: !0,
        [s.FIELDSET]: !0,
        [s.FIGCAPTION]: !0,
        [s.FIGURE]: !0,
        [s.FOOTER]: !0,
        [s.FORM]: !0,
        [s.FRAME]: !0,
        [s.FRAMESET]: !0,
        [s.H1]: !0,
        [s.H2]: !0,
        [s.H3]: !0,
        [s.H4]: !0,
        [s.H5]: !0,
        [s.H6]: !0,
        [s.HEAD]: !0,
        [s.HEADER]: !0,
        [s.HGROUP]: !0,
        [s.HR]: !0,
        [s.HTML]: !0,
        [s.IFRAME]: !0,
        [s.IMG]: !0,
        [s.INPUT]: !0,
        [s.LI]: !0,
        [s.LINK]: !0,
        [s.LISTING]: !0,
        [s.MAIN]: !0,
        [s.MARQUEE]: !0,
        [s.MENU]: !0,
        [s.META]: !0,
        [s.NAV]: !0,
        [s.NOEMBED]: !0,
        [s.NOFRAMES]: !0,
        [s.NOSCRIPT]: !0,
        [s.OBJECT]: !0,
        [s.OL]: !0,
        [s.P]: !0,
        [s.PARAM]: !0,
        [s.PLAINTEXT]: !0,
        [s.PRE]: !0,
        [s.SCRIPT]: !0,
        [s.SECTION]: !0,
        [s.SELECT]: !0,
        [s.SOURCE]: !0,
        [s.STYLE]: !0,
        [s.SUMMARY]: !0,
        [s.TABLE]: !0,
        [s.TBODY]: !0,
        [s.TD]: !0,
        [s.TEMPLATE]: !0,
        [s.TEXTAREA]: !0,
        [s.TFOOT]: !0,
        [s.TH]: !0,
        [s.THEAD]: !0,
        [s.TITLE]: !0,
        [s.TR]: !0,
        [s.TRACK]: !0,
        [s.UL]: !0,
        [s.WBR]: !0,
        [s.XMP]: !0,
      },
      [n.MATHML]: { [s.MI]: !0, [s.MO]: !0, [s.MN]: !0, [s.MS]: !0, [s.MTEXT]: !0, [s.ANNOTATION_XML]: !0 },
      [n.SVG]: { [s.TITLE]: !0, [s.FOREIGN_OBJECT]: !0, [s.DESC]: !0 },
    };
  });
  const Ot = Ct.TAG_NAMES,
    ft = Ct.NAMESPACES;
  function St(e) {
    switch (e.length) {
      case 1:
        return e === Ot.P;
      case 2:
        return e === Ot.RB || e === Ot.RP || e === Ot.RT || e === Ot.DD || e === Ot.DT || e === Ot.LI;
      case 3:
        return e === Ot.RTC;
      case 6:
        return e === Ot.OPTION;
      case 8:
        return e === Ot.OPTGROUP;
    }
    return !1;
  }
  function Rt(e) {
    switch (e.length) {
      case 1:
        return e === Ot.P;
      case 2:
        return e === Ot.RB || e === Ot.RP || e === Ot.RT || e === Ot.DD || e === Ot.DT || e === Ot.LI || e === Ot.TD || e === Ot.TH || e === Ot.TR;
      case 3:
        return e === Ot.RTC;
      case 5:
        return e === Ot.TBODY || e === Ot.TFOOT || e === Ot.THEAD;
      case 6:
        return e === Ot.OPTION;
      case 7:
        return e === Ot.CAPTION;
      case 8:
        return e === Ot.OPTGROUP || e === Ot.COLGROUP;
    }
    return !1;
  }
  function It(e, t) {
    switch (e.length) {
      case 2:
        if (e === Ot.TD || e === Ot.TH) return t === ft.HTML;
        if (e === Ot.MI || e === Ot.MO || e === Ot.MN || e === Ot.MS) return t === ft.MATHML;
        break;
      case 4:
        if (e === Ot.HTML) return t === ft.HTML;
        if (e === Ot.DESC) return t === ft.SVG;
        break;
      case 5:
        if (e === Ot.TABLE) return t === ft.HTML;
        if (e === Ot.MTEXT) return t === ft.MATHML;
        if (e === Ot.TITLE) return t === ft.SVG;
        break;
      case 6:
        return (e === Ot.APPLET || e === Ot.OBJECT) && t === ft.HTML;
      case 7:
        return (e === Ot.CAPTION || e === Ot.MARQUEE) && t === ft.HTML;
      case 8:
        return e === Ot.TEMPLATE && t === ft.HTML;
      case 13:
        return e === Ot.FOREIGN_OBJECT && t === ft.SVG;
      case 14:
        return e === Ot.ANNOTATION_XML && t === ft.MATHML;
    }
    return !1;
  }
  class Lt {
    constructor(e) {
      (this.length = 0), (this.entries = []), (this.treeAdapter = e), (this.bookmark = null);
    }
    _getNoahArkConditionCandidates(e) {
      const t = [];
      if (this.length >= 3) {
        const n = this.treeAdapter.getAttrList(e).length,
          s = this.treeAdapter.getTagName(e),
          r = this.treeAdapter.getNamespaceURI(e);
        for (let e = this.length - 1; e >= 0; e--) {
          const i = this.entries[e];
          if (i.type === Lt.MARKER_ENTRY) break;
          const o = i.element,
            a = this.treeAdapter.getAttrList(o);
          this.treeAdapter.getTagName(o) === s && this.treeAdapter.getNamespaceURI(o) === r && a.length === n && t.push({ idx: e, attrs: a });
        }
      }
      return t.length < 3 ? [] : t;
    }
    _ensureNoahArkCondition(e) {
      const t = this._getNoahArkConditionCandidates(e);
      let n = t.length;
      if (n) {
        const s = this.treeAdapter.getAttrList(e),
          r = s.length,
          i = Object.create(null);
        for (let e = 0; e < r; e++) {
          const t = s[e];
          i[t.name] = t.value;
        }
        for (let e = 0; e < r; e++)
          for (let s = 0; s < n; s++) {
            const r = t[s].attrs[e];
            if ((i[r.name] !== r.value && (t.splice(s, 1), n--), t.length < 3)) return;
          }
        for (let e = n - 1; e >= 2; e--) this.entries.splice(t[e].idx, 1), this.length--;
      }
    }
    insertMarker() {
      this.entries.push({ type: Lt.MARKER_ENTRY }), this.length++;
    }
    pushElement(e, t) {
      this._ensureNoahArkCondition(e), this.entries.push({ type: Lt.ELEMENT_ENTRY, element: e, token: t }), this.length++;
    }
    insertElementAfterBookmark(e, t) {
      let n = this.length - 1;
      for (; n >= 0 && this.entries[n] !== this.bookmark; n--);
      this.entries.splice(n + 1, 0, { type: Lt.ELEMENT_ENTRY, element: e, token: t }), this.length++;
    }
    removeEntry(e) {
      for (let t = this.length - 1; t >= 0; t--)
        if (this.entries[t] === e) {
          this.entries.splice(t, 1), this.length--;
          break;
        }
    }
    clearToLastMarker() {
      for (; this.length; ) {
        const e = this.entries.pop();
        if ((this.length--, e.type === Lt.MARKER_ENTRY)) break;
      }
    }
    getElementEntryInScopeWithTagName(e) {
      for (let t = this.length - 1; t >= 0; t--) {
        const n = this.entries[t];
        if (n.type === Lt.MARKER_ENTRY) return null;
        if (this.treeAdapter.getTagName(n.element) === e) return n;
      }
      return null;
    }
    getElementEntry(e) {
      for (let t = this.length - 1; t >= 0; t--) {
        const n = this.entries[t];
        if (n.type === Lt.ELEMENT_ENTRY && n.element === e) return n;
      }
      return null;
    }
  }
  (Lt.MARKER_ENTRY = 'MARKER_ENTRY'), (Lt.ELEMENT_ENTRY = 'ELEMENT_ENTRY');
  var kt = Lt;
  class Mt {
    constructor(e) {
      const t = {},
        n = this._getOverriddenMethods(this, t);
      for (const s of Object.keys(n)) 'function' == typeof n[s] && ((t[s] = e[s]), (e[s] = n[s]));
    }
    _getOverriddenMethods() {
      throw new Error('Not implemented');
    }
  }
  Mt.install = function (e, t, n) {
    e.__mixins || (e.__mixins = []);
    for (let n = 0; n < e.__mixins.length; n++) if (e.__mixins[n].constructor === t) return e.__mixins[n];
    const s = new t(e, n);
    return e.__mixins.push(s), s;
  };
  var gt = Mt,
    Pt = class extends gt {
      constructor(e) {
        super(e), (this.preprocessor = e), (this.isEol = !1), (this.lineStartPos = 0), (this.droppedBufferSize = 0), (this.offset = 0), (this.col = 0), (this.line = 1);
      }
      _getOverriddenMethods(e, t) {
        return {
          advance() {
            const n = this.pos + 1,
              s = this.html[n];
            return (
              e.isEol && ((e.isEol = !1), e.line++, (e.lineStartPos = n)),
              ('\n' === s || ('\r' === s && '\n' !== this.html[n + 1])) && (e.isEol = !0),
              (e.col = n - e.lineStartPos + 1),
              (e.offset = e.droppedBufferSize + n),
              t.advance.call(this)
            );
          },
          retreat() {
            t.retreat.call(this), (e.isEol = !1), (e.col = this.pos - e.lineStartPos + 1);
          },
          dropParsedChunk() {
            const n = this.pos;
            t.dropParsedChunk.call(this);
            const s = n - this.pos;
            (e.lineStartPos -= s), (e.droppedBufferSize += s), (e.offset = e.droppedBufferSize + this.pos);
          },
        };
      }
    },
    Ht = class extends gt {
      constructor(e) {
        super(e), (this.tokenizer = e), (this.posTracker = gt.install(e.preprocessor, Pt)), (this.currentAttrLocation = null), (this.ctLoc = null);
      }
      _getCurrentLocation() {
        return { startLine: this.posTracker.line, startCol: this.posTracker.col, startOffset: this.posTracker.offset, endLine: -1, endCol: -1, endOffset: -1 };
      }
      _attachCurrentAttrLocationInfo() {
        (this.currentAttrLocation.endLine = this.posTracker.line),
          (this.currentAttrLocation.endCol = this.posTracker.col),
          (this.currentAttrLocation.endOffset = this.posTracker.offset);
        const e = this.tokenizer.currentToken,
          t = this.tokenizer.currentAttr;
        e.location.attrs || (e.location.attrs = Object.create(null)), (e.location.attrs[t.name] = this.currentAttrLocation);
      }
      _getOverriddenMethods(e, t) {
        const n = {
          _createStartTagToken() {
            t._createStartTagToken.call(this), (this.currentToken.location = e.ctLoc);
          },
          _createEndTagToken() {
            t._createEndTagToken.call(this), (this.currentToken.location = e.ctLoc);
          },
          _createCommentToken() {
            t._createCommentToken.call(this), (this.currentToken.location = e.ctLoc);
          },
          _createDoctypeToken(n) {
            t._createDoctypeToken.call(this, n), (this.currentToken.location = e.ctLoc);
          },
          _createCharacterToken(n, s) {
            t._createCharacterToken.call(this, n, s), (this.currentCharacterToken.location = e.ctLoc);
          },
          _createEOFToken() {
            t._createEOFToken.call(this), (this.currentToken.location = e._getCurrentLocation());
          },
          _createAttr(n) {
            t._createAttr.call(this, n), (e.currentAttrLocation = e._getCurrentLocation());
          },
          _leaveAttrName(n) {
            t._leaveAttrName.call(this, n), e._attachCurrentAttrLocationInfo();
          },
          _leaveAttrValue(n) {
            t._leaveAttrValue.call(this, n), e._attachCurrentAttrLocationInfo();
          },
          _emitCurrentToken() {
            const n = this.currentToken.location;
            this.currentCharacterToken &&
              ((this.currentCharacterToken.location.endLine = n.startLine),
              (this.currentCharacterToken.location.endCol = n.startCol),
              (this.currentCharacterToken.location.endOffset = n.startOffset)),
              this.currentToken.type === Nt.EOF_TOKEN
                ? ((n.endLine = n.startLine), (n.endCol = n.startCol), (n.endOffset = n.startOffset))
                : ((n.endLine = e.posTracker.line), (n.endCol = e.posTracker.col + 1), (n.endOffset = e.posTracker.offset + 1)),
              t._emitCurrentToken.call(this);
          },
          _emitCurrentCharacterToken() {
            const n = this.currentCharacterToken && this.currentCharacterToken.location;
            n && -1 === n.endOffset && ((n.endLine = e.posTracker.line), (n.endCol = e.posTracker.col), (n.endOffset = e.posTracker.offset)),
              t._emitCurrentCharacterToken.call(this);
          },
        };
        return (
          Object.keys(Nt.MODE).forEach(s => {
            const r = Nt.MODE[s];
            n[r] = function (n) {
              (e.ctLoc = e._getCurrentLocation()), t[r].call(this, n);
            };
          }),
          n
        );
      }
    },
    Dt = class extends gt {
      constructor(e, t) {
        super(e), (this.onItemPop = t.onItemPop);
      }
      _getOverriddenMethods(e, t) {
        return {
          pop() {
            e.onItemPop(this.current), t.pop.call(this);
          },
          popAllUpToHtmlElement() {
            for (let t = this.stackTop; t > 0; t--) e.onItemPop(this.items[t]);
            t.popAllUpToHtmlElement.call(this);
          },
          remove(n) {
            e.onItemPop(this.current), t.remove.call(this, n);
          },
        };
      }
    };
  const Ft = Ct.TAG_NAMES;
  var Ut = class extends gt {
      constructor(e) {
        super(e),
          (this.parser = e),
          (this.treeAdapter = this.parser.treeAdapter),
          (this.posTracker = null),
          (this.lastStartTagToken = null),
          (this.lastFosterParentingLocation = null),
          (this.currentToken = null);
      }
      _setStartLocation(e) {
        let t = null;
        this.lastStartTagToken && ((t = Object.assign({}, this.lastStartTagToken.location)), (t.startTag = this.lastStartTagToken.location)),
          this.treeAdapter.setNodeSourceCodeLocation(e, t);
      }
      _setEndLocation(e, t) {
        if (this.treeAdapter.getNodeSourceCodeLocation(e) && t.location) {
          const n = t.location,
            s = this.treeAdapter.getTagName(e),
            r = {};
          t.type === Nt.END_TAG_TOKEN && s === t.tagName
            ? ((r.endTag = Object.assign({}, n)), (r.endLine = n.endLine), (r.endCol = n.endCol), (r.endOffset = n.endOffset))
            : ((r.endLine = n.startLine), (r.endCol = n.startCol), (r.endOffset = n.startOffset)),
            this.treeAdapter.updateNodeSourceCodeLocation(e, r);
        }
      }
      _getOverriddenMethods(e, t) {
        return {
          _bootstrap(n, s) {
            t._bootstrap.call(this, n, s), (e.lastStartTagToken = null), (e.lastFosterParentingLocation = null), (e.currentToken = null);
            const r = gt.install(this.tokenizer, Ht);
            (e.posTracker = r.posTracker),
              gt.install(this.openElements, Dt, {
                onItemPop: function (t) {
                  e._setEndLocation(t, e.currentToken);
                },
              });
          },
          _runParsingLoop(n) {
            t._runParsingLoop.call(this, n);
            for (let t = this.openElements.stackTop; t >= 0; t--) e._setEndLocation(this.openElements.items[t], e.currentToken);
          },
          _processTokenInForeignContent(n) {
            (e.currentToken = n), t._processTokenInForeignContent.call(this, n);
          },
          _processToken(n) {
            if (
              ((e.currentToken = n),
              t._processToken.call(this, n),
              n.type === Nt.END_TAG_TOKEN && (n.tagName === Ft.HTML || (n.tagName === Ft.BODY && this.openElements.hasInScope(Ft.BODY))))
            )
              for (let t = this.openElements.stackTop; t >= 0; t--) {
                const s = this.openElements.items[t];
                if (this.treeAdapter.getTagName(s) === n.tagName) {
                  e._setEndLocation(s, n);
                  break;
                }
              }
          },
          _setDocumentType(e) {
            t._setDocumentType.call(this, e);
            const n = this.treeAdapter.getChildNodes(this.document),
              s = n.length;
            for (let t = 0; t < s; t++) {
              const s = n[t];
              if (this.treeAdapter.isDocumentTypeNode(s)) {
                this.treeAdapter.setNodeSourceCodeLocation(s, e.location);
                break;
              }
            }
          },
          _attachElementToTree(n) {
            e._setStartLocation(n), (e.lastStartTagToken = null), t._attachElementToTree.call(this, n);
          },
          _appendElement(n, s) {
            (e.lastStartTagToken = n), t._appendElement.call(this, n, s);
          },
          _insertElement(n, s) {
            (e.lastStartTagToken = n), t._insertElement.call(this, n, s);
          },
          _insertTemplate(n) {
            (e.lastStartTagToken = n), t._insertTemplate.call(this, n);
            const s = this.treeAdapter.getTemplateContent(this.openElements.current);
            this.treeAdapter.setNodeSourceCodeLocation(s, null);
          },
          _insertFakeRootElement() {
            t._insertFakeRootElement.call(this), this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
          },
          _appendCommentNode(e, n) {
            t._appendCommentNode.call(this, e, n);
            const s = this.treeAdapter.getChildNodes(n),
              r = s[s.length - 1];
            this.treeAdapter.setNodeSourceCodeLocation(r, e.location);
          },
          _findFosterParentingLocation() {
            return (e.lastFosterParentingLocation = t._findFosterParentingLocation.call(this)), e.lastFosterParentingLocation;
          },
          _insertCharacters(n) {
            t._insertCharacters.call(this, n);
            const s = this._shouldFosterParentOnInsertion(),
              r = (s && e.lastFosterParentingLocation.parent) || this.openElements.currentTmplContent || this.openElements.current,
              i = this.treeAdapter.getChildNodes(r),
              o = s && e.lastFosterParentingLocation.beforeElement ? i.indexOf(e.lastFosterParentingLocation.beforeElement) - 1 : i.length - 1,
              a = i[o];
            if (this.treeAdapter.getNodeSourceCodeLocation(a)) {
              const { endLine: e, endCol: t, endOffset: s } = n.location;
              this.treeAdapter.updateNodeSourceCodeLocation(a, { endLine: e, endCol: t, endOffset: s });
            } else this.treeAdapter.setNodeSourceCodeLocation(a, n.location);
          },
        };
      }
    },
    Gt = class extends gt {
      constructor(e, t) {
        super(e), (this.posTracker = null), (this.onParseError = t.onParseError);
      }
      _setErrorLocation(e) {
        (e.startLine = e.endLine = this.posTracker.line), (e.startCol = e.endCol = this.posTracker.col), (e.startOffset = e.endOffset = this.posTracker.offset);
      }
      _reportError(e) {
        const t = { code: e, startLine: -1, startCol: -1, startOffset: -1, endLine: -1, endCol: -1, endOffset: -1 };
        this._setErrorLocation(t), this.onParseError(t);
      }
      _getOverriddenMethods(e) {
        return {
          _err(t) {
            e._reportError(t);
          },
        };
      }
    },
    Bt = class extends Gt {
      constructor(e, t) {
        super(e, t), (this.posTracker = gt.install(e, Pt)), (this.lastErrOffset = -1);
      }
      _reportError(e) {
        this.lastErrOffset !== this.posTracker.offset && ((this.lastErrOffset = this.posTracker.offset), super._reportError(e));
      }
    },
    Kt = class extends Gt {
      constructor(e, t) {
        super(e, t);
        const n = gt.install(e.preprocessor, Bt, t);
        this.posTracker = n.posTracker;
      }
    },
    bt = class extends Gt {
      constructor(e, t) {
        super(e, t), (this.opts = t), (this.ctLoc = null), (this.locBeforeToken = !1);
      }
      _setErrorLocation(e) {
        this.ctLoc &&
          ((e.startLine = this.ctLoc.startLine),
          (e.startCol = this.ctLoc.startCol),
          (e.startOffset = this.ctLoc.startOffset),
          (e.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine),
          (e.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol),
          (e.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset));
      }
      _getOverriddenMethods(e, t) {
        return {
          _bootstrap(n, s) {
            t._bootstrap.call(this, n, s), gt.install(this.tokenizer, Kt, e.opts), gt.install(this.tokenizer, Ht);
          },
          _processInputToken(n) {
            (e.ctLoc = n.location), t._processInputToken.call(this, n);
          },
          _err(t, n) {
            (e.locBeforeToken = n && n.beforeToken), e._reportError(t);
          },
        };
      }
    },
    xt = dt(function (e, t) {
      const { DOCUMENT_MODE: n } = Ct;
      (t.createDocument = function () {
        return { nodeName: '#document', mode: n.NO_QUIRKS, childNodes: [] };
      }),
        (t.createDocumentFragment = function () {
          return { nodeName: '#document-fragment', childNodes: [] };
        }),
        (t.createElement = function (e, t, n) {
          return { nodeName: e, tagName: e, attrs: n, namespaceURI: t, childNodes: [], parentNode: null };
        }),
        (t.createCommentNode = function (e) {
          return { nodeName: '#comment', data: e, parentNode: null };
        });
      const s = function (e) {
          return { nodeName: '#text', value: e, parentNode: null };
        },
        r = (t.appendChild = function (e, t) {
          e.childNodes.push(t), (t.parentNode = e);
        }),
        i = (t.insertBefore = function (e, t, n) {
          const s = e.childNodes.indexOf(n);
          e.childNodes.splice(s, 0, t), (t.parentNode = e);
        });
      (t.setTemplateContent = function (e, t) {
        e.content = t;
      }),
        (t.getTemplateContent = function (e) {
          return e.content;
        }),
        (t.setDocumentType = function (e, t, n, s) {
          let i = null;
          for (let t = 0; t < e.childNodes.length; t++)
            if ('#documentType' === e.childNodes[t].nodeName) {
              i = e.childNodes[t];
              break;
            }
          i ? ((i.name = t), (i.publicId = n), (i.systemId = s)) : r(e, { nodeName: '#documentType', name: t, publicId: n, systemId: s });
        }),
        (t.setDocumentMode = function (e, t) {
          e.mode = t;
        }),
        (t.getDocumentMode = function (e) {
          return e.mode;
        }),
        (t.detachNode = function (e) {
          if (e.parentNode) {
            const t = e.parentNode.childNodes.indexOf(e);
            e.parentNode.childNodes.splice(t, 1), (e.parentNode = null);
          }
        }),
        (t.insertText = function (e, t) {
          if (e.childNodes.length) {
            const n = e.childNodes[e.childNodes.length - 1];
            if ('#text' === n.nodeName) return void (n.value += t);
          }
          r(e, s(t));
        }),
        (t.insertTextBefore = function (e, t, n) {
          const r = e.childNodes[e.childNodes.indexOf(n) - 1];
          r && '#text' === r.nodeName ? (r.value += t) : i(e, s(t), n);
        }),
        (t.adoptAttributes = function (e, t) {
          const n = [];
          for (let t = 0; t < e.attrs.length; t++) n.push(e.attrs[t].name);
          for (let s = 0; s < t.length; s++) -1 === n.indexOf(t[s].name) && e.attrs.push(t[s]);
        }),
        (t.getFirstChild = function (e) {
          return e.childNodes[0];
        }),
        (t.getChildNodes = function (e) {
          return e.childNodes;
        }),
        (t.getParentNode = function (e) {
          return e.parentNode;
        }),
        (t.getAttrList = function (e) {
          return e.attrs;
        }),
        (t.getTagName = function (e) {
          return e.tagName;
        }),
        (t.getNamespaceURI = function (e) {
          return e.namespaceURI;
        }),
        (t.getTextNodeContent = function (e) {
          return e.value;
        }),
        (t.getCommentNodeContent = function (e) {
          return e.data;
        }),
        (t.getDocumentTypeNodeName = function (e) {
          return e.name;
        }),
        (t.getDocumentTypeNodePublicId = function (e) {
          return e.publicId;
        }),
        (t.getDocumentTypeNodeSystemId = function (e) {
          return e.systemId;
        }),
        (t.isTextNode = function (e) {
          return '#text' === e.nodeName;
        }),
        (t.isCommentNode = function (e) {
          return '#comment' === e.nodeName;
        }),
        (t.isDocumentTypeNode = function (e) {
          return '#documentType' === e.nodeName;
        }),
        (t.isElementNode = function (e) {
          return !!e.tagName;
        }),
        (t.setNodeSourceCodeLocation = function (e, t) {
          e.sourceCodeLocation = t;
        }),
        (t.getNodeSourceCodeLocation = function (e) {
          return e.sourceCodeLocation;
        }),
        (t.updateNodeSourceCodeLocation = function (e, t) {
          e.sourceCodeLocation = Object.assign(e.sourceCodeLocation, t);
        });
    });
  const { DOCUMENT_MODE: yt } = Ct,
    vt = 'html',
    Yt = [
      '+//silmaril//dtd html pro v0r11 19970101//',
      '-//as//dtd html 3.0 aswedit + extensions//',
      '-//advasoft ltd//dtd html 3.0 aswedit + extensions//',
      '-//ietf//dtd html 2.0 level 1//',
      '-//ietf//dtd html 2.0 level 2//',
      '-//ietf//dtd html 2.0 strict level 1//',
      '-//ietf//dtd html 2.0 strict level 2//',
      '-//ietf//dtd html 2.0 strict//',
      '-//ietf//dtd html 2.0//',
      '-//ietf//dtd html 2.1e//',
      '-//ietf//dtd html 3.0//',
      '-//ietf//dtd html 3.2 final//',
      '-//ietf//dtd html 3.2//',
      '-//ietf//dtd html 3//',
      '-//ietf//dtd html level 0//',
      '-//ietf//dtd html level 1//',
      '-//ietf//dtd html level 2//',
      '-//ietf//dtd html level 3//',
      '-//ietf//dtd html strict level 0//',
      '-//ietf//dtd html strict level 1//',
      '-//ietf//dtd html strict level 2//',
      '-//ietf//dtd html strict level 3//',
      '-//ietf//dtd html strict//',
      '-//ietf//dtd html//',
      '-//metrius//dtd metrius presentational//',
      '-//microsoft//dtd internet explorer 2.0 html strict//',
      '-//microsoft//dtd internet explorer 2.0 html//',
      '-//microsoft//dtd internet explorer 2.0 tables//',
      '-//microsoft//dtd internet explorer 3.0 html strict//',
      '-//microsoft//dtd internet explorer 3.0 html//',
      '-//microsoft//dtd internet explorer 3.0 tables//',
      '-//netscape comm. corp.//dtd html//',
      '-//netscape comm. corp.//dtd strict html//',
      "-//o'reilly and associates//dtd html 2.0//",
      "-//o'reilly and associates//dtd html extended 1.0//",
      "-//o'reilly and associates//dtd html extended relaxed 1.0//",
      '-//sq//dtd html 2.0 hotmetal + extensions//',
      '-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',
      '-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',
      '-//spyglass//dtd html 2.0 extended//',
      '-//sun microsystems corp.//dtd hotjava html//',
      '-//sun microsystems corp.//dtd hotjava strict html//',
      '-//w3c//dtd html 3 1995-03-24//',
      '-//w3c//dtd html 3.2 draft//',
      '-//w3c//dtd html 3.2 final//',
      '-//w3c//dtd html 3.2//',
      '-//w3c//dtd html 3.2s draft//',
      '-//w3c//dtd html 4.0 frameset//',
      '-//w3c//dtd html 4.0 transitional//',
      '-//w3c//dtd html experimental 19960712//',
      '-//w3c//dtd html experimental 970421//',
      '-//w3c//dtd w3 html//',
      '-//w3o//dtd w3 html 3.0//',
      '-//webtechs//dtd mozilla html 2.0//',
      '-//webtechs//dtd mozilla html//',
    ],
    wt = Yt.concat(['-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//']),
    Qt = ['-//w3o//dtd w3 html strict 3.0//en//', '-/w3c/dtd html 4.0 transitional/en', 'html'],
    Xt = ['-//w3c//dtd xhtml 1.0 frameset//', '-//w3c//dtd xhtml 1.0 transitional//'],
    Wt = Xt.concat(['-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//']);
  function Vt(e, t) {
    for (let n = 0; n < t.length; n++) if (0 === e.indexOf(t[n])) return !0;
    return !1;
  }
  var jt = dt(function (e, t) {
    const n = Ct.TAG_NAMES,
      s = Ct.NAMESPACES,
      r = Ct.ATTRS,
      i = {
        attributename: 'attributeName',
        attributetype: 'attributeType',
        basefrequency: 'baseFrequency',
        baseprofile: 'baseProfile',
        calcmode: 'calcMode',
        clippathunits: 'clipPathUnits',
        diffuseconstant: 'diffuseConstant',
        edgemode: 'edgeMode',
        filterunits: 'filterUnits',
        glyphref: 'glyphRef',
        gradienttransform: 'gradientTransform',
        gradientunits: 'gradientUnits',
        kernelmatrix: 'kernelMatrix',
        kernelunitlength: 'kernelUnitLength',
        keypoints: 'keyPoints',
        keysplines: 'keySplines',
        keytimes: 'keyTimes',
        lengthadjust: 'lengthAdjust',
        limitingconeangle: 'limitingConeAngle',
        markerheight: 'markerHeight',
        markerunits: 'markerUnits',
        markerwidth: 'markerWidth',
        maskcontentunits: 'maskContentUnits',
        maskunits: 'maskUnits',
        numoctaves: 'numOctaves',
        pathlength: 'pathLength',
        patterncontentunits: 'patternContentUnits',
        patterntransform: 'patternTransform',
        patternunits: 'patternUnits',
        pointsatx: 'pointsAtX',
        pointsaty: 'pointsAtY',
        pointsatz: 'pointsAtZ',
        preservealpha: 'preserveAlpha',
        preserveaspectratio: 'preserveAspectRatio',
        primitiveunits: 'primitiveUnits',
        refx: 'refX',
        refy: 'refY',
        repeatcount: 'repeatCount',
        repeatdur: 'repeatDur',
        requiredextensions: 'requiredExtensions',
        requiredfeatures: 'requiredFeatures',
        specularconstant: 'specularConstant',
        specularexponent: 'specularExponent',
        spreadmethod: 'spreadMethod',
        startoffset: 'startOffset',
        stddeviation: 'stdDeviation',
        stitchtiles: 'stitchTiles',
        surfacescale: 'surfaceScale',
        systemlanguage: 'systemLanguage',
        tablevalues: 'tableValues',
        targetx: 'targetX',
        targety: 'targetY',
        textlength: 'textLength',
        viewbox: 'viewBox',
        viewtarget: 'viewTarget',
        xchannelselector: 'xChannelSelector',
        ychannelselector: 'yChannelSelector',
        zoomandpan: 'zoomAndPan',
      },
      o = {
        'xlink:actuate': { prefix: 'xlink', name: 'actuate', namespace: s.XLINK },
        'xlink:arcrole': { prefix: 'xlink', name: 'arcrole', namespace: s.XLINK },
        'xlink:href': { prefix: 'xlink', name: 'href', namespace: s.XLINK },
        'xlink:role': { prefix: 'xlink', name: 'role', namespace: s.XLINK },
        'xlink:show': { prefix: 'xlink', name: 'show', namespace: s.XLINK },
        'xlink:title': { prefix: 'xlink', name: 'title', namespace: s.XLINK },
        'xlink:type': { prefix: 'xlink', name: 'type', namespace: s.XLINK },
        'xml:base': { prefix: 'xml', name: 'base', namespace: s.XML },
        'xml:lang': { prefix: 'xml', name: 'lang', namespace: s.XML },
        'xml:space': { prefix: 'xml', name: 'space', namespace: s.XML },
        'xmlns': { prefix: '', name: 'xmlns', namespace: s.XMLNS },
        'xmlns:xlink': { prefix: 'xmlns', name: 'xlink', namespace: s.XMLNS },
      },
      a = (t.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
        altglyph: 'altGlyph',
        altglyphdef: 'altGlyphDef',
        altglyphitem: 'altGlyphItem',
        animatecolor: 'animateColor',
        animatemotion: 'animateMotion',
        animatetransform: 'animateTransform',
        clippath: 'clipPath',
        feblend: 'feBlend',
        fecolormatrix: 'feColorMatrix',
        fecomponenttransfer: 'feComponentTransfer',
        fecomposite: 'feComposite',
        feconvolvematrix: 'feConvolveMatrix',
        fediffuselighting: 'feDiffuseLighting',
        fedisplacementmap: 'feDisplacementMap',
        fedistantlight: 'feDistantLight',
        feflood: 'feFlood',
        fefunca: 'feFuncA',
        fefuncb: 'feFuncB',
        fefuncg: 'feFuncG',
        fefuncr: 'feFuncR',
        fegaussianblur: 'feGaussianBlur',
        feimage: 'feImage',
        femerge: 'feMerge',
        femergenode: 'feMergeNode',
        femorphology: 'feMorphology',
        feoffset: 'feOffset',
        fepointlight: 'fePointLight',
        fespecularlighting: 'feSpecularLighting',
        fespotlight: 'feSpotLight',
        fetile: 'feTile',
        feturbulence: 'feTurbulence',
        foreignobject: 'foreignObject',
        glyphref: 'glyphRef',
        lineargradient: 'linearGradient',
        radialgradient: 'radialGradient',
        textpath: 'textPath',
      }),
      T = {
        [n.B]: !0,
        [n.BIG]: !0,
        [n.BLOCKQUOTE]: !0,
        [n.BODY]: !0,
        [n.BR]: !0,
        [n.CENTER]: !0,
        [n.CODE]: !0,
        [n.DD]: !0,
        [n.DIV]: !0,
        [n.DL]: !0,
        [n.DT]: !0,
        [n.EM]: !0,
        [n.EMBED]: !0,
        [n.H1]: !0,
        [n.H2]: !0,
        [n.H3]: !0,
        [n.H4]: !0,
        [n.H5]: !0,
        [n.H6]: !0,
        [n.HEAD]: !0,
        [n.HR]: !0,
        [n.I]: !0,
        [n.IMG]: !0,
        [n.LI]: !0,
        [n.LISTING]: !0,
        [n.MENU]: !0,
        [n.META]: !0,
        [n.NOBR]: !0,
        [n.OL]: !0,
        [n.P]: !0,
        [n.PRE]: !0,
        [n.RUBY]: !0,
        [n.S]: !0,
        [n.SMALL]: !0,
        [n.SPAN]: !0,
        [n.STRONG]: !0,
        [n.STRIKE]: !0,
        [n.SUB]: !0,
        [n.SUP]: !0,
        [n.TABLE]: !0,
        [n.TT]: !0,
        [n.U]: !0,
        [n.UL]: !0,
        [n.VAR]: !0,
      };
    (t.causesExit = function (e) {
      const t = e.tagName;
      return !(t !== n.FONT || (null === Nt.getTokenAttr(e, r.COLOR) && null === Nt.getTokenAttr(e, r.SIZE) && null === Nt.getTokenAttr(e, r.FACE))) || T[t];
    }),
      (t.adjustTokenMathMLAttrs = function (e) {
        for (let t = 0; t < e.attrs.length; t++)
          if ('definitionurl' === e.attrs[t].name) {
            e.attrs[t].name = 'definitionURL';
            break;
          }
      }),
      (t.adjustTokenSVGAttrs = function (e) {
        for (let t = 0; t < e.attrs.length; t++) {
          const n = i[e.attrs[t].name];
          n && (e.attrs[t].name = n);
        }
      }),
      (t.adjustTokenXMLAttrs = function (e) {
        for (let t = 0; t < e.attrs.length; t++) {
          const n = o[e.attrs[t].name];
          n && ((e.attrs[t].prefix = n.prefix), (e.attrs[t].name = n.name), (e.attrs[t].namespace = n.namespace));
        }
      }),
      (t.adjustTokenSVGTagName = function (e) {
        const t = a[e.tagName];
        t && (e.tagName = t);
      }),
      (t.isIntegrationPoint = function (e, t, i, o) {
        return (
          !(
            (o && o !== s.HTML) ||
            !(function (e, t, i) {
              if (t === s.MATHML && e === n.ANNOTATION_XML)
                for (let e = 0; e < i.length; e++)
                  if (i[e].name === r.ENCODING) {
                    const t = i[e].value.toLowerCase();
                    return 'text/html' === t || 'application/xhtml+xml' === t;
                  }
              return t === s.SVG && (e === n.FOREIGN_OBJECT || e === n.DESC || e === n.TITLE);
            })(e, t, i)
          ) ||
          !(
            (o && o !== s.MATHML) ||
            !(function (e, t) {
              return t === s.MATHML && (e === n.MI || e === n.MO || e === n.MN || e === n.MS || e === n.MTEXT);
            })(e, t)
          )
        );
      });
  });
  const zt = Ct.TAG_NAMES,
    qt = Ct.NAMESPACES,
    Jt = Ct.ATTRS,
    Zt = { scriptingEnabled: !0, sourceCodeLocationInfo: !1, onParseError: null, treeAdapter: xt },
    $t = 'hidden',
    en = 'INITIAL_MODE',
    tn = 'BEFORE_HTML_MODE',
    nn = 'BEFORE_HEAD_MODE',
    sn = 'IN_HEAD_MODE',
    rn = 'IN_HEAD_NO_SCRIPT_MODE',
    on = 'AFTER_HEAD_MODE',
    an = 'IN_BODY_MODE',
    Tn = 'TEXT_MODE',
    En = 'IN_TABLE_MODE',
    hn = 'IN_TABLE_TEXT_MODE',
    cn = 'IN_CAPTION_MODE',
    _n = 'IN_COLUMN_GROUP_MODE',
    ln = 'IN_TABLE_BODY_MODE',
    mn = 'IN_ROW_MODE',
    pn = 'IN_CELL_MODE',
    An = 'IN_SELECT_MODE',
    un = 'IN_SELECT_IN_TABLE_MODE',
    Nn = 'IN_TEMPLATE_MODE',
    dn = 'AFTER_BODY_MODE',
    Cn = 'IN_FRAMESET_MODE',
    On = 'AFTER_FRAMESET_MODE',
    fn = 'AFTER_AFTER_BODY_MODE',
    Sn = 'AFTER_AFTER_FRAMESET_MODE',
    Rn = { [zt.TR]: mn, [zt.TBODY]: ln, [zt.THEAD]: ln, [zt.TFOOT]: ln, [zt.CAPTION]: cn, [zt.COLGROUP]: _n, [zt.TABLE]: En, [zt.BODY]: an, [zt.FRAMESET]: Cn },
    In = { [zt.CAPTION]: En, [zt.COLGROUP]: En, [zt.TBODY]: En, [zt.TFOOT]: En, [zt.THEAD]: En, [zt.COL]: _n, [zt.TR]: ln, [zt.TD]: mn, [zt.TH]: mn },
    Ln = {
      [en]: {
        [Nt.CHARACTER_TOKEN]: vn,
        [Nt.NULL_CHARACTER_TOKEN]: vn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: Gn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: function (e, t) {
          e._setDocumentType(t);
          const n = t.forceQuirks
            ? Ct.DOCUMENT_MODE.QUIRKS
            : (function (e) {
                if (e.name !== vt) return yt.QUIRKS;
                const t = e.systemId;
                if (t && 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd' === t.toLowerCase()) return yt.QUIRKS;
                let n = e.publicId;
                if (null !== n) {
                  if (((n = n.toLowerCase()), Qt.indexOf(n) > -1)) return yt.QUIRKS;
                  let e = null === t ? wt : Yt;
                  if (Vt(n, e)) return yt.QUIRKS;
                  if (((e = null === t ? Xt : Wt), Vt(n, e))) return yt.LIMITED_QUIRKS;
                }
                return yt.NO_QUIRKS;
              })(t);
          (function (e) {
            return e.name === vt && null === e.publicId && (null === e.systemId || 'about:legacy-compat' === e.systemId);
          })(t) || e._err('non-conforming-doctype'),
            e.treeAdapter.setDocumentMode(e.document, n),
            (e.insertionMode = tn);
        },
        [Nt.START_TAG_TOKEN]: vn,
        [Nt.END_TAG_TOKEN]: vn,
        [Nt.EOF_TOKEN]: vn,
      },
      [tn]: {
        [Nt.CHARACTER_TOKEN]: Yn,
        [Nt.NULL_CHARACTER_TOKEN]: Yn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: Gn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          t.tagName === zt.HTML ? (e._insertElement(t, qt.HTML), (e.insertionMode = nn)) : Yn(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          (n !== zt.HTML && n !== zt.HEAD && n !== zt.BODY && n !== zt.BR) || Yn(e, t);
        },
        [Nt.EOF_TOKEN]: Yn,
      },
      [nn]: {
        [Nt.CHARACTER_TOKEN]: wn,
        [Nt.NULL_CHARACTER_TOKEN]: wn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: Gn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Bn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.HTML ? as(e, t) : n === zt.HEAD ? (e._insertElement(t, qt.HTML), (e.headElement = e.openElements.current), (e.insertionMode = sn)) : wn(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.HEAD || n === zt.BODY || n === zt.HTML || n === zt.BR ? wn(e, t) : e._err(L);
        },
        [Nt.EOF_TOKEN]: wn,
      },
      [sn]: {
        [Nt.CHARACTER_TOKEN]: Wn,
        [Nt.NULL_CHARACTER_TOKEN]: Wn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: xn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Bn,
        [Nt.START_TAG_TOKEN]: Qn,
        [Nt.END_TAG_TOKEN]: Xn,
        [Nt.EOF_TOKEN]: Wn,
      },
      [rn]: {
        [Nt.CHARACTER_TOKEN]: Vn,
        [Nt.NULL_CHARACTER_TOKEN]: Vn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: xn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Bn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.HTML
            ? as(e, t)
            : n === zt.BASEFONT || n === zt.BGSOUND || n === zt.HEAD || n === zt.LINK || n === zt.META || n === zt.NOFRAMES || n === zt.STYLE
            ? Qn(e, t)
            : n === zt.NOSCRIPT
            ? e._err('nested-noscript-in-head')
            : Vn(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.NOSCRIPT ? (e.openElements.pop(), (e.insertionMode = sn)) : n === zt.BR ? Vn(e, t) : e._err(L);
        },
        [Nt.EOF_TOKEN]: Vn,
      },
      [on]: {
        [Nt.CHARACTER_TOKEN]: jn,
        [Nt.NULL_CHARACTER_TOKEN]: jn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: xn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Bn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.HTML
            ? as(e, t)
            : n === zt.BODY
            ? (e._insertElement(t, qt.HTML), (e.framesetOk = !1), (e.insertionMode = an))
            : n === zt.FRAMESET
            ? (e._insertElement(t, qt.HTML), (e.insertionMode = Cn))
            : n === zt.BASE ||
              n === zt.BASEFONT ||
              n === zt.BGSOUND ||
              n === zt.LINK ||
              n === zt.META ||
              n === zt.NOFRAMES ||
              n === zt.SCRIPT ||
              n === zt.STYLE ||
              n === zt.TEMPLATE ||
              n === zt.TITLE
            ? (e._err('abandoned-head-element-child'), e.openElements.push(e.headElement), Qn(e, t), e.openElements.remove(e.headElement))
            : n === zt.HEAD
            ? e._err(k)
            : jn(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.BODY || n === zt.HTML || n === zt.BR ? jn(e, t) : n === zt.TEMPLATE ? Xn(e, t) : e._err(L);
        },
        [Nt.EOF_TOKEN]: jn,
      },
      [an]: {
        [Nt.CHARACTER_TOKEN]: qn,
        [Nt.NULL_CHARACTER_TOKEN]: Gn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: zn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: as,
        [Nt.END_TAG_TOKEN]: cs,
        [Nt.EOF_TOKEN]: _s,
      },
      [Tn]: {
        [Nt.CHARACTER_TOKEN]: xn,
        [Nt.NULL_CHARACTER_TOKEN]: xn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: xn,
        [Nt.COMMENT_TOKEN]: Gn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: Gn,
        [Nt.END_TAG_TOKEN]: function (e, t) {
          t.tagName === zt.SCRIPT && (e.pendingScript = e.openElements.current), e.openElements.pop(), (e.insertionMode = e.originalInsertionMode);
        },
        [Nt.EOF_TOKEN]: function (e, t) {
          e._err('eof-in-element-that-can-contain-only-text'), e.openElements.pop(), (e.insertionMode = e.originalInsertionMode), e._processToken(t);
        },
      },
      [En]: {
        [Nt.CHARACTER_TOKEN]: ls,
        [Nt.NULL_CHARACTER_TOKEN]: ls,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: ls,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: ms,
        [Nt.END_TAG_TOKEN]: ps,
        [Nt.EOF_TOKEN]: _s,
      },
      [hn]: {
        [Nt.CHARACTER_TOKEN]: function (e, t) {
          e.pendingCharacterTokens.push(t), (e.hasNonWhitespacePendingCharacterToken = !0);
        },
        [Nt.NULL_CHARACTER_TOKEN]: Gn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: function (e, t) {
          e.pendingCharacterTokens.push(t);
        },
        [Nt.COMMENT_TOKEN]: us,
        [Nt.DOCTYPE_TOKEN]: us,
        [Nt.START_TAG_TOKEN]: us,
        [Nt.END_TAG_TOKEN]: us,
        [Nt.EOF_TOKEN]: us,
      },
      [cn]: {
        [Nt.CHARACTER_TOKEN]: qn,
        [Nt.NULL_CHARACTER_TOKEN]: Gn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: zn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.CAPTION || n === zt.COL || n === zt.COLGROUP || n === zt.TBODY || n === zt.TD || n === zt.TFOOT || n === zt.TH || n === zt.THEAD || n === zt.TR
            ? e.openElements.hasInTableScope(zt.CAPTION) &&
              (e.openElements.generateImpliedEndTags(),
              e.openElements.popUntilTagNamePopped(zt.CAPTION),
              e.activeFormattingElements.clearToLastMarker(),
              (e.insertionMode = En),
              e._processToken(t))
            : as(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.CAPTION || n === zt.TABLE
            ? e.openElements.hasInTableScope(zt.CAPTION) &&
              (e.openElements.generateImpliedEndTags(),
              e.openElements.popUntilTagNamePopped(zt.CAPTION),
              e.activeFormattingElements.clearToLastMarker(),
              (e.insertionMode = En),
              n === zt.TABLE && e._processToken(t))
            : n !== zt.BODY &&
              n !== zt.COL &&
              n !== zt.COLGROUP &&
              n !== zt.HTML &&
              n !== zt.TBODY &&
              n !== zt.TD &&
              n !== zt.TFOOT &&
              n !== zt.TH &&
              n !== zt.THEAD &&
              n !== zt.TR &&
              cs(e, t);
        },
        [Nt.EOF_TOKEN]: _s,
      },
      [_n]: {
        [Nt.CHARACTER_TOKEN]: Ns,
        [Nt.NULL_CHARACTER_TOKEN]: Ns,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: xn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.HTML ? as(e, t) : n === zt.COL ? (e._appendElement(t, qt.HTML), (t.ackSelfClosing = !0)) : n === zt.TEMPLATE ? Qn(e, t) : Ns(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.COLGROUP
            ? e.openElements.currentTagName === zt.COLGROUP && (e.openElements.pop(), (e.insertionMode = En))
            : n === zt.TEMPLATE
            ? Xn(e, t)
            : n !== zt.COL && Ns(e, t);
        },
        [Nt.EOF_TOKEN]: _s,
      },
      [ln]: {
        [Nt.CHARACTER_TOKEN]: ls,
        [Nt.NULL_CHARACTER_TOKEN]: ls,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: ls,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.TR
            ? (e.openElements.clearBackToTableBodyContext(), e._insertElement(t, qt.HTML), (e.insertionMode = mn))
            : n === zt.TH || n === zt.TD
            ? (e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(zt.TR), (e.insertionMode = mn), e._processToken(t))
            : n === zt.CAPTION || n === zt.COL || n === zt.COLGROUP || n === zt.TBODY || n === zt.TFOOT || n === zt.THEAD
            ? e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), (e.insertionMode = En), e._processToken(t))
            : ms(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.TBODY || n === zt.TFOOT || n === zt.THEAD
            ? e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), (e.insertionMode = En))
            : n === zt.TABLE
            ? e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), (e.insertionMode = En), e._processToken(t))
            : ((n !== zt.BODY && n !== zt.CAPTION && n !== zt.COL && n !== zt.COLGROUP) || (n !== zt.HTML && n !== zt.TD && n !== zt.TH && n !== zt.TR)) && ps(e, t);
        },
        [Nt.EOF_TOKEN]: _s,
      },
      [mn]: {
        [Nt.CHARACTER_TOKEN]: ls,
        [Nt.NULL_CHARACTER_TOKEN]: ls,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: ls,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.TH || n === zt.TD
            ? (e.openElements.clearBackToTableRowContext(), e._insertElement(t, qt.HTML), (e.insertionMode = pn), e.activeFormattingElements.insertMarker())
            : n === zt.CAPTION || n === zt.COL || n === zt.COLGROUP || n === zt.TBODY || n === zt.TFOOT || n === zt.THEAD || n === zt.TR
            ? e.openElements.hasInTableScope(zt.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), (e.insertionMode = ln), e._processToken(t))
            : ms(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.TR
            ? e.openElements.hasInTableScope(zt.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), (e.insertionMode = ln))
            : n === zt.TABLE
            ? e.openElements.hasInTableScope(zt.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), (e.insertionMode = ln), e._processToken(t))
            : n === zt.TBODY || n === zt.TFOOT || n === zt.THEAD
            ? (e.openElements.hasInTableScope(n) || e.openElements.hasInTableScope(zt.TR)) &&
              (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), (e.insertionMode = ln), e._processToken(t))
            : ((n !== zt.BODY && n !== zt.CAPTION && n !== zt.COL && n !== zt.COLGROUP) || (n !== zt.HTML && n !== zt.TD && n !== zt.TH)) && ps(e, t);
        },
        [Nt.EOF_TOKEN]: _s,
      },
      [pn]: {
        [Nt.CHARACTER_TOKEN]: qn,
        [Nt.NULL_CHARACTER_TOKEN]: Gn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: zn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.CAPTION || n === zt.COL || n === zt.COLGROUP || n === zt.TBODY || n === zt.TD || n === zt.TFOOT || n === zt.TH || n === zt.THEAD || n === zt.TR
            ? (e.openElements.hasInTableScope(zt.TD) || e.openElements.hasInTableScope(zt.TH)) && (e._closeTableCell(), e._processToken(t))
            : as(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.TD || n === zt.TH
            ? e.openElements.hasInTableScope(n) &&
              (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), (e.insertionMode = mn))
            : n === zt.TABLE || n === zt.TBODY || n === zt.TFOOT || n === zt.THEAD || n === zt.TR
            ? e.openElements.hasInTableScope(n) && (e._closeTableCell(), e._processToken(t))
            : n !== zt.BODY && n !== zt.CAPTION && n !== zt.COL && n !== zt.COLGROUP && n !== zt.HTML && cs(e, t);
        },
        [Nt.EOF_TOKEN]: _s,
      },
      [An]: {
        [Nt.CHARACTER_TOKEN]: xn,
        [Nt.NULL_CHARACTER_TOKEN]: Gn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: xn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: ds,
        [Nt.END_TAG_TOKEN]: Cs,
        [Nt.EOF_TOKEN]: _s,
      },
      [un]: {
        [Nt.CHARACTER_TOKEN]: xn,
        [Nt.NULL_CHARACTER_TOKEN]: Gn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: xn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.CAPTION || n === zt.TABLE || n === zt.TBODY || n === zt.TFOOT || n === zt.THEAD || n === zt.TR || n === zt.TD || n === zt.TH
            ? (e.openElements.popUntilTagNamePopped(zt.SELECT), e._resetInsertionMode(), e._processToken(t))
            : ds(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.CAPTION || n === zt.TABLE || n === zt.TBODY || n === zt.TFOOT || n === zt.THEAD || n === zt.TR || n === zt.TD || n === zt.TH
            ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(zt.SELECT), e._resetInsertionMode(), e._processToken(t))
            : Cs(e, t);
        },
        [Nt.EOF_TOKEN]: _s,
      },
      [Nn]: {
        [Nt.CHARACTER_TOKEN]: qn,
        [Nt.NULL_CHARACTER_TOKEN]: Gn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: zn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          if (
            n === zt.BASE ||
            n === zt.BASEFONT ||
            n === zt.BGSOUND ||
            n === zt.LINK ||
            n === zt.META ||
            n === zt.NOFRAMES ||
            n === zt.SCRIPT ||
            n === zt.STYLE ||
            n === zt.TEMPLATE ||
            n === zt.TITLE
          )
            Qn(e, t);
          else {
            const s = In[n] || an;
            e._popTmplInsertionMode(), e._pushTmplInsertionMode(s), (e.insertionMode = s), e._processToken(t);
          }
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          t.tagName === zt.TEMPLATE && Xn(e, t);
        },
        [Nt.EOF_TOKEN]: Os,
      },
      [dn]: {
        [Nt.CHARACTER_TOKEN]: fs,
        [Nt.NULL_CHARACTER_TOKEN]: fs,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: zn,
        [Nt.COMMENT_TOKEN]: function (e, t) {
          e._appendCommentNode(t, e.openElements.items[0]);
        },
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          t.tagName === zt.HTML ? as(e, t) : fs(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          t.tagName === zt.HTML ? e.fragmentContext || (e.insertionMode = fn) : fs(e, t);
        },
        [Nt.EOF_TOKEN]: yn,
      },
      [Cn]: {
        [Nt.CHARACTER_TOKEN]: Gn,
        [Nt.NULL_CHARACTER_TOKEN]: Gn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: xn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.HTML
            ? as(e, t)
            : n === zt.FRAMESET
            ? e._insertElement(t, qt.HTML)
            : n === zt.FRAME
            ? (e._appendElement(t, qt.HTML), (t.ackSelfClosing = !0))
            : n === zt.NOFRAMES && Qn(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          t.tagName !== zt.FRAMESET ||
            e.openElements.isRootHtmlElementCurrent() ||
            (e.openElements.pop(), e.fragmentContext || e.openElements.currentTagName === zt.FRAMESET || (e.insertionMode = On));
        },
        [Nt.EOF_TOKEN]: yn,
      },
      [On]: {
        [Nt.CHARACTER_TOKEN]: Gn,
        [Nt.NULL_CHARACTER_TOKEN]: Gn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: xn,
        [Nt.COMMENT_TOKEN]: Kn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.HTML ? as(e, t) : n === zt.NOFRAMES && Qn(e, t);
        },
        [Nt.END_TAG_TOKEN]: function (e, t) {
          t.tagName === zt.HTML && (e.insertionMode = Sn);
        },
        [Nt.EOF_TOKEN]: yn,
      },
      [fn]: {
        [Nt.CHARACTER_TOKEN]: Ss,
        [Nt.NULL_CHARACTER_TOKEN]: Ss,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: zn,
        [Nt.COMMENT_TOKEN]: bn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          t.tagName === zt.HTML ? as(e, t) : Ss(e, t);
        },
        [Nt.END_TAG_TOKEN]: Ss,
        [Nt.EOF_TOKEN]: yn,
      },
      [Sn]: {
        [Nt.CHARACTER_TOKEN]: Gn,
        [Nt.NULL_CHARACTER_TOKEN]: Gn,
        [Nt.WHITESPACE_CHARACTER_TOKEN]: zn,
        [Nt.COMMENT_TOKEN]: bn,
        [Nt.DOCTYPE_TOKEN]: Gn,
        [Nt.START_TAG_TOKEN]: function (e, t) {
          const n = t.tagName;
          n === zt.HTML ? as(e, t) : n === zt.NOFRAMES && Qn(e, t);
        },
        [Nt.END_TAG_TOKEN]: Gn,
        [Nt.EOF_TOKEN]: yn,
      },
    };
  var kn = class {
    constructor(e) {
      (this.options = (function (e, t) {
        return [e, (t = t || Object.create(null))].reduce(
          (e, t) => (
            Object.keys(t).forEach(n => {
              e[n] = t[n];
            }),
            e
          ),
          Object.create(null),
        );
      })(Zt, e)),
        (this.treeAdapter = this.options.treeAdapter),
        (this.pendingScript = null),
        this.options.sourceCodeLocationInfo && gt.install(this, Ut),
        this.options.onParseError && gt.install(this, bt, { onParseError: this.options.onParseError });
    }
    parse(e) {
      const t = this.treeAdapter.createDocument();
      return this._bootstrap(t, null), this.tokenizer.write(e, !0), this._runParsingLoop(null), t;
    }
    parseFragment(e, t) {
      t || (t = this.treeAdapter.createElement(zt.TEMPLATE, qt.HTML, []));
      const n = this.treeAdapter.createElement('documentmock', qt.HTML, []);
      this._bootstrap(n, t),
        this.treeAdapter.getTagName(t) === zt.TEMPLATE && this._pushTmplInsertionMode(Nn),
        this._initTokenizerForFragmentParsing(),
        this._insertFakeRootElement(),
        this._resetInsertionMode(),
        this._findFormInFragmentContext(),
        this.tokenizer.write(e, !0),
        this._runParsingLoop(null);
      const s = this.treeAdapter.getFirstChild(n),
        r = this.treeAdapter.createDocumentFragment();
      return this._adoptNodes(s, r), r;
    }
    _bootstrap(e, t) {
      (this.tokenizer = new Nt(this.options)),
        (this.stopped = !1),
        (this.insertionMode = en),
        (this.originalInsertionMode = ''),
        (this.document = e),
        (this.fragmentContext = t),
        (this.headElement = null),
        (this.formElement = null),
        (this.openElements = new (class {
          constructor(e, t) {
            (this.stackTop = -1),
              (this.items = []),
              (this.current = e),
              (this.currentTagName = null),
              (this.currentTmplContent = null),
              (this.tmplCount = 0),
              (this.treeAdapter = t);
          }
          _indexOf(e) {
            let t = -1;
            for (let n = this.stackTop; n >= 0; n--)
              if (this.items[n] === e) {
                t = n;
                break;
              }
            return t;
          }
          _isInTemplate() {
            return this.currentTagName === Ot.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === ft.HTML;
          }
          _updateCurrentElement() {
            (this.current = this.items[this.stackTop]),
              (this.currentTagName = this.current && this.treeAdapter.getTagName(this.current)),
              (this.currentTmplContent = this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : null);
          }
          push(e) {
            (this.items[++this.stackTop] = e), this._updateCurrentElement(), this._isInTemplate() && this.tmplCount++;
          }
          pop() {
            this.stackTop--, this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this._updateCurrentElement();
          }
          replace(e, t) {
            const n = this._indexOf(e);
            (this.items[n] = t), n === this.stackTop && this._updateCurrentElement();
          }
          insertAfter(e, t) {
            const n = this._indexOf(e) + 1;
            this.items.splice(n, 0, t), n === ++this.stackTop && this._updateCurrentElement();
          }
          popUntilTagNamePopped(e) {
            for (; this.stackTop > -1; ) {
              const t = this.currentTagName,
                n = this.treeAdapter.getNamespaceURI(this.current);
              if ((this.pop(), t === e && n === ft.HTML)) break;
            }
          }
          popUntilElementPopped(e) {
            for (; this.stackTop > -1; ) {
              const t = this.current;
              if ((this.pop(), t === e)) break;
            }
          }
          popUntilNumberedHeaderPopped() {
            for (; this.stackTop > -1; ) {
              const e = this.currentTagName,
                t = this.treeAdapter.getNamespaceURI(this.current);
              if ((this.pop(), e === Ot.H1 || e === Ot.H2 || e === Ot.H3 || e === Ot.H4 || e === Ot.H5 || (e === Ot.H6 && t === ft.HTML))) break;
            }
          }
          popUntilTableCellPopped() {
            for (; this.stackTop > -1; ) {
              const e = this.currentTagName,
                t = this.treeAdapter.getNamespaceURI(this.current);
              if ((this.pop(), e === Ot.TD || (e === Ot.TH && t === ft.HTML))) break;
            }
          }
          popAllUpToHtmlElement() {
            (this.stackTop = 0), this._updateCurrentElement();
          }
          clearBackToTableContext() {
            for (
              ;
              (this.currentTagName !== Ot.TABLE && this.currentTagName !== Ot.TEMPLATE && this.currentTagName !== Ot.HTML) ||
              this.treeAdapter.getNamespaceURI(this.current) !== ft.HTML;

            )
              this.pop();
          }
          clearBackToTableBodyContext() {
            for (
              ;
              (this.currentTagName !== Ot.TBODY &&
                this.currentTagName !== Ot.TFOOT &&
                this.currentTagName !== Ot.THEAD &&
                this.currentTagName !== Ot.TEMPLATE &&
                this.currentTagName !== Ot.HTML) ||
              this.treeAdapter.getNamespaceURI(this.current) !== ft.HTML;

            )
              this.pop();
          }
          clearBackToTableRowContext() {
            for (
              ;
              (this.currentTagName !== Ot.TR && this.currentTagName !== Ot.TEMPLATE && this.currentTagName !== Ot.HTML) ||
              this.treeAdapter.getNamespaceURI(this.current) !== ft.HTML;

            )
              this.pop();
          }
          remove(e) {
            for (let t = this.stackTop; t >= 0; t--)
              if (this.items[t] === e) {
                this.items.splice(t, 1), this.stackTop--, this._updateCurrentElement();
                break;
              }
          }
          tryPeekProperlyNestedBodyElement() {
            const e = this.items[1];
            return e && this.treeAdapter.getTagName(e) === Ot.BODY ? e : null;
          }
          contains(e) {
            return this._indexOf(e) > -1;
          }
          getCommonAncestor(e) {
            let t = this._indexOf(e);
            return --t >= 0 ? this.items[t] : null;
          }
          isRootHtmlElementCurrent() {
            return 0 === this.stackTop && this.currentTagName === Ot.HTML;
          }
          hasInScope(e) {
            for (let t = this.stackTop; t >= 0; t--) {
              const n = this.treeAdapter.getTagName(this.items[t]),
                s = this.treeAdapter.getNamespaceURI(this.items[t]);
              if (n === e && s === ft.HTML) return !0;
              if (It(n, s)) return !1;
            }
            return !0;
          }
          hasNumberedHeaderInScope() {
            for (let e = this.stackTop; e >= 0; e--) {
              const t = this.treeAdapter.getTagName(this.items[e]),
                n = this.treeAdapter.getNamespaceURI(this.items[e]);
              if ((t === Ot.H1 || t === Ot.H2 || t === Ot.H3 || t === Ot.H4 || t === Ot.H5 || t === Ot.H6) && n === ft.HTML) return !0;
              if (It(t, n)) return !1;
            }
            return !0;
          }
          hasInListItemScope(e) {
            for (let t = this.stackTop; t >= 0; t--) {
              const n = this.treeAdapter.getTagName(this.items[t]),
                s = this.treeAdapter.getNamespaceURI(this.items[t]);
              if (n === e && s === ft.HTML) return !0;
              if (((n === Ot.UL || n === Ot.OL) && s === ft.HTML) || It(n, s)) return !1;
            }
            return !0;
          }
          hasInButtonScope(e) {
            for (let t = this.stackTop; t >= 0; t--) {
              const n = this.treeAdapter.getTagName(this.items[t]),
                s = this.treeAdapter.getNamespaceURI(this.items[t]);
              if (n === e && s === ft.HTML) return !0;
              if ((n === Ot.BUTTON && s === ft.HTML) || It(n, s)) return !1;
            }
            return !0;
          }
          hasInTableScope(e) {
            for (let t = this.stackTop; t >= 0; t--) {
              const n = this.treeAdapter.getTagName(this.items[t]);
              if (this.treeAdapter.getNamespaceURI(this.items[t]) === ft.HTML) {
                if (n === e) return !0;
                if (n === Ot.TABLE || n === Ot.TEMPLATE || n === Ot.HTML) return !1;
              }
            }
            return !0;
          }
          hasTableBodyContextInTableScope() {
            for (let e = this.stackTop; e >= 0; e--) {
              const t = this.treeAdapter.getTagName(this.items[e]);
              if (this.treeAdapter.getNamespaceURI(this.items[e]) === ft.HTML) {
                if (t === Ot.TBODY || t === Ot.THEAD || t === Ot.TFOOT) return !0;
                if (t === Ot.TABLE || t === Ot.HTML) return !1;
              }
            }
            return !0;
          }
          hasInSelectScope(e) {
            for (let t = this.stackTop; t >= 0; t--) {
              const n = this.treeAdapter.getTagName(this.items[t]);
              if (this.treeAdapter.getNamespaceURI(this.items[t]) === ft.HTML) {
                if (n === e) return !0;
                if (n !== Ot.OPTION && n !== Ot.OPTGROUP) return !1;
              }
            }
            return !0;
          }
          generateImpliedEndTags() {
            for (; St(this.currentTagName); ) this.pop();
          }
          generateImpliedEndTagsThoroughly() {
            for (; Rt(this.currentTagName); ) this.pop();
          }
          generateImpliedEndTagsWithExclusion(e) {
            for (; St(this.currentTagName) && this.currentTagName !== e; ) this.pop();
          }
        })(this.document, this.treeAdapter)),
        (this.activeFormattingElements = new kt(this.treeAdapter)),
        (this.tmplInsertionModeStack = []),
        (this.tmplInsertionModeStackTop = -1),
        (this.currentTmplInsertionMode = null),
        (this.pendingCharacterTokens = []),
        (this.hasNonWhitespacePendingCharacterToken = !1),
        (this.framesetOk = !0),
        (this.skipNextNewLine = !1),
        (this.fosterParentingEnabled = !1);
    }
    _err() {}
    _runParsingLoop(e) {
      for (; !this.stopped; ) {
        this._setupTokenizerCDATAMode();
        const t = this.tokenizer.getNextToken();
        if (t.type === Nt.HIBERNATION_TOKEN) break;
        if (this.skipNextNewLine && ((this.skipNextNewLine = !1), t.type === Nt.WHITESPACE_CHARACTER_TOKEN && '\n' === t.chars[0])) {
          if (1 === t.chars.length) continue;
          t.chars = t.chars.substr(1);
        }
        if ((this._processInputToken(t), e && this.pendingScript)) break;
      }
    }
    runParsingLoopForCurrentChunk(e, t) {
      if ((this._runParsingLoop(t), t && this.pendingScript)) {
        const e = this.pendingScript;
        return (this.pendingScript = null), void t(e);
      }
      e && e();
    }
    _setupTokenizerCDATAMode() {
      const e = this._getAdjustedCurrentElement();
      this.tokenizer.allowCDATA = e && e !== this.document && this.treeAdapter.getNamespaceURI(e) !== qt.HTML && !this._isIntegrationPoint(e);
    }
    _switchToTextParsing(e, t) {
      this._insertElement(e, qt.HTML), (this.tokenizer.state = t), (this.originalInsertionMode = this.insertionMode), (this.insertionMode = Tn);
    }
    switchToPlaintextParsing() {
      (this.insertionMode = Tn), (this.originalInsertionMode = an), (this.tokenizer.state = Nt.MODE.PLAINTEXT);
    }
    _getAdjustedCurrentElement() {
      return 0 === this.openElements.stackTop && this.fragmentContext ? this.fragmentContext : this.openElements.current;
    }
    _findFormInFragmentContext() {
      let e = this.fragmentContext;
      do {
        if (this.treeAdapter.getTagName(e) === zt.FORM) {
          this.formElement = e;
          break;
        }
        e = this.treeAdapter.getParentNode(e);
      } while (e);
    }
    _initTokenizerForFragmentParsing() {
      if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === qt.HTML) {
        const e = this.treeAdapter.getTagName(this.fragmentContext);
        e === zt.TITLE || e === zt.TEXTAREA
          ? (this.tokenizer.state = Nt.MODE.RCDATA)
          : e === zt.STYLE || e === zt.XMP || e === zt.IFRAME || e === zt.NOEMBED || e === zt.NOFRAMES || e === zt.NOSCRIPT
          ? (this.tokenizer.state = Nt.MODE.RAWTEXT)
          : e === zt.SCRIPT
          ? (this.tokenizer.state = Nt.MODE.SCRIPT_DATA)
          : e === zt.PLAINTEXT && (this.tokenizer.state = Nt.MODE.PLAINTEXT);
      }
    }
    _setDocumentType(e) {
      const t = e.name || '',
        n = e.publicId || '',
        s = e.systemId || '';
      this.treeAdapter.setDocumentType(this.document, t, n, s);
    }
    _attachElementToTree(e) {
      if (this._shouldFosterParentOnInsertion()) this._fosterParentElement(e);
      else {
        const t = this.openElements.currentTmplContent || this.openElements.current;
        this.treeAdapter.appendChild(t, e);
      }
    }
    _appendElement(e, t) {
      const n = this.treeAdapter.createElement(e.tagName, t, e.attrs);
      this._attachElementToTree(n);
    }
    _insertElement(e, t) {
      const n = this.treeAdapter.createElement(e.tagName, t, e.attrs);
      this._attachElementToTree(n), this.openElements.push(n);
    }
    _insertFakeElement(e) {
      const t = this.treeAdapter.createElement(e, qt.HTML, []);
      this._attachElementToTree(t), this.openElements.push(t);
    }
    _insertTemplate(e) {
      const t = this.treeAdapter.createElement(e.tagName, qt.HTML, e.attrs),
        n = this.treeAdapter.createDocumentFragment();
      this.treeAdapter.setTemplateContent(t, n), this._attachElementToTree(t), this.openElements.push(t);
    }
    _insertFakeRootElement() {
      const e = this.treeAdapter.createElement(zt.HTML, qt.HTML, []);
      this.treeAdapter.appendChild(this.openElements.current, e), this.openElements.push(e);
    }
    _appendCommentNode(e, t) {
      const n = this.treeAdapter.createCommentNode(e.data);
      this.treeAdapter.appendChild(t, n);
    }
    _insertCharacters(e) {
      if (this._shouldFosterParentOnInsertion()) this._fosterParentText(e.chars);
      else {
        const t = this.openElements.currentTmplContent || this.openElements.current;
        this.treeAdapter.insertText(t, e.chars);
      }
    }
    _adoptNodes(e, t) {
      for (let n = this.treeAdapter.getFirstChild(e); n; n = this.treeAdapter.getFirstChild(e)) this.treeAdapter.detachNode(n), this.treeAdapter.appendChild(t, n);
    }
    _shouldProcessTokenInForeignContent(e) {
      const t = this._getAdjustedCurrentElement();
      if (!t || t === this.document) return !1;
      const n = this.treeAdapter.getNamespaceURI(t);
      if (n === qt.HTML) return !1;
      if (this.treeAdapter.getTagName(t) === zt.ANNOTATION_XML && n === qt.MATHML && e.type === Nt.START_TAG_TOKEN && e.tagName === zt.SVG) return !1;
      const s = e.type === Nt.CHARACTER_TOKEN || e.type === Nt.NULL_CHARACTER_TOKEN || e.type === Nt.WHITESPACE_CHARACTER_TOKEN;
      return !(
        (((e.type === Nt.START_TAG_TOKEN && e.tagName !== zt.MGLYPH && e.tagName !== zt.MALIGNMARK) || s) && this._isIntegrationPoint(t, qt.MATHML)) ||
        ((e.type === Nt.START_TAG_TOKEN || s) && this._isIntegrationPoint(t, qt.HTML)) ||
        e.type === Nt.EOF_TOKEN
      );
    }
    _processToken(e) {
      Ln[this.insertionMode][e.type](this, e);
    }
    _processTokenInBodyMode(e) {
      Ln.IN_BODY_MODE[e.type](this, e);
    }
    _processTokenInForeignContent(e) {
      e.type === Nt.CHARACTER_TOKEN
        ? (function (e, t) {
            e._insertCharacters(t), (e.framesetOk = !1);
          })(this, e)
        : e.type === Nt.NULL_CHARACTER_TOKEN
        ? (function (e, t) {
            (t.chars = n), e._insertCharacters(t);
          })(this, e)
        : e.type === Nt.WHITESPACE_CHARACTER_TOKEN
        ? xn(this, e)
        : e.type === Nt.COMMENT_TOKEN
        ? Kn(this, e)
        : e.type === Nt.START_TAG_TOKEN
        ? (function (e, t) {
            if (jt.causesExit(t) && !e.fragmentContext) {
              for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== qt.HTML && !e._isIntegrationPoint(e.openElements.current); ) e.openElements.pop();
              e._processToken(t);
            } else {
              const n = e._getAdjustedCurrentElement(),
                s = e.treeAdapter.getNamespaceURI(n);
              s === qt.MATHML ? jt.adjustTokenMathMLAttrs(t) : s === qt.SVG && (jt.adjustTokenSVGTagName(t), jt.adjustTokenSVGAttrs(t)),
                jt.adjustTokenXMLAttrs(t),
                t.selfClosing ? e._appendElement(t, s) : e._insertElement(t, s),
                (t.ackSelfClosing = !0);
            }
          })(this, e)
        : e.type === Nt.END_TAG_TOKEN &&
          (function (e, t) {
            for (let n = e.openElements.stackTop; n > 0; n--) {
              const s = e.openElements.items[n];
              if (e.treeAdapter.getNamespaceURI(s) === qt.HTML) {
                e._processToken(t);
                break;
              }
              if (e.treeAdapter.getTagName(s).toLowerCase() === t.tagName) {
                e.openElements.popUntilElementPopped(s);
                break;
              }
            }
          })(this, e);
    }
    _processInputToken(e) {
      this._shouldProcessTokenInForeignContent(e) ? this._processTokenInForeignContent(e) : this._processToken(e),
        e.type === Nt.START_TAG_TOKEN && e.selfClosing && !e.ackSelfClosing && this._err('non-void-html-element-start-tag-with-trailing-solidus');
    }
    _isIntegrationPoint(e, t) {
      const n = this.treeAdapter.getTagName(e),
        s = this.treeAdapter.getNamespaceURI(e),
        r = this.treeAdapter.getAttrList(e);
      return jt.isIntegrationPoint(n, s, r, t);
    }
    _reconstructActiveFormattingElements() {
      const e = this.activeFormattingElements.length;
      if (e) {
        let t = e,
          n = null;
        do {
          if ((t--, (n = this.activeFormattingElements.entries[t]), n.type === kt.MARKER_ENTRY || this.openElements.contains(n.element))) {
            t++;
            break;
          }
        } while (t > 0);
        for (let s = t; s < e; s++)
          (n = this.activeFormattingElements.entries[s]), this._insertElement(n.token, this.treeAdapter.getNamespaceURI(n.element)), (n.element = this.openElements.current);
      }
    }
    _closeTableCell() {
      this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), (this.insertionMode = mn);
    }
    _closePElement() {
      this.openElements.generateImpliedEndTagsWithExclusion(zt.P), this.openElements.popUntilTagNamePopped(zt.P);
    }
    _resetInsertionMode() {
      for (let e = this.openElements.stackTop, t = !1; e >= 0; e--) {
        let n = this.openElements.items[e];
        0 === e && ((t = !0), this.fragmentContext && (n = this.fragmentContext));
        const s = this.treeAdapter.getTagName(n),
          r = Rn[s];
        if (r) {
          this.insertionMode = r;
          break;
        }
        if (!(t || (s !== zt.TD && s !== zt.TH))) {
          this.insertionMode = pn;
          break;
        }
        if (!t && s === zt.HEAD) {
          this.insertionMode = sn;
          break;
        }
        if (s === zt.SELECT) {
          this._resetInsertionModeForSelect(e);
          break;
        }
        if (s === zt.TEMPLATE) {
          this.insertionMode = this.currentTmplInsertionMode;
          break;
        }
        if (s === zt.HTML) {
          this.insertionMode = this.headElement ? on : nn;
          break;
        }
        if (t) {
          this.insertionMode = an;
          break;
        }
      }
    }
    _resetInsertionModeForSelect(e) {
      if (e > 0)
        for (let t = e - 1; t > 0; t--) {
          const e = this.openElements.items[t],
            n = this.treeAdapter.getTagName(e);
          if (n === zt.TEMPLATE) break;
          if (n === zt.TABLE) return void (this.insertionMode = un);
        }
      this.insertionMode = An;
    }
    _pushTmplInsertionMode(e) {
      this.tmplInsertionModeStack.push(e), this.tmplInsertionModeStackTop++, (this.currentTmplInsertionMode = e);
    }
    _popTmplInsertionMode() {
      this.tmplInsertionModeStack.pop(), this.tmplInsertionModeStackTop--, (this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop]);
    }
    _isElementCausesFosterParenting(e) {
      const t = this.treeAdapter.getTagName(e);
      return t === zt.TABLE || t === zt.TBODY || t === zt.TFOOT || t === zt.THEAD || t === zt.TR;
    }
    _shouldFosterParentOnInsertion() {
      return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);
    }
    _findFosterParentingLocation() {
      const e = { parent: null, beforeElement: null };
      for (let t = this.openElements.stackTop; t >= 0; t--) {
        const n = this.openElements.items[t],
          s = this.treeAdapter.getTagName(n),
          r = this.treeAdapter.getNamespaceURI(n);
        if (s === zt.TEMPLATE && r === qt.HTML) {
          e.parent = this.treeAdapter.getTemplateContent(n);
          break;
        }
        if (s === zt.TABLE) {
          (e.parent = this.treeAdapter.getParentNode(n)), e.parent ? (e.beforeElement = n) : (e.parent = this.openElements.items[t - 1]);
          break;
        }
      }
      return e.parent || (e.parent = this.openElements.items[0]), e;
    }
    _fosterParentElement(e) {
      const t = this._findFosterParentingLocation();
      t.beforeElement ? this.treeAdapter.insertBefore(t.parent, e, t.beforeElement) : this.treeAdapter.appendChild(t.parent, e);
    }
    _fosterParentText(e) {
      const t = this._findFosterParentingLocation();
      t.beforeElement ? this.treeAdapter.insertTextBefore(t.parent, e, t.beforeElement) : this.treeAdapter.insertText(t.parent, e);
    }
    _isSpecialElement(e) {
      const t = this.treeAdapter.getTagName(e),
        n = this.treeAdapter.getNamespaceURI(e);
      return Ct.SPECIAL_ELEMENTS[n][t];
    }
  };
  function Mn(e, t) {
    let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
    return n ? (e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagName) || (n = null) : (e.activeFormattingElements.removeEntry(n), (n = null))) : hs(e, t), n;
  }
  function gn(e, t) {
    let n = null;
    for (let s = e.openElements.stackTop; s >= 0; s--) {
      const r = e.openElements.items[s];
      if (r === t.element) break;
      e._isSpecialElement(r) && (n = r);
    }
    return n || (e.openElements.popUntilElementPopped(t.element), e.activeFormattingElements.removeEntry(t)), n;
  }
  function Pn(e, t, n) {
    let s = t,
      r = e.openElements.getCommonAncestor(t);
    for (let i = 0, o = r; o !== n; i++, o = r) {
      r = e.openElements.getCommonAncestor(o);
      const n = e.activeFormattingElements.getElementEntry(o),
        a = n && i >= 3;
      !n || a
        ? (a && e.activeFormattingElements.removeEntry(n), e.openElements.remove(o))
        : ((o = Hn(e, n)), s === t && (e.activeFormattingElements.bookmark = n), e.treeAdapter.detachNode(s), e.treeAdapter.appendChild(o, s), (s = o));
    }
    return s;
  }
  function Hn(e, t) {
    const n = e.treeAdapter.getNamespaceURI(t.element),
      s = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs);
    return e.openElements.replace(t.element, s), (t.element = s), s;
  }
  function Dn(e, t, n) {
    if (e._isElementCausesFosterParenting(t)) e._fosterParentElement(n);
    else {
      const s = e.treeAdapter.getTagName(t),
        r = e.treeAdapter.getNamespaceURI(t);
      s === zt.TEMPLATE && r === qt.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n);
    }
  }
  function Fn(e, t, n) {
    const s = e.treeAdapter.getNamespaceURI(n.element),
      r = n.token,
      i = e.treeAdapter.createElement(r.tagName, s, r.attrs);
    e._adoptNodes(t, i),
      e.treeAdapter.appendChild(t, i),
      e.activeFormattingElements.insertElementAfterBookmark(i, n.token),
      e.activeFormattingElements.removeEntry(n),
      e.openElements.remove(n.element),
      e.openElements.insertAfter(t, i);
  }
  function Un(e, t) {
    let n;
    for (let s = 0; s < 8 && ((n = Mn(e, t)), n); s++) {
      const t = gn(e, n);
      if (!t) break;
      e.activeFormattingElements.bookmark = n;
      const s = Pn(e, t, n.element),
        r = e.openElements.getCommonAncestor(n.element);
      e.treeAdapter.detachNode(s), Dn(e, r, s), Fn(e, t, n);
    }
  }
  function Gn() {}
  function Bn(e) {
    e._err('misplaced-doctype');
  }
  function Kn(e, t) {
    e._appendCommentNode(t, e.openElements.currentTmplContent || e.openElements.current);
  }
  function bn(e, t) {
    e._appendCommentNode(t, e.document);
  }
  function xn(e, t) {
    e._insertCharacters(t);
  }
  function yn(e) {
    e.stopped = !0;
  }
  function vn(e, t) {
    e._err('missing-doctype', { beforeToken: !0 }), e.treeAdapter.setDocumentMode(e.document, Ct.DOCUMENT_MODE.QUIRKS), (e.insertionMode = tn), e._processToken(t);
  }
  function Yn(e, t) {
    e._insertFakeRootElement(), (e.insertionMode = nn), e._processToken(t);
  }
  function wn(e, t) {
    e._insertFakeElement(zt.HEAD), (e.headElement = e.openElements.current), (e.insertionMode = sn), e._processToken(t);
  }
  function Qn(e, t) {
    const n = t.tagName;
    n === zt.HTML
      ? as(e, t)
      : n === zt.BASE || n === zt.BASEFONT || n === zt.BGSOUND || n === zt.LINK || n === zt.META
      ? (e._appendElement(t, qt.HTML), (t.ackSelfClosing = !0))
      : n === zt.TITLE
      ? e._switchToTextParsing(t, Nt.MODE.RCDATA)
      : n === zt.NOSCRIPT
      ? e.options.scriptingEnabled
        ? e._switchToTextParsing(t, Nt.MODE.RAWTEXT)
        : (e._insertElement(t, qt.HTML), (e.insertionMode = rn))
      : n === zt.NOFRAMES || n === zt.STYLE
      ? e._switchToTextParsing(t, Nt.MODE.RAWTEXT)
      : n === zt.SCRIPT
      ? e._switchToTextParsing(t, Nt.MODE.SCRIPT_DATA)
      : n === zt.TEMPLATE
      ? (e._insertTemplate(t, qt.HTML), e.activeFormattingElements.insertMarker(), (e.framesetOk = !1), (e.insertionMode = Nn), e._pushTmplInsertionMode(Nn))
      : n === zt.HEAD
      ? e._err(k)
      : Wn(e, t);
  }
  function Xn(e, t) {
    const n = t.tagName;
    n === zt.HEAD
      ? (e.openElements.pop(), (e.insertionMode = on))
      : n === zt.BODY || n === zt.BR || n === zt.HTML
      ? Wn(e, t)
      : n === zt.TEMPLATE && e.openElements.tmplCount > 0
      ? (e.openElements.generateImpliedEndTagsThoroughly(),
        e.openElements.currentTagName !== zt.TEMPLATE && e._err('closing-of-element-with-open-child-elements'),
        e.openElements.popUntilTagNamePopped(zt.TEMPLATE),
        e.activeFormattingElements.clearToLastMarker(),
        e._popTmplInsertionMode(),
        e._resetInsertionMode())
      : e._err(L);
  }
  function Wn(e, t) {
    e.openElements.pop(), (e.insertionMode = on), e._processToken(t);
  }
  function Vn(e, t) {
    const n = t.type === Nt.EOF_TOKEN ? 'open-elements-left-after-eof' : 'disallowed-content-in-noscript-in-head';
    e._err(n), e.openElements.pop(), (e.insertionMode = sn), e._processToken(t);
  }
  function jn(e, t) {
    e._insertFakeElement(zt.BODY), (e.insertionMode = an), e._processToken(t);
  }
  function zn(e, t) {
    e._reconstructActiveFormattingElements(), e._insertCharacters(t);
  }
  function qn(e, t) {
    e._reconstructActiveFormattingElements(), e._insertCharacters(t), (e.framesetOk = !1);
  }
  function Jn(e, t) {
    e.openElements.hasInButtonScope(zt.P) && e._closePElement(), e._insertElement(t, qt.HTML);
  }
  function Zn(e, t) {
    e.openElements.hasInButtonScope(zt.P) && e._closePElement(), e._insertElement(t, qt.HTML), (e.skipNextNewLine = !0), (e.framesetOk = !1);
  }
  function $n(e, t) {
    e._reconstructActiveFormattingElements(), e._insertElement(t, qt.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
  }
  function es(e, t) {
    e._reconstructActiveFormattingElements(), e._insertElement(t, qt.HTML), e.activeFormattingElements.insertMarker(), (e.framesetOk = !1);
  }
  function ts(e, t) {
    e._reconstructActiveFormattingElements(), e._appendElement(t, qt.HTML), (e.framesetOk = !1), (t.ackSelfClosing = !0);
  }
  function ns(e, t) {
    e._appendElement(t, qt.HTML), (t.ackSelfClosing = !0);
  }
  function ss(e, t) {
    e._switchToTextParsing(t, Nt.MODE.RAWTEXT);
  }
  function rs(e, t) {
    e.openElements.currentTagName === zt.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, qt.HTML);
  }
  function is(e, t) {
    e.openElements.hasInScope(zt.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, qt.HTML);
  }
  function os(e, t) {
    e._reconstructActiveFormattingElements(), e._insertElement(t, qt.HTML);
  }
  function as(e, t) {
    const n = t.tagName;
    switch (n.length) {
      case 1:
        n === zt.I || n === zt.S || n === zt.B || n === zt.U
          ? $n(e, t)
          : n === zt.P
          ? Jn(e, t)
          : n === zt.A
          ? (function (e, t) {
              const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(zt.A);
              n && (Un(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)),
                e._reconstructActiveFormattingElements(),
                e._insertElement(t, qt.HTML),
                e.activeFormattingElements.pushElement(e.openElements.current, t);
            })(e, t)
          : os(e, t);
        break;
      case 2:
        n === zt.DL || n === zt.OL || n === zt.UL
          ? Jn(e, t)
          : n === zt.H1 || n === zt.H2 || n === zt.H3 || n === zt.H4 || n === zt.H5 || n === zt.H6
          ? (function (e, t) {
              e.openElements.hasInButtonScope(zt.P) && e._closePElement();
              const n = e.openElements.currentTagName;
              (n !== zt.H1 && n !== zt.H2 && n !== zt.H3 && n !== zt.H4 && n !== zt.H5 && n !== zt.H6) || e.openElements.pop(), e._insertElement(t, qt.HTML);
            })(e, t)
          : n === zt.LI || n === zt.DD || n === zt.DT
          ? (function (e, t) {
              e.framesetOk = !1;
              const n = t.tagName;
              for (let t = e.openElements.stackTop; t >= 0; t--) {
                const s = e.openElements.items[t],
                  r = e.treeAdapter.getTagName(s);
                let i = null;
                if ((n === zt.LI && r === zt.LI ? (i = zt.LI) : (n !== zt.DD && n !== zt.DT) || (r !== zt.DD && r !== zt.DT) || (i = r), i)) {
                  e.openElements.generateImpliedEndTagsWithExclusion(i), e.openElements.popUntilTagNamePopped(i);
                  break;
                }
                if (r !== zt.ADDRESS && r !== zt.DIV && r !== zt.P && e._isSpecialElement(s)) break;
              }
              e.openElements.hasInButtonScope(zt.P) && e._closePElement(), e._insertElement(t, qt.HTML);
            })(e, t)
          : n === zt.EM || n === zt.TT
          ? $n(e, t)
          : n === zt.BR
          ? ts(e, t)
          : n === zt.HR
          ? (function (e, t) {
              e.openElements.hasInButtonScope(zt.P) && e._closePElement(), e._appendElement(t, qt.HTML), (e.framesetOk = !1), (t.ackSelfClosing = !0);
            })(e, t)
          : n === zt.RB
          ? is(e, t)
          : n === zt.RT || n === zt.RP
          ? (function (e, t) {
              e.openElements.hasInScope(zt.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(zt.RTC), e._insertElement(t, qt.HTML);
            })(e, t)
          : n !== zt.TH && n !== zt.TD && n !== zt.TR && os(e, t);
        break;
      case 3:
        n === zt.DIV || n === zt.DIR || n === zt.NAV
          ? Jn(e, t)
          : n === zt.PRE
          ? Zn(e, t)
          : n === zt.BIG
          ? $n(e, t)
          : n === zt.IMG || n === zt.WBR
          ? ts(e, t)
          : n === zt.XMP
          ? (function (e, t) {
              e.openElements.hasInButtonScope(zt.P) && e._closePElement(),
                e._reconstructActiveFormattingElements(),
                (e.framesetOk = !1),
                e._switchToTextParsing(t, Nt.MODE.RAWTEXT);
            })(e, t)
          : n === zt.SVG
          ? (function (e, t) {
              e._reconstructActiveFormattingElements(),
                jt.adjustTokenSVGAttrs(t),
                jt.adjustTokenXMLAttrs(t),
                t.selfClosing ? e._appendElement(t, qt.SVG) : e._insertElement(t, qt.SVG),
                (t.ackSelfClosing = !0);
            })(e, t)
          : n === zt.RTC
          ? is(e, t)
          : n !== zt.COL && os(e, t);
        break;
      case 4:
        n === zt.HTML
          ? (function (e, t) {
              0 === e.openElements.tmplCount && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
            })(e, t)
          : n === zt.BASE || n === zt.LINK || n === zt.META
          ? Qn(e, t)
          : n === zt.BODY
          ? (function (e, t) {
              const n = e.openElements.tryPeekProperlyNestedBodyElement();
              n && 0 === e.openElements.tmplCount && ((e.framesetOk = !1), e.treeAdapter.adoptAttributes(n, t.attrs));
            })(e, t)
          : n === zt.MAIN || n === zt.MENU
          ? Jn(e, t)
          : n === zt.FORM
          ? (function (e, t) {
              const n = e.openElements.tmplCount > 0;
              (e.formElement && !n) || (e.openElements.hasInButtonScope(zt.P) && e._closePElement(), e._insertElement(t, qt.HTML), n || (e.formElement = e.openElements.current));
            })(e, t)
          : n === zt.CODE || n === zt.FONT
          ? $n(e, t)
          : n === zt.NOBR
          ? (function (e, t) {
              e._reconstructActiveFormattingElements(),
                e.openElements.hasInScope(zt.NOBR) && (Un(e, t), e._reconstructActiveFormattingElements()),
                e._insertElement(t, qt.HTML),
                e.activeFormattingElements.pushElement(e.openElements.current, t);
            })(e, t)
          : n === zt.AREA
          ? ts(e, t)
          : n === zt.MATH
          ? (function (e, t) {
              e._reconstructActiveFormattingElements(),
                jt.adjustTokenMathMLAttrs(t),
                jt.adjustTokenXMLAttrs(t),
                t.selfClosing ? e._appendElement(t, qt.MATHML) : e._insertElement(t, qt.MATHML),
                (t.ackSelfClosing = !0);
            })(e, t)
          : n === zt.MENU
          ? (function (e, t) {
              e.openElements.hasInButtonScope(zt.P) && e._closePElement(), e._insertElement(t, qt.HTML);
            })(e, t)
          : n !== zt.HEAD && os(e, t);
        break;
      case 5:
        n === zt.STYLE || n === zt.TITLE
          ? Qn(e, t)
          : n === zt.ASIDE
          ? Jn(e, t)
          : n === zt.SMALL
          ? $n(e, t)
          : n === zt.TABLE
          ? (function (e, t) {
              e.treeAdapter.getDocumentMode(e.document) !== Ct.DOCUMENT_MODE.QUIRKS && e.openElements.hasInButtonScope(zt.P) && e._closePElement(),
                e._insertElement(t, qt.HTML),
                (e.framesetOk = !1),
                (e.insertionMode = En);
            })(e, t)
          : n === zt.EMBED
          ? ts(e, t)
          : n === zt.INPUT
          ? (function (e, t) {
              e._reconstructActiveFormattingElements(), e._appendElement(t, qt.HTML);
              const n = Nt.getTokenAttr(t, Jt.TYPE);
              (n && n.toLowerCase() === $t) || (e.framesetOk = !1), (t.ackSelfClosing = !0);
            })(e, t)
          : n === zt.PARAM || n === zt.TRACK
          ? ns(e, t)
          : n === zt.IMAGE
          ? (function (e, t) {
              (t.tagName = zt.IMG), ts(e, t);
            })(e, t)
          : n !== zt.FRAME && n !== zt.TBODY && n !== zt.TFOOT && n !== zt.THEAD && os(e, t);
        break;
      case 6:
        n === zt.SCRIPT
          ? Qn(e, t)
          : n === zt.CENTER || n === zt.FIGURE || n === zt.FOOTER || n === zt.HEADER || n === zt.HGROUP || n === zt.DIALOG
          ? Jn(e, t)
          : n === zt.BUTTON
          ? (function (e, t) {
              e.openElements.hasInScope(zt.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(zt.BUTTON)),
                e._reconstructActiveFormattingElements(),
                e._insertElement(t, qt.HTML),
                (e.framesetOk = !1);
            })(e, t)
          : n === zt.STRIKE || n === zt.STRONG
          ? $n(e, t)
          : n === zt.APPLET || n === zt.OBJECT
          ? es(e, t)
          : n === zt.KEYGEN
          ? ts(e, t)
          : n === zt.SOURCE
          ? ns(e, t)
          : n === zt.IFRAME
          ? (function (e, t) {
              (e.framesetOk = !1), e._switchToTextParsing(t, Nt.MODE.RAWTEXT);
            })(e, t)
          : n === zt.SELECT
          ? (function (e, t) {
              e._reconstructActiveFormattingElements(),
                e._insertElement(t, qt.HTML),
                (e.framesetOk = !1),
                e.insertionMode === En || e.insertionMode === cn || e.insertionMode === ln || e.insertionMode === mn || e.insertionMode === pn
                  ? (e.insertionMode = un)
                  : (e.insertionMode = An);
            })(e, t)
          : n === zt.OPTION
          ? rs(e, t)
          : os(e, t);
        break;
      case 7:
        n === zt.BGSOUND
          ? Qn(e, t)
          : n === zt.DETAILS || n === zt.ADDRESS || n === zt.ARTICLE || n === zt.SECTION || n === zt.SUMMARY
          ? Jn(e, t)
          : n === zt.LISTING
          ? Zn(e, t)
          : n === zt.MARQUEE
          ? es(e, t)
          : n === zt.NOEMBED
          ? ss(e, t)
          : n !== zt.CAPTION && os(e, t);
        break;
      case 8:
        n === zt.BASEFONT
          ? Qn(e, t)
          : n === zt.FRAMESET
          ? (function (e, t) {
              const n = e.openElements.tryPeekProperlyNestedBodyElement();
              e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, qt.HTML), (e.insertionMode = Cn));
            })(e, t)
          : n === zt.FIELDSET
          ? Jn(e, t)
          : n === zt.TEXTAREA
          ? (function (e, t) {
              e._insertElement(t, qt.HTML),
                (e.skipNextNewLine = !0),
                (e.tokenizer.state = Nt.MODE.RCDATA),
                (e.originalInsertionMode = e.insertionMode),
                (e.framesetOk = !1),
                (e.insertionMode = Tn);
            })(e, t)
          : n === zt.TEMPLATE
          ? Qn(e, t)
          : n === zt.NOSCRIPT
          ? e.options.scriptingEnabled
            ? ss(e, t)
            : os(e, t)
          : n === zt.OPTGROUP
          ? rs(e, t)
          : n !== zt.COLGROUP && os(e, t);
        break;
      case 9:
        n === zt.PLAINTEXT
          ? (function (e, t) {
              e.openElements.hasInButtonScope(zt.P) && e._closePElement(), e._insertElement(t, qt.HTML), (e.tokenizer.state = Nt.MODE.PLAINTEXT);
            })(e, t)
          : os(e, t);
        break;
      case 10:
        n === zt.BLOCKQUOTE || n === zt.FIGCAPTION ? Jn(e, t) : os(e, t);
        break;
      default:
        os(e, t);
    }
  }
  function Ts(e, t) {
    const n = t.tagName;
    e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n));
  }
  function Es(e, t) {
    const n = t.tagName;
    e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker());
  }
  function hs(e, t) {
    const n = t.tagName;
    for (let t = e.openElements.stackTop; t > 0; t--) {
      const s = e.openElements.items[t];
      if (e.treeAdapter.getTagName(s) === n) {
        e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilElementPopped(s);
        break;
      }
      if (e._isSpecialElement(s)) break;
    }
  }
  function cs(e, t) {
    const n = t.tagName;
    switch (n.length) {
      case 1:
        n === zt.A || n === zt.B || n === zt.I || n === zt.S || n === zt.U
          ? Un(e, t)
          : n === zt.P
          ? (function (e) {
              e.openElements.hasInButtonScope(zt.P) || e._insertFakeElement(zt.P), e._closePElement();
            })(e)
          : hs(e, t);
        break;
      case 2:
        n === zt.DL || n === zt.UL || n === zt.OL
          ? Ts(e, t)
          : n === zt.LI
          ? (function (e) {
              e.openElements.hasInListItemScope(zt.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(zt.LI), e.openElements.popUntilTagNamePopped(zt.LI));
            })(e)
          : n === zt.DD || n === zt.DT
          ? (function (e, t) {
              const n = t.tagName;
              e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n));
            })(e, t)
          : n === zt.H1 || n === zt.H2 || n === zt.H3 || n === zt.H4 || n === zt.H5 || n === zt.H6
          ? (function (e) {
              e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
            })(e)
          : n === zt.BR
          ? (function (e) {
              e._reconstructActiveFormattingElements(), e._insertFakeElement(zt.BR), e.openElements.pop(), (e.framesetOk = !1);
            })(e)
          : n === zt.EM || n === zt.TT
          ? Un(e, t)
          : hs(e, t);
        break;
      case 3:
        n === zt.BIG ? Un(e, t) : n === zt.DIR || n === zt.DIV || n === zt.NAV || n === zt.PRE ? Ts(e, t) : hs(e, t);
        break;
      case 4:
        n === zt.BODY
          ? (function (e) {
              e.openElements.hasInScope(zt.BODY) && (e.insertionMode = dn);
            })(e)
          : n === zt.HTML
          ? (function (e, t) {
              e.openElements.hasInScope(zt.BODY) && ((e.insertionMode = dn), e._processToken(t));
            })(e, t)
          : n === zt.FORM
          ? (function (e) {
              const t = e.openElements.tmplCount > 0,
                n = e.formElement;
              t || (e.formElement = null),
                (n || t) &&
                  e.openElements.hasInScope(zt.FORM) &&
                  (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(zt.FORM) : e.openElements.remove(n));
            })(e)
          : n === zt.CODE || n === zt.FONT || n === zt.NOBR
          ? Un(e, t)
          : n === zt.MAIN || n === zt.MENU
          ? Ts(e, t)
          : hs(e, t);
        break;
      case 5:
        n === zt.ASIDE ? Ts(e, t) : n === zt.SMALL ? Un(e, t) : hs(e, t);
        break;
      case 6:
        n === zt.CENTER || n === zt.FIGURE || n === zt.FOOTER || n === zt.HEADER || n === zt.HGROUP || n === zt.DIALOG
          ? Ts(e, t)
          : n === zt.APPLET || n === zt.OBJECT
          ? Es(e, t)
          : n === zt.STRIKE || n === zt.STRONG
          ? Un(e, t)
          : hs(e, t);
        break;
      case 7:
        n === zt.ADDRESS || n === zt.ARTICLE || n === zt.DETAILS || n === zt.SECTION || n === zt.SUMMARY || n === zt.LISTING ? Ts(e, t) : n === zt.MARQUEE ? Es(e, t) : hs(e, t);
        break;
      case 8:
        n === zt.FIELDSET ? Ts(e, t) : n === zt.TEMPLATE ? Xn(e, t) : hs(e, t);
        break;
      case 10:
        n === zt.BLOCKQUOTE || n === zt.FIGCAPTION ? Ts(e, t) : hs(e, t);
        break;
      default:
        hs(e, t);
    }
  }
  function _s(e, t) {
    e.tmplInsertionModeStackTop > -1 ? Os(e, t) : (e.stopped = !0);
  }
  function ls(e, t) {
    const n = e.openElements.currentTagName;
    n === zt.TABLE || n === zt.TBODY || n === zt.TFOOT || n === zt.THEAD || n === zt.TR
      ? ((e.pendingCharacterTokens = []), (e.hasNonWhitespacePendingCharacterToken = !1), (e.originalInsertionMode = e.insertionMode), (e.insertionMode = hn), e._processToken(t))
      : As(e, t);
  }
  function ms(e, t) {
    const n = t.tagName;
    switch (n.length) {
      case 2:
        n === zt.TD || n === zt.TH || n === zt.TR
          ? (function (e, t) {
              e.openElements.clearBackToTableContext(), e._insertFakeElement(zt.TBODY), (e.insertionMode = ln), e._processToken(t);
            })(e, t)
          : As(e, t);
        break;
      case 3:
        n === zt.COL
          ? (function (e, t) {
              e.openElements.clearBackToTableContext(), e._insertFakeElement(zt.COLGROUP), (e.insertionMode = _n), e._processToken(t);
            })(e, t)
          : As(e, t);
        break;
      case 4:
        n === zt.FORM
          ? (function (e, t) {
              e.formElement || 0 !== e.openElements.tmplCount || (e._insertElement(t, qt.HTML), (e.formElement = e.openElements.current), e.openElements.pop());
            })(e, t)
          : As(e, t);
        break;
      case 5:
        n === zt.TABLE
          ? (function (e, t) {
              e.openElements.hasInTableScope(zt.TABLE) && (e.openElements.popUntilTagNamePopped(zt.TABLE), e._resetInsertionMode(), e._processToken(t));
            })(e, t)
          : n === zt.STYLE
          ? Qn(e, t)
          : n === zt.TBODY || n === zt.TFOOT || n === zt.THEAD
          ? (function (e, t) {
              e.openElements.clearBackToTableContext(), e._insertElement(t, qt.HTML), (e.insertionMode = ln);
            })(e, t)
          : n === zt.INPUT
          ? (function (e, t) {
              const n = Nt.getTokenAttr(t, Jt.TYPE);
              n && n.toLowerCase() === $t ? e._appendElement(t, qt.HTML) : As(e, t), (t.ackSelfClosing = !0);
            })(e, t)
          : As(e, t);
        break;
      case 6:
        n === zt.SCRIPT ? Qn(e, t) : As(e, t);
        break;
      case 7:
        n === zt.CAPTION
          ? (function (e, t) {
              e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, qt.HTML), (e.insertionMode = cn);
            })(e, t)
          : As(e, t);
        break;
      case 8:
        n === zt.COLGROUP
          ? (function (e, t) {
              e.openElements.clearBackToTableContext(), e._insertElement(t, qt.HTML), (e.insertionMode = _n);
            })(e, t)
          : n === zt.TEMPLATE
          ? Qn(e, t)
          : As(e, t);
        break;
      default:
        As(e, t);
    }
  }
  function ps(e, t) {
    const n = t.tagName;
    n === zt.TABLE
      ? e.openElements.hasInTableScope(zt.TABLE) && (e.openElements.popUntilTagNamePopped(zt.TABLE), e._resetInsertionMode())
      : n === zt.TEMPLATE
      ? Xn(e, t)
      : n !== zt.BODY &&
        n !== zt.CAPTION &&
        n !== zt.COL &&
        n !== zt.COLGROUP &&
        n !== zt.HTML &&
        n !== zt.TBODY &&
        n !== zt.TD &&
        n !== zt.TFOOT &&
        n !== zt.TH &&
        n !== zt.THEAD &&
        n !== zt.TR &&
        As(e, t);
  }
  function As(e, t) {
    const n = e.fosterParentingEnabled;
    (e.fosterParentingEnabled = !0), e._processTokenInBodyMode(t), (e.fosterParentingEnabled = n);
  }
  function us(e, t) {
    let n = 0;
    if (e.hasNonWhitespacePendingCharacterToken) for (; n < e.pendingCharacterTokens.length; n++) As(e, e.pendingCharacterTokens[n]);
    else for (; n < e.pendingCharacterTokens.length; n++) e._insertCharacters(e.pendingCharacterTokens[n]);
    (e.insertionMode = e.originalInsertionMode), e._processToken(t);
  }
  function Ns(e, t) {
    e.openElements.currentTagName === zt.COLGROUP && (e.openElements.pop(), (e.insertionMode = En), e._processToken(t));
  }
  function ds(e, t) {
    const n = t.tagName;
    n === zt.HTML
      ? as(e, t)
      : n === zt.OPTION
      ? (e.openElements.currentTagName === zt.OPTION && e.openElements.pop(), e._insertElement(t, qt.HTML))
      : n === zt.OPTGROUP
      ? (e.openElements.currentTagName === zt.OPTION && e.openElements.pop(), e.openElements.currentTagName === zt.OPTGROUP && e.openElements.pop(), e._insertElement(t, qt.HTML))
      : n === zt.INPUT || n === zt.KEYGEN || n === zt.TEXTAREA || n === zt.SELECT
      ? e.openElements.hasInSelectScope(zt.SELECT) && (e.openElements.popUntilTagNamePopped(zt.SELECT), e._resetInsertionMode(), n !== zt.SELECT && e._processToken(t))
      : (n !== zt.SCRIPT && n !== zt.TEMPLATE) || Qn(e, t);
  }
  function Cs(e, t) {
    const n = t.tagName;
    if (n === zt.OPTGROUP) {
      const t = e.openElements.items[e.openElements.stackTop - 1],
        n = t && e.treeAdapter.getTagName(t);
      e.openElements.currentTagName === zt.OPTION && n === zt.OPTGROUP && e.openElements.pop(), e.openElements.currentTagName === zt.OPTGROUP && e.openElements.pop();
    } else
      n === zt.OPTION
        ? e.openElements.currentTagName === zt.OPTION && e.openElements.pop()
        : n === zt.SELECT && e.openElements.hasInSelectScope(zt.SELECT)
        ? (e.openElements.popUntilTagNamePopped(zt.SELECT), e._resetInsertionMode())
        : n === zt.TEMPLATE && Xn(e, t);
  }
  function Os(e, t) {
    e.openElements.tmplCount > 0
      ? (e.openElements.popUntilTagNamePopped(zt.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e._popTmplInsertionMode(), e._resetInsertionMode(), e._processToken(t))
      : (e.stopped = !0);
  }
  function fs(e, t) {
    (e.insertionMode = an), e._processToken(t);
  }
  function Ss(e, t) {
    (e.insertionMode = an), e._processToken(t);
  }
  return (
    Ct.TAG_NAMES,
    Ct.NAMESPACES,
    (e.parse = function (e, t) {
      return new kn(t).parse(e);
    }),
    (e.parseFragment = function (e, t, n) {
      return 'string' == typeof e && ((n = t), (t = e), (e = null)), new kn(n).parseFragment(t, e);
    }),
    Object.defineProperty(e, '__esModule', { value: !0 }),
    e
  );
})({});
const parse = e.parse;
const parseFragment = e.parseFragment;

const docParser = new WeakMap();
function parseDocumentUtil(ownerDocument, html) {
  const doc = parse(html.trim(), getParser(ownerDocument));
  doc.documentElement = doc.firstElementChild;
  doc.head = doc.documentElement.firstElementChild;
  doc.body = doc.head.nextElementSibling;
  return doc;
}
function parseFragmentUtil(ownerDocument, html) {
  if (typeof html === 'string') {
    html = html.trim();
  } else {
    html = '';
  }
  const frag = parseFragment(html, getParser(ownerDocument));
  return frag;
}
function getParser(ownerDocument) {
  let parseOptions = docParser.get(ownerDocument);
  if (parseOptions != null) {
    return parseOptions;
  }
  const treeAdapter = {
    createDocument() {
      const doc = ownerDocument.createElement('#document' /* DOCUMENT_NODE */);
      doc['x-mode'] = 'no-quirks';
      return doc;
    },
    setNodeSourceCodeLocation(node, location) {
      node.sourceCodeLocation = location;
    },
    getNodeSourceCodeLocation(node) {
      return node.sourceCodeLocation;
    },
    createDocumentFragment() {
      return ownerDocument.createDocumentFragment();
    },
    createElement(tagName, namespaceURI, attrs) {
      const elm = ownerDocument.createElementNS(namespaceURI, tagName);
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (attr.namespace == null || attr.namespace === 'http://www.w3.org/1999/xhtml') {
          elm.setAttribute(attr.name, attr.value);
        } else {
          elm.setAttributeNS(attr.namespace, attr.name, attr.value);
        }
      }
      return elm;
    },
    createCommentNode(data) {
      return ownerDocument.createComment(data);
    },
    appendChild(parentNode, newNode) {
      parentNode.appendChild(newNode);
    },
    insertBefore(parentNode, newNode, referenceNode) {
      parentNode.insertBefore(newNode, referenceNode);
    },
    setTemplateContent(templateElement, contentElement) {
      templateElement.content = contentElement;
    },
    getTemplateContent(templateElement) {
      return templateElement.content;
    },
    setDocumentType(doc, name, publicId, systemId) {
      let doctypeNode = doc.childNodes.find(n => n.nodeType === 10 /* DOCUMENT_TYPE_NODE */);
      if (doctypeNode == null) {
        doctypeNode = ownerDocument.createDocumentTypeNode();
        doc.insertBefore(doctypeNode, doc.firstChild);
      }
      doctypeNode.nodeValue = '!DOCTYPE';
      doctypeNode['x-name'] = name;
      doctypeNode['x-publicId'] = publicId;
      doctypeNode['x-systemId'] = systemId;
    },
    setDocumentMode(doc, mode) {
      doc['x-mode'] = mode;
    },
    getDocumentMode(doc) {
      return doc['x-mode'];
    },
    detachNode(node) {
      node.remove();
    },
    insertText(parentNode, text) {
      const lastChild = parentNode.lastChild;
      if (lastChild != null && lastChild.nodeType === 3 /* TEXT_NODE */) {
        lastChild.nodeValue += text;
      } else {
        parentNode.appendChild(ownerDocument.createTextNode(text));
      }
    },
    insertTextBefore(parentNode, text, referenceNode) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
      if (prevNode != null && prevNode.nodeType === 3 /* TEXT_NODE */) {
        prevNode.nodeValue += text;
      } else {
        parentNode.insertBefore(ownerDocument.createTextNode(text), referenceNode);
      }
    },
    adoptAttributes(recipient, attrs) {
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (recipient.hasAttributeNS(attr.namespace, attr.name) === false) {
          recipient.setAttributeNS(attr.namespace, attr.name, attr.value);
        }
      }
    },
    getFirstChild(node) {
      return node.childNodes[0];
    },
    getChildNodes(node) {
      return node.childNodes;
    },
    getParentNode(node) {
      return node.parentNode;
    },
    getAttrList(element) {
      const attrs = element.attributes.__items.map(attr => {
        return {
          name: attr.name,
          value: attr.value,
          namespace: attr.namespaceURI,
          prefix: null,
        };
      });
      return attrs;
    },
    getTagName(element) {
      if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
        return element.nodeName.toLowerCase();
      } else {
        return element.nodeName;
      }
    },
    getNamespaceURI(element) {
      return element.namespaceURI;
    },
    getTextNodeContent(textNode) {
      return textNode.nodeValue;
    },
    getCommentNodeContent(commentNode) {
      return commentNode.nodeValue;
    },
    getDocumentTypeNodeName(doctypeNode) {
      return doctypeNode['x-name'];
    },
    getDocumentTypeNodePublicId(doctypeNode) {
      return doctypeNode['x-publicId'];
    },
    getDocumentTypeNodeSystemId(doctypeNode) {
      return doctypeNode['x-systemId'];
    },
    isTextNode(node) {
      return node.nodeType === 3 /* TEXT_NODE */;
    },
    isCommentNode(node) {
      return node.nodeType === 8 /* COMMENT_NODE */;
    },
    isDocumentTypeNode(node) {
      return node.nodeType === 10 /* DOCUMENT_TYPE_NODE */;
    },
    isElementNode(node) {
      return node.nodeType === 1 /* ELEMENT_NODE */;
    },
  };
  parseOptions = {
    treeAdapter: treeAdapter,
  };
  docParser.set(ownerDocument, parseOptions);
  return parseOptions;
}

class MockNode {
  constructor(ownerDocument, nodeType, nodeName, nodeValue) {
    this.ownerDocument = ownerDocument;
    this.nodeType = nodeType;
    this.nodeName = nodeName;
    this._nodeValue = nodeValue;
    this.parentNode = null;
    this.childNodes = [];
  }
  appendChild(newNode) {
    if (newNode.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
      const nodes = newNode.childNodes.slice();
      for (const child of nodes) {
        this.appendChild(child);
      }
    } else {
      newNode.remove();
      newNode.parentNode = this;
      this.childNodes.push(newNode);
      connectNode(this.ownerDocument, newNode);
    }
    return newNode;
  }
  append(...items) {
    items.forEach(item => {
      const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
      this.appendChild(isNode ? item : this.ownerDocument.createTextNode(String(item)));
    });
  }
  prepend(...items) {
    const firstChild = this.firstChild;
    items.forEach(item => {
      const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
      this.insertBefore(isNode ? item : this.ownerDocument.createTextNode(String(item)), firstChild);
    });
  }
  cloneNode(deep) {
    throw new Error(`invalid node type to clone: ${this.nodeType}, deep: ${deep}`);
  }
  compareDocumentPosition(_other) {
    // unimplemented
    // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
    return -1;
  }
  get firstChild() {
    return this.childNodes[0] || null;
  }
  insertBefore(newNode, referenceNode) {
    if (newNode.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
      for (let i = 0, ii = newNode.childNodes.length; i < ii; i++) {
        insertBefore(this, newNode.childNodes[i], referenceNode);
      }
    } else {
      insertBefore(this, newNode, referenceNode);
    }
    return newNode;
  }
  get isConnected() {
    let node = this;
    while (node != null) {
      if (node.nodeType === 9 /* DOCUMENT_NODE */) {
        return true;
      }
      node = node.parentNode;
      if (node != null && node.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */) {
        node = node.host;
      }
    }
    return false;
  }
  isSameNode(node) {
    return this === node;
  }
  get lastChild() {
    return this.childNodes[this.childNodes.length - 1] || null;
  }
  get nextSibling() {
    if (this.parentNode != null) {
      const index = this.parentNode.childNodes.indexOf(this) + 1;
      return this.parentNode.childNodes[index] || null;
    }
    return null;
  }
  get nodeValue() {
    return this._nodeValue;
  }
  set nodeValue(value) {
    this._nodeValue = value;
  }
  get parentElement() {
    return this.parentNode || null;
  }
  set parentElement(value) {
    this.parentNode = value;
  }
  get previousSibling() {
    if (this.parentNode != null) {
      const index = this.parentNode.childNodes.indexOf(this) - 1;
      return this.parentNode.childNodes[index] || null;
    }
    return null;
  }
  contains(otherNode) {
    return this.childNodes.includes(otherNode);
  }
  removeChild(childNode) {
    const index = this.childNodes.indexOf(childNode);
    if (index > -1) {
      this.childNodes.splice(index, 1);
      if (this.nodeType === 1 /* ELEMENT_NODE */) {
        const wasConnected = this.isConnected;
        childNode.parentNode = null;
        if (wasConnected === true) {
          disconnectNode(childNode);
        }
      } else {
        childNode.parentNode = null;
      }
    } else {
      throw new Error(`node not found within childNodes during removeChild`);
    }
    return childNode;
  }
  remove() {
    if (this.parentNode != null) {
      this.parentNode.removeChild(this);
    }
  }
  replaceChild(newChild, oldChild) {
    if (oldChild.parentNode === this) {
      this.insertBefore(newChild, oldChild);
      oldChild.remove();
      return newChild;
    }
    return null;
  }
  get textContent() {
    return this._nodeValue;
  }
  set textContent(value) {
    this._nodeValue = String(value);
  }
}
MockNode.ELEMENT_NODE = 1;
MockNode.TEXT_NODE = 3;
MockNode.PROCESSING_INSTRUCTION_NODE = 7;
MockNode.COMMENT_NODE = 8;
MockNode.DOCUMENT_NODE = 9;
MockNode.DOCUMENT_TYPE_NODE = 10;
MockNode.DOCUMENT_FRAGMENT_NODE = 11;
class MockNodeList {
  constructor(ownerDocument, childNodes, length) {
    this.ownerDocument = ownerDocument;
    this.childNodes = childNodes;
    this.length = length;
  }
}
class MockElement extends MockNode {
  constructor(ownerDocument, nodeName) {
    super(ownerDocument, 1 /* ELEMENT_NODE */, typeof nodeName === 'string' ? nodeName : null, null);
    this.namespaceURI = null;
  }
  addEventListener(type, handler) {
    addEventListener(this, type, handler);
  }
  attachShadow(_opts) {
    const shadowRoot = this.ownerDocument.createDocumentFragment();
    this.shadowRoot = shadowRoot;
    return shadowRoot;
  }
  get shadowRoot() {
    return this.__shadowRoot || null;
  }
  set shadowRoot(shadowRoot) {
    if (shadowRoot != null) {
      shadowRoot.host = this;
      this.__shadowRoot = shadowRoot;
    } else {
      delete this.__shadowRoot;
    }
  }
  get attributes() {
    if (this.__attributeMap == null) {
      this.__attributeMap = createAttributeProxy(false);
    }
    return this.__attributeMap;
  }
  set attributes(attrs) {
    this.__attributeMap = attrs;
  }
  get children() {
    return this.childNodes.filter(n => n.nodeType === 1 /* ELEMENT_NODE */);
  }
  get childElementCount() {
    return this.childNodes.filter(n => n.nodeType === 1 /* ELEMENT_NODE */).length;
  }
  get className() {
    return this.getAttributeNS(null, 'class') || '';
  }
  set className(value) {
    this.setAttributeNS(null, 'class', value);
  }
  get classList() {
    return new MockClassList(this);
  }
  click() {
    dispatchEvent(this, new MockEvent('click', { bubbles: true, cancelable: true, composed: true }));
  }
  cloneNode(_deep) {
    // implemented on MockElement.prototype from within element.ts
    return null;
  }
  closest(selector) {
    let elm = this;
    while (elm != null) {
      if (elm.matches(selector)) {
        return elm;
      }
      elm = elm.parentNode;
    }
    return null;
  }
  get dataset() {
    return dataset(this);
  }
  get dir() {
    return this.getAttributeNS(null, 'dir') || '';
  }
  set dir(value) {
    this.setAttributeNS(null, 'dir', value);
  }
  dispatchEvent(ev) {
    return dispatchEvent(this, ev);
  }
  get firstElementChild() {
    return this.children[0] || null;
  }
  getAttribute(attrName) {
    if (attrName === 'style') {
      if (this.__style != null && this.__style.length > 0) {
        return this.style.cssText;
      }
      return null;
    }
    const attr = this.attributes.getNamedItem(attrName);
    if (attr != null) {
      return attr.value;
    }
    return null;
  }
  getAttributeNS(namespaceURI, attrName) {
    const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
    if (attr != null) {
      return attr.value;
    }
    return null;
  }
  getBoundingClientRect() {
    return { bottom: 0, height: 0, left: 0, right: 0, top: 0, width: 0, x: 0, y: 0 };
  }
  getRootNode(opts) {
    const isComposed = opts != null && opts.composed === true;
    let node = this;
    while (node.parentNode != null) {
      node = node.parentNode;
      if (isComposed === true && node.parentNode == null && node.host != null) {
        node = node.host;
      }
    }
    return node;
  }
  get draggable() {
    return this.getAttributeNS(null, 'draggable') === 'true';
  }
  set draggable(value) {
    this.setAttributeNS(null, 'draggable', value);
  }
  hasChildNodes() {
    return this.childNodes.length > 0;
  }
  get id() {
    return this.getAttributeNS(null, 'id') || '';
  }
  set id(value) {
    this.setAttributeNS(null, 'id', value);
  }
  get innerHTML() {
    if (this.childNodes.length === 0) {
      return '';
    }
    return serializeNodeToHtml(this, {
      newLines: false,
      indentSpaces: 0,
    });
  }
  set innerHTML(html) {
    if (NON_ESCAPABLE_CONTENT.has(this.nodeName) === true) {
      setTextContent(this, html);
    } else {
      for (let i = this.childNodes.length - 1; i >= 0; i--) {
        this.removeChild(this.childNodes[i]);
      }
      if (typeof html === 'string') {
        const frag = parseFragmentUtil(this.ownerDocument, html);
        while (frag.childNodes.length > 0) {
          this.appendChild(frag.childNodes[0]);
        }
      }
    }
  }
  get innerText() {
    const text = [];
    getTextContent(this.childNodes, text);
    return text.join('');
  }
  set innerText(value) {
    setTextContent(this, value);
  }
  insertAdjacentElement(position, elm) {
    if (position === 'beforebegin') {
      insertBefore(this.parentNode, elm, this);
    } else if (position === 'afterbegin') {
      this.prepend(elm);
    } else if (position === 'beforeend') {
      this.appendChild(elm);
    } else if (position === 'afterend') {
      insertBefore(this.parentNode, elm, this.nextSibling);
    }
    return elm;
  }
  insertAdjacentHTML(position, html) {
    const frag = parseFragmentUtil(this.ownerDocument, html);
    if (position === 'beforebegin') {
      while (frag.childNodes.length > 0) {
        insertBefore(this.parentNode, frag.childNodes[0], this);
      }
    } else if (position === 'afterbegin') {
      while (frag.childNodes.length > 0) {
        this.prepend(frag.childNodes[frag.childNodes.length - 1]);
      }
    } else if (position === 'beforeend') {
      while (frag.childNodes.length > 0) {
        this.appendChild(frag.childNodes[0]);
      }
    } else if (position === 'afterend') {
      while (frag.childNodes.length > 0) {
        insertBefore(this.parentNode, frag.childNodes[frag.childNodes.length - 1], this.nextSibling);
      }
    }
  }
  insertAdjacentText(position, text) {
    const elm = this.ownerDocument.createTextNode(text);
    if (position === 'beforebegin') {
      insertBefore(this.parentNode, elm, this);
    } else if (position === 'afterbegin') {
      this.prepend(elm);
    } else if (position === 'beforeend') {
      this.appendChild(elm);
    } else if (position === 'afterend') {
      insertBefore(this.parentNode, elm, this.nextSibling);
    }
  }
  hasAttribute(attrName) {
    if (attrName === 'style') {
      return this.__style != null && this.__style.length > 0;
    }
    return this.getAttribute(attrName) !== null;
  }
  hasAttributeNS(namespaceURI, name) {
    return this.getAttributeNS(namespaceURI, name) !== null;
  }
  get hidden() {
    return this.hasAttributeNS(null, 'hidden');
  }
  set hidden(isHidden) {
    if (isHidden === true) {
      this.setAttributeNS(null, 'hidden', '');
    } else {
      this.removeAttributeNS(null, 'hidden');
    }
  }
  get lang() {
    return this.getAttributeNS(null, 'lang') || '';
  }
  set lang(value) {
    this.setAttributeNS(null, 'lang', value);
  }
  get lastElementChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  matches(selector) {
    return matches(selector, this);
  }
  get nextElementSibling() {
    const parentElement = this.parentElement;
    if (
      parentElement != null &&
      (parentElement.nodeType === 1 /* ELEMENT_NODE */ || parentElement.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */ || parentElement.nodeType === 9) /* DOCUMENT_NODE */
    ) {
      const children = parentElement.children;
      const index = children.indexOf(this) + 1;
      return parentElement.children[index] || null;
    }
    return null;
  }
  get outerHTML() {
    return serializeNodeToHtml(this, {
      newLines: false,
      outerHtml: true,
      indentSpaces: 0,
    });
  }
  get previousElementSibling() {
    const parentElement = this.parentElement;
    if (
      parentElement != null &&
      (parentElement.nodeType === 1 /* ELEMENT_NODE */ || parentElement.nodeType === 11 /* DOCUMENT_FRAGMENT_NODE */ || parentElement.nodeType === 9) /* DOCUMENT_NODE */
    ) {
      const children = parentElement.children;
      const index = children.indexOf(this) - 1;
      return parentElement.children[index] || null;
    }
    return null;
  }
  getElementsByClassName(classNames) {
    const classes = classNames
      .trim()
      .split(' ')
      .filter(c => c.length > 0);
    const results = [];
    getElementsByClassName(this, classes, results);
    return results;
  }
  getElementsByTagName(tagName) {
    const results = [];
    getElementsByTagName(this, tagName.toLowerCase(), results);
    return results;
  }
  querySelector(selector) {
    return selectOne(selector, this);
  }
  querySelectorAll(selector) {
    return selectAll(selector, this);
  }
  removeAttribute(attrName) {
    if (attrName === 'style') {
      delete this.__style;
    } else {
      const attr = this.attributes.getNamedItem(attrName);
      if (attr != null) {
        this.attributes.removeNamedItemNS(attr);
        if (checkAttributeChanged(this) === true) {
          attributeChanged(this, attrName, attr.value, null);
        }
      }
    }
  }
  removeAttributeNS(namespaceURI, attrName) {
    const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
    if (attr != null) {
      this.attributes.removeNamedItemNS(attr);
      if (checkAttributeChanged(this) === true) {
        attributeChanged(this, attrName, attr.value, null);
      }
    }
  }
  removeEventListener(type, handler) {
    removeEventListener(this, type, handler);
  }
  setAttribute(attrName, value) {
    if (attrName === 'style') {
      this.style = value;
    } else {
      const attributes = this.attributes;
      let attr = attributes.getNamedItem(attrName);
      const checkAttrChanged = checkAttributeChanged(this);
      if (attr != null) {
        if (checkAttrChanged === true) {
          const oldValue = attr.value;
          attr.value = value;
          if (oldValue !== attr.value) {
            attributeChanged(this, attr.name, oldValue, attr.value);
          }
        } else {
          attr.value = value;
        }
      } else {
        if (attributes.caseInsensitive) {
          attrName = attrName.toLowerCase();
        }
        attr = new MockAttr(attrName, value);
        attributes.__items.push(attr);
        if (checkAttrChanged === true) {
          attributeChanged(this, attrName, null, attr.value);
        }
      }
    }
  }
  setAttributeNS(namespaceURI, attrName, value) {
    const attributes = this.attributes;
    let attr = attributes.getNamedItemNS(namespaceURI, attrName);
    const checkAttrChanged = checkAttributeChanged(this);
    if (attr != null) {
      if (checkAttrChanged === true) {
        const oldValue = attr.value;
        attr.value = value;
        if (oldValue !== attr.value) {
          attributeChanged(this, attr.name, oldValue, attr.value);
        }
      } else {
        attr.value = value;
      }
    } else {
      attr = new MockAttr(attrName, value, namespaceURI);
      attributes.__items.push(attr);
      if (checkAttrChanged === true) {
        attributeChanged(this, attrName, null, attr.value);
      }
    }
  }
  get style() {
    if (this.__style == null) {
      this.__style = createCSSStyleDeclaration();
    }
    return this.__style;
  }
  set style(val) {
    if (typeof val === 'string') {
      if (this.__style == null) {
        this.__style = createCSSStyleDeclaration();
      }
      this.__style.cssText = val;
    } else {
      this.__style = val;
    }
  }
  get tabIndex() {
    return parseInt(this.getAttributeNS(null, 'tabindex') || '-1', 10);
  }
  set tabIndex(value) {
    this.setAttributeNS(null, 'tabindex', value);
  }
  get tagName() {
    return this.nodeName;
  }
  set tagName(value) {
    this.nodeName = value;
  }
  get textContent() {
    const text = [];
    getTextContent(this.childNodes, text);
    return text.join('');
  }
  set textContent(value) {
    setTextContent(this, value);
  }
  get title() {
    return this.getAttributeNS(null, 'title') || '';
  }
  set title(value) {
    this.setAttributeNS(null, 'title', value);
  }
  onanimationstart() {
    /**/
  }
  onanimationend() {
    /**/
  }
  onanimationiteration() {
    /**/
  }
  onabort() {
    /**/
  }
  onauxclick() {
    /**/
  }
  onbeforecopy() {
    /**/
  }
  onbeforecut() {
    /**/
  }
  onbeforepaste() {
    /**/
  }
  onblur() {
    /**/
  }
  oncancel() {
    /**/
  }
  oncanplay() {
    /**/
  }
  oncanplaythrough() {
    /**/
  }
  onchange() {
    /**/
  }
  onclick() {
    /**/
  }
  onclose() {
    /**/
  }
  oncontextmenu() {
    /**/
  }
  oncopy() {
    /**/
  }
  oncuechange() {
    /**/
  }
  oncut() {
    /**/
  }
  ondblclick() {
    /**/
  }
  ondrag() {
    /**/
  }
  ondragend() {
    /**/
  }
  ondragenter() {
    /**/
  }
  ondragleave() {
    /**/
  }
  ondragover() {
    /**/
  }
  ondragstart() {
    /**/
  }
  ondrop() {
    /**/
  }
  ondurationchange() {
    /**/
  }
  onemptied() {
    /**/
  }
  onended() {
    /**/
  }
  onerror() {
    /**/
  }
  onfocus() {
    /**/
  }
  onfocusin() {
    /**/
  }
  onfocusout() {
    /**/
  }
  onformdata() {
    /**/
  }
  onfullscreenchange() {
    /**/
  }
  onfullscreenerror() {
    /**/
  }
  ongotpointercapture() {
    /**/
  }
  oninput() {
    /**/
  }
  oninvalid() {
    /**/
  }
  onkeydown() {
    /**/
  }
  onkeypress() {
    /**/
  }
  onkeyup() {
    /**/
  }
  onload() {
    /**/
  }
  onloadeddata() {
    /**/
  }
  onloadedmetadata() {
    /**/
  }
  onloadstart() {
    /**/
  }
  onlostpointercapture() {
    /**/
  }
  onmousedown() {
    /**/
  }
  onmouseenter() {
    /**/
  }
  onmouseleave() {
    /**/
  }
  onmousemove() {
    /**/
  }
  onmouseout() {
    /**/
  }
  onmouseover() {
    /**/
  }
  onmouseup() {
    /**/
  }
  onmousewheel() {
    /**/
  }
  onpaste() {
    /**/
  }
  onpause() {
    /**/
  }
  onplay() {
    /**/
  }
  onplaying() {
    /**/
  }
  onpointercancel() {
    /**/
  }
  onpointerdown() {
    /**/
  }
  onpointerenter() {
    /**/
  }
  onpointerleave() {
    /**/
  }
  onpointermove() {
    /**/
  }
  onpointerout() {
    /**/
  }
  onpointerover() {
    /**/
  }
  onpointerup() {
    /**/
  }
  onprogress() {
    /**/
  }
  onratechange() {
    /**/
  }
  onreset() {
    /**/
  }
  onresize() {
    /**/
  }
  onscroll() {
    /**/
  }
  onsearch() {
    /**/
  }
  onseeked() {
    /**/
  }
  onseeking() {
    /**/
  }
  onselect() {
    /**/
  }
  onselectstart() {
    /**/
  }
  onstalled() {
    /**/
  }
  onsubmit() {
    /**/
  }
  onsuspend() {
    /**/
  }
  ontimeupdate() {
    /**/
  }
  ontoggle() {
    /**/
  }
  onvolumechange() {
    /**/
  }
  onwaiting() {
    /**/
  }
  onwebkitfullscreenchange() {
    /**/
  }
  onwebkitfullscreenerror() {
    /**/
  }
  onwheel() {
    /**/
  }
  toString(opts) {
    return serializeNodeToHtml(this, opts);
  }
}
function getElementsByClassName(elm, classNames, foundElms) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    for (let j = 0, jj = classNames.length; j < jj; j++) {
      if (childElm.classList.contains(classNames[j])) {
        foundElms.push(childElm);
      }
    }
    getElementsByClassName(childElm, classNames, foundElms);
  }
}
function getElementsByTagName(elm, tagName, foundElms) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (tagName === '*' || childElm.nodeName.toLowerCase() === tagName) {
      foundElms.push(childElm);
    }
    getElementsByTagName(childElm, tagName, foundElms);
  }
}
function resetElement(elm) {
  resetEventListeners(elm);
  delete elm.__attributeMap;
  delete elm.__shadowRoot;
  delete elm.__style;
}
function insertBefore(parentNode, newNode, referenceNode) {
  if (newNode !== referenceNode) {
    newNode.remove();
    newNode.parentNode = parentNode;
    newNode.ownerDocument = parentNode.ownerDocument;
    if (referenceNode != null) {
      const index = parentNode.childNodes.indexOf(referenceNode);
      if (index > -1) {
        parentNode.childNodes.splice(index, 0, newNode);
      } else {
        throw new Error(`referenceNode not found in parentNode.childNodes`);
      }
    } else {
      parentNode.childNodes.push(newNode);
    }
    connectNode(parentNode.ownerDocument, newNode);
  }
  return newNode;
}
class MockHTMLElement extends MockElement {
  constructor(ownerDocument, nodeName) {
    super(ownerDocument, typeof nodeName === 'string' ? nodeName.toUpperCase() : null);
    this.namespaceURI = 'http://www.w3.org/1999/xhtml';
  }
  get tagName() {
    return this.nodeName;
  }
  set tagName(value) {
    this.nodeName = value;
  }
  get attributes() {
    if (this.__attributeMap == null) {
      this.__attributeMap = createAttributeProxy(true);
    }
    return this.__attributeMap;
  }
  set attributes(attrs) {
    this.__attributeMap = attrs;
  }
}
class MockTextNode extends MockNode {
  constructor(ownerDocument, text) {
    super(ownerDocument, 3 /* TEXT_NODE */, '#text' /* TEXT_NODE */, text);
  }
  cloneNode(_deep) {
    return new MockTextNode(null, this.nodeValue);
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(text) {
    this.nodeValue = text;
  }
  get data() {
    return this.nodeValue;
  }
  set data(text) {
    this.nodeValue = text;
  }
  get wholeText() {
    if (this.parentNode != null) {
      const text = [];
      for (let i = 0, ii = this.parentNode.childNodes.length; i < ii; i++) {
        const childNode = this.parentNode.childNodes[i];
        if (childNode.nodeType === 3 /* TEXT_NODE */) {
          text.push(childNode.nodeValue);
        }
      }
      return text.join('');
    }
    return this.nodeValue;
  }
}
function getTextContent(childNodes, text) {
  for (let i = 0, ii = childNodes.length; i < ii; i++) {
    const childNode = childNodes[i];
    if (childNode.nodeType === 3 /* TEXT_NODE */) {
      text.push(childNode.nodeValue);
    } else if (childNode.nodeType === 1 /* ELEMENT_NODE */) {
      getTextContent(childNode.childNodes, text);
    }
  }
}
function setTextContent(elm, text) {
  for (let i = elm.childNodes.length - 1; i >= 0; i--) {
    elm.removeChild(elm.childNodes[i]);
  }
  const textNode = new MockTextNode(elm.ownerDocument, text);
  elm.appendChild(textNode);
}

class MockComment extends MockNode {
  constructor(ownerDocument, data) {
    super(ownerDocument, 8 /* COMMENT_NODE */, '#comment' /* COMMENT_NODE */, data);
  }
  cloneNode(_deep) {
    return new MockComment(null, this.nodeValue);
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(text) {
    this.nodeValue = text;
  }
}

class MockDocumentFragment extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, null);
    this.nodeName = '#document-fragment' /* DOCUMENT_FRAGMENT_NODE */;
    this.nodeType = 11 /* DOCUMENT_FRAGMENT_NODE */;
  }
  getElementById(id) {
    return getElementById(this, id);
  }
  cloneNode(deep) {
    const cloned = new MockDocumentFragment(null);
    if (deep) {
      for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
        const childNode = this.childNodes[i];
        if (childNode.nodeType === 1 /* ELEMENT_NODE */ || childNode.nodeType === 3 /* TEXT_NODE */ || childNode.nodeType === 8 /* COMMENT_NODE */) {
          const clonedChildNode = this.childNodes[i].cloneNode(true);
          cloned.appendChild(clonedChildNode);
        }
      }
    }
    return cloned;
  }
}

class MockDocumentTypeNode extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, '!DOCTYPE');
    this.nodeType = 10 /* DOCUMENT_TYPE_NODE */;
    this.setAttribute('html', '');
  }
}

class MockCSSRule {
  constructor(parentStyleSheet) {
    this.parentStyleSheet = parentStyleSheet;
    this.cssText = '';
    this.type = 0;
  }
}
class MockCSSStyleSheet {
  constructor(ownerNode) {
    this.type = 'text/css';
    this.parentStyleSheet = null;
    this.cssRules = [];
    this.ownerNode = ownerNode;
  }
  get rules() {
    return this.cssRules;
  }
  set rules(rules) {
    this.cssRules = rules;
  }
  deleteRule(index) {
    if (index >= 0 && index < this.cssRules.length) {
      this.cssRules.splice(index, 1);
      updateStyleTextNode(this.ownerNode);
    }
  }
  insertRule(rule, index = 0) {
    if (typeof index !== 'number') {
      index = 0;
    }
    if (index < 0) {
      index = 0;
    }
    if (index > this.cssRules.length) {
      index = this.cssRules.length;
    }
    const cssRule = new MockCSSRule(this);
    cssRule.cssText = rule;
    this.cssRules.splice(index, 0, cssRule);
    updateStyleTextNode(this.ownerNode);
    return index;
  }
}
function getStyleElementText(styleElm) {
  const output = [];
  for (let i = 0; i < styleElm.childNodes.length; i++) {
    output.push(styleElm.childNodes[i].nodeValue);
  }
  return output.join('');
}
function setStyleElementText(styleElm, text) {
  // keeping the innerHTML and the sheet.cssRules connected
  // is not technically correct, but since we're doing
  // SSR we'll need to turn any assigned cssRules into
  // real text, not just properties that aren't rendered
  const sheet = styleElm.sheet;
  sheet.cssRules.length = 0;
  sheet.insertRule(text);
  updateStyleTextNode(styleElm);
}
function updateStyleTextNode(styleElm) {
  const childNodeLen = styleElm.childNodes.length;
  if (childNodeLen > 1) {
    for (let i = childNodeLen - 1; i >= 1; i--) {
      styleElm.removeChild(styleElm.childNodes[i]);
    }
  } else if (childNodeLen < 1) {
    styleElm.appendChild(styleElm.ownerDocument.createTextNode(''));
  }
  const textNode = styleElm.childNodes[0];
  textNode.nodeValue = styleElm.sheet.cssRules.map(r => r.cssText).join('\n');
}

function createElement(ownerDocument, tagName) {
  if (typeof tagName !== 'string' || tagName === '' || !/^[a-z0-9-_:]+$/i.test(tagName)) {
    throw new Error(`The tag name provided (${tagName}) is not a valid name.`);
  }
  tagName = tagName.toLowerCase();
  switch (tagName) {
    case 'a':
      return new MockAnchorElement(ownerDocument);
    case 'base':
      return new MockBaseElement(ownerDocument);
    case 'button':
      return new MockButtonElement(ownerDocument);
    case 'canvas':
      return new MockCanvasElement(ownerDocument);
    case 'form':
      return new MockFormElement(ownerDocument);
    case 'img':
      return new MockImageElement(ownerDocument);
    case 'input':
      return new MockInputElement(ownerDocument);
    case 'link':
      return new MockLinkElement(ownerDocument);
    case 'meta':
      return new MockMetaElement(ownerDocument);
    case 'script':
      return new MockScriptElement(ownerDocument);
    case 'style':
      return new MockStyleElement(ownerDocument);
    case 'template':
      return new MockTemplateElement(ownerDocument);
    case 'title':
      return new MockTitleElement(ownerDocument);
  }
  if (ownerDocument != null && tagName.includes('-')) {
    const win = ownerDocument.defaultView;
    if (win != null && win.customElements != null) {
      return createCustomElement(win.customElements, ownerDocument, tagName);
    }
  }
  return new MockHTMLElement(ownerDocument, tagName);
}
function createElementNS(ownerDocument, namespaceURI, tagName) {
  if (namespaceURI === 'http://www.w3.org/1999/xhtml') {
    return createElement(ownerDocument, tagName);
  } else if (namespaceURI === 'http://www.w3.org/2000/svg') {
    return new MockSVGElement(ownerDocument, tagName);
  } else {
    return new MockElement(ownerDocument, tagName);
  }
}
class MockAnchorElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'a');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
  get pathname() {
    return new URL(this.href).pathname;
  }
}
class MockButtonElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'button');
  }
}
patchPropAttributes(
  MockButtonElement.prototype,
  {
    type: String,
  },
  {
    type: 'submit',
  },
);
class MockImageElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'img');
  }
  get draggable() {
    return this.getAttributeNS(null, 'draggable') !== 'false';
  }
  set draggable(value) {
    this.setAttributeNS(null, 'draggable', value);
  }
  get src() {
    return fullUrl(this, 'src');
  }
  set src(value) {
    this.setAttribute('src', value);
  }
}
patchPropAttributes(MockImageElement.prototype, {
  height: Number,
  width: Number,
});
class MockInputElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'input');
  }
  get list() {
    const listId = this.getAttribute('list');
    if (listId) {
      return this.ownerDocument.getElementById(listId);
    }
    return null;
  }
}
patchPropAttributes(
  MockInputElement.prototype,
  {
    accept: String,
    autocomplete: String,
    autofocus: Boolean,
    capture: String,
    checked: Boolean,
    disabled: Boolean,
    form: String,
    formaction: String,
    formenctype: String,
    formmethod: String,
    formnovalidate: String,
    formtarget: String,
    height: Number,
    inputmode: String,
    max: String,
    maxLength: Number,
    min: String,
    minLength: Number,
    multiple: Boolean,
    name: String,
    pattern: String,
    placeholder: String,
    required: Boolean,
    readOnly: Boolean,
    size: Number,
    spellCheck: Boolean,
    src: String,
    step: String,
    type: String,
    value: String,
    width: Number,
  },
  {
    type: 'text',
  },
);
class MockFormElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'form');
  }
}
patchPropAttributes(MockFormElement.prototype, {
  name: String,
});
class MockLinkElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'link');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
}
patchPropAttributes(MockLinkElement.prototype, {
  crossorigin: String,
  media: String,
  rel: String,
  type: String,
});
class MockMetaElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'meta');
  }
}
patchPropAttributes(MockMetaElement.prototype, {
  charset: String,
  content: String,
  name: String,
});
class MockScriptElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'script');
  }
  get src() {
    return fullUrl(this, 'src');
  }
  set src(value) {
    this.setAttribute('src', value);
  }
}
patchPropAttributes(MockScriptElement.prototype, {
  type: String,
});
class MockStyleElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'style');
    this.sheet = new MockCSSStyleSheet(this);
  }
  get innerHTML() {
    return getStyleElementText(this);
  }
  set innerHTML(value) {
    setStyleElementText(this, value);
  }
  get innerText() {
    return getStyleElementText(this);
  }
  set innerText(value) {
    setStyleElementText(this, value);
  }
  get textContent() {
    return getStyleElementText(this);
  }
  set textContent(value) {
    setStyleElementText(this, value);
  }
}
class MockSVGElement extends MockElement {
  // SVGElement properties and methods
  get ownerSVGElement() {
    return null;
  }
  get viewportElement() {
    return null;
  }
  focus() {
    /**/
  }
  onunload() {
    /**/
  }
  // SVGGeometryElement properties and methods
  get pathLength() {
    return 0;
  }
  isPointInFill(_pt) {
    return false;
  }
  isPointInStroke(_pt) {
    return false;
  }
  getTotalLength() {
    return 0;
  }
}
class MockBaseElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'base');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
}
class MockTemplateElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'template');
    this.content = new MockDocumentFragment(ownerDocument);
  }
  get innerHTML() {
    return this.content.innerHTML;
  }
  set innerHTML(html) {
    this.content.innerHTML = html;
  }
  cloneNode(deep) {
    const cloned = new MockTemplateElement(null);
    cloned.attributes = cloneAttributes(this.attributes);
    const styleCssText = this.getAttribute('style');
    if (styleCssText != null && styleCssText.length > 0) {
      cloned.setAttribute('style', styleCssText);
    }
    cloned.content = this.content.cloneNode(deep);
    if (deep) {
      for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
        const clonedChildNode = this.childNodes[i].cloneNode(true);
        cloned.appendChild(clonedChildNode);
      }
    }
    return cloned;
  }
}
class MockTitleElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'title');
  }
  get text() {
    return this.textContent;
  }
  set text(value) {
    this.textContent = value;
  }
}
class MockCanvasElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'canvas');
  }
  getContext() {
    return {
      fillRect() {
        return;
      },
      clearRect() {},
      getImageData: function (_, __, w, h) {
        return {
          data: new Array(w * h * 4),
        };
      },
      putImageData() {},
      createImageData: function () {
        return [];
      },
      setTransform() {},
      drawImage() {},
      save() {},
      fillText() {},
      restore() {},
      beginPath() {},
      moveTo() {},
      lineTo() {},
      closePath() {},
      stroke() {},
      translate() {},
      scale() {},
      rotate() {},
      arc() {},
      fill() {},
      measureText() {
        return { width: 0 };
      },
      transform() {},
      rect() {},
      clip() {},
    };
  }
}
function fullUrl(elm, attrName) {
  const val = elm.getAttribute(attrName) || '';
  if (elm.ownerDocument != null) {
    const win = elm.ownerDocument.defaultView;
    if (win != null) {
      const loc = win.location;
      if (loc != null) {
        try {
          const url = new URL(val, loc.href);
          return url.href;
        } catch (e) {}
      }
    }
  }
  return val.replace(/\'|\"/g, '').trim();
}
function patchPropAttributes(prototype, attrs, defaults = {}) {
  Object.keys(attrs).forEach(propName => {
    const attr = attrs[propName];
    const defaultValue = defaults[propName];
    if (attr === Boolean) {
      Object.defineProperty(prototype, propName, {
        get() {
          return this.hasAttribute(propName);
        },
        set(value) {
          if (value) {
            this.setAttribute(propName, '');
          } else {
            this.removeAttribute(propName);
          }
        },
      });
    } else if (attr === Number) {
      Object.defineProperty(prototype, propName, {
        get() {
          const value = this.getAttribute(propName);
          return value ? parseInt(value, 10) : defaultValue === undefined ? 0 : defaultValue;
        },
        set(value) {
          this.setAttribute(propName, value);
        },
      });
    } else {
      Object.defineProperty(prototype, propName, {
        get() {
          return this.hasAttribute(propName) ? this.getAttribute(propName) : defaultValue || '';
        },
        set(value) {
          this.setAttribute(propName, value);
        },
      });
    }
  });
}
MockElement.prototype.cloneNode = function (deep) {
  // because we're creating elements, which extending specific HTML base classes there
  // is a MockElement circular reference that bundling has trouble dealing with so
  // the fix is to add cloneNode() to MockElement's prototype after the HTML classes
  const cloned = createElement(this.ownerDocument, this.nodeName);
  cloned.attributes = cloneAttributes(this.attributes);
  const styleCssText = this.getAttribute('style');
  if (styleCssText != null && styleCssText.length > 0) {
    cloned.setAttribute('style', styleCssText);
  }
  if (deep) {
    for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
      const clonedChildNode = this.childNodes[i].cloneNode(true);
      cloned.appendChild(clonedChildNode);
    }
  }
  return cloned;
};

let sharedDocument;
function parseHtmlToDocument(html, ownerDocument = null) {
  if (ownerDocument == null) {
    if (sharedDocument == null) {
      sharedDocument = new MockDocument();
    }
    ownerDocument = sharedDocument;
  }
  return parseDocumentUtil(ownerDocument, html);
}
function parseHtmlToFragment(html, ownerDocument = null) {
  if (ownerDocument == null) {
    if (sharedDocument == null) {
      sharedDocument = new MockDocument();
    }
    ownerDocument = sharedDocument;
  }
  return parseFragmentUtil(ownerDocument, html);
}

class MockHeaders {
  constructor(init) {
    this._values = [];
    if (typeof init === 'object') {
      if (typeof init[Symbol.iterator] === 'function') {
        const kvs = [];
        for (const kv of init) {
          if (typeof kv[Symbol.iterator] === 'function') {
            kvs.push([...kv]);
          }
        }
        for (const kv of kvs) {
          this.append(kv[0], kv[1]);
        }
      } else {
        for (const key in init) {
          this.append(key, init[key]);
        }
      }
    }
  }
  append(key, value) {
    this._values.push([key, value + '']);
  }
  delete(key) {
    key = key.toLowerCase();
    for (let i = this._values.length - 1; i >= 0; i--) {
      if (this._values[i][0].toLowerCase() === key) {
        this._values.splice(i, 1);
      }
    }
  }
  entries() {
    const entries = [];
    for (const kv of this.keys()) {
      entries.push([kv, this.get(kv)]);
    }
    let index = -1;
    return {
      next() {
        index++;
        return {
          value: entries[index],
          done: !entries[index],
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  forEach(cb) {
    for (const kv of this.entries()) {
      cb(kv[1], kv[0]);
    }
  }
  get(key) {
    const rtn = [];
    key = key.toLowerCase();
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key) {
        rtn.push(kv[1]);
      }
    }
    return rtn.length > 0 ? rtn.join(', ') : null;
  }
  has(key) {
    key = key.toLowerCase();
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key) {
        return true;
      }
    }
    return false;
  }
  keys() {
    const keys = [];
    for (const kv of this._values) {
      const key = kv[0].toLowerCase();
      if (!keys.includes(key)) {
        keys.push(key);
      }
    }
    let index = -1;
    return {
      next() {
        index++;
        return {
          value: keys[index],
          done: !keys[index],
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  set(key, value) {
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key.toLowerCase()) {
        kv[1] = value + '';
        return;
      }
    }
    this.append(key, value);
  }
  values() {
    const values = this._values;
    let index = -1;
    return {
      next() {
        index++;
        const done = !values[index];
        return {
          value: done ? undefined : values[index][1],
          done,
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  [Symbol.iterator]() {
    return this.entries();
  }
}

class MockRequest {
  constructor(input, init = {}) {
    this._method = 'GET';
    this._url = '/';
    this.bodyUsed = false;
    this.cache = 'default';
    this.credentials = 'same-origin';
    this.integrity = '';
    this.keepalive = false;
    this.mode = 'cors';
    this.redirect = 'follow';
    this.referrer = 'about:client';
    this.referrerPolicy = '';
    if (typeof input === 'string') {
      this.url = input;
    } else if (input) {
      Object.assign(this, input);
      this.headers = new MockHeaders(input.headers);
    }
    Object.assign(this, init);
    if (init.headers) {
      this.headers = new MockHeaders(init.headers);
    }
    if (!this.headers) {
      this.headers = new MockHeaders();
    }
  }
  get url() {
    if (typeof this._url === 'string') {
      return new URL(this._url, location.href).href;
    }
    return new URL('/', location.href).href;
  }
  set url(value) {
    this._url = value;
  }
  get method() {
    if (typeof this._method === 'string') {
      return this._method.toUpperCase();
    }
    return 'GET';
  }
  set method(value) {
    this._method = value;
  }
  clone() {
    const clone = { ...this };
    clone.headers = new MockHeaders(this.headers);
    return new MockRequest(clone);
  }
}
class MockResponse {
  constructor(body, init = {}) {
    this.ok = true;
    this.status = 200;
    this.statusText = '';
    this.type = 'default';
    this.url = '';
    this._body = body;
    if (init) {
      Object.assign(this, init);
    }
    this.headers = new MockHeaders(init.headers);
  }
  async json() {
    return JSON.parse(this._body);
  }
  async text() {
    return this._body;
  }
  clone() {
    const initClone = { ...this };
    initClone.headers = new MockHeaders(this.headers);
    return new MockResponse(this._body, initClone);
  }
}

function setupGlobal(gbl) {
  if (gbl.window == null) {
    const win = (gbl.window = new MockWindow());
    WINDOW_FUNCTIONS.forEach(fnName => {
      if (!(fnName in gbl)) {
        gbl[fnName] = win[fnName].bind(win);
      }
    });
    WINDOW_PROPS.forEach(propName => {
      if (!(propName in gbl)) {
        Object.defineProperty(gbl, propName, {
          get() {
            return win[propName];
          },
          set(val) {
            win[propName] = val;
          },
          configurable: true,
          enumerable: true,
        });
      }
    });
    GLOBAL_CONSTRUCTORS.forEach(([cstrName]) => {
      gbl[cstrName] = win[cstrName];
    });
  }
  return gbl.window;
}
function teardownGlobal(gbl) {
  const win = gbl.window;
  if (win && typeof win.close === 'function') {
    win.close();
  }
}
function patchWindow(winToBePatched) {
  const mockWin = new MockWindow(false);
  WINDOW_FUNCTIONS.forEach(fnName => {
    if (typeof winToBePatched[fnName] !== 'function') {
      winToBePatched[fnName] = mockWin[fnName].bind(mockWin);
    }
  });
  WINDOW_PROPS.forEach(propName => {
    if (winToBePatched === undefined) {
      Object.defineProperty(winToBePatched, propName, {
        get() {
          return mockWin[propName];
        },
        set(val) {
          mockWin[propName] = val;
        },
        configurable: true,
        enumerable: true,
      });
    }
  });
}
function addGlobalsToWindowPrototype(mockWinPrototype) {
  GLOBAL_CONSTRUCTORS.forEach(([cstrName, Cstr]) => {
    Object.defineProperty(mockWinPrototype, cstrName, {
      get() {
        return this['__' + cstrName] || Cstr;
      },
      set(cstr) {
        this['__' + cstrName] = cstr;
      },
      configurable: true,
      enumerable: true,
    });
  });
}
const WINDOW_FUNCTIONS = [
  'addEventListener',
  'alert',
  'blur',
  'cancelAnimationFrame',
  'cancelIdleCallback',
  'clearInterval',
  'clearTimeout',
  'close',
  'confirm',
  'dispatchEvent',
  'focus',
  'getComputedStyle',
  'matchMedia',
  'open',
  'prompt',
  'removeEventListener',
  'requestAnimationFrame',
  'requestIdleCallback',
  'URL',
];
const WINDOW_PROPS = [
  'customElements',
  'devicePixelRatio',
  'document',
  'history',
  'innerHeight',
  'innerWidth',
  'localStorage',
  'location',
  'navigator',
  'pageXOffset',
  'pageYOffset',
  'performance',
  'screenLeft',
  'screenTop',
  'screenX',
  'screenY',
  'scrollX',
  'scrollY',
  'sessionStorage',
  'CSS',
  'CustomEvent',
  'Event',
  'Element',
  'HTMLElement',
  'Node',
  'NodeList',
  'KeyboardEvent',
  'MouseEvent',
];
const GLOBAL_CONSTRUCTORS = [
  ['CustomEvent', MockCustomEvent],
  ['Event', MockEvent],
  ['Headers', MockHeaders],
  ['KeyboardEvent', MockKeyboardEvent],
  ['MouseEvent', MockMouseEvent],
  ['Request', MockRequest],
  ['Response', MockResponse],
  ['HTMLAnchorElement', MockAnchorElement],
  ['HTMLBaseElement', MockBaseElement],
  ['HTMLButtonElement', MockButtonElement],
  ['HTMLCanvasElement', MockCanvasElement],
  ['HTMLFormElement', MockFormElement],
  ['HTMLImageElement', MockImageElement],
  ['HTMLInputElement', MockInputElement],
  ['HTMLLinkElement', MockLinkElement],
  ['HTMLMetaElement', MockMetaElement],
  ['HTMLScriptElement', MockScriptElement],
  ['HTMLStyleElement', MockStyleElement],
  ['HTMLTemplateElement', MockTemplateElement],
  ['HTMLTitleElement', MockTitleElement],
];

const consoleNoop = () => {
  /**/
};
function createConsole() {
  return {
    debug: consoleNoop,
    error: consoleNoop,
    info: consoleNoop,
    log: consoleNoop,
    warn: consoleNoop,
    dir: consoleNoop,
    dirxml: consoleNoop,
    table: consoleNoop,
    trace: consoleNoop,
    group: consoleNoop,
    groupCollapsed: consoleNoop,
    groupEnd: consoleNoop,
    clear: consoleNoop,
    count: consoleNoop,
    countReset: consoleNoop,
    assert: consoleNoop,
    profile: consoleNoop,
    profileEnd: consoleNoop,
    time: consoleNoop,
    timeLog: consoleNoop,
    timeEnd: consoleNoop,
    timeStamp: consoleNoop,
    context: consoleNoop,
    memory: consoleNoop,
  };
}

class MockHistory {
  constructor() {
    this.items = [];
  }
  get length() {
    return this.items.length;
  }
  back() {
    this.go(-1);
  }
  forward() {
    this.go(1);
  }
  go(_value) {
    //
  }
  pushState(_state, _title, _url) {
    //
  }
  replaceState(_state, _title, _url) {
    //
  }
}

class MockIntersectionObserver {
  constructor() {
    /**/
  }
  disconnect() {
    /**/
  }
  observe() {
    /**/
  }
  takeRecords() {
    return [];
  }
  unobserve() {
    /**/
  }
}

class MockLocation {
  constructor() {
    this.ancestorOrigins = null;
    this.protocol = '';
    this.host = '';
    this.hostname = '';
    this.port = '';
    this.pathname = '';
    this.search = '';
    this.hash = '';
    this.username = '';
    this.password = '';
    this.origin = '';
    this._href = '';
  }
  get href() {
    return this._href;
  }
  set href(value) {
    const url = new URL(value, 'http://mockdoc.stenciljs.com');
    this._href = url.href;
    this.protocol = url.protocol;
    this.host = url.host;
    this.hostname = url.hostname;
    this.port = url.port;
    this.pathname = url.pathname;
    this.search = url.search;
    this.hash = url.hash;
    this.username = url.username;
    this.password = url.password;
    this.origin = url.origin;
  }
  assign(_url) {
    //
  }
  reload(_forcedReload) {
    //
  }
  replace(_url) {
    //
  }
  toString() {
    return this.href;
  }
}

class MockNavigator {
  constructor() {
    this.appCodeName = 'MockNavigator';
    this.appName = 'MockNavigator';
    this.appVersion = 'MockNavigator';
    this.platform = 'MockNavigator';
    this.userAgent = 'MockNavigator';
  }
}

/**
 * https://developer.mozilla.org/en-US/docs/Web/API/Performance
 */
class MockPerformance {
  constructor() {
    this.timeOrigin = Date.now();
  }
  addEventListener() {
    //
  }
  clearMarks() {
    //
  }
  clearMeasures() {
    //
  }
  clearResourceTimings() {
    //
  }
  dispatchEvent() {
    return true;
  }
  getEntries() {
    return [];
  }
  getEntriesByName() {
    return [];
  }
  getEntriesByType() {
    return [];
  }
  mark() {
    //
  }
  measure() {
    //
  }
  get navigation() {
    return {};
  }
  now() {
    return Date.now() - this.timeOrigin;
  }
  get onresourcetimingbufferfull() {
    return null;
  }
  removeEventListener() {
    //
  }
  setResourceTimingBufferSize() {
    //
  }
  get timing() {
    return {};
  }
  toJSON() {
    //
  }
}
function resetPerformance(perf) {
  if (perf != null) {
    try {
      perf.timeOrigin = Date.now();
    } catch (e) {}
  }
}

class MockStorage {
  constructor() {
    this.items = new Map();
  }
  key(_value) {
    //
  }
  getItem(key) {
    key = String(key);
    if (this.items.has(key)) {
      return this.items.get(key);
    }
    return null;
  }
  setItem(key, value) {
    if (value == null) {
      value = 'null';
    }
    this.items.set(String(key), String(value));
  }
  removeItem(key) {
    this.items.delete(String(key));
  }
  clear() {
    this.items.clear();
  }
}

const nativeClearInterval = clearInterval;
const nativeClearTimeout = clearTimeout;
const nativeSetInterval = setInterval;
const nativeSetTimeout = setTimeout;
const nativeURL = URL;
class MockWindow {
  constructor(html = null) {
    if (html !== false) {
      this.document = new MockDocument(html, this);
    } else {
      this.document = null;
    }
    this.performance = new MockPerformance();
    this.customElements = new MockCustomElementRegistry(this);
    this.console = createConsole();
    resetWindowDefaults(this);
    resetWindowDimensions(this);
  }
  addEventListener(type, handler) {
    addEventListener(this, type, handler);
  }
  alert(msg) {
    if (this.console) {
      this.console.debug(msg);
    } else {
      console.debug(msg);
    }
  }
  blur() {
    /**/
  }
  cancelAnimationFrame(id) {
    this.__clearTimeout(id);
  }
  cancelIdleCallback(id) {
    this.__clearTimeout(id);
  }
  get CharacterData() {
    if (this.__charDataCstr == null) {
      const ownerDocument = this.document;
      this.__charDataCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct CharacterData');
        }
      };
    }
    return this.__charDataCstr;
  }
  set CharacterData(charDataCstr) {
    this.__charDataCstr = charDataCstr;
  }
  clearInterval(id) {
    this.__clearInterval(id);
  }
  clearTimeout(id) {
    this.__clearTimeout(id);
  }
  close() {
    resetWindow(this);
  }
  confirm() {
    return false;
  }
  get CSS() {
    return {
      supports: () => true,
    };
  }
  get Document() {
    if (this.__docCstr == null) {
      const win = this;
      this.__docCstr = class extends MockDocument {
        constructor() {
          super(false, win);
          throw new Error('Illegal constructor: cannot construct Document');
        }
      };
    }
    return this.__docCstr;
  }
  set Document(docCstr) {
    this.__docCstr = docCstr;
  }
  get DocumentFragment() {
    if (this.__docFragCstr == null) {
      const ownerDocument = this.document;
      this.__docFragCstr = class extends MockDocumentFragment {
        constructor() {
          super(ownerDocument);
          throw new Error('Illegal constructor: cannot construct DocumentFragment');
        }
      };
    }
    return this.__docFragCstr;
  }
  set DocumentFragment(docFragCstr) {
    this.__docFragCstr = docFragCstr;
  }
  get DocumentType() {
    if (this.__docTypeCstr == null) {
      const ownerDocument = this.document;
      this.__docTypeCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct DocumentType');
        }
      };
    }
    return this.__docTypeCstr;
  }
  set DocumentType(docTypeCstr) {
    this.__docTypeCstr = docTypeCstr;
  }
  get DOMTokenList() {
    if (this.__domTokenListCstr == null) {
      this.__domTokenListCstr = class MockDOMTokenList {};
    }
    return this.__domTokenListCstr;
  }
  set DOMTokenList(domTokenListCstr) {
    this.__domTokenListCstr = domTokenListCstr;
  }
  dispatchEvent(ev) {
    return dispatchEvent(this, ev);
  }
  get Element() {
    if (this.__elementCstr == null) {
      const ownerDocument = this.document;
      this.__elementCstr = class extends MockElement {
        constructor() {
          super(ownerDocument, '');
          throw new Error('Illegal constructor: cannot construct Element');
        }
      };
    }
    return this.__elementCstr;
  }
  fetch(input, init) {
    if (typeof fetch === 'function') {
      return fetch(input, init);
    }
    throw new Error(`fetch() not implemented`);
  }
  focus() {
    /**/
  }
  getComputedStyle(_) {
    return {
      cssText: '',
      length: 0,
      parentRule: null,
      getPropertyPriority() {
        return null;
      },
      getPropertyValue() {
        return '';
      },
      item() {
        return null;
      },
      removeProperty() {
        return null;
      },
      setProperty() {
        return null;
      },
    };
  }
  get globalThis() {
    return this;
  }
  get history() {
    if (this.__history == null) {
      this.__history = new MockHistory();
    }
    return this.__history;
  }
  set history(hsty) {
    this.__history = hsty;
  }
  get JSON() {
    return JSON;
  }
  get HTMLElement() {
    if (this.__htmlElementCstr == null) {
      const ownerDocument = this.document;
      this.__htmlElementCstr = class extends MockHTMLElement {
        constructor() {
          super(ownerDocument, '');
          const observedAttributes = this.constructor.observedAttributes;
          if (Array.isArray(observedAttributes) && typeof this.attributeChangedCallback === 'function') {
            observedAttributes.forEach(attrName => {
              const attrValue = this.getAttribute(attrName);
              if (attrValue != null) {
                this.attributeChangedCallback(attrName, null, attrValue);
              }
            });
          }
        }
      };
    }
    return this.__htmlElementCstr;
  }
  set HTMLElement(htmlElementCstr) {
    this.__htmlElementCstr = htmlElementCstr;
  }
  get IntersectionObserver() {
    return MockIntersectionObserver;
  }
  get localStorage() {
    if (this.__localStorage == null) {
      this.__localStorage = new MockStorage();
    }
    return this.__localStorage;
  }
  set localStorage(locStorage) {
    this.__localStorage = locStorage;
  }
  get location() {
    if (this.__location == null) {
      this.__location = new MockLocation();
    }
    return this.__location;
  }
  set location(val) {
    if (typeof val === 'string') {
      if (this.__location == null) {
        this.__location = new MockLocation();
      }
      this.__location.href = val;
    } else {
      this.__location = val;
    }
  }
  matchMedia() {
    return {
      matches: false,
    };
  }
  get Node() {
    if (this.__nodeCstr == null) {
      const ownerDocument = this.document;
      this.__nodeCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct Node');
        }
      };
    }
    return this.__nodeCstr;
  }
  get NodeList() {
    if (this.__nodeListCstr == null) {
      const ownerDocument = this.document;
      this.__nodeListCstr = class extends MockNodeList {
        constructor() {
          super(ownerDocument, [], 0);
          throw new Error('Illegal constructor: cannot construct NodeList');
        }
      };
    }
    return this.__nodeListCstr;
  }
  get navigator() {
    if (this.__navigator == null) {
      this.__navigator = new MockNavigator();
    }
    return this.__navigator;
  }
  set navigator(nav) {
    this.__navigator = nav;
  }
  get parent() {
    return null;
  }
  prompt() {
    return '';
  }
  open() {
    return null;
  }
  get origin() {
    return this.location.origin;
  }
  removeEventListener(type, handler) {
    removeEventListener(this, type, handler);
  }
  requestAnimationFrame(callback) {
    return this.setTimeout(() => {
      callback(Date.now());
    }, 0);
  }
  requestIdleCallback(callback) {
    return this.setTimeout(() => {
      callback({
        didTimeout: false,
        timeRemaining: () => 0,
      });
    }, 0);
  }
  scroll(_x, _y) {
    /**/
  }
  scrollBy(_x, _y) {
    /**/
  }
  scrollTo(_x, _y) {
    /**/
  }
  get self() {
    return this;
  }
  get sessionStorage() {
    if (this.__sessionStorage == null) {
      this.__sessionStorage = new MockStorage();
    }
    return this.__sessionStorage;
  }
  set sessionStorage(locStorage) {
    this.__sessionStorage = locStorage;
  }
  setInterval(callback, ms, ...args) {
    if (this.__timeouts == null) {
      this.__timeouts = new Set();
    }
    ms = Math.min(ms, this.__maxTimeout);
    if (this.__allowInterval) {
      const intervalId = this.__setInterval(() => {
        if (this.__timeouts) {
          this.__timeouts.delete(intervalId);
          try {
            callback(...args);
          } catch (e) {
            if (this.console) {
              this.console.error(e);
            } else {
              console.error(e);
            }
          }
        }
      }, ms);
      if (this.__timeouts) {
        this.__timeouts.add(intervalId);
      }
      return intervalId;
    }
    const timeoutId = this.__setTimeout(() => {
      if (this.__timeouts) {
        this.__timeouts.delete(timeoutId);
        try {
          callback(...args);
        } catch (e) {
          if (this.console) {
            this.console.error(e);
          } else {
            console.error(e);
          }
        }
      }
    }, ms);
    if (this.__timeouts) {
      this.__timeouts.add(timeoutId);
    }
    return timeoutId;
  }
  setTimeout(callback, ms, ...args) {
    if (this.__timeouts == null) {
      this.__timeouts = new Set();
    }
    ms = Math.min(ms, this.__maxTimeout);
    const timeoutId = this.__setTimeout(() => {
      if (this.__timeouts) {
        this.__timeouts.delete(timeoutId);
        try {
          callback(...args);
        } catch (e) {
          if (this.console) {
            this.console.error(e);
          } else {
            console.error(e);
          }
        }
      }
    }, ms);
    if (this.__timeouts) {
      this.__timeouts.add(timeoutId);
    }
    return timeoutId;
  }
  get top() {
    return this;
  }
  get window() {
    return this;
  }
  onanimationstart() {
    /**/
  }
  onanimationend() {
    /**/
  }
  onanimationiteration() {
    /**/
  }
  onabort() {
    /**/
  }
  onauxclick() {
    /**/
  }
  onbeforecopy() {
    /**/
  }
  onbeforecut() {
    /**/
  }
  onbeforepaste() {
    /**/
  }
  onblur() {
    /**/
  }
  oncancel() {
    /**/
  }
  oncanplay() {
    /**/
  }
  oncanplaythrough() {
    /**/
  }
  onchange() {
    /**/
  }
  onclick() {
    /**/
  }
  onclose() {
    /**/
  }
  oncontextmenu() {
    /**/
  }
  oncopy() {
    /**/
  }
  oncuechange() {
    /**/
  }
  oncut() {
    /**/
  }
  ondblclick() {
    /**/
  }
  ondrag() {
    /**/
  }
  ondragend() {
    /**/
  }
  ondragenter() {
    /**/
  }
  ondragleave() {
    /**/
  }
  ondragover() {
    /**/
  }
  ondragstart() {
    /**/
  }
  ondrop() {
    /**/
  }
  ondurationchange() {
    /**/
  }
  onemptied() {
    /**/
  }
  onended() {
    /**/
  }
  onerror() {
    /**/
  }
  onfocus() {
    /**/
  }
  onfocusin() {
    /**/
  }
  onfocusout() {
    /**/
  }
  onformdata() {
    /**/
  }
  onfullscreenchange() {
    /**/
  }
  onfullscreenerror() {
    /**/
  }
  ongotpointercapture() {
    /**/
  }
  oninput() {
    /**/
  }
  oninvalid() {
    /**/
  }
  onkeydown() {
    /**/
  }
  onkeypress() {
    /**/
  }
  onkeyup() {
    /**/
  }
  onload() {
    /**/
  }
  onloadeddata() {
    /**/
  }
  onloadedmetadata() {
    /**/
  }
  onloadstart() {
    /**/
  }
  onlostpointercapture() {
    /**/
  }
  onmousedown() {
    /**/
  }
  onmouseenter() {
    /**/
  }
  onmouseleave() {
    /**/
  }
  onmousemove() {
    /**/
  }
  onmouseout() {
    /**/
  }
  onmouseover() {
    /**/
  }
  onmouseup() {
    /**/
  }
  onmousewheel() {
    /**/
  }
  onpaste() {
    /**/
  }
  onpause() {
    /**/
  }
  onplay() {
    /**/
  }
  onplaying() {
    /**/
  }
  onpointercancel() {
    /**/
  }
  onpointerdown() {
    /**/
  }
  onpointerenter() {
    /**/
  }
  onpointerleave() {
    /**/
  }
  onpointermove() {
    /**/
  }
  onpointerout() {
    /**/
  }
  onpointerover() {
    /**/
  }
  onpointerup() {
    /**/
  }
  onprogress() {
    /**/
  }
  onratechange() {
    /**/
  }
  onreset() {
    /**/
  }
  onresize() {
    /**/
  }
  onscroll() {
    /**/
  }
  onsearch() {
    /**/
  }
  onseeked() {
    /**/
  }
  onseeking() {
    /**/
  }
  onselect() {
    /**/
  }
  onselectstart() {
    /**/
  }
  onstalled() {
    /**/
  }
  onsubmit() {
    /**/
  }
  onsuspend() {
    /**/
  }
  ontimeupdate() {
    /**/
  }
  ontoggle() {
    /**/
  }
  onvolumechange() {
    /**/
  }
  onwaiting() {
    /**/
  }
  onwebkitfullscreenchange() {
    /**/
  }
  onwebkitfullscreenerror() {
    /**/
  }
  onwheel() {
    /**/
  }
}
addGlobalsToWindowPrototype(MockWindow.prototype);
function resetWindowDefaults(win) {
  win.__clearInterval = nativeClearInterval;
  win.__clearTimeout = nativeClearTimeout;
  win.__setInterval = nativeSetInterval;
  win.__setTimeout = nativeSetTimeout;
  win.__maxTimeout = 30000;
  win.__allowInterval = true;
  win.URL = nativeURL;
}
function cloneWindow(srcWin, opts = {}) {
  if (srcWin == null) {
    return null;
  }
  const clonedWin = new MockWindow(false);
  if (!opts.customElementProxy) {
    srcWin.customElements = null;
  }
  if (srcWin.document != null) {
    const clonedDoc = new MockDocument(false, clonedWin);
    clonedWin.document = clonedDoc;
    clonedDoc.documentElement = srcWin.document.documentElement.cloneNode(true);
  } else {
    clonedWin.document = new MockDocument(null, clonedWin);
  }
  return clonedWin;
}
function cloneDocument(srcDoc) {
  if (srcDoc == null) {
    return null;
  }
  const dstWin = cloneWindow(srcDoc.defaultView);
  return dstWin.document;
}
/**
 * Constrain setTimeout() to 1ms, but still async. Also
 * only allow setInterval() to fire once, also constrained to 1ms.
 */
function constrainTimeouts(win) {
  win.__allowInterval = false;
  win.__maxTimeout = 0;
}
function resetWindow(win) {
  if (win != null) {
    if (win.__timeouts) {
      win.__timeouts.forEach(timeoutId => {
        nativeClearInterval(timeoutId);
        nativeClearTimeout(timeoutId);
      });
      win.__timeouts.clear();
    }
    if (win.customElements && win.customElements.clear) {
      win.customElements.clear();
    }
    resetDocument(win.document);
    resetPerformance(win.performance);
    for (const key in win) {
      if (win.hasOwnProperty(key) && key !== 'document' && key !== 'performance' && key !== 'customElements') {
        delete win[key];
      }
    }
    resetWindowDefaults(win);
    resetWindowDimensions(win);
    resetEventListeners(win);
    if (win.document != null) {
      try {
        win.document.defaultView = win;
      } catch (e) {}
    }
    // ensure we don't hold onto nodeFetch values
    win.fetch = null;
    win.Headers = null;
    win.Request = null;
    win.Response = null;
    win.FetchError = null;
  }
}
function resetWindowDimensions(win) {
  try {
    win.devicePixelRatio = 1;
    win.innerHeight = 768;
    win.innerWidth = 1366;
    win.pageXOffset = 0;
    win.pageYOffset = 0;
    win.screenLeft = 0;
    win.screenTop = 0;
    win.screenX = 0;
    win.screenY = 0;
    win.scrollX = 0;
    win.scrollY = 0;
    win.screen = {
      availHeight: win.innerHeight,
      availLeft: 0,
      availTop: 0,
      availWidth: win.innerWidth,
      colorDepth: 24,
      height: win.innerHeight,
      keepAwake: false,
      orientation: {
        angle: 0,
        type: 'portrait-primary',
      },
      pixelDepth: 24,
      width: win.innerWidth,
    };
  } catch (e) {}
}

class MockDocument extends MockHTMLElement {
  constructor(html = null, win = null) {
    super(null, null);
    this.nodeName = '#document' /* DOCUMENT_NODE */;
    this.nodeType = 9 /* DOCUMENT_NODE */;
    this.defaultView = win;
    this.cookie = '';
    this.referrer = '';
    this.appendChild(this.createDocumentTypeNode());
    if (typeof html === 'string') {
      const parsedDoc = parseDocumentUtil(this, html);
      const documentElement = parsedDoc.children.find(elm => elm.nodeName === 'HTML');
      if (documentElement != null) {
        this.appendChild(documentElement);
        setOwnerDocument(documentElement, this);
      }
    } else if (html !== false) {
      const documentElement = new MockHTMLElement(this, 'html');
      this.appendChild(documentElement);
      documentElement.appendChild(new MockHTMLElement(this, 'head'));
      documentElement.appendChild(new MockHTMLElement(this, 'body'));
    }
  }
  get dir() {
    return this.documentElement.dir;
  }
  set dir(value) {
    this.documentElement.dir = value;
  }
  get location() {
    if (this.defaultView != null) {
      return this.defaultView.location;
    }
    return null;
  }
  set location(val) {
    if (this.defaultView != null) {
      this.defaultView.location = val;
    }
  }
  get baseURI() {
    const baseNode = this.head.childNodes.find(node => node.nodeName === 'BASE');
    if (baseNode) {
      return baseNode.href;
    }
    return this.URL;
  }
  get URL() {
    return this.location.href;
  }
  get styleSheets() {
    return this.querySelectorAll('style');
  }
  get scripts() {
    return this.querySelectorAll('script');
  }
  get forms() {
    return this.querySelectorAll('form');
  }
  get images() {
    return this.querySelectorAll('img');
  }
  get scrollingElement() {
    return this.documentElement;
  }
  get documentElement() {
    for (let i = this.childNodes.length - 1; i >= 0; i--) {
      if (this.childNodes[i].nodeName === 'HTML') {
        return this.childNodes[i];
      }
    }
    const documentElement = new MockHTMLElement(this, 'html');
    this.appendChild(documentElement);
    return documentElement;
  }
  set documentElement(documentElement) {
    for (let i = this.childNodes.length - 1; i >= 0; i--) {
      if (this.childNodes[i].nodeType !== 10 /* DOCUMENT_TYPE_NODE */) {
        this.childNodes[i].remove();
      }
    }
    if (documentElement != null) {
      this.appendChild(documentElement);
      setOwnerDocument(documentElement, this);
    }
  }
  get head() {
    const documentElement = this.documentElement;
    for (let i = 0; i < documentElement.childNodes.length; i++) {
      if (documentElement.childNodes[i].nodeName === 'HEAD') {
        return documentElement.childNodes[i];
      }
    }
    const head = new MockHTMLElement(this, 'head');
    documentElement.insertBefore(head, documentElement.firstChild);
    return head;
  }
  set head(head) {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'HEAD') {
        documentElement.childNodes[i].remove();
      }
    }
    if (head != null) {
      documentElement.insertBefore(head, documentElement.firstChild);
      setOwnerDocument(head, this);
    }
  }
  get body() {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'BODY') {
        return documentElement.childNodes[i];
      }
    }
    const body = new MockHTMLElement(this, 'body');
    documentElement.appendChild(body);
    return body;
  }
  set body(body) {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'BODY') {
        documentElement.childNodes[i].remove();
      }
    }
    if (body != null) {
      documentElement.appendChild(body);
      setOwnerDocument(body, this);
    }
  }
  appendChild(newNode) {
    newNode.remove();
    newNode.parentNode = this;
    this.childNodes.push(newNode);
    return newNode;
  }
  createComment(data) {
    return new MockComment(this, data);
  }
  createAttribute(attrName) {
    return new MockAttr(attrName.toLowerCase(), '');
  }
  createAttributeNS(namespaceURI, attrName) {
    return new MockAttr(attrName, '', namespaceURI);
  }
  createElement(tagName) {
    if (tagName === '#document' /* DOCUMENT_NODE */) {
      const doc = new MockDocument(false);
      doc.nodeName = tagName;
      doc.parentNode = null;
      return doc;
    }
    return createElement(this, tagName);
  }
  createElementNS(namespaceURI, tagName) {
    const elmNs = createElementNS(this, namespaceURI, tagName);
    elmNs.namespaceURI = namespaceURI;
    return elmNs;
  }
  createTextNode(text) {
    return new MockTextNode(this, text);
  }
  createDocumentFragment() {
    return new MockDocumentFragment(this);
  }
  createDocumentTypeNode() {
    return new MockDocumentTypeNode(this);
  }
  getElementById(id) {
    return getElementById(this, id);
  }
  getElementsByName(elmName) {
    return getElementsByName(this, elmName.toLowerCase());
  }
  get title() {
    const title = this.head.childNodes.find(elm => elm.nodeName === 'TITLE');
    if (title != null && typeof title.textContent === 'string') {
      return title.textContent.trim();
    }
    return '';
  }
  set title(value) {
    const head = this.head;
    let title = head.childNodes.find(elm => elm.nodeName === 'TITLE');
    if (title == null) {
      title = this.createElement('title');
      head.appendChild(title);
    }
    title.textContent = value;
  }
}
function createDocument(html = null) {
  return new MockWindow(html).document;
}
function createFragment(html) {
  return parseHtmlToFragment(html, null);
}
function resetDocument(doc) {
  if (doc != null) {
    resetEventListeners(doc);
    const documentElement = doc.documentElement;
    if (documentElement != null) {
      resetElement(documentElement);
      for (let i = 0, ii = documentElement.childNodes.length; i < ii; i++) {
        const childNode = documentElement.childNodes[i];
        resetElement(childNode);
        childNode.childNodes.length = 0;
      }
    }
    for (const key in doc) {
      if (doc.hasOwnProperty(key) && !DOC_KEY_KEEPERS.has(key)) {
        delete doc[key];
      }
    }
    try {
      doc.nodeName = '#document' /* DOCUMENT_NODE */;
    } catch (e) {}
    try {
      doc.nodeType = 9 /* DOCUMENT_NODE */;
    } catch (e) {}
    try {
      doc.cookie = '';
    } catch (e) {}
    try {
      doc.referrer = '';
    } catch (e) {}
  }
}
const DOC_KEY_KEEPERS = new Set(['nodeName', 'nodeType', 'nodeValue', 'ownerDocument', 'parentNode', 'childNodes', '_shadowRoot']);
function getElementById(elm, id) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (childElm.id === id) {
      return childElm;
    }
    const childElmFound = getElementById(childElm, id);
    if (childElmFound != null) {
      return childElmFound;
    }
  }
  return null;
}
function getElementsByName(elm, elmName, foundElms = []) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (childElm.name && childElm.name.toLowerCase() === elmName) {
      foundElms.push(childElm);
    }
    getElementsByName(childElm, elmName, foundElms);
  }
  return foundElms;
}
function setOwnerDocument(elm, ownerDocument) {
  for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
    elm.childNodes[i].ownerDocument = ownerDocument;
    if (elm.childNodes[i].nodeType === 1 /* ELEMENT_NODE */) {
      setOwnerDocument(elm.childNodes[i], ownerDocument);
    }
  }
}

function hydrateFactory($stencilWindow, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve) {
  var globalThis = $stencilWindow;
  var self = $stencilWindow;
  var top = $stencilWindow;
  var parent = $stencilWindow;

  var addEventListener = $stencilWindow.addEventListener.bind($stencilWindow);
  var alert = $stencilWindow.alert.bind($stencilWindow);
  var blur = $stencilWindow.blur.bind($stencilWindow);
  var cancelAnimationFrame = $stencilWindow.cancelAnimationFrame.bind($stencilWindow);
  var cancelIdleCallback = $stencilWindow.cancelIdleCallback.bind($stencilWindow);
  var clearInterval = $stencilWindow.clearInterval.bind($stencilWindow);
  var clearTimeout = $stencilWindow.clearTimeout.bind($stencilWindow);
  var close = () => {};
  var confirm = $stencilWindow.confirm.bind($stencilWindow);
  var dispatchEvent = $stencilWindow.dispatchEvent.bind($stencilWindow);
  var focus = $stencilWindow.focus.bind($stencilWindow);
  var getComputedStyle = $stencilWindow.getComputedStyle.bind($stencilWindow);
  var matchMedia = $stencilWindow.matchMedia.bind($stencilWindow);
  var open = $stencilWindow.open.bind($stencilWindow);
  var prompt = $stencilWindow.prompt.bind($stencilWindow);
  var removeEventListener = $stencilWindow.removeEventListener.bind($stencilWindow);
  var requestAnimationFrame = $stencilWindow.requestAnimationFrame.bind($stencilWindow);
  var requestIdleCallback = $stencilWindow.requestIdleCallback.bind($stencilWindow);
  var setInterval = $stencilWindow.setInterval.bind($stencilWindow);
  var setTimeout = $stencilWindow.setTimeout.bind($stencilWindow);

  var CharacterData = $stencilWindow.CharacterData;
  var CSS = $stencilWindow.CSS;
  var CustomEvent = $stencilWindow.CustomEvent;
  var Document = $stencilWindow.Document;
  var DocumentFragment = $stencilWindow.DocumentFragment;
  var DocumentType = $stencilWindow.DocumentType;
  var DOMTokenList = $stencilWindow.DOMTokenList;
  var Element = $stencilWindow.Element;
  var Event = $stencilWindow.Event;
  var HTMLAnchorElement = $stencilWindow.HTMLAnchorElement;
  var HTMLBaseElement = $stencilWindow.HTMLBaseElement;
  var HTMLButtonElement = $stencilWindow.HTMLButtonElement;
  var HTMLCanvasElement = $stencilWindow.HTMLCanvasElement;
  var HTMLElement = $stencilWindow.HTMLElement;
  var HTMLFormElement = $stencilWindow.HTMLFormElement;
  var HTMLImageElement = $stencilWindow.HTMLImageElement;
  var HTMLInputElement = $stencilWindow.HTMLInputElement;
  var HTMLLinkElement = $stencilWindow.HTMLLinkElement;
  var HTMLMetaElement = $stencilWindow.HTMLMetaElement;
  var HTMLScriptElement = $stencilWindow.HTMLScriptElement;
  var HTMLStyleElement = $stencilWindow.HTMLStyleElement;
  var HTMLTemplateElement = $stencilWindow.HTMLTemplateElement;
  var HTMLTitleElement = $stencilWindow.HTMLTitleElement;
  var IntersectionObserver = $stencilWindow.IntersectionObserver;
  var KeyboardEvent = $stencilWindow.KeyboardEvent;
  var MouseEvent = $stencilWindow.MouseEvent;
  var Node = $stencilWindow.Node;
  var NodeList = $stencilWindow.NodeList;
  var URL = $stencilWindow.URL;

  var console = $stencilWindow.console;
  var customElements = $stencilWindow.customElements;
  var history = $stencilWindow.history;
  var localStorage = $stencilWindow.localStorage;
  var location = $stencilWindow.location;
  var navigator = $stencilWindow.navigator;
  var performance = $stencilWindow.performance;
  var sessionStorage = $stencilWindow.sessionStorage;

  var devicePixelRatio = $stencilWindow.devicePixelRatio;
  var innerHeight = $stencilWindow.innerHeight;
  var innerWidth = $stencilWindow.innerWidth;
  var origin = $stencilWindow.origin;
  var pageXOffset = $stencilWindow.pageXOffset;
  var pageYOffset = $stencilWindow.pageYOffset;
  var screen = $stencilWindow.screen;
  var screenLeft = $stencilWindow.screenLeft;
  var screenTop = $stencilWindow.screenTop;
  var screenX = $stencilWindow.screenX;
  var screenY = $stencilWindow.screenY;
  var scrollX = $stencilWindow.scrollX;
  var scrollY = $stencilWindow.scrollY;
  var exports = {};

  var fetch, FetchError, Headers, Request, Response;

  if (typeof $stencilWindow.fetch === 'function') {
    fetch = $stencilWindow.fetch;
  } else {
    fetch = $stencilWindow.fetch = function () {
      throw new Error('fetch() is not implemented');
    };
  }

  if (typeof $stencilWindow.FetchError === 'function') {
    FetchError = $stencilWindow.FetchError;
  } else {
    FetchError = $stencilWindow.FetchError = class FetchError {
      constructor() {
        throw new Error('FetchError is not implemented');
      }
    };
  }

  if (typeof $stencilWindow.Headers === 'function') {
    Headers = $stencilWindow.Headers;
  } else {
    Headers = $stencilWindow.Headers = class Headers {
      constructor() {
        throw new Error('Headers is not implemented');
      }
    };
  }

  if (typeof $stencilWindow.Request === 'function') {
    Request = $stencilWindow.Request;
  } else {
    Request = $stencilWindow.Request = class Request {
      constructor() {
        throw new Error('Request is not implemented');
      }
    };
  }

  if (typeof $stencilWindow.Response === 'function') {
    Response = $stencilWindow.Response;
  } else {
    Response = $stencilWindow.Response = class Response {
      constructor() {
        throw new Error('Response is not implemented');
      }
    };
  }

  function hydrateAppClosure($stencilWindow) {
    const window = $stencilWindow;
    const document = $stencilWindow.document;
    /*hydrateAppClosure start*/

    const NAMESPACE = 'app';
    const BUILD = /* app */ {
      allRenderFn: false,
      appendChildSlotFix: false,
      asyncLoading: true,
      attachStyles: true,
      cloneNodeFix: false,
      cmpDidLoad: true,
      cmpDidRender: true,
      cmpDidUnload: false,
      cmpDidUpdate: true,
      cmpShouldUpdate: false,
      cmpWillLoad: true,
      cmpWillRender: true,
      cmpWillUpdate: false,
      connectedCallback: true,
      constructableCSS: false,
      cssAnnotations: true,
      cssVarShim: false,
      devTools: false,
      disconnectedCallback: true,
      dynamicImportShim: false,
      element: false,
      event: true,
      hasRenderFn: true,
      hostListener: true,
      hostListenerTarget: true,
      hostListenerTargetBody: true,
      hostListenerTargetDocument: true,
      hostListenerTargetParent: false,
      hostListenerTargetWindow: true,
      hotModuleReplacement: false,
      hydrateClientSide: true,
      hydrateServerSide: true,
      hydratedAttribute: false,
      hydratedClass: true,
      isDebug: false,
      isDev: false,
      isTesting: false,
      lazyLoad: true,
      lifecycle: true,
      lifecycleDOMEvents: false,
      member: true,
      method: true,
      mode: true,
      observeAttribute: true,
      profile: false,
      prop: true,
      propBoolean: true,
      propMutable: true,
      propNumber: true,
      propString: true,
      reflect: true,
      safari10: false,
      scoped: true,
      scriptDataOpts: false,
      shadowDelegatesFocus: true,
      shadowDom: true,
      shadowDomShim: true,
      slot: true,
      slotChildNodesFix: false,
      slotRelocation: true,
      state: true,
      style: true,
      svg: true,
      taskQueue: true,
      updatable: true,
      vdomAttribute: true,
      vdomClass: true,
      vdomFunctional: true,
      vdomKey: true,
      vdomListener: true,
      vdomPropOrAttr: true,
      vdomRef: true,
      vdomRender: true,
      vdomStyle: true,
      vdomText: true,
      vdomXlink: true,
      watchCallback: true,
    };

    const getPlatforms = win => setupPlatforms(win);
    const isPlatform = (winOrPlatform, platform) => {
      if (typeof winOrPlatform === 'string') {
        platform = winOrPlatform;
        winOrPlatform = undefined;
      }
      return getPlatforms(winOrPlatform).includes(platform);
    };
    const setupPlatforms = (win = window) => {
      if (typeof win === 'undefined') {
        return [];
      }
      win.Ionic = win.Ionic || {};
      let platforms = win.Ionic.platforms;
      if (platforms == null) {
        platforms = win.Ionic.platforms = detectPlatforms(win);
        platforms.forEach(p => win.document.documentElement.classList.add(`plt-${p}`));
      }
      return platforms;
    };
    const detectPlatforms = win => Object.keys(PLATFORMS_MAP).filter(p => PLATFORMS_MAP[p](win));
    const isMobileWeb = win => isMobile(win) && !isHybrid(win);
    const isIpad = win => {
      // iOS 12 and below
      if (testUserAgent(win, /iPad/i)) {
        return true;
      }
      // iOS 13+
      if (testUserAgent(win, /Macintosh/i) && isMobile(win)) {
        return true;
      }
      return false;
    };
    const isIphone = win => testUserAgent(win, /iPhone/i);
    const isIOS = win => testUserAgent(win, /iPhone|iPod/i) || isIpad(win);
    const isAndroid = win => testUserAgent(win, /android|sink/i);
    const isAndroidTablet = win => {
      return isAndroid(win) && !testUserAgent(win, /mobile/i);
    };
    const isPhablet = win => {
      const width = win.innerWidth;
      const height = win.innerHeight;
      const smallest = Math.min(width, height);
      const largest = Math.max(width, height);
      return smallest > 390 && smallest < 520 && largest > 620 && largest < 800;
    };
    const isTablet = win => {
      const width = win.innerWidth;
      const height = win.innerHeight;
      const smallest = Math.min(width, height);
      const largest = Math.max(width, height);
      return isIpad(win) || isAndroidTablet(win) || (smallest > 460 && smallest < 820 && largest > 780 && largest < 1400);
    };
    const isMobile = win => matchMedia(win, '(any-pointer:coarse)');
    const isDesktop = win => !isMobile(win);
    const isHybrid = win => isCordova(win) || isCapacitorNative(win);
    const isCordova = win => !!(win['cordova'] || win['phonegap'] || win['PhoneGap']);
    const isCapacitorNative = win => {
      const capacitor = win['Capacitor'];
      return !!(capacitor && capacitor.isNative);
    };
    const isElectron = win => testUserAgent(win, /electron/i);
    const isPWA = win => !!(win.matchMedia('(display-mode: standalone)').matches || win.navigator.standalone);
    const testUserAgent = (win, expr) => expr.test(win.navigator.userAgent);
    const matchMedia = (win, query) => win.matchMedia(query).matches;
    const PLATFORMS_MAP = {
      ipad: isIpad,
      iphone: isIphone,
      ios: isIOS,
      android: isAndroid,
      phablet: isPhablet,
      tablet: isTablet,
      cordova: isCordova,
      capacitor: isCapacitorNative,
      electron: isElectron,
      pwa: isPWA,
      mobile: isMobile,
      mobileweb: isMobileWeb,
      desktop: isDesktop,
      hybrid: isHybrid,
    };

    class Config {
      constructor() {
        this.m = new Map();
      }
      reset(configObj) {
        this.m = new Map(Object.entries(configObj));
      }
      get(key, fallback) {
        const value = this.m.get(key);
        return value !== undefined ? value : fallback;
      }
      getBoolean(key, fallback = false) {
        const val = this.m.get(key);
        if (val === undefined) {
          return fallback;
        }
        if (typeof val === 'string') {
          return val === 'true';
        }
        return !!val;
      }
      getNumber(key, fallback) {
        const val = parseFloat(this.m.get(key));
        return isNaN(val) ? (fallback !== undefined ? fallback : NaN) : val;
      }
      set(key, value) {
        this.m.set(key, value);
      }
    }
    const config$2 = /*@__PURE__*/ new Config();
    const configFromSession = win => {
      try {
        const configStr = win.sessionStorage.getItem(IONIC_SESSION_KEY);
        return configStr !== null ? JSON.parse(configStr) : {};
      } catch (e) {
        return {};
      }
    };
    const saveConfig = (win, c) => {
      try {
        win.sessionStorage.setItem(IONIC_SESSION_KEY, JSON.stringify(c));
      } catch (e) {
        return;
      }
    };
    const configFromURL = win => {
      const configObj = {};
      win.location.search
        .slice(1)
        .split('&')
        .map(entry => entry.split('='))
        .map(([key, value]) => [decodeURIComponent(key), decodeURIComponent(value)])
        .filter(([key]) => startsWith(key, IONIC_PREFIX))
        .map(([key, value]) => [key.slice(IONIC_PREFIX.length), value])
        .forEach(([key, value]) => {
          configObj[key] = value;
        });
      return configObj;
    };
    const startsWith = (input, search) => {
      return input.substr(0, search.length) === search;
    };
    const IONIC_PREFIX = 'ionic:';
    const IONIC_SESSION_KEY = 'ionic-persist-config';

    let defaultMode;
    const getIonMode$1 = ref => {
      return (ref && getMode(ref)) || defaultMode;
    };
    const initialize = (userConfig = {}) => {
      if (typeof window === 'undefined') {
        return;
      }
      const doc = window.document;
      const win = window;
      const Ionic = (win.Ionic = win.Ionic || {});
      // Setup platforms
      setupPlatforms(win);
      // create the Ionic.config from raw config object (if it exists)
      // and convert Ionic.config into a ConfigApi that has a get() fn
      const configObj = Object.assign(
        Object.assign(Object.assign(Object.assign(Object.assign({}, configFromSession(win)), { persistConfig: false }), Ionic.config), configFromURL(win)),
        userConfig,
      );
      config$2.reset(configObj);
      if (config$2.getBoolean('persistConfig')) {
        saveConfig(win, configObj);
      }
      // first see if the mode was set as an attribute on <html>
      // which could have been set by the user, or by pre-rendering
      // otherwise get the mode via config settings, and fallback to md
      Ionic.config = config$2;
      Ionic.mode = defaultMode = config$2.get('mode', doc.documentElement.getAttribute('mode') || (isPlatform(win, 'ios') ? 'ios' : 'md'));
      config$2.set('mode', defaultMode);
      doc.documentElement.setAttribute('mode', defaultMode);
      doc.documentElement.classList.add(defaultMode);
      if (config$2.getBoolean('_testing')) {
        config$2.set('animated', false);
      }
      const isIonicElement = elm => elm.tagName && elm.tagName.startsWith('ION-');
      const isAllowedIonicModeValue = elmMode => ['ios', 'md'].includes(elmMode);
      setMode(elm => {
        while (elm) {
          const elmMode = elm.mode || elm.getAttribute('mode');
          if (elmMode) {
            if (isAllowedIonicModeValue(elmMode)) {
              return elmMode;
            } else if (isIonicElement(elm)) {
              console.warn('Invalid ionic mode: "' + elmMode + '", expected: "ios" or "md"');
            }
          }
          elm = elm.parentElement;
        }
        return defaultMode;
      });
    };

    const globalScripts = () => {
      initialize();
    };

    function componentOnReady$1() {
      return getHostRef(this).$onReadyPromise$;
    }

    function forceUpdate() {}

    function hydrateApp(e, t, o, n, s) {
      function l() {
        if ((global.clearTimeout(p), i.clear(), r.clear(), !h)) {
          h = !0;
          try {
            t.clientHydrateAnnotations && insertVdomAnnotations(e.document, t.staticComponents),
              e.dispatchEvent(new e.Event('DOMContentLoaded')),
              (e.document.createElement = c),
              (e.document.createElementNS = $);
          } catch (e) {
            renderCatchError(t, o, e);
          }
        }
        n(e, t, o, s);
      }
      function a(e) {
        renderCatchError(t, o, e), l();
      }
      const r = new Set(),
        i = new Set(),
        d = new Set(),
        c = e.document.createElement,
        $ = e.document.createElementNS,
        m = Promise.resolve();
      let p,
        h = !1;
      try {
        function u() {
          return g(this);
        }
        function f(e) {
          if (isValidComponent(e, t) && !getHostRef(e)) {
            const t = loadModule({
              $tagName$: e.nodeName.toLowerCase(),
              $flags$: null,
            });
            null != t &&
              null != t.cmpMeta &&
              (i.add(e),
              (e.connectedCallback = u),
              registerHost(e, t.cmpMeta),
              (function o(e, t) {
                if (
                  ('function' != typeof e.componentOnReady && (e.componentOnReady = componentOnReady$1),
                  'function' != typeof e.forceUpdate && (e.forceUpdate = forceUpdate),
                  1 & t.$flags$ && (e.shadowRoot = e),
                  null != t.$members$)
                ) {
                  const o = getHostRef(e);
                  Object.entries(t.$members$).forEach(([n, s]) => {
                    const l = s[0];
                    if (31 & l) {
                      const a = s[1] || n,
                        r = e.getAttribute(a);
                      if (null != r) {
                        const e = parsePropertyValue(r, l);
                        o.$instanceValues$.set(n, e);
                      }
                      const i = e[n];
                      void 0 !== i && (o.$instanceValues$.set(n, i), delete e[n]),
                        Object.defineProperty(e, n, {
                          get() {
                            return getValue(this, n);
                          },
                          set(e) {
                            setValue(this, n, e, t);
                          },
                          configurable: !0,
                          enumerable: !0,
                        });
                    } else
                      64 & l &&
                        Object.defineProperty(e, n, {
                          value() {
                            const e = getHostRef(this),
                              t = arguments;
                            return e.$onInstancePromise$.then(() => e.$lazyInstance$[n].apply(e.$lazyInstance$, t)).catch(consoleError);
                          },
                        });
                  });
                }
              })(e, t.cmpMeta));
          }
        }
        function g(n) {
          return (
            i.delete(n),
            isValidComponent(n, t) && o.hydratedCount < t.maxHydrateCount && !r.has(n) && shouldHydrate(n)
              ? (r.add(n),
                (async function s(e, t, o, n, l) {
                  o = o.toLowerCase();
                  const a = loadModule({
                    $tagName$: o,
                    $flags$: null,
                  });
                  if (null != a && null != a.cmpMeta) {
                    l.add(n);
                    try {
                      connectedCallback(n), await n.componentOnReady(), t.hydratedCount++;
                      const e = getHostRef(n),
                        s = e.$modeName$ ? e.$modeName$ : '$';
                      t.components.some(e => e.tag === o && e.mode === s) ||
                        t.components.push({
                          tag: o,
                          mode: s,
                          count: 0,
                          depth: -1,
                        });
                    } catch (t) {
                      e.console.error(t);
                    }
                    l.delete(n);
                  }
                })(e, o, n.nodeName, n, d))
              : m
          );
        }
        (e.document.createElement = function t(o) {
          const n = c.call(e.document, o);
          return f(n), n;
        }),
          (e.document.createElementNS = function t(o, n) {
            const s = $.call(e.document, o, n);
            return f(s), s;
          }),
          (p = global.setTimeout(function L() {
            a(
              `Hydrate exceeded timeout${(function e(t) {
                return Array.from(t).map(waitingOnElementMsg);
              })(d)}`,
            );
          }, t.timeout)),
          (plt.$resourcesUrl$ = new URL(t.resourcesUrl || './', doc$1.baseURI).href),
          globalScripts(),
          (function e(t) {
            if (null != t && 1 === t.nodeType) {
              f(t);
              const o = t.children;
              for (let t = 0, n = o.length; t < n; t++) e(o[t]);
            }
          })(e.document.body),
          (function e() {
            const t = Array.from(i).filter(e => e.parentElement);
            return t.length > 0 ? Promise.all(t.map(g)).then(e) : m;
          })()
            .then(l)
            .catch(a);
      } catch (e) {
        a(e);
      }
    }

    function isValidComponent(e, t) {
      if (null != e && 1 === e.nodeType) {
        const o = e.nodeName;
        if ('string' == typeof o && o.includes('-')) return !t.excludeComponents.includes(o.toLowerCase());
      }
      return !1;
    }

    function shouldHydrate(e) {
      if (9 === e.nodeType) return !0;
      if (NO_HYDRATE_TAGS.has(e.nodeName)) return !1;
      if (e.hasAttribute('no-prerender')) return !1;
      const t = e.parentNode;
      return null == t || shouldHydrate(t);
    }

    function renderCatchError(e, t, o) {
      const n = {
        level: 'error',
        type: 'build',
        header: 'Hydrate Error',
        messageText: '',
        relFilePath: null,
        absFilePath: null,
        lines: [],
      };
      if (e.url)
        try {
          const t = new URL(e.url);
          '/' !== t.pathname && (n.header += ': ' + t.pathname);
        } catch (e) {}
      null != o && (null != o.stack ? (n.messageText = o.stack.toString()) : null != o.message ? (n.messageText = o.message.toString()) : (n.messageText = o.toString())),
        t.diagnostics.push(n);
    }

    function printTag(e) {
      let t = `<${e.nodeName.toLowerCase()}`;
      if (Array.isArray(e.attributes))
        for (let o = 0; o < e.attributes.length; o++) {
          const n = e.attributes[o];
          (t += ` ${n.name}`), '' !== n.value && (t += `="${n.value}"`);
        }
      return (t += '>'), t;
    }

    function waitingOnElementMsg(e) {
      let t = '';
      if (e) {
        const o = [];
        t = ' - waiting on:';
        let n = e;
        for (; n && 9 !== n.nodeType && 'BODY' !== n.nodeName; ) o.unshift(printTag(n)), (n = n.parentElement);
        let s = '';
        for (const e of o) (s += '  '), (t += `\n${s}${e}`);
      }
      return t;
    }

    const addHostEventListeners = (e, t, o, n) => {
        o &&
          o.map(([o, n, s]) => {
            const l = getHostListenerTarget(e, o),
              a = hostListenerProxy(t, s),
              r = hostListenerOpts(o);
            plt.ael(l, n, a, r), (t.$rmListeners$ = t.$rmListeners$ || []).push(() => plt.rel(l, n, a, r));
          });
      },
      hostListenerProxy = (e, t) => o => {
        try {
          256 & e.$flags$ ? e.$lazyInstance$[t](o) : (e.$queuedListeners$ = e.$queuedListeners$ || []).push([t, o]);
        } catch (e) {
          consoleError(e);
        }
      },
      getHostListenerTarget = (e, t) => (4 & t ? doc$1 : 8 & t ? win$2 : 16 & t ? doc$1.body : e),
      hostListenerOpts = e => 0 != (2 & e),
      XLINK_NS = 'http://www.w3.org/1999/xlink';

    const createTime = (e, t = '') => {
        return () => {};
      },
      rootAppliedStyles = new WeakMap(),
      registerStyle = (e, t, o) => {
        let n = styles$2.get(e);
        (n = t), styles$2.set(e, n);
      },
      addStyle = (e, t, o, n) => {
        let s = getScopeId(t, o),
          l = styles$2.get(s);
        if (((e = 11 === e.nodeType ? e : doc$1), l))
          if ('string' == typeof l) {
            e = e.head || e;
            let o,
              a = rootAppliedStyles.get(e);
            if ((a || rootAppliedStyles.set(e, (a = new Set())), !a.has(s))) {
              if (e.host && (o = e.querySelector(`[sty-id="${s}"]`))) o.innerHTML = l;
              else {
                (o = doc$1.createElement('style')), (o.innerHTML = l);
                o.setAttribute('sty-id', s), e.insertBefore(o, e.querySelector('link'));
              }
              a && a.add(s);
            }
          }
        return s;
      },
      attachStyles = e => {
        const t = e.$cmpMeta$,
          o = e.$hostElement$,
          n = t.$flags$,
          s = createTime('attachStyles', t.$tagName$),
          l = addStyle(o.getRootNode(), t, e.$modeName$);
        10 & n && ((o['s-sc'] = l), o.classList.add(l + '-h'), 2 & n && o.classList.add(l + '-s')), s();
      },
      getScopeId = (e, t) => 'sc-' + (t && 32 & e.$flags$ ? e.$tagName$ + '-' + t : e.$tagName$),
      computeMode = e => modeResolutionChain.map(t => t(e)).find(e => !!e),
      setMode = e => modeResolutionChain.push(e),
      getMode = e => getHostRef(e).$modeName$,
      EMPTY_OBJ = {},
      isComplexType = e => 'object' == (e = typeof e) || 'function' === e,
      isPromise$1 = e => !!e && ('object' == typeof e || 'function' == typeof e) && 'function' == typeof e.then,
      h = (e, t, ...o) => {
        let n = null,
          s = null,
          l = null,
          a = !1,
          r = !1,
          i = [];
        const d = t => {
          for (let o = 0; o < t.length; o++)
            (n = t[o]),
              Array.isArray(n)
                ? d(n)
                : null != n &&
                  'boolean' != typeof n &&
                  ((a = 'function' != typeof e && !isComplexType(n)) ? (n = String(n)) : BUILD.isDev,
                  a && r ? (i[i.length - 1].$text$ += n) : i.push(a ? newVNode(null, n) : n),
                  (r = a));
        };
        if ((d(o), t && (t.key && (s = t.key), t.name && (l = t.name), BUILD.vdomClass))) {
          const e = t.className || t.class;
          e &&
            (t.class =
              'object' != typeof e
                ? e
                : Object.keys(e)
                    .filter(t => e[t])
                    .join(' '));
        }
        if ('function' == typeof e) return e(null === t ? {} : t, i, vdomFnUtils);
        const c = newVNode(e, null);
        return (c.$attrs$ = t), i.length > 0 && (c.$children$ = i), (c.$key$ = s), (c.$name$ = l), c;
      },
      newVNode = (e, t) => {
        const o = {
          $flags$: 0,
          $tag$: e,
          $text$: t,
          $elm$: null,
          $children$: null,
        };
        return (o.$attrs$ = null), (o.$key$ = null), (o.$name$ = null), o;
      },
      Host = {},
      isHost = e => e && e.$tag$ === Host,
      vdomFnUtils = {
        forEach: (e, t) => e.map(convertToPublic).forEach(t),
        map: (e, t) => e.map(convertToPublic).map(t).map(convertToPrivate),
      },
      convertToPublic = e => ({
        vattrs: e.$attrs$,
        vchildren: e.$children$,
        vkey: e.$key$,
        vname: e.$name$,
        vtag: e.$tag$,
        vtext: e.$text$,
      }),
      convertToPrivate = e => {
        if ('function' == typeof e.vtag) {
          const t = {
            ...e.vattrs,
          };
          return e.vkey && (t.key = e.vkey), e.vname && (t.name = e.vname), h(e.vtag, t, ...(e.vchildren || []));
        }
        const t = newVNode(e.vtag, e.vtext);
        return (t.$attrs$ = e.vattrs), (t.$children$ = e.vchildren), (t.$key$ = e.vkey), (t.$name$ = e.vname), t;
      },
      setAccessor = (e, t, o, n, s, l) => {
        if (o !== n) {
          let a = isMemberInElement(e, t),
            r = t.toLowerCase();
          if ('class' === t) {
            const t = e.classList,
              s = parseClassList(o),
              l = parseClassList(n);
            t.remove(...s.filter(e => e && !l.includes(e))), t.add(...l.filter(e => e && !s.includes(e)));
          } else if ('style' === t) {
            for (const t in o) (n && null != n[t]) || (e.style[t] = '');
            for (const t in n) (o && n[t] === o[t]) || (e.style[t] = n[t]);
          } else if ('key' === t);
          else if ('ref' === t) n && n(e);
          else if (a || 'o' !== t[0] || 'n' !== t[1]) {
            {
              const i = isComplexType(n);
              if ((a || (i && null !== n)) && !s)
                try {
                  if (e.tagName.includes('-')) e[t] = n;
                  else {
                    let s = null == n ? '' : n;
                    'list' === t ? (a = !1) : (null != o && e[t] == s) || (e[t] = s);
                  }
                } catch (e) {}
              let d = !1;
              r !== (r = r.replace(/^xlink\:?/, '')) && ((t = r), (d = !0)),
                null == n || !1 === n
                  ? (!1 === n && '' !== e.getAttribute(t)) || (d ? e.removeAttributeNS(XLINK_NS, t) : e.removeAttribute(t))
                  : (!a || 4 & l || s) && !i && ((n = !0 === n ? '' : n), d ? e.setAttributeNS(XLINK_NS, t, n) : e.setAttribute(t, n));
            }
          } else (t = '-' === t[2] ? t.slice(3) : isMemberInElement(win$2, r) ? r.slice(2) : r[2] + t.slice(3)), o && plt.rel(e, t, o, !1), n && plt.ael(e, t, n, !1);
        }
      },
      parseClassListRegex = /\s/,
      parseClassList = e => (e ? e.split(parseClassListRegex) : []),
      updateElement = (e, t, o, n) => {
        const s = 11 === t.$elm$.nodeType && t.$elm$.host ? t.$elm$.host : t.$elm$,
          l = (e && e.$attrs$) || EMPTY_OBJ,
          a = t.$attrs$ || EMPTY_OBJ;
        for (n in l) n in a || setAccessor(s, n, l[n], void 0, o, t.$flags$);
        for (n in a) setAccessor(s, n, l[n], a[n], o, t.$flags$);
      };

    let scopeId,
      contentRef,
      hostTagName,
      useNativeShadowDom = !1,
      checkSlotFallbackVisibility = !1,
      checkSlotRelocate = !1,
      isSvgMode = !1;

    const createElm = (e, t, o, n) => {
        let s,
          l,
          a,
          r = t.$children$[o],
          i = 0;
        if (
          (!useNativeShadowDom && ((checkSlotRelocate = !0), 'slot' === r.$tag$ && (scopeId && n.classList.add(scopeId + '-s'), (r.$flags$ |= r.$children$ ? 2 : 1))),
          null !== r.$text$)
        )
          s = r.$elm$ = doc$1.createTextNode(r.$text$);
        else if (1 & r.$flags$) s = r.$elm$ = slotReferenceDebugNode(r);
        else {
          if (
            (!isSvgMode && (isSvgMode = 'svg' === r.$tag$),
            (s = r.$elm$ = doc$1.createElementNS(isSvgMode ? 'http://www.w3.org/2000/svg' : 'http://www.w3.org/1999/xhtml', 2 & r.$flags$ ? 'slot-fb' : r.$tag$)),
            isSvgMode && 'foreignObject' === r.$tag$ && (isSvgMode = !1),
            updateElement(null, r, isSvgMode),
            null != scopeId && s['s-si'] !== scopeId && s.classList.add((s['s-si'] = scopeId)),
            r.$children$)
          )
            for (i = 0; i < r.$children$.length; ++i) (l = createElm(e, r, i, s)), l && s.appendChild(l);
          'svg' === r.$tag$ ? (isSvgMode = !1) : 'foreignObject' === s.tagName && (isSvgMode = !0);
        }
        return (
          ((s['s-hn'] = hostTagName),
          3 & r.$flags$ &&
            ((s['s-sr'] = !0),
            (s['s-cr'] = contentRef),
            (s['s-sn'] = r.$name$ || ''),
            (a = e && e.$children$ && e.$children$[o]),
            a && a.$tag$ === r.$tag$ && e.$elm$ && putBackInOriginalLocation(e.$elm$, !1))),
          s
        );
      },
      putBackInOriginalLocation = (e, t) => {
        plt.$flags$ |= 1;
        const o = e.childNodes;
        for (let e = o.length - 1; e >= 0; e--) {
          const n = o[e];
          n['s-hn'] !== hostTagName && n['s-ol'] && (parentReferenceNode(n).insertBefore(n, referenceNode(n)), n['s-ol'].remove(), (n['s-ol'] = void 0), (checkSlotRelocate = !0)),
            t && putBackInOriginalLocation(n, t);
        }
        plt.$flags$ &= -2;
      },
      addVnodes = (e, t, o, n, s, l) => {
        let a,
          r = (e['s-cr'] && e['s-cr'].parentNode) || e;
        for (r.shadowRoot && r.tagName === hostTagName && (r = r.shadowRoot); s <= l; ++s)
          n[s] && ((a = createElm(null, o, s, e)), a && ((n[s].$elm$ = a), r.insertBefore(a, referenceNode(t))));
      },
      removeVnodes = (e, t, o, n, s) => {
        for (; t <= o; ++t)
          (n = e[t]) && ((s = n.$elm$), callNodeRefs(n), ((checkSlotFallbackVisibility = !0), s['s-ol'] ? s['s-ol'].remove() : putBackInOriginalLocation(s, !0)), s.remove());
      },
      isSameVnode = (e, t) => e.$tag$ === t.$tag$ && ('slot' === e.$tag$ ? e.$name$ === t.$name$ : e.$key$ === t.$key$),
      referenceNode = e => (e && e['s-ol']) || e,
      parentReferenceNode = e => (e['s-ol'] ? e['s-ol'] : e).parentNode,
      patch = (e, t) => {
        const o = (t.$elm$ = e.$elm$),
          n = e.$children$,
          s = t.$children$,
          l = t.$tag$,
          a = t.$text$;
        let r;
        null !== a
          ? (r = o['s-cr'])
            ? (r.parentNode.textContent = a)
            : e.$text$ !== a && (o.data = a)
          : ((isSvgMode = 'svg' === l || ('foreignObject' !== l && isSvgMode)),
            'slot' === l || updateElement(e, t, isSvgMode),
            null !== n && null !== s
              ? ((e, t, o, n) => {
                  let s,
                    l,
                    a = 0,
                    r = 0,
                    i = 0,
                    d = 0,
                    c = t.length - 1,
                    $ = t[0],
                    m = t[c],
                    p = n.length - 1,
                    h = n[0],
                    u = n[p];
                  for (; a <= c && r <= p; )
                    if (null == $) $ = t[++a];
                    else if (null == m) m = t[--c];
                    else if (null == h) h = n[++r];
                    else if (null == u) u = n[--p];
                    else if (isSameVnode($, h)) patch($, h), ($ = t[++a]), (h = n[++r]);
                    else if (isSameVnode(m, u)) patch(m, u), (m = t[--c]), (u = n[--p]);
                    else if (isSameVnode($, u))
                      ('slot' !== $.$tag$ && 'slot' !== u.$tag$) || putBackInOriginalLocation($.$elm$.parentNode, !1),
                        patch($, u),
                        e.insertBefore($.$elm$, m.$elm$.nextSibling),
                        ($ = t[++a]),
                        (u = n[--p]);
                    else if (isSameVnode(m, h))
                      ('slot' !== $.$tag$ && 'slot' !== u.$tag$) || putBackInOriginalLocation(m.$elm$.parentNode, !1),
                        patch(m, h),
                        e.insertBefore(m.$elm$, $.$elm$),
                        (m = t[--c]),
                        (h = n[++r]);
                    else {
                      if (((i = -1), BUILD.vdomKey))
                        for (d = a; d <= c; ++d)
                          if (t[d] && null !== t[d].$key$ && t[d].$key$ === h.$key$) {
                            i = d;
                            break;
                          }
                      i >= 0
                        ? ((l = t[i]), l.$tag$ !== h.$tag$ ? (s = createElm(t && t[r], o, i, e)) : (patch(l, h), (t[i] = void 0), (s = l.$elm$)), (h = n[++r]))
                        : ((s = createElm(t && t[r], o, r, e)), (h = n[++r])),
                        s && parentReferenceNode($.$elm$).insertBefore(s, referenceNode($.$elm$));
                    }
                  a > c ? addVnodes(e, null == n[p + 1] ? null : n[p + 1].$elm$, o, n, r, p) : r > p && removeVnodes(t, a, c);
                })(o, n, t, s)
              : null !== s
              ? (null !== e.$text$ && (o.textContent = ''), addVnodes(o, null, t, s, 0, s.length - 1))
              : null !== n && removeVnodes(n, 0, n.length - 1),
            isSvgMode && 'svg' === l && (isSvgMode = !1));
      },
      updateFallbackSlotVisibility = e => {
        let t,
          o,
          n,
          s,
          l,
          a,
          r = e.childNodes;
        for (o = 0, n = r.length; o < n; o++)
          if (((t = r[o]), 1 === t.nodeType)) {
            if (t['s-sr'])
              for (l = t['s-sn'], t.hidden = !1, s = 0; s < n; s++)
                if (((a = r[s].nodeType), r[s]['s-hn'] !== t['s-hn'] || '' !== l)) {
                  if (1 === a && l === r[s].getAttribute('slot')) {
                    t.hidden = !0;
                    break;
                  }
                } else if (1 === a || (3 === a && '' !== r[s].textContent.trim())) {
                  t.hidden = !0;
                  break;
                }
            updateFallbackSlotVisibility(t);
          }
      },
      relocateNodes = [],
      relocateSlotContent = e => {
        let t,
          o,
          n,
          s,
          l,
          a,
          r = 0,
          i = e.childNodes,
          d = i.length;
        for (; r < d; r++) {
          if (((t = i[r]), t['s-sr'] && (o = t['s-cr']) && o.parentNode))
            for (n = o.parentNode.childNodes, s = t['s-sn'], a = n.length - 1; a >= 0; a--)
              (o = n[a]),
                o['s-cn'] ||
                  o['s-nr'] ||
                  o['s-hn'] === t['s-hn'] ||
                  (isNodeLocatedInSlot(o, s)
                    ? ((l = relocateNodes.find(e => e.$nodeToRelocate$ === o)),
                      (checkSlotFallbackVisibility = !0),
                      (o['s-sn'] = o['s-sn'] || s),
                      l
                        ? (l.$slotRefNode$ = t)
                        : relocateNodes.push({
                            $slotRefNode$: t,
                            $nodeToRelocate$: o,
                          }),
                      o['s-sr'] &&
                        relocateNodes.map(e => {
                          isNodeLocatedInSlot(e.$nodeToRelocate$, o['s-sn']) &&
                            ((l = relocateNodes.find(e => e.$nodeToRelocate$ === o)), l && !e.$slotRefNode$ && (e.$slotRefNode$ = l.$slotRefNode$));
                        }))
                    : relocateNodes.some(e => e.$nodeToRelocate$ === o) ||
                      relocateNodes.push({
                        $nodeToRelocate$: o,
                      }));
          1 === t.nodeType && relocateSlotContent(t);
        }
      },
      isNodeLocatedInSlot = (e, t) => (1 === e.nodeType ? (null === e.getAttribute('slot') && '' === t) || e.getAttribute('slot') === t : e['s-sn'] === t || '' === t),
      callNodeRefs = e => {
        e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(callNodeRefs);
      },
      renderVdom = (e, t) => {
        const o = e.$hostElement$,
          n = e.$cmpMeta$,
          s = e.$vnode$ || newVNode(null, null),
          l = isHost(t) ? t : h(null, null, t);
        if (((hostTagName = o.tagName), BUILD.isDev));
        if (
          (n.$attrsToReflect$ && ((l.$attrs$ = l.$attrs$ || {}), n.$attrsToReflect$.map(([e, t]) => (l.$attrs$[t] = o[e]))),
          (l.$tag$ = null),
          (l.$flags$ |= 4),
          (e.$vnode$ = l),
          (l.$elm$ = s.$elm$ = o.shadowRoot || o),
          (scopeId = o['s-sc']),
          ((contentRef = o['s-cr']), (useNativeShadowDom = supportsShadow), (checkSlotFallbackVisibility = !1)),
          patch(s, l),
          BUILD.slotRelocation)
        ) {
          if (((plt.$flags$ |= 1), checkSlotRelocate)) {
            let e, t, o, n, s, a;
            relocateSlotContent(l.$elm$);
            let r = 0;
            for (; r < relocateNodes.length; r++)
              (e = relocateNodes[r]), (t = e.$nodeToRelocate$), t['s-ol'] || ((o = originalLocationDebugNode(t)), (o['s-nr'] = t), t.parentNode.insertBefore((t['s-ol'] = o), t));
            for (r = 0; r < relocateNodes.length; r++)
              if (((e = relocateNodes[r]), (t = e.$nodeToRelocate$), e.$slotRefNode$)) {
                for (n = e.$slotRefNode$.parentNode, s = e.$slotRefNode$.nextSibling, o = t['s-ol']; (o = o.previousSibling); )
                  if (((a = o['s-nr']), a && a['s-sn'] === t['s-sn'] && n === a.parentNode && ((a = a.nextSibling), !a || !a['s-nr']))) {
                    s = a;
                    break;
                  }
                ((!s && n !== t.parentNode) || t.nextSibling !== s) && t !== s && (!t['s-hn'] && t['s-ol'] && (t['s-hn'] = t['s-ol'].parentNode.nodeName), n.insertBefore(t, s));
              } else 1 === t.nodeType && (t.hidden = !0);
          }
          checkSlotFallbackVisibility && updateFallbackSlotVisibility(l.$elm$), (plt.$flags$ &= -2), (relocateNodes.length = 0);
        }
      },
      slotReferenceDebugNode = e => doc$1.createComment(`<slot${e.$name$ ? ' name="' + e.$name$ + '"' : ''}> (host=${hostTagName.toLowerCase()})`),
      originalLocationDebugNode = e => doc$1.createComment('org-location for ' + (e.localName ? `<${e.localName}> (host=${e['s-hn']})` : `[${e.textContent}]`)),
      getElement = e => getHostRef(e).$hostElement$,
      createEvent = (e, t, o) => {
        const n = getElement(e);
        return {
          emit: e =>
            emitEvent(n, t, {
              bubbles: !!(4 & o),
              composed: !!(2 & o),
              cancelable: !!(1 & o),
              detail: e,
            }),
        };
      },
      emitEvent = (e, t, o) => {
        const n = plt.ce(t, o);
        return e.dispatchEvent(n), n;
      },
      attachToAncestor = (e, t) => {
        t && !e.$onRenderResolve$ && t['s-p'] && t['s-p'].push(new Promise(t => (e.$onRenderResolve$ = t)));
      },
      scheduleUpdate = (e, t) => {
        if (((e.$flags$ |= 16), 4 & e.$flags$)) return void (e.$flags$ |= 512);
        attachToAncestor(e, e.$ancestorComponent$);
        const o = () => dispatchHooks(e, t);
        return writeTask(o);
      },
      dispatchHooks = (e, t) => {
        const n = createTime('scheduleUpdate', e.$cmpMeta$.$tagName$),
          s = e.$lazyInstance$;
        let l;
        return (
          t
            ? (((e.$flags$ |= 256), e.$queuedListeners$ && (e.$queuedListeners$.map(([e, t]) => safeCall$1(s, e, t)), (e.$queuedListeners$ = null))),
              (l = safeCall$1(s, 'componentWillLoad')))
            : BUILD.cmpWillUpdate,
          (l = then(l, () => safeCall$1(s, 'componentWillRender'))),
          n(),
          then(l, () => updateComponent(e, s, t))
        );
      },
      updateComponent = async (e, t, o) => {
        const n = e.$hostElement$,
          s = createTime('update', e.$cmpMeta$.$tagName$),
          l = n['s-rc'];
        o && attachStyles(e);
        const a = createTime('render', e.$cmpMeta$.$tagName$);
        if ((await callRender(e, t), BUILD.hydrateServerSide))
          try {
            serverSideConnected(n), o && (1 & e.$cmpMeta$.$flags$ ? (n['s-en'] = '') : 2 & e.$cmpMeta$.$flags$ && (n['s-en'] = 'c'));
          } catch (e) {
            consoleError(e, n);
          }
        if ((l && (l.map(e => e()), (n['s-rc'] = void 0)), a(), s(), BUILD.asyncLoading)) {
          const t = n['s-p'],
            o = () => postUpdateComponent(e);
          0 === t.length ? o() : (Promise.all(t).then(o), (e.$flags$ |= 4), (t.length = 0));
        }
      };

    let renderingRef = null;

    const callRender = (e, t, o) => {
        try {
          if (((renderingRef = t), (t = t.render && t.render()), (e.$flags$ &= -17), (e.$flags$ |= 2), BUILD.hasRenderFn)) {
            return Promise.resolve(t).then(t => renderVdom(e, t));
          }
        } catch (t) {
          consoleError(t, e.$hostElement$);
        }
        return (renderingRef = null), null;
      },
      getRenderingRef = () => renderingRef,
      postUpdateComponent = e => {
        const t = e.$cmpMeta$.$tagName$,
          o = e.$hostElement$,
          n = createTime('postUpdate', t),
          s = e.$lazyInstance$,
          l = e.$ancestorComponent$;
        (safeCall$1(s, 'componentDidRender'), BUILD.isDev),
          64 & e.$flags$
            ? ((safeCall$1(s, 'componentDidUpdate'), BUILD.isDev), n())
            : ((e.$flags$ |= 64), addHydratedFlag(o), (safeCall$1(s, 'componentDidLoad'), BUILD.isDev), n(), (e.$onReadyResolve$(o), l || appDidLoad())),
          e.$onInstanceResolve$(o),
          (e.$onRenderResolve$ && (e.$onRenderResolve$(), (e.$onRenderResolve$ = void 0)), 512 & e.$flags$ && nextTick$1(() => scheduleUpdate(e, !1)), (e.$flags$ &= -517));
      },
      forceUpdate$1 = e => {
        {
          const t = getHostRef(e),
            o = t.$hostElement$.isConnected;
          return o && 2 == (18 & t.$flags$) && scheduleUpdate(t, !1), o;
        }
      },
      appDidLoad = e => {
        addHydratedFlag(doc$1.documentElement),
          nextTick$1(() =>
            emitEvent(win$2, 'appload', {
              detail: {
                namespace: NAMESPACE,
              },
            }),
          ),
          BUILD.profile;
      },
      safeCall$1 = (e, t, o) => {
        if (e && e[t])
          try {
            return e[t](o);
          } catch (e) {
            consoleError(e);
          }
      },
      then = (e, t) => (e && e.then ? e.then(t) : t()),
      addHydratedFlag = e => e.classList.add('hydrated'),
      serverSideConnected = e => {
        const t = e.children;
        if (null != t)
          for (let e = 0, o = t.length; e < o; e++) {
            const o = t[e];
            'function' == typeof o.connectedCallback && o.connectedCallback(), serverSideConnected(o);
          }
      },
      clientHydrate = (e, t, o, n, s, l, a) => {
        let r, i, d, c;
        if (1 === l.nodeType) {
          for (
            r = l.getAttribute('c-id'),
              r &&
                ((i = r.split('.')),
                (i[0] !== a && '0' !== i[0]) ||
                  ((d = {
                    $flags$: 0,
                    $hostId$: i[0],
                    $nodeId$: i[1],
                    $depth$: i[2],
                    $index$: i[3],
                    $tag$: l.tagName.toLowerCase(),
                    $elm$: l,
                    $attrs$: null,
                    $children$: null,
                    $key$: null,
                    $name$: null,
                    $text$: null,
                  }),
                  t.push(d),
                  l.removeAttribute('c-id'),
                  e.$children$ || (e.$children$ = []),
                  (e.$children$[d.$index$] = d),
                  (e = d),
                  n && '0' === d.$depth$ && (n[d.$index$] = d.$elm$))),
              c = l.childNodes.length - 1;
            c >= 0;
            c--
          )
            clientHydrate(e, t, o, n, s, l.childNodes[c], a);
          if (l.shadowRoot) for (c = l.shadowRoot.childNodes.length - 1; c >= 0; c--) clientHydrate(e, t, o, n, s, l.shadowRoot.childNodes[c], a);
        } else if (8 === l.nodeType)
          (i = l.nodeValue.split('.')),
            (i[1] !== a && '0' !== i[1]) ||
              ((r = i[0]),
              (d = {
                $flags$: 0,
                $hostId$: i[1],
                $nodeId$: i[2],
                $depth$: i[3],
                $index$: i[4],
                $elm$: l,
                $attrs$: null,
                $children$: null,
                $key$: null,
                $name$: null,
                $tag$: null,
                $text$: null,
              }),
              't' === r
                ? ((d.$elm$ = l.nextSibling),
                  d.$elm$ &&
                    3 === d.$elm$.nodeType &&
                    ((d.$text$ = d.$elm$.textContent),
                    t.push(d),
                    l.remove(),
                    e.$children$ || (e.$children$ = []),
                    (e.$children$[d.$index$] = d),
                    n && '0' === d.$depth$ && (n[d.$index$] = d.$elm$)))
                : d.$hostId$ === a &&
                  ('s' === r
                    ? ((d.$tag$ = 'slot'),
                      i[5] ? (l['s-sn'] = d.$name$ = i[5]) : (l['s-sn'] = ''),
                      (l['s-sr'] = !0),
                      n &&
                        ((d.$elm$ = doc$1.createElement(d.$tag$)),
                        d.$name$ && d.$elm$.setAttribute('name', d.$name$),
                        l.parentNode.insertBefore(d.$elm$, l),
                        l.remove(),
                        '0' === d.$depth$ && (n[d.$index$] = d.$elm$)),
                      o.push(d),
                      e.$children$ || (e.$children$ = []),
                      (e.$children$[d.$index$] = d))
                    : 'r' === r && (n ? l.remove() : ((s['s-cr'] = l), (l['s-cn'] = !0)))));
        else if (e && 'style' === e.$tag$) {
          const t = newVNode(null, l.textContent);
          (t.$elm$ = l), (t.$index$ = '0'), (e.$children$ = [t]);
        }
      },
      initializeDocumentHydrate = (e, t) => {
        if (1 === e.nodeType) {
          let o = 0;
          for (; o < e.childNodes.length; o++) initializeDocumentHydrate(e.childNodes[o], t);
          if (e.shadowRoot) for (o = 0; o < e.shadowRoot.childNodes.length; o++) initializeDocumentHydrate(e.shadowRoot.childNodes[o], t);
        } else if (8 === e.nodeType) {
          const o = e.nodeValue.split('.');
          'o' === o[0] && (t.set(o[1] + '.' + o[2], e), (e.nodeValue = ''), (e['s-en'] = o[3]));
        }
      },
      parsePropertyValue = (e, t) => (null == e || isComplexType(e) ? e : 4 & t ? 'false' !== e && ('' === e || !!e) : 2 & t ? parseFloat(e) : 1 & t ? String(e) : e),
      getValue = (e, t) => getHostRef(e).$instanceValues$.get(t),
      setValue = (e, t, o, n) => {
        const s = getHostRef(e),
          l = s.$hostElement$,
          a = s.$instanceValues$.get(t),
          r = s.$flags$,
          i = s.$lazyInstance$;
        if (((o = parsePropertyValue(o, n.$members$[t][0])), !((8 & r && void 0 !== a) || o === a) && (s.$instanceValues$.set(t, o), i))) {
          if (n.$watchers$ && 128 & r) {
            const e = n.$watchers$[t];
            e &&
              e.map(e => {
                try {
                  i[e](o, a, t);
                } catch (e) {
                  consoleError(e, l);
                }
              });
          }
          if (2 == (18 & r)) {
            scheduleUpdate(s, !1);
          }
        }
      },
      proxyComponent = (e, t, o) => {
        if (t.$members$) {
          e.watchers && (t.$watchers$ = e.watchers);
          const n = Object.entries(t.$members$),
            s = e.prototype;
          if (
            (n.map(([e, [n]]) => {
              31 & n || (2 & o && 32 & n)
                ? Object.defineProperty(s, e, {
                    get() {
                      return getValue(this, e);
                    },
                    set(s) {
                      setValue(this, e, s, t);
                    },
                    configurable: !0,
                    enumerable: !0,
                  })
                : 1 & o &&
                  64 & n &&
                  Object.defineProperty(s, e, {
                    value(...t) {
                      const o = getHostRef(this);
                      return o.$onInstancePromise$.then(() => o.$lazyInstance$[e](...t));
                    },
                  });
            }),
            1 & o)
          ) {
            const o = new Map();
            (s.attributeChangedCallback = function (e, t, n) {
              plt.jmp(() => {
                const t = o.get(e);
                this.hasOwnProperty(t) && ((n = this[t]), delete this[t]), (this[t] = (null !== n || 'boolean' != typeof this[t]) && n);
              });
            }),
              (e.observedAttributes = n
                .filter(([e, t]) => 15 & t[0])
                .map(([e, n]) => {
                  const s = n[1] || e;
                  return o.set(s, e), 512 & n[0] && t.$attrsToReflect$.push([e, s]), s;
                }));
          }
        }
        return e;
      },
      initializeComponent = async (e, t, o, n, s) => {
        if (0 == (32 & t.$flags$)) {
          {
            if (((t.$flags$ |= 32), (s = loadModule(o)).then)) {
              const e = () => {};
              (s = await s), e();
            }
            !s.isProxied && ((o.$watchers$ = s.watchers), proxyComponent(s, o, 2), (s.isProxied = !0));
            const e = createTime('createInstance', o.$tagName$);
            t.$flags$ |= 8;
            try {
              new s(t);
            } catch (e) {
              consoleError(e);
            }
            (t.$flags$ &= -9), (t.$flags$ |= 128), e(), fireConnectedCallback(t.$lazyInstance$);
          }
          if (s.style) {
            let n = s.style;
            'string' != typeof n && ((n = n[(t.$modeName$ = computeMode(e))]), t.$modeName$ && e.setAttribute('s-mode', t.$modeName$));
            const l = getScopeId(o, t.$modeName$);
            if (!styles$2.has(l)) {
              const e = createTime('registerStyles', o.$tagName$);
              registerStyle(l, n), e();
            }
          }
        }
        const r = t.$ancestorComponent$,
          i = () => scheduleUpdate(t, !0);
        r && r['s-rc'] ? r['s-rc'].push(i) : i();
      },
      fireConnectedCallback = e => {
        safeCall$1(e, 'connectedCallback');
      },
      connectedCallback = e => {
        if (0 == (1 & plt.$flags$)) {
          const t = getHostRef(e),
            o = t.$cmpMeta$,
            n = createTime('connectedCallback', o.$tagName$);
          if (1 & t.$flags$) addHostEventListeners(e, t, o.$listeners$), fireConnectedCallback(t.$lazyInstance$);
          else {
            let n;
            if (((t.$flags$ |= 1), ((n = e.getAttribute('s-id')), n))) {
              ((e, t, o, n) => {
                const s = createTime('hydrateClient', t),
                  l = e.shadowRoot,
                  a = [],
                  r = l ? [] : null,
                  i = (n.$vnode$ = newVNode(t, null));
                plt.$orgLocNodes$ || initializeDocumentHydrate(doc$1.body, (plt.$orgLocNodes$ = new Map())),
                  (e['s-id'] = o),
                  e.removeAttribute('s-id'),
                  clientHydrate(i, a, [], r, e, e, o),
                  a.map(e => {
                    const o = e.$hostId$ + '.' + e.$nodeId$,
                      n = plt.$orgLocNodes$.get(o),
                      s = e.$elm$;
                    n && supportsShadow && '' === n['s-en'] && n.parentNode.insertBefore(s, n.nextSibling),
                      l || ((s['s-hn'] = t), n && ((s['s-ol'] = n), (s['s-ol']['s-nr'] = s))),
                      plt.$orgLocNodes$.delete(o);
                  }),
                  l &&
                    r.map(e => {
                      e && l.appendChild(e);
                    }),
                  s();
              })(e, o.$tagName$, n, t);
            }
            if ((!n && BUILD.hydrateServerSide && setContentReference(e), BUILD.asyncLoading)) {
              let o = e;
              for (; (o = o.parentNode || o.host); )
                if ((1 === o.nodeType && o.hasAttribute('s-id') && o['s-p']) || o['s-p']) {
                  attachToAncestor(t, (t.$ancestorComponent$ = o));
                  break;
                }
            }
            initializeComponent(e, t, o);
          }
          n();
        }
      },
      setContentReference = e => {
        const t = (e['s-cr'] = doc$1.createComment(''));
        (t['s-cn'] = !0), e.insertBefore(t, e.firstChild);
      },
      insertVdomAnnotations = (e, t) => {
        if (null != e) {
          const o = {
              hostIds: 0,
              rootLevelIds: 0,
              staticComponents: new Set(t),
            },
            n = [];
          parseVNodeAnnotations(e, e.body, o, n),
            n.forEach(t => {
              if (null != t) {
                const n = t['s-nr'];
                let s = n['s-host-id'],
                  l = n['s-node-id'],
                  a = `${s}.${l}`;
                if (null == s)
                  if (((s = 0), o.rootLevelIds++, (l = o.rootLevelIds), (a = `${s}.${l}`), 1 === n.nodeType)) n.setAttribute('c-id', a);
                  else if (3 === n.nodeType) {
                    if (0 === s && '' === n.nodeValue.trim()) return void t.remove();
                    const o = e.createComment(a);
                    (o.nodeValue = `t.${a}`), n.parentNode.insertBefore(o, n);
                  }
                let r = `o.${a}`;
                const i = t.parentElement;
                i && ('' === i['s-en'] ? (r += '.') : 'c' === i['s-en'] && (r += '.c')), (t.nodeValue = r);
              }
            });
        }
      },
      parseVNodeAnnotations = (e, t, o, n) => {
        null != t &&
          (null != t['s-nr'] && n.push(t),
          1 === t.nodeType &&
            t.childNodes.forEach(t => {
              const s = getHostRef(t);
              if (null != s && !o.staticComponents.has(t.nodeName.toLowerCase())) {
                const n = {
                  nodeIds: 0,
                };
                insertVNodeAnnotations(e, t, s.$vnode$, o, n);
              }
              parseVNodeAnnotations(e, t, o, n);
            }));
      },
      insertVNodeAnnotations = (e, t, o, n, s) => {
        if (null != o) {
          const l = ++n.hostIds;
          if ((t.setAttribute('s-id', l), null != t['s-cr'] && (t['s-cr'].nodeValue = `r.${l}`), null != o.$children$)) {
            const t = 0;
            o.$children$.forEach((o, n) => {
              insertChildVNodeAnnotations(e, o, s, l, t, n);
            });
          }
          if (t && o && o.$elm$ && !t.hasAttribute('c-id')) {
            const e = t.parentElement;
            if (e && e.childNodes) {
              const n = Array.from(e.childNodes),
                s = n.find(e => 8 === e.nodeType && e['s-sr']);
              if (s) {
                const e = n.indexOf(t) - 1;
                o.$elm$.setAttribute('c-id', `${s['s-host-id']}.${s['s-node-id']}.0.${e}`);
              }
            }
          }
        }
      },
      insertChildVNodeAnnotations = (e, t, o, n, s, l) => {
        const a = t.$elm$;
        if (null == a) return;
        const r = o.nodeIds++,
          i = `${n}.${r}.${s}.${l}`;
        if (((a['s-host-id'] = n), (a['s-node-id'] = r), 1 === a.nodeType)) a.setAttribute('c-id', i);
        else if (3 === a.nodeType) {
          const t = a.parentNode,
            o = t.nodeName;
          if ('STYLE' !== o && 'SCRIPT' !== o) {
            const o = `t.${i}`,
              n = e.createComment(o);
            t.insertBefore(n, a);
          }
        } else if (8 === a.nodeType && a['s-sr']) {
          const e = `s.${i}.${a['s-sn'] || ''}`;
          a.nodeValue = e;
        }
        if (null != t.$children$) {
          const l = s + 1;
          t.$children$.forEach((t, s) => {
            insertChildVNodeAnnotations(e, t, o, n, l, s);
          });
        }
      },
      NO_HYDRATE_TAGS = new Set(['CODE', 'HEAD', 'IFRAME', 'INPUT', 'OBJECT', 'OUTPUT', 'NOSCRIPT', 'PRE', 'SCRIPT', 'SELECT', 'STYLE', 'TEMPLATE', 'TEXTAREA']),
      hAsync = (e, t, ...o) => {
        if (Array.isArray(o) && o.length > 0) {
          const n = o.flat(1 / 0);
          return n.some(isPromise$1)
            ? Promise.all(n)
                .then(o => h(e, t, ...o))
                .catch(o => h(e, t))
            : h(e, t, ...o);
        }
        return h(e, t);
      };

    const cmpModules = new Map(),
      getModule = e => {
        if ('string' == typeof e) {
          e = e.toLowerCase();
          const t = cmpModules.get(e);
          if (null != t) return t[e];
        }
        return null;
      },
      loadModule = (e, t, o) => getModule(e.$tagName$),
      isMemberInElement = (e, t) => {
        if (null != e) {
          if (t in e) return !0;
          const o = getModule(e.nodeName);
          if (null != o) {
            const e = o;
            if (null != e && null != e.cmpMeta && null != e.cmpMeta.$members$) return t in e.cmpMeta.$members$;
          }
        }
        return !1;
      },
      registerComponents = e => {
        for (const t of e) {
          const e = t.cmpMeta.$tagName$;
          cmpModules.set(e, {
            [e]: t,
          });
        }
      },
      win$2 = window,
      doc$1 = win$2.document,
      readTask = e => {
        process.nextTick(() => {
          try {
            e();
          } catch (e) {
            consoleError(e);
          }
        });
      },
      writeTask = e => {
        process.nextTick(() => {
          try {
            e();
          } catch (e) {
            consoleError(e);
          }
        });
      },
      resolved = Promise.resolve(),
      nextTick$1 = e => resolved.then(e),
      defaultConsoleError = e => {
        null != e && console.error(e.stack || e.message || e);
      },
      consoleError = (e, t) => defaultConsoleError(e, t),
      plt = {
        $flags$: 0,
        $resourcesUrl$: '',
        jmp: e => e(),
        raf: e => requestAnimationFrame(e),
        ael: (e, t, o, n) => e.addEventListener(t, o, n),
        rel: (e, t, o, n) => e.removeEventListener(t, o, n),
        ce: (e, t) => new win$2.CustomEvent(e, t),
      },
      supportsShadow = !1,
      hostRefs = new WeakMap(),
      getHostRef = e => hostRefs.get(e),
      registerInstance = (e, t) => hostRefs.set((t.$lazyInstance$ = e), t),
      registerHost = (e, t) => {
        const o = {
          $flags$: 0,
          $cmpMeta$: t,
          $hostElement$: e,
          $instanceValues$: new Map(),
          $renderCount$: 0,
        };
        return (
          (o.$onInstancePromise$ = new Promise(e => (o.$onInstanceResolve$ = e))),
          (o.$onReadyPromise$ = new Promise(e => (o.$onReadyResolve$ = e))),
          (e['s-p'] = []),
          (e['s-rc'] = []),
          addHostEventListeners(e, o, t.$listeners$),
          hostRefs.set(e, o)
        );
      },
      Build = {
        isDev: !1,
        isBrowser: !1,
        isServer: !0,
        isTesting: !1,
      },
      styles$2 = new Map(),
      modeResolutionChain = [];

    const HapticEngine = {
      getEngine() {
        const win = window;
        return win.TapticEngine || (win.Capacitor && win.Capacitor.isPluginAvailable('Haptics') && win.Capacitor.Plugins.Haptics);
      },
      available() {
        return !!this.getEngine();
      },
      isCordova() {
        return !!window.TapticEngine;
      },
      isCapacitor() {
        const win = window;
        return !!win.Capacitor;
      },
      impact(options) {
        const engine = this.getEngine();
        if (!engine) {
          return;
        }
        const style = this.isCapacitor() ? options.style.toUpperCase() : options.style;
        engine.impact({ style });
      },
      notification(options) {
        const engine = this.getEngine();
        if (!engine) {
          return;
        }
        const style = this.isCapacitor() ? options.style.toUpperCase() : options.style;
        engine.notification({ style });
      },
      selection() {
        this.impact({ style: 'light' });
      },
      selectionStart() {
        const engine = this.getEngine();
        if (!engine) {
          return;
        }
        if (this.isCapacitor()) {
          engine.selectionStart();
        } else {
          engine.gestureSelectionStart();
        }
      },
      selectionChanged() {
        const engine = this.getEngine();
        if (!engine) {
          return;
        }
        if (this.isCapacitor()) {
          engine.selectionChanged();
        } else {
          engine.gestureSelectionChanged();
        }
      },
      selectionEnd() {
        const engine = this.getEngine();
        if (!engine) {
          return;
        }
        if (this.isCapacitor()) {
          engine.selectionEnd();
        } else {
          engine.gestureSelectionEnd();
        }
      },
    };
    /**
     * Trigger a selection changed haptic event. Good for one-time events
     * (not for gestures)
     */
    const hapticSelection = () => {
      HapticEngine.selection();
    };
    /**
     * Tell the haptic engine that a gesture for a selection change is starting.
     */
    const hapticSelectionStart = () => {
      HapticEngine.selectionStart();
    };
    /**
     * Tell the haptic engine that a selection changed during a gesture.
     */
    const hapticSelectionChanged = () => {
      HapticEngine.selectionChanged();
    };
    /**
     * Tell the haptic engine we are done with a gesture. This needs to be
     * called lest resources are not properly recycled.
     */
    const hapticSelectionEnd = () => {
      HapticEngine.selectionEnd();
    };
    /**
     * Use this to indicate success/failure/warning to the user.
     * options should be of the type `{ style: 'light' }` (or `medium`/`heavy`)
     */
    const hapticImpact = options => {
      HapticEngine.impact(options);
    };

    class GestureController {
      constructor() {
        this.gestureId = 0;
        this.requestedStart = new Map();
        this.disabledGestures = new Map();
        this.disabledScroll = new Set();
      }
      /**
       * Creates a gesture delegate based on the GestureConfig passed
       */
      createGesture(config) {
        return new GestureDelegate(this, this.newID(), config.name, config.priority || 0, !!config.disableScroll);
      }
      /**
       * Creates a blocker that will block any other gesture events from firing. Set in the ion-gesture component.
       */
      createBlocker(opts = {}) {
        return new BlockerDelegate(this, this.newID(), opts.disable, !!opts.disableScroll);
      }
      start(gestureName, id, priority) {
        if (!this.canStart(gestureName)) {
          this.requestedStart.delete(id);
          return false;
        }
        this.requestedStart.set(id, priority);
        return true;
      }
      capture(gestureName, id, priority) {
        if (!this.start(gestureName, id, priority)) {
          return false;
        }
        const requestedStart = this.requestedStart;
        let maxPriority = -10000;
        requestedStart.forEach(value => {
          maxPriority = Math.max(maxPriority, value);
        });
        if (maxPriority === priority) {
          this.capturedId = id;
          requestedStart.clear();
          const event = new CustomEvent('ionGestureCaptured', { detail: { gestureName } });
          document.dispatchEvent(event);
          return true;
        }
        requestedStart.delete(id);
        return false;
      }
      release(id) {
        this.requestedStart.delete(id);
        if (this.capturedId === id) {
          this.capturedId = undefined;
        }
      }
      disableGesture(gestureName, id) {
        let set = this.disabledGestures.get(gestureName);
        if (set === undefined) {
          set = new Set();
          this.disabledGestures.set(gestureName, set);
        }
        set.add(id);
      }
      enableGesture(gestureName, id) {
        const set = this.disabledGestures.get(gestureName);
        if (set !== undefined) {
          set.delete(id);
        }
      }
      disableScroll(id) {
        this.disabledScroll.add(id);
        if (this.disabledScroll.size === 1) {
          document.body.classList.add(BACKDROP_NO_SCROLL);
        }
      }
      enableScroll(id) {
        this.disabledScroll.delete(id);
        if (this.disabledScroll.size === 0) {
          document.body.classList.remove(BACKDROP_NO_SCROLL);
        }
      }
      canStart(gestureName) {
        if (this.capturedId !== undefined) {
          // a gesture already captured
          return false;
        }
        if (this.isDisabled(gestureName)) {
          return false;
        }
        return true;
      }
      isCaptured() {
        return this.capturedId !== undefined;
      }
      isScrollDisabled() {
        return this.disabledScroll.size > 0;
      }
      isDisabled(gestureName) {
        const disabled = this.disabledGestures.get(gestureName);
        if (disabled && disabled.size > 0) {
          return true;
        }
        return false;
      }
      newID() {
        this.gestureId++;
        return this.gestureId;
      }
    }
    class GestureDelegate {
      constructor(ctrl, id, name, priority, disableScroll) {
        this.id = id;
        this.name = name;
        this.disableScroll = disableScroll;
        this.priority = priority * 1000000 + id;
        this.ctrl = ctrl;
      }
      canStart() {
        if (!this.ctrl) {
          return false;
        }
        return this.ctrl.canStart(this.name);
      }
      start() {
        if (!this.ctrl) {
          return false;
        }
        return this.ctrl.start(this.name, this.id, this.priority);
      }
      capture() {
        if (!this.ctrl) {
          return false;
        }
        const captured = this.ctrl.capture(this.name, this.id, this.priority);
        if (captured && this.disableScroll) {
          this.ctrl.disableScroll(this.id);
        }
        return captured;
      }
      release() {
        if (this.ctrl) {
          this.ctrl.release(this.id);
          if (this.disableScroll) {
            this.ctrl.enableScroll(this.id);
          }
        }
      }
      destroy() {
        this.release();
        this.ctrl = undefined;
      }
    }
    class BlockerDelegate {
      constructor(ctrl, id, disable, disableScroll) {
        this.id = id;
        this.disable = disable;
        this.disableScroll = disableScroll;
        this.ctrl = ctrl;
      }
      block() {
        if (!this.ctrl) {
          return;
        }
        if (this.disable) {
          for (const gesture of this.disable) {
            this.ctrl.disableGesture(gesture, this.id);
          }
        }
        if (this.disableScroll) {
          this.ctrl.disableScroll(this.id);
        }
      }
      unblock() {
        if (!this.ctrl) {
          return;
        }
        if (this.disable) {
          for (const gesture of this.disable) {
            this.ctrl.enableGesture(gesture, this.id);
          }
        }
        if (this.disableScroll) {
          this.ctrl.enableScroll(this.id);
        }
      }
      destroy() {
        this.unblock();
        this.ctrl = undefined;
      }
    }
    const BACKDROP_NO_SCROLL = 'backdrop-no-scroll';
    const GESTURE_CONTROLLER = new GestureController();

    const addEventListener$1 = (el, eventName, callback, opts) => {
      // use event listener options when supported
      // otherwise it's just a boolean for the "capture" arg
      const listenerOpts = supportsPassive(el)
        ? {
            capture: !!opts.capture,
            passive: !!opts.passive,
          }
        : !!opts.capture;
      let add;
      let remove;
      if (el['__zone_symbol__addEventListener']) {
        add = '__zone_symbol__addEventListener';
        remove = '__zone_symbol__removeEventListener';
      } else {
        add = 'addEventListener';
        remove = 'removeEventListener';
      }
      el[add](eventName, callback, listenerOpts);
      return () => {
        el[remove](eventName, callback, listenerOpts);
      };
    };
    const supportsPassive = node => {
      if (_sPassive === undefined) {
        try {
          const opts = Object.defineProperty({}, 'passive', {
            get: () => {
              _sPassive = true;
            },
          });
          node.addEventListener(
            'optsTest',
            () => {
              return;
            },
            opts,
          );
        } catch (e) {
          _sPassive = false;
        }
      }
      return !!_sPassive;
    };
    let _sPassive;

    const MOUSE_WAIT = 2000;
    const createPointerEvents = (el, pointerDown, pointerMove, pointerUp, options) => {
      let rmTouchStart;
      let rmTouchMove;
      let rmTouchEnd;
      let rmTouchCancel;
      let rmMouseStart;
      let rmMouseMove;
      let rmMouseUp;
      let lastTouchEvent = 0;
      const handleTouchStart = ev => {
        lastTouchEvent = Date.now() + MOUSE_WAIT;
        if (!pointerDown(ev)) {
          return;
        }
        if (!rmTouchMove && pointerMove) {
          rmTouchMove = addEventListener$1(el, 'touchmove', pointerMove, options);
        }
        /**
         * Events are dispatched on the element that is tapped and bubble up to
         * the reference element in the gesture. In the event that the element this
         * event was first dispatched on is removed from the DOM, the event will no
         * longer bubble up to our reference element. This leaves the gesture in an
         * unusable state. To account for this, the touchend and touchcancel listeners
         * should be added to the event target so that they still fire even if the target
         * is removed from the DOM.
         */
        if (!rmTouchEnd) {
          rmTouchEnd = addEventListener$1(ev.target, 'touchend', handleTouchEnd, options);
        }
        if (!rmTouchCancel) {
          rmTouchCancel = addEventListener$1(ev.target, 'touchcancel', handleTouchEnd, options);
        }
      };
      const handleMouseDown = ev => {
        if (lastTouchEvent > Date.now()) {
          return;
        }
        if (!pointerDown(ev)) {
          return;
        }
        if (!rmMouseMove && pointerMove) {
          rmMouseMove = addEventListener$1(getDocument$1(el), 'mousemove', pointerMove, options);
        }
        if (!rmMouseUp) {
          rmMouseUp = addEventListener$1(getDocument$1(el), 'mouseup', handleMouseUp, options);
        }
      };
      const handleTouchEnd = ev => {
        stopTouch();
        if (pointerUp) {
          pointerUp(ev);
        }
      };
      const handleMouseUp = ev => {
        stopMouse();
        if (pointerUp) {
          pointerUp(ev);
        }
      };
      const stopTouch = () => {
        if (rmTouchMove) {
          rmTouchMove();
        }
        if (rmTouchEnd) {
          rmTouchEnd();
        }
        if (rmTouchCancel) {
          rmTouchCancel();
        }
        rmTouchMove = rmTouchEnd = rmTouchCancel = undefined;
      };
      const stopMouse = () => {
        if (rmMouseMove) {
          rmMouseMove();
        }
        if (rmMouseUp) {
          rmMouseUp();
        }
        rmMouseMove = rmMouseUp = undefined;
      };
      const stop = () => {
        stopTouch();
        stopMouse();
      };
      const enable = (isEnabled = true) => {
        if (!isEnabled) {
          if (rmTouchStart) {
            rmTouchStart();
          }
          if (rmMouseStart) {
            rmMouseStart();
          }
          rmTouchStart = rmMouseStart = undefined;
          stop();
        } else {
          if (!rmTouchStart) {
            rmTouchStart = addEventListener$1(el, 'touchstart', handleTouchStart, options);
          }
          if (!rmMouseStart) {
            rmMouseStart = addEventListener$1(el, 'mousedown', handleMouseDown, options);
          }
        }
      };
      const destroy = () => {
        enable(false);
        pointerUp = pointerMove = pointerDown = undefined;
      };
      return {
        enable,
        stop,
        destroy,
      };
    };
    const getDocument$1 = node => {
      return node instanceof Document ? node : node.ownerDocument;
    };

    const createPanRecognizer = (direction, thresh, maxAngle) => {
      const radians = maxAngle * (Math.PI / 180);
      const isDirX = direction === 'x';
      const maxCosine = Math.cos(radians);
      const threshold = thresh * thresh;
      let startX = 0;
      let startY = 0;
      let dirty = false;
      let isPan = 0;
      return {
        start(x, y) {
          startX = x;
          startY = y;
          isPan = 0;
          dirty = true;
        },
        detect(x, y) {
          if (!dirty) {
            return false;
          }
          const deltaX = x - startX;
          const deltaY = y - startY;
          const distance = deltaX * deltaX + deltaY * deltaY;
          if (distance < threshold) {
            return false;
          }
          const hypotenuse = Math.sqrt(distance);
          const cosine = (isDirX ? deltaX : deltaY) / hypotenuse;
          if (cosine > maxCosine) {
            isPan = 1;
          } else if (cosine < -maxCosine) {
            isPan = -1;
          } else {
            isPan = 0;
          }
          dirty = false;
          return true;
        },
        isGesture() {
          return isPan !== 0;
        },
        getDirection() {
          return isPan;
        },
      };
    };

    const createGesture = config => {
      let hasCapturedPan = false;
      let hasStartedPan = false;
      let hasFiredStart = true;
      let isMoveQueued = false;
      const finalConfig = Object.assign({ disableScroll: false, direction: 'x', gesturePriority: 0, passive: true, maxAngle: 40, threshold: 10 }, config);
      const canStart = finalConfig.canStart;
      const onWillStart = finalConfig.onWillStart;
      const onStart = finalConfig.onStart;
      const onEnd = finalConfig.onEnd;
      const notCaptured = finalConfig.notCaptured;
      const onMove = finalConfig.onMove;
      const threshold = finalConfig.threshold;
      const passive = finalConfig.passive;
      const blurOnStart = finalConfig.blurOnStart;
      const detail = {
        type: 'pan',
        startX: 0,
        startY: 0,
        startTime: 0,
        currentX: 0,
        currentY: 0,
        velocityX: 0,
        velocityY: 0,
        deltaX: 0,
        deltaY: 0,
        currentTime: 0,
        event: undefined,
        data: undefined,
      };
      const pan = createPanRecognizer(finalConfig.direction, finalConfig.threshold, finalConfig.maxAngle);
      const gesture = GESTURE_CONTROLLER.createGesture({
        name: config.gestureName,
        priority: config.gesturePriority,
        disableScroll: config.disableScroll,
      });
      const pointerDown = ev => {
        const timeStamp = now$1(ev);
        if (hasStartedPan || !hasFiredStart) {
          return false;
        }
        updateDetail(ev, detail);
        detail.startX = detail.currentX;
        detail.startY = detail.currentY;
        detail.startTime = detail.currentTime = timeStamp;
        detail.velocityX = detail.velocityY = detail.deltaX = detail.deltaY = 0;
        detail.event = ev;
        // Check if gesture can start
        if (canStart && canStart(detail) === false) {
          return false;
        }
        // Release fallback
        gesture.release();
        // Start gesture
        if (!gesture.start()) {
          return false;
        }
        hasStartedPan = true;
        if (threshold === 0) {
          return tryToCapturePan();
        }
        pan.start(detail.startX, detail.startY);
        return true;
      };
      const pointerMove = ev => {
        // fast path, if gesture is currently captured
        // do minimum job to get user-land even dispatched
        if (hasCapturedPan) {
          if (!isMoveQueued && hasFiredStart) {
            isMoveQueued = true;
            calcGestureData(detail, ev);
            requestAnimationFrame(fireOnMove);
          }
          return;
        }
        // gesture is currently being detected
        calcGestureData(detail, ev);
        if (pan.detect(detail.currentX, detail.currentY)) {
          if (!pan.isGesture() || !tryToCapturePan()) {
            abortGesture();
          }
        }
      };
      const fireOnMove = () => {
        // Since fireOnMove is called inside a RAF, onEnd() might be called,
        // we must double check hasCapturedPan
        if (!hasCapturedPan) {
          return;
        }
        isMoveQueued = false;
        if (onMove) {
          onMove(detail);
        }
      };
      const tryToCapturePan = () => {
        if (gesture && !gesture.capture()) {
          return false;
        }
        hasCapturedPan = true;
        hasFiredStart = false;
        // reset start position since the real user-land event starts here
        // If the pan detector threshold is big, not resetting the start position
        // will cause a jump in the animation equal to the detector threshold.
        // the array of positions used to calculate the gesture velocity does not
        // need to be cleaned, more points in the positions array always results in a
        // more accurate value of the velocity.
        detail.startX = detail.currentX;
        detail.startY = detail.currentY;
        detail.startTime = detail.currentTime;
        if (onWillStart) {
          onWillStart(detail).then(fireOnStart);
        } else {
          fireOnStart();
        }
        return true;
      };
      const blurActiveElement = () => {
        /* tslint:disable-next-line */
        if (typeof document !== 'undefined') {
          const activeElement = document.activeElement;
          if (activeElement !== null && activeElement.blur) {
            activeElement.blur();
          }
        }
      };
      const fireOnStart = () => {
        if (blurOnStart) {
          blurActiveElement();
        }
        if (onStart) {
          onStart(detail);
        }
        hasFiredStart = true;
      };
      const reset = () => {
        hasCapturedPan = false;
        hasStartedPan = false;
        isMoveQueued = false;
        hasFiredStart = true;
        gesture.release();
      };
      // END *************************
      const pointerUp = ev => {
        const tmpHasCaptured = hasCapturedPan;
        const tmpHasFiredStart = hasFiredStart;
        reset();
        if (!tmpHasFiredStart) {
          return;
        }
        calcGestureData(detail, ev);
        // Try to capture press
        if (tmpHasCaptured) {
          if (onEnd) {
            onEnd(detail);
          }
          return;
        }
        // Not captured any event
        if (notCaptured) {
          notCaptured(detail);
        }
      };
      const pointerEvents = createPointerEvents(finalConfig.el, pointerDown, pointerMove, pointerUp, {
        capture: false,
        passive,
      });
      const abortGesture = () => {
        reset();
        pointerEvents.stop();
        if (notCaptured) {
          notCaptured(detail);
        }
      };
      return {
        enable(enable = true) {
          if (!enable) {
            if (hasCapturedPan) {
              pointerUp(undefined);
            }
            reset();
          }
          pointerEvents.enable(enable);
        },
        destroy() {
          gesture.destroy();
          pointerEvents.destroy();
        },
      };
    };
    const calcGestureData = (detail, ev) => {
      if (!ev) {
        return;
      }
      const prevX = detail.currentX;
      const prevY = detail.currentY;
      const prevT = detail.currentTime;
      updateDetail(ev, detail);
      const currentX = detail.currentX;
      const currentY = detail.currentY;
      const timestamp = (detail.currentTime = now$1(ev));
      const timeDelta = timestamp - prevT;
      if (timeDelta > 0 && timeDelta < 100) {
        const velocityX = (currentX - prevX) / timeDelta;
        const velocityY = (currentY - prevY) / timeDelta;
        detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;
        detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;
      }
      detail.deltaX = currentX - detail.startX;
      detail.deltaY = currentY - detail.startY;
      detail.event = ev;
    };
    const updateDetail = (ev, detail) => {
      // get X coordinates for either a mouse click
      // or a touch depending on the given event
      let x = 0;
      let y = 0;
      if (ev) {
        const changedTouches = ev.changedTouches;
        if (changedTouches && changedTouches.length > 0) {
          const touch = changedTouches[0];
          x = touch.clientX;
          y = touch.clientY;
        } else if (ev.pageX !== undefined) {
          x = ev.pageX;
          y = ev.pageY;
        }
      }
      detail.currentX = x;
      detail.currentY = y;
    };
    const now$1 = ev => {
      return ev.timeStamp || Date.now();
    };

    var index$2 = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      createGesture: createGesture,
      GESTURE_CONTROLLER: GESTURE_CONTROLLER,
    });

    const createButtonActiveGesture = (el, isButton) => {
      let currentTouchedButton;
      let initialTouchedButton;
      const activateButtonAtPoint = (x, y, hapticFeedbackFn) => {
        if (typeof document === 'undefined') {
          return;
        }
        const target = document.elementFromPoint(x, y);
        if (!target || !isButton(target)) {
          clearActiveButton();
          return;
        }
        if (target !== currentTouchedButton) {
          clearActiveButton();
          setActiveButton(target, hapticFeedbackFn);
        }
      };
      const setActiveButton = (button, hapticFeedbackFn) => {
        currentTouchedButton = button;
        if (!initialTouchedButton) {
          initialTouchedButton = currentTouchedButton;
        }
        const buttonToModify = currentTouchedButton;
        writeTask(() => buttonToModify.classList.add('ion-activated'));
        hapticFeedbackFn();
      };
      const clearActiveButton = (dispatchClick = false) => {
        if (!currentTouchedButton) {
          return;
        }
        const buttonToModify = currentTouchedButton;
        writeTask(() => buttonToModify.classList.remove('ion-activated'));
        /**
         * Clicking on one button, but releasing on another button
         * does not dispatch a click event in browsers, so we
         * need to do it manually here. Some browsers will
         * dispatch a click if clicking on one button, dragging over
         * another button, and releasing on the original button. In that
         * case, we need to make sure we do not cause a double click there.
         */
        if (dispatchClick && initialTouchedButton !== currentTouchedButton) {
          currentTouchedButton.click();
        }
        currentTouchedButton = undefined;
      };
      return createGesture({
        el,
        gestureName: 'buttonActiveDrag',
        threshold: 0,
        onStart: ev => activateButtonAtPoint(ev.currentX, ev.currentY, hapticSelectionStart),
        onMove: ev => activateButtonAtPoint(ev.currentX, ev.currentY, hapticSelectionChanged),
        onEnd: () => {
          clearActiveButton(true);
          hapticSelectionEnd();
          initialTouchedButton = undefined;
        },
      });
    };

    /**
     * When hardwareBackButton: false in config,
     * we need to make sure we also block the default
     * webview behavior. If we don't then it will be
     * possible for users to navigate backward while
     * an overlay is still open. Additionally, it will
     * give the appearance that the hardwareBackButton
     * config is not working as the page transition
     * will still happen.
     */
    const OVERLAY_BACK_BUTTON_PRIORITY = 100;
    const MENU_BACK_BUTTON_PRIORITY = 99; // 1 less than overlay priority since menu is displayed behind overlays

    /**
     * Waits for a component to be ready for
     * both custom element and non-custom element builds.
     * If non-custom element build, el.componentOnReady
     * will be used.
     * For custom element builds, we wait a frame
     * so that the inner contents of the component
     * have a chance to render.
     *
     * Use this utility rather than calling
     * el.componentOnReady yourself.
     */
    const componentOnReady = (el, callback) => {
      if (el.componentOnReady) {
        el.componentOnReady().then(resolvedEl => callback(resolvedEl));
      } else {
        raf(() => callback(el));
      }
    };
    /**
     * Elements inside of web components sometimes need to inherit global attributes
     * set on the host. For example, the inner input in `ion-input` should inherit
     * the `title` attribute that developers set directly on `ion-input`. This
     * helper function should be called in componentWillLoad and assigned to a variable
     * that is later used in the render function.
     *
     * This does not need to be reactive as changing attributes on the host element
     * does not trigger a re-render.
     */
    const inheritAttributes = (el, attributes = []) => {
      const attributeObject = {};
      attributes.forEach(attr => {
        if (el.hasAttribute(attr)) {
          const value = el.getAttribute(attr);
          if (value !== null) {
            attributeObject[attr] = el.getAttribute(attr);
          }
          el.removeAttribute(attr);
        }
      });
      return attributeObject;
    };
    const addEventListener = (el, eventName, callback, opts) => {
      if (typeof window !== 'undefined') {
        const win = window;
        const config = win && win.Ionic && win.Ionic.config;
        if (config) {
          const ael = config.get('_ael');
          if (ael) {
            return ael(el, eventName, callback, opts);
          } else if (config._ael) {
            return config._ael(el, eventName, callback, opts);
          }
        }
      }
      return el.addEventListener(eventName, callback, opts);
    };
    const removeEventListener = (el, eventName, callback, opts) => {
      if (typeof window !== 'undefined') {
        const win = window;
        const config = win && win.Ionic && win.Ionic.config;
        if (config) {
          const rel = config.get('_rel');
          if (rel) {
            return rel(el, eventName, callback, opts);
          } else if (config._rel) {
            return config._rel(el, eventName, callback, opts);
          }
        }
      }
      return el.removeEventListener(eventName, callback, opts);
    };
    /**
     * Gets the root context of a shadow dom element
     * On newer browsers this will be the shadowRoot,
     * but for older browser this may just be the
     * element itself.
     *
     * Useful for whenever you need to explicitly
     * do "myElement.shadowRoot!.querySelector(...)".
     */
    const getElementRoot = (el, fallback = el) => {
      return el.shadowRoot || fallback;
    };
    /**
     * Patched version of requestAnimationFrame that avoids ngzone
     * Use only when you know ngzone should not run
     */
    const raf = h => {
      if (typeof __zone_symbol__requestAnimationFrame === 'function') {
        return __zone_symbol__requestAnimationFrame(h);
      }
      if (typeof requestAnimationFrame === 'function') {
        return requestAnimationFrame(h);
      }
      return setTimeout(h);
    };
    const hasShadowDom = el => {
      return !!el.shadowRoot && !!el.attachShadow;
    };
    const findItemLabel = componentEl => {
      const itemEl = componentEl.closest('ion-item');
      if (itemEl) {
        return itemEl.querySelector('ion-label');
      }
      return null;
    };
    /**
     * This method is used for Ionic's input components that use Shadow DOM. In
     * order to properly label the inputs to work with screen readers, we need
     * to get the text content of the label outside of the shadow root and pass
     * it to the input inside of the shadow root.
     *
     * Referencing label elements by id from outside of the component is
     * impossible due to the shadow boundary, read more here:
     * https://developer.salesforce.com/blogs/2020/01/accessibility-for-web-components.html
     *
     * @param componentEl The shadow element that needs the aria label
     * @param inputId The unique identifier for the input
     */
    const getAriaLabel = (componentEl, inputId) => {
      let labelText;
      // If the user provides their own label via the aria-labelledby attr
      // we should use that instead of looking for an ion-label
      const labelledBy = componentEl.getAttribute('aria-labelledby');
      // Grab the id off of the component in case they are using
      // a custom label using the label element
      const componentId = componentEl.id;
      let labelId = labelledBy !== null && labelledBy.trim() !== '' ? labelledBy : inputId + '-lbl';
      let label = labelledBy !== null && labelledBy.trim() !== '' ? document.getElementById(labelledBy) : findItemLabel(componentEl);
      if (label) {
        if (labelledBy === null) {
          label.id = labelId;
        }
        labelText = label.textContent;
        label.setAttribute('aria-hidden', 'true');
        // if there is no label, check to see if the user has provided
        // one by setting an id on the component and using the label element
      } else if (componentId.trim() !== '') {
        label = document.querySelector(`label[for="${componentId}"]`);
        if (label) {
          if (label.id !== '') {
            labelId = label.id;
          } else {
            label.id = labelId = `${componentId}-lbl`;
          }
          labelText = label.textContent;
        }
      }
      return { label, labelId, labelText };
    };
    /**
     * This method is used to add a hidden input to a host element that contains
     * a Shadow DOM. It does not add the input inside of the Shadow root which
     * allows it to be picked up inside of forms. It should contain the same
     * values as the host element.
     *
     * @param always Add a hidden input even if the container does not use Shadow
     * @param container The element where the input will be added
     * @param name The name of the input
     * @param value The value of the input
     * @param disabled If true, the input is disabled
     */
    const renderHiddenInput = (always, container, name, value, disabled) => {
      if (always || hasShadowDom(container)) {
        let input = container.querySelector('input.aux-input');
        if (!input) {
          input = container.ownerDocument.createElement('input');
          input.type = 'hidden';
          input.classList.add('aux-input');
          container.appendChild(input);
        }
        input.disabled = disabled;
        input.name = name;
        input.value = value || '';
      }
    };
    const clamp = (min, n, max) => {
      return Math.max(min, Math.min(n, max));
    };
    const assert = (actual, reason) => {
      if (!actual) {
        const message = 'ASSERT: ' + reason;
        console.error(message);
        debugger; // tslint:disable-line
        throw new Error(message);
      }
    };
    const pointerCoord = ev => {
      // get X coordinates for either a mouse click
      // or a touch depending on the given event
      if (ev) {
        const changedTouches = ev.changedTouches;
        if (changedTouches && changedTouches.length > 0) {
          const touch = changedTouches[0];
          return { x: touch.clientX, y: touch.clientY };
        }
        if (ev.pageX !== undefined) {
          return { x: ev.pageX, y: ev.pageY };
        }
      }
      return { x: 0, y: 0 };
    };
    /**
     * @hidden
     * Given a side, return if it should be on the end
     * based on the value of dir
     * @param side the side
     * @param isRTL whether the application dir is rtl
     */
    const isEndSide = side => {
      const isRTL = document.dir === 'rtl';
      switch (side) {
        case 'start':
          return isRTL;
        case 'end':
          return !isRTL;
        default:
          throw new Error(`"${side}" is not a valid value for [side]. Use "start" or "end" instead.`);
      }
    };
    const debounceEvent = (event, wait) => {
      const original = event._original || event;
      return {
        _original: event,
        emit: debounce$1(original.emit.bind(original), wait),
      };
    };
    const debounce$1 = (func, wait = 0) => {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(func, wait, ...args);
      };
    };

    let lastId = 0;
    const activeAnimations = new WeakMap();
    const createController = tagName => {
      return {
        create(options) {
          return createOverlay(tagName, options);
        },
        dismiss(data, role, id) {
          return dismissOverlay(document, data, role, tagName, id);
        },
        async getTop() {
          return getOverlay(document, tagName);
        },
      };
    };
    const alertController = /*@__PURE__*/ createController('ion-alert');
    const actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');
    const pickerController = /*@__PURE__*/ createController('ion-picker');
    const popoverController = /*@__PURE__*/ createController('ion-popover');
    const prepareOverlay = el => {
      /* tslint:disable-next-line */
      if (typeof document !== 'undefined') {
        connectListeners(document);
      }
      const overlayIndex = lastId++;
      el.overlayIndex = overlayIndex;
      if (!el.hasAttribute('id')) {
        el.id = `ion-overlay-${overlayIndex}`;
      }
    };
    const createOverlay = (tagName, opts) => {
      /* tslint:disable-next-line */
      if (typeof customElements !== 'undefined') {
        return customElements.whenDefined(tagName).then(() => {
          const element = document.createElement(tagName);
          element.classList.add('overlay-hidden');
          // convert the passed in overlay options into props
          // that get passed down into the new overlay
          Object.assign(element, opts);
          // append the overlay element to the document body
          getAppRoot(document).appendChild(element);
          return new Promise(resolve => componentOnReady(element, resolve));
        });
      }
      return Promise.resolve();
    };
    const focusableQueryString =
      '[tabindex]:not([tabindex^="-"]), input:not([type=hidden]):not([tabindex^="-"]), textarea:not([tabindex^="-"]), button:not([tabindex^="-"]), select:not([tabindex^="-"]), .ion-focusable:not([tabindex^="-"])';
    const innerFocusableQueryString = 'input:not([type=hidden]), textarea, button, select';
    const focusFirstDescendant = (ref, overlay) => {
      let firstInput = ref.querySelector(focusableQueryString);
      const shadowRoot = firstInput && firstInput.shadowRoot;
      if (shadowRoot) {
        // If there are no inner focusable elements, just focus the host element.
        firstInput = shadowRoot.querySelector(innerFocusableQueryString) || firstInput;
      }
      if (firstInput) {
        firstInput.focus();
      } else {
        // Focus overlay instead of letting focus escape
        overlay.focus();
      }
    };
    const focusLastDescendant = (ref, overlay) => {
      const inputs = Array.from(ref.querySelectorAll(focusableQueryString));
      let lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;
      const shadowRoot = lastInput && lastInput.shadowRoot;
      if (shadowRoot) {
        // If there are no inner focusable elements, just focus the host element.
        lastInput = shadowRoot.querySelector(innerFocusableQueryString) || lastInput;
      }
      if (lastInput) {
        lastInput.focus();
      } else {
        // Focus overlay instead of letting focus escape
        overlay.focus();
      }
    };
    /**
     * Traps keyboard focus inside of overlay components.
     * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html
     * This includes the following components: Action Sheet, Alert, Loading, Modal,
     * Picker, and Popover.
     * Should NOT include: Toast
     */
    const trapKeyboardFocus = (ev, doc) => {
      const lastOverlay = getOverlay(doc);
      const target = ev.target;
      // If no active overlay, ignore this event
      if (!lastOverlay || !target) {
        return;
      }
      /**
       * If we are focusing the overlay, clear
       * the last focused element so that hitting
       * tab activates the first focusable element
       * in the overlay wrapper.
       */
      if (lastOverlay === target) {
        lastOverlay.lastFocus = undefined;
        /**
         * Otherwise, we must be focusing an element
         * inside of the overlay. The two possible options
         * here are an input/button/etc or the ion-focus-trap
         * element. The focus trap element is used to prevent
         * the keyboard focus from leaving the overlay when
         * using Tab or screen assistants.
         */
      } else {
        /**
         * We do not want to focus the traps, so get the overlay
         * wrapper element as the traps live outside of the wrapper.
         */
        const overlayRoot = getElementRoot(lastOverlay);
        if (!overlayRoot.contains(target)) {
          return;
        }
        const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');
        if (!overlayWrapper) {
          return;
        }
        /**
         * If the target is inside the wrapper, let the browser
         * focus as normal and keep a log of the last focused element.
         */
        if (overlayWrapper.contains(target)) {
          lastOverlay.lastFocus = target;
        } else {
          /**
           * Otherwise, we must have focused one of the focus traps.
           * We need to wrap the focus to either the first element
           * or the last element.
           */
          /**
           * Once we call `focusFirstDescendant` and focus the first
           * descendant, another focus event will fire which will
           * cause `lastOverlay.lastFocus` to be updated before
           * we can run the code after that. We will cache the value
           * here to avoid that.
           */
          const lastFocus = lastOverlay.lastFocus;
          // Focus the first element in the overlay wrapper
          focusFirstDescendant(overlayWrapper, lastOverlay);
          /**
           * If the cached last focused element is the
           * same as the active element, then we need
           * to wrap focus to the last descendant. This happens
           * when the first descendant is focused, and the user
           * presses Shift + Tab. The previous line will focus
           * the same descendant again (the first one), causing
           * last focus to equal the active element.
           */
          if (lastFocus === doc.activeElement) {
            focusLastDescendant(overlayWrapper, lastOverlay);
          }
          lastOverlay.lastFocus = doc.activeElement;
        }
      }
    };
    const connectListeners = doc => {
      if (lastId === 0) {
        lastId = 1;
        doc.addEventListener('focus', ev => trapKeyboardFocus(ev, doc), true);
        // handle back-button click
        doc.addEventListener('ionBackButton', ev => {
          const lastOverlay = getOverlay(doc);
          if (lastOverlay && lastOverlay.backdropDismiss) {
            ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {
              return lastOverlay.dismiss(undefined, BACKDROP);
            });
          }
        });
        // handle ESC to close overlay
        doc.addEventListener('keyup', ev => {
          if (ev.key === 'Escape') {
            const lastOverlay = getOverlay(doc);
            if (lastOverlay && lastOverlay.backdropDismiss) {
              lastOverlay.dismiss(undefined, BACKDROP);
            }
          }
        });
      }
    };
    const dismissOverlay = (doc, data, role, overlayTag, id) => {
      const overlay = getOverlay(doc, overlayTag, id);
      if (!overlay) {
        return Promise.reject('overlay does not exist');
      }
      return overlay.dismiss(data, role);
    };
    const getOverlays = (doc, selector) => {
      if (selector === undefined) {
        selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker,ion-popover,ion-toast';
      }
      return Array.from(doc.querySelectorAll(selector)).filter(c => c.overlayIndex > 0);
    };
    const getOverlay = (doc, overlayTag, id) => {
      const overlays = getOverlays(doc, overlayTag);
      return id === undefined ? overlays[overlays.length - 1] : overlays.find(o => o.id === id);
    };
    /**
     * When an overlay is presented, the main
     * focus is the overlay not the page content.
     * We need to remove the page content from the
     * accessibility tree otherwise when
     * users use "read screen from top" gestures with
     * TalkBack and VoiceOver, the screen reader will begin
     * to read the content underneath the overlay.
     *
     * We need a container where all page components
     * exist that is separate from where the overlays
     * are added in the DOM. For most apps, this element
     * is the top most ion-router-outlet. In the event
     * that devs are not using a router,
     * they will need to add the "ion-view-container-root"
     * id to the element that contains all of their views.
     *
     * TODO: If Framework supports having multiple top
     * level router outlets we would need to update this.
     * Example: One outlet for side menu and one outlet
     * for main content.
     */
    const setRootAriaHidden = (hidden = false) => {
      const root = getAppRoot(document);
      const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');
      if (!viewContainer) {
        return;
      }
      if (hidden) {
        viewContainer.setAttribute('aria-hidden', 'true');
      } else {
        viewContainer.removeAttribute('aria-hidden');
      }
    };
    const present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {
      if (overlay.presented) {
        return;
      }
      setRootAriaHidden(true);
      overlay.presented = true;
      overlay.willPresent.emit();
      const mode = getIonMode$1(overlay);
      // get the user's animation fn if one was provided
      const animationBuilder = overlay.enterAnimation ? overlay.enterAnimation : config$2.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);
      const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);
      if (completed) {
        overlay.didPresent.emit();
      }
      /**
       * When an overlay that steals focus
       * is dismissed, focus should be returned
       * to the element that was focused
       * prior to the overlay opening. Toast
       * does not steal focus and is excluded
       * from returning focus as a result.
       */
      if (overlay.el.tagName !== 'ION-TOAST') {
        focusPreviousElementOnDismiss(overlay.el);
      }
      if (overlay.keyboardClose) {
        overlay.el.focus();
      }
    };
    /**
     * When an overlay component is dismissed,
     * focus should be returned to the element
     * that presented the overlay. Otherwise
     * focus will be set on the body which
     * means that people using screen readers
     * or tabbing will need to re-navigate
     * to where they were before they
     * opened the overlay.
     */
    const focusPreviousElementOnDismiss = async overlayEl => {
      let previousElement = document.activeElement;
      if (!previousElement) {
        return;
      }
      const shadowRoot = previousElement && previousElement.shadowRoot;
      if (shadowRoot) {
        // If there are no inner focusable elements, just focus the host element.
        previousElement = shadowRoot.querySelector(innerFocusableQueryString) || previousElement;
      }
      await overlayEl.onDidDismiss();
      previousElement.focus();
    };
    const dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {
      if (!overlay.presented) {
        return false;
      }
      setRootAriaHidden(false);
      overlay.presented = false;
      try {
        // Overlay contents should not be clickable during dismiss
        overlay.el.style.setProperty('pointer-events', 'none');
        overlay.willDismiss.emit({ data, role });
        const mode = getIonMode$1(overlay);
        const animationBuilder = overlay.leaveAnimation ? overlay.leaveAnimation : config$2.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);
        // If dismissed via gesture, no need to play leaving animation again
        if (role !== 'gesture') {
          await overlayAnimation(overlay, animationBuilder, overlay.el, opts);
        }
        overlay.didDismiss.emit({ data, role });
        activeAnimations.delete(overlay);
      } catch (err) {
        console.error(err);
      }
      overlay.el.remove();
      return true;
    };
    const getAppRoot = doc => {
      return doc.querySelector('ion-app') || doc.body;
    };
    const overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {
      // Make overlay visible in case it's hidden
      baseEl.classList.remove('overlay-hidden');
      const aniRoot = baseEl.shadowRoot || overlay.el;
      const animation = animationBuilder(aniRoot, opts);
      if (!overlay.animated || !config$2.getBoolean('animated', true)) {
        animation.duration(0);
      }
      if (overlay.keyboardClose) {
        animation.beforeAddWrite(() => {
          const activeElement = baseEl.ownerDocument.activeElement;
          if (activeElement && activeElement.matches('input, ion-input, ion-textarea')) {
            activeElement.blur();
          }
        });
      }
      const activeAni = activeAnimations.get(overlay) || [];
      activeAnimations.set(overlay, [...activeAni, animation]);
      await animation.play();
      return true;
    };
    const eventMethod = (element, eventName) => {
      let resolve;
      const promise = new Promise(r => (resolve = r));
      onceEvent(element, eventName, event => {
        resolve(event.detail);
      });
      return promise;
    };
    const onceEvent = (element, eventName, callback) => {
      const handler = ev => {
        removeEventListener(element, eventName, handler);
        callback(ev);
      };
      addEventListener(element, eventName, handler);
    };
    const isCancel = role => {
      return role === 'cancel' || role === BACKDROP;
    };
    const defaultGate = h => h();
    const safeCall = (handler, arg) => {
      if (typeof handler === 'function') {
        const jmp = config$2.get('_zoneGate', defaultGate);
        return jmp(() => {
          try {
            return handler(arg);
          } catch (e) {
            console.error(e);
          }
        });
      }
      return undefined;
    };
    const BACKDROP = 'backdrop';

    const hostContext = (selector, el) => {
      return el.closest(selector) !== null;
    };
    /**
     * Create the mode and color classes for the component based on the classes passed in
     */
    const createColorClasses$1 = (color, cssClassMap) => {
      return typeof color === 'string' && color.length > 0 ? Object.assign({ 'ion-color': true, [`ion-color-${color}`]: true }, cssClassMap) : cssClassMap;
    };
    const getClassList = classes => {
      if (classes !== undefined) {
        const array = Array.isArray(classes) ? classes : classes.split(' ');
        return array
          .filter(c => c != null)
          .map(c => c.trim())
          .filter(c => c !== '');
      }
      return [];
    };
    const getClassMap = classes => {
      const map = {};
      getClassList(classes).forEach(c => (map[c] = true));
      return map;
    };
    const SCHEME = /^[a-z][a-z0-9+\-.]*:/;
    const openURL = async (url, ev, direction, animation) => {
      if (url != null && url[0] !== '#' && !SCHEME.test(url)) {
        const router = document.querySelector('ion-router');
        if (router) {
          if (ev != null) {
            ev.preventDefault();
          }
          return router.push(url, direction, animation);
        }
      }
      return false;
    };

    let animationPrefix;
    /**
     * Web Animations requires hyphenated CSS properties
     * to be written in camelCase when animating
     */
    const processKeyframes = keyframes => {
      keyframes.forEach(keyframe => {
        for (const key in keyframe) {
          if (keyframe.hasOwnProperty(key)) {
            const value = keyframe[key];
            if (key === 'easing') {
              const newKey = 'animation-timing-function';
              keyframe[newKey] = value;
              delete keyframe[key];
            } else {
              const newKey = convertCamelCaseToHypen(key);
              if (newKey !== key) {
                keyframe[newKey] = value;
                delete keyframe[key];
              }
            }
          }
        }
      });
      return keyframes;
    };
    const convertCamelCaseToHypen = str => {
      return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
    };
    const getAnimationPrefix = el => {
      if (animationPrefix === undefined) {
        const supportsUnprefixed = el.style.animationName !== undefined;
        const supportsWebkitPrefix = el.style.webkitAnimationName !== undefined;
        animationPrefix = !supportsUnprefixed && supportsWebkitPrefix ? '-webkit-' : '';
      }
      return animationPrefix;
    };
    const setStyleProperty = (element, propertyName, value) => {
      const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';
      element.style.setProperty(prefix + propertyName, value);
    };
    const removeStyleProperty = (element, propertyName) => {
      const prefix = propertyName.startsWith('animation') ? getAnimationPrefix(element) : '';
      element.style.removeProperty(prefix + propertyName);
    };
    const animationEnd = (el, callback) => {
      let unRegTrans;
      const opts = { passive: true };
      const unregister = () => {
        if (unRegTrans) {
          unRegTrans();
        }
      };
      const onTransitionEnd = ev => {
        if (el === ev.target) {
          unregister();
          callback(ev);
        }
      };
      if (el) {
        el.addEventListener('webkitAnimationEnd', onTransitionEnd, opts);
        el.addEventListener('animationend', onTransitionEnd, opts);
        unRegTrans = () => {
          el.removeEventListener('webkitAnimationEnd', onTransitionEnd, opts);
          el.removeEventListener('animationend', onTransitionEnd, opts);
        };
      }
      return unregister;
    };
    const generateKeyframeRules = (keyframes = []) => {
      return keyframes
        .map(keyframe => {
          const offset = keyframe.offset;
          const frameString = [];
          for (const property in keyframe) {
            if (keyframe.hasOwnProperty(property) && property !== 'offset') {
              frameString.push(`${property}: ${keyframe[property]};`);
            }
          }
          return `${offset * 100}% { ${frameString.join(' ')} }`;
        })
        .join(' ');
    };
    const keyframeIds = [];
    const generateKeyframeName = keyframeRules => {
      let index = keyframeIds.indexOf(keyframeRules);
      if (index < 0) {
        index = keyframeIds.push(keyframeRules) - 1;
      }
      return `ion-animation-${index}`;
    };
    const getStyleContainer = element => {
      const rootNode = element.getRootNode();
      return rootNode.head || rootNode;
    };
    const createKeyframeStylesheet = (keyframeName, keyframeRules, element) => {
      const styleContainer = getStyleContainer(element);
      const keyframePrefix = getAnimationPrefix(element);
      const existingStylesheet = styleContainer.querySelector('#' + keyframeName);
      if (existingStylesheet) {
        return existingStylesheet;
      }
      const stylesheet = (element.ownerDocument || document).createElement('style');
      stylesheet.id = keyframeName;
      stylesheet.textContent = `@${keyframePrefix}keyframes ${keyframeName} { ${keyframeRules} } @${keyframePrefix}keyframes ${keyframeName}-alt { ${keyframeRules} }`;
      styleContainer.appendChild(stylesheet);
      return stylesheet;
    };
    const addClassToArray = (classes = [], className) => {
      if (className !== undefined) {
        const classNameToAppend = Array.isArray(className) ? className : [className];
        return [...classes, ...classNameToAppend];
      }
      return classes;
    };

    const createAnimation = animationId => {
      let _delay;
      let _duration;
      let _easing;
      let _iterations;
      let _fill;
      let _direction;
      let _keyframes = [];
      let beforeAddClasses = [];
      let beforeRemoveClasses = [];
      let initialized = false;
      let parentAnimation;
      let beforeStylesValue = {};
      let afterAddClasses = [];
      let afterRemoveClasses = [];
      let afterStylesValue = {};
      let numAnimationsRunning = 0;
      let shouldForceLinearEasing = false;
      let shouldForceSyncPlayback = false;
      let cssAnimationsTimerFallback;
      let forceDirectionValue;
      let forceDurationValue;
      let forceDelayValue;
      let willComplete = true;
      let finished = false;
      let shouldCalculateNumAnimations = true;
      let keyframeName;
      let ani;
      const id = animationId;
      const onFinishCallbacks = [];
      const onFinishOneTimeCallbacks = [];
      const elements = [];
      const childAnimations = [];
      const stylesheets = [];
      const _beforeAddReadFunctions = [];
      const _beforeAddWriteFunctions = [];
      const _afterAddReadFunctions = [];
      const _afterAddWriteFunctions = [];
      const webAnimations = [];
      const supportsAnimationEffect = typeof AnimationEffect === 'function' || typeof window.AnimationEffect === 'function';
      const supportsWebAnimations = typeof Element === 'function' && typeof Element.prototype.animate === 'function' && supportsAnimationEffect;
      const ANIMATION_END_FALLBACK_PADDING_MS = 100;
      const getWebAnimations = () => {
        return webAnimations;
      };
      const destroy = clearStyleSheets => {
        childAnimations.forEach(childAnimation => {
          childAnimation.destroy(clearStyleSheets);
        });
        cleanUp(clearStyleSheets);
        elements.length = 0;
        childAnimations.length = 0;
        _keyframes.length = 0;
        clearOnFinish();
        initialized = false;
        shouldCalculateNumAnimations = true;
        return ani;
      };
      /**
       * Cancels any Web Animations, removes
       * any animation properties from the
       * animation's elements, and removes the
       * animation's stylesheets from the DOM.
       */
      const cleanUp = clearStyleSheets => {
        cleanUpElements();
        if (clearStyleSheets) {
          cleanUpStyleSheets();
        }
      };
      const resetFlags = () => {
        shouldForceLinearEasing = false;
        shouldForceSyncPlayback = false;
        shouldCalculateNumAnimations = true;
        forceDirectionValue = undefined;
        forceDurationValue = undefined;
        forceDelayValue = undefined;
        numAnimationsRunning = 0;
        finished = false;
        willComplete = true;
      };
      const onFinish = (callback, opts) => {
        const callbacks = opts && opts.oneTimeCallback ? onFinishOneTimeCallbacks : onFinishCallbacks;
        callbacks.push({ c: callback, o: opts });
        return ani;
      };
      const clearOnFinish = () => {
        onFinishCallbacks.length = 0;
        onFinishOneTimeCallbacks.length = 0;
        return ani;
      };
      /**
       * Cancels any Web Animations and removes
       * any animation properties from the
       * the animation's elements.
       */
      const cleanUpElements = () => {
        if (supportsWebAnimations) {
          webAnimations.forEach(animation => {
            animation.cancel();
          });
          webAnimations.length = 0;
        } else {
          const elementsArray = elements.slice();
          raf(() => {
            elementsArray.forEach(element => {
              removeStyleProperty(element, 'animation-name');
              removeStyleProperty(element, 'animation-duration');
              removeStyleProperty(element, 'animation-timing-function');
              removeStyleProperty(element, 'animation-iteration-count');
              removeStyleProperty(element, 'animation-delay');
              removeStyleProperty(element, 'animation-play-state');
              removeStyleProperty(element, 'animation-fill-mode');
              removeStyleProperty(element, 'animation-direction');
            });
          });
        }
      };
      /**
       * Removes the animation's stylesheets
       * from the DOM.
       */
      const cleanUpStyleSheets = () => {
        stylesheets.forEach(stylesheet => {
          /**
           * When sharing stylesheets, it's possible
           * for another animation to have already
           * cleaned up a particular stylesheet
           */
          if (stylesheet && stylesheet.parentNode) {
            stylesheet.parentNode.removeChild(stylesheet);
          }
        });
        stylesheets.length = 0;
      };
      const beforeAddRead = readFn => {
        _beforeAddReadFunctions.push(readFn);
        return ani;
      };
      const beforeAddWrite = writeFn => {
        _beforeAddWriteFunctions.push(writeFn);
        return ani;
      };
      const afterAddRead = readFn => {
        _afterAddReadFunctions.push(readFn);
        return ani;
      };
      const afterAddWrite = writeFn => {
        _afterAddWriteFunctions.push(writeFn);
        return ani;
      };
      const beforeAddClass = className => {
        beforeAddClasses = addClassToArray(beforeAddClasses, className);
        return ani;
      };
      const beforeRemoveClass = className => {
        beforeRemoveClasses = addClassToArray(beforeRemoveClasses, className);
        return ani;
      };
      /**
       * Set CSS inline styles to the animation's
       * elements before the animation begins.
       */
      const beforeStyles = (styles = {}) => {
        beforeStylesValue = styles;
        return ani;
      };
      /**
       * Clear CSS inline styles from the animation's
       * elements before the animation begins.
       */
      const beforeClearStyles = (propertyNames = []) => {
        for (const property of propertyNames) {
          beforeStylesValue[property] = '';
        }
        return ani;
      };
      const afterAddClass = className => {
        afterAddClasses = addClassToArray(afterAddClasses, className);
        return ani;
      };
      const afterRemoveClass = className => {
        afterRemoveClasses = addClassToArray(afterRemoveClasses, className);
        return ani;
      };
      const afterStyles = (styles = {}) => {
        afterStylesValue = styles;
        return ani;
      };
      const afterClearStyles = (propertyNames = []) => {
        for (const property of propertyNames) {
          afterStylesValue[property] = '';
        }
        return ani;
      };
      const getFill = () => {
        if (_fill !== undefined) {
          return _fill;
        }
        if (parentAnimation) {
          return parentAnimation.getFill();
        }
        return 'both';
      };
      const getDirection = () => {
        if (forceDirectionValue !== undefined) {
          return forceDirectionValue;
        }
        if (_direction !== undefined) {
          return _direction;
        }
        if (parentAnimation) {
          return parentAnimation.getDirection();
        }
        return 'normal';
      };
      const getEasing = () => {
        if (shouldForceLinearEasing) {
          return 'linear';
        }
        if (_easing !== undefined) {
          return _easing;
        }
        if (parentAnimation) {
          return parentAnimation.getEasing();
        }
        return 'linear';
      };
      const getDuration = () => {
        if (shouldForceSyncPlayback) {
          return 0;
        }
        if (forceDurationValue !== undefined) {
          return forceDurationValue;
        }
        if (_duration !== undefined) {
          return _duration;
        }
        if (parentAnimation) {
          return parentAnimation.getDuration();
        }
        return 0;
      };
      const getIterations = () => {
        if (_iterations !== undefined) {
          return _iterations;
        }
        if (parentAnimation) {
          return parentAnimation.getIterations();
        }
        return 1;
      };
      const getDelay = () => {
        if (forceDelayValue !== undefined) {
          return forceDelayValue;
        }
        if (_delay !== undefined) {
          return _delay;
        }
        if (parentAnimation) {
          return parentAnimation.getDelay();
        }
        return 0;
      };
      const getKeyframes = () => {
        return _keyframes;
      };
      const direction = animationDirection => {
        _direction = animationDirection;
        update(true);
        return ani;
      };
      const fill = animationFill => {
        _fill = animationFill;
        update(true);
        return ani;
      };
      const delay = animationDelay => {
        _delay = animationDelay;
        update(true);
        return ani;
      };
      const easing = animationEasing => {
        _easing = animationEasing;
        update(true);
        return ani;
      };
      const duration = animationDuration => {
        /**
         * CSS Animation Durations of 0ms work fine on Chrome
         * but do not run on Safari, so force it to 1ms to
         * get it to run on both platforms.
         */
        if (!supportsWebAnimations && animationDuration === 0) {
          animationDuration = 1;
        }
        _duration = animationDuration;
        update(true);
        return ani;
      };
      const iterations = animationIterations => {
        _iterations = animationIterations;
        update(true);
        return ani;
      };
      const parent = animation => {
        parentAnimation = animation;
        return ani;
      };
      const addElement = el => {
        if (el != null) {
          if (el.nodeType === 1) {
            elements.push(el);
          } else if (el.length >= 0) {
            for (let i = 0; i < el.length; i++) {
              elements.push(el[i]);
            }
          } else {
            console.error('Invalid addElement value');
          }
        }
        return ani;
      };
      const addAnimation = animationToAdd => {
        if (animationToAdd != null) {
          if (Array.isArray(animationToAdd)) {
            for (const animation of animationToAdd) {
              animation.parent(ani);
              childAnimations.push(animation);
            }
          } else {
            animationToAdd.parent(ani);
            childAnimations.push(animationToAdd);
          }
        }
        return ani;
      };
      const keyframes = keyframeValues => {
        _keyframes = keyframeValues;
        return ani;
      };
      /**
       * Run all "before" animation hooks.
       */
      const beforeAnimation = () => {
        // Runs all before read callbacks
        _beforeAddReadFunctions.forEach(callback => callback());
        // Runs all before write callbacks
        _beforeAddWriteFunctions.forEach(callback => callback());
        // Updates styles and classes before animation runs
        const addClasses = beforeAddClasses;
        const removeClasses = beforeRemoveClasses;
        const styles = beforeStylesValue;
        elements.forEach(el => {
          const elementClassList = el.classList;
          addClasses.forEach(c => elementClassList.add(c));
          removeClasses.forEach(c => elementClassList.remove(c));
          for (const property in styles) {
            if (styles.hasOwnProperty(property)) {
              setStyleProperty(el, property, styles[property]);
            }
          }
        });
      };
      /**
       * Run all "after" animation hooks.
       */
      const afterAnimation = () => {
        clearCSSAnimationsTimeout();
        // Runs all after read callbacks
        _afterAddReadFunctions.forEach(callback => callback());
        // Runs all after write callbacks
        _afterAddWriteFunctions.forEach(callback => callback());
        // Updates styles and classes before animation ends
        const currentStep = willComplete ? 1 : 0;
        const addClasses = afterAddClasses;
        const removeClasses = afterRemoveClasses;
        const styles = afterStylesValue;
        elements.forEach(el => {
          const elementClassList = el.classList;
          addClasses.forEach(c => elementClassList.add(c));
          removeClasses.forEach(c => elementClassList.remove(c));
          for (const property in styles) {
            if (styles.hasOwnProperty(property)) {
              setStyleProperty(el, property, styles[property]);
            }
          }
        });
        onFinishCallbacks.forEach(onFinishCallback => {
          return onFinishCallback.c(currentStep, ani);
        });
        onFinishOneTimeCallbacks.forEach(onFinishCallback => {
          return onFinishCallback.c(currentStep, ani);
        });
        onFinishOneTimeCallbacks.length = 0;
        shouldCalculateNumAnimations = true;
        if (willComplete) {
          finished = true;
        }
        willComplete = true;
      };
      const animationFinish = () => {
        if (numAnimationsRunning === 0) {
          return;
        }
        numAnimationsRunning--;
        if (numAnimationsRunning === 0) {
          afterAnimation();
          if (parentAnimation) {
            parentAnimation.animationFinish();
          }
        }
      };
      const initializeCSSAnimation = (toggleAnimationName = true) => {
        cleanUpStyleSheets();
        const processedKeyframes = processKeyframes(_keyframes);
        elements.forEach(element => {
          if (processedKeyframes.length > 0) {
            const keyframeRules = generateKeyframeRules(processedKeyframes);
            keyframeName = animationId !== undefined ? animationId : generateKeyframeName(keyframeRules);
            const stylesheet = createKeyframeStylesheet(keyframeName, keyframeRules, element);
            stylesheets.push(stylesheet);
            setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);
            setStyleProperty(element, 'animation-timing-function', getEasing());
            setStyleProperty(element, 'animation-delay', `${getDelay()}ms`);
            setStyleProperty(element, 'animation-fill-mode', getFill());
            setStyleProperty(element, 'animation-direction', getDirection());
            const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();
            setStyleProperty(element, 'animation-iteration-count', iterationsCount);
            setStyleProperty(element, 'animation-play-state', 'paused');
            if (toggleAnimationName) {
              setStyleProperty(element, 'animation-name', `${stylesheet.id}-alt`);
            }
            raf(() => {
              setStyleProperty(element, 'animation-name', stylesheet.id || null);
            });
          }
        });
      };
      const initializeWebAnimation = () => {
        elements.forEach(element => {
          const animation = element.animate(_keyframes, {
            id,
            delay: getDelay(),
            duration: getDuration(),
            easing: getEasing(),
            iterations: getIterations(),
            fill: getFill(),
            direction: getDirection(),
          });
          animation.pause();
          webAnimations.push(animation);
        });
        if (webAnimations.length > 0) {
          webAnimations[0].onfinish = () => {
            animationFinish();
          };
        }
      };
      const initializeAnimation = (toggleAnimationName = true) => {
        beforeAnimation();
        if (_keyframes.length > 0) {
          if (supportsWebAnimations) {
            initializeWebAnimation();
          } else {
            initializeCSSAnimation(toggleAnimationName);
          }
        }
        initialized = true;
      };
      const setAnimationStep = step => {
        step = Math.min(Math.max(step, 0), 0.9999);
        if (supportsWebAnimations) {
          webAnimations.forEach(animation => {
            animation.currentTime = animation.effect.getComputedTiming().delay + getDuration() * step;
            animation.pause();
          });
        } else {
          const animationDuration = `-${getDuration() * step}ms`;
          elements.forEach(element => {
            if (_keyframes.length > 0) {
              setStyleProperty(element, 'animation-delay', animationDuration);
              setStyleProperty(element, 'animation-play-state', 'paused');
            }
          });
        }
      };
      const updateWebAnimation = step => {
        webAnimations.forEach(animation => {
          animation.effect.updateTiming({
            delay: getDelay(),
            duration: getDuration(),
            easing: getEasing(),
            iterations: getIterations(),
            fill: getFill(),
            direction: getDirection(),
          });
        });
        if (step !== undefined) {
          setAnimationStep(step);
        }
      };
      const updateCSSAnimation = (toggleAnimationName = true, step) => {
        raf(() => {
          elements.forEach(element => {
            setStyleProperty(element, 'animation-name', keyframeName || null);
            setStyleProperty(element, 'animation-duration', `${getDuration()}ms`);
            setStyleProperty(element, 'animation-timing-function', getEasing());
            setStyleProperty(element, 'animation-delay', step !== undefined ? `-${step * getDuration()}ms` : `${getDelay()}ms`);
            setStyleProperty(element, 'animation-fill-mode', getFill() || null);
            setStyleProperty(element, 'animation-direction', getDirection() || null);
            const iterationsCount = getIterations() === Infinity ? 'infinite' : getIterations().toString();
            setStyleProperty(element, 'animation-iteration-count', iterationsCount);
            if (toggleAnimationName) {
              setStyleProperty(element, 'animation-name', `${keyframeName}-alt`);
            }
            raf(() => {
              setStyleProperty(element, 'animation-name', keyframeName || null);
            });
          });
        });
      };
      const update = (deep = false, toggleAnimationName = true, step) => {
        if (deep) {
          childAnimations.forEach(animation => {
            animation.update(deep, toggleAnimationName, step);
          });
        }
        if (supportsWebAnimations) {
          updateWebAnimation(step);
        } else {
          updateCSSAnimation(toggleAnimationName, step);
        }
        return ani;
      };
      const progressStart = (forceLinearEasing = false, step) => {
        childAnimations.forEach(animation => {
          animation.progressStart(forceLinearEasing, step);
        });
        pauseAnimation();
        shouldForceLinearEasing = forceLinearEasing;
        if (!initialized) {
          initializeAnimation();
        } else {
          update(false, true, step);
        }
        return ani;
      };
      const progressStep = step => {
        childAnimations.forEach(animation => {
          animation.progressStep(step);
        });
        setAnimationStep(step);
        return ani;
      };
      const progressEnd = (playTo, step, dur) => {
        shouldForceLinearEasing = false;
        childAnimations.forEach(animation => {
          animation.progressEnd(playTo, step, dur);
        });
        if (dur !== undefined) {
          forceDurationValue = dur;
        }
        finished = false;
        // tslint:disable-next-line: strict-boolean-conditions
        willComplete = true;
        if (playTo === 0) {
          forceDirectionValue = getDirection() === 'reverse' ? 'normal' : 'reverse';
          if (forceDirectionValue === 'reverse') {
            willComplete = false;
          }
          if (supportsWebAnimations) {
            update();
            setAnimationStep(1 - step);
          } else {
            forceDelayValue = (1 - step) * getDuration() * -1;
            update(false, false);
          }
        } else if (playTo === 1) {
          if (supportsWebAnimations) {
            update();
            setAnimationStep(step);
          } else {
            forceDelayValue = step * getDuration() * -1;
            update(false, false);
          }
        }
        if (playTo !== undefined) {
          onFinish(
            () => {
              forceDurationValue = undefined;
              forceDirectionValue = undefined;
              forceDelayValue = undefined;
            },
            {
              oneTimeCallback: true,
            },
          );
          if (!parentAnimation) {
            play();
          }
        }
        return ani;
      };
      const pauseAnimation = () => {
        if (initialized) {
          if (supportsWebAnimations) {
            webAnimations.forEach(animation => {
              animation.pause();
            });
          } else {
            elements.forEach(element => {
              setStyleProperty(element, 'animation-play-state', 'paused');
            });
          }
        }
      };
      const pause = () => {
        childAnimations.forEach(animation => {
          animation.pause();
        });
        pauseAnimation();
        return ani;
      };
      const onAnimationEndFallback = () => {
        cssAnimationsTimerFallback = undefined;
        animationFinish();
      };
      const clearCSSAnimationsTimeout = () => {
        if (cssAnimationsTimerFallback) {
          clearTimeout(cssAnimationsTimerFallback);
        }
      };
      const playCSSAnimations = () => {
        clearCSSAnimationsTimeout();
        raf(() => {
          elements.forEach(element => {
            if (_keyframes.length > 0) {
              setStyleProperty(element, 'animation-play-state', 'running');
            }
          });
        });
        if (_keyframes.length === 0 || elements.length === 0) {
          animationFinish();
        } else {
          /**
           * This is a catchall in the event that a CSS Animation did not finish.
           * The Web Animations API has mechanisms in place for preventing this.
           * CSS Animations will not fire an `animationend` event
           * for elements with `display: none`. The Web Animations API
           * accounts for this, but using raw CSS Animations requires
           * this workaround.
           */
          const animationDelay = getDelay() || 0;
          const animationDuration = getDuration() || 0;
          const animationIterations = getIterations() || 1;
          // No need to set a timeout when animation has infinite iterations
          if (isFinite(animationIterations)) {
            cssAnimationsTimerFallback = setTimeout(onAnimationEndFallback, animationDelay + animationDuration * animationIterations + ANIMATION_END_FALLBACK_PADDING_MS);
          }
          animationEnd(elements[0], () => {
            clearCSSAnimationsTimeout();
            /**
             * Ensure that clean up
             * is always done a frame
             * before the onFinish handlers
             * are fired. Otherwise, there
             * may be flickering if a new
             * animation is started on the same
             * element too quickly
             *
             * TODO: Is there a cleaner way to do this?
             */
            raf(() => {
              clearCSSAnimationPlayState();
              raf(animationFinish);
            });
          });
        }
      };
      const clearCSSAnimationPlayState = () => {
        elements.forEach(element => {
          removeStyleProperty(element, 'animation-duration');
          removeStyleProperty(element, 'animation-delay');
          removeStyleProperty(element, 'animation-play-state');
        });
      };
      const playWebAnimations = () => {
        webAnimations.forEach(animation => {
          animation.play();
        });
        if (_keyframes.length === 0 || elements.length === 0) {
          animationFinish();
        }
      };
      const resetAnimation = () => {
        if (supportsWebAnimations) {
          setAnimationStep(0);
          updateWebAnimation();
        } else {
          updateCSSAnimation();
        }
      };
      const play = opts => {
        return new Promise(resolve => {
          if (opts && opts.sync) {
            shouldForceSyncPlayback = true;
            onFinish(() => (shouldForceSyncPlayback = false), { oneTimeCallback: true });
          }
          if (!initialized) {
            initializeAnimation();
          }
          if (finished) {
            resetAnimation();
            finished = false;
          }
          if (shouldCalculateNumAnimations) {
            numAnimationsRunning = childAnimations.length + 1;
            shouldCalculateNumAnimations = false;
          }
          onFinish(() => resolve(), { oneTimeCallback: true });
          childAnimations.forEach(animation => {
            animation.play();
          });
          if (supportsWebAnimations) {
            playWebAnimations();
          } else {
            playCSSAnimations();
          }
        });
      };
      const stop = () => {
        childAnimations.forEach(animation => {
          animation.stop();
        });
        if (initialized) {
          cleanUpElements();
          initialized = false;
        }
        resetFlags();
      };
      const from = (property, value) => {
        const firstFrame = _keyframes[0];
        if (firstFrame !== undefined && (firstFrame.offset === undefined || firstFrame.offset === 0)) {
          firstFrame[property] = value;
        } else {
          _keyframes = [{ offset: 0, [property]: value }, ..._keyframes];
        }
        return ani;
      };
      const to = (property, value) => {
        const lastFrame = _keyframes[_keyframes.length - 1];
        if (lastFrame !== undefined && (lastFrame.offset === undefined || lastFrame.offset === 1)) {
          lastFrame[property] = value;
        } else {
          _keyframes = [..._keyframes, { offset: 1, [property]: value }];
        }
        return ani;
      };
      const fromTo = (property, fromValue, toValue) => {
        return from(property, fromValue).to(property, toValue);
      };
      return (ani = {
        parentAnimation,
        elements,
        childAnimations,
        id,
        animationFinish,
        from,
        to,
        fromTo,
        parent,
        play,
        pause,
        stop,
        destroy,
        keyframes,
        addAnimation,
        addElement,
        update,
        fill,
        direction,
        iterations,
        duration,
        easing,
        delay,
        getWebAnimations,
        getKeyframes,
        getFill,
        getDirection,
        getDelay,
        getIterations,
        getEasing,
        getDuration,
        afterAddRead,
        afterAddWrite,
        afterClearStyles,
        afterStyles,
        afterRemoveClass,
        afterAddClass,
        beforeAddRead,
        beforeAddWrite,
        beforeClearStyles,
        beforeStyles,
        beforeRemoveClass,
        beforeAddClass,
        onFinish,
        progressStart,
        progressStep,
        progressEnd,
      });
    };

    /**
     * iOS Action Sheet Enter Animation
     */
    const iosEnterAnimation$6 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      wrapperAnimation.addElement(baseEl.querySelector('.action-sheet-wrapper')).fromTo('transform', 'translateY(100%)', 'translateY(0%)');
      return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * iOS Action Sheet Leave Animation
     */
    const iosLeaveAnimation$6 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);
      wrapperAnimation.addElement(baseEl.querySelector('.action-sheet-wrapper')).fromTo('transform', 'translateY(0%)', 'translateY(100%)');
      return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(450).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * MD Action Sheet Enter Animation
     */
    const mdEnterAnimation$5 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      wrapperAnimation.addElement(baseEl.querySelector('.action-sheet-wrapper')).fromTo('transform', 'translateY(100%)', 'translateY(0%)');
      return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * MD Action Sheet Leave Animation
     */
    const mdLeaveAnimation$5 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);
      wrapperAnimation.addElement(baseEl.querySelector('.action-sheet-wrapper')).fromTo('transform', 'translateY(0%)', 'translateY(100%)');
      return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(450).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    const actionSheetIosCss =
      '.sc-ion-action-sheet-ios-h{--color:initial;--button-color-activated:var(--button-color);--button-color-focused:var(--button-color);--button-color-hover:var(--button-color);--button-color-selected:var(--button-color);--min-width:auto;--width:100%;--max-width:500px;--min-height:auto;--height:100%;--max-height:calc(100% - (var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:block;position:fixed;outline:none;font-family:var(--ion-font-family, inherit);touch-action:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-action-sheet-ios-h{display:none}.action-sheet-wrapper.sc-ion-action-sheet-ios{left:0;right:0;bottom:0;margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;transform:translate3d(0,  100%,  0);display:block;position:absolute;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);z-index:10;pointer-events:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.action-sheet-wrapper.sc-ion-action-sheet-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.action-sheet-button.sc-ion-action-sheet-ios{display:block;position:relative;width:100%;border:0;outline:none;background:var(--button-background);color:var(--button-color);font-family:inherit;overflow:hidden}.action-sheet-button-inner.sc-ion-action-sheet-ios{display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;pointer-events:none;width:100%;height:100%;z-index:1}.action-sheet-container.sc-ion-action-sheet-ios{display:flex;flex-flow:column;justify-content:flex-end;height:100%;max-height:100%}.action-sheet-group.sc-ion-action-sheet-ios{flex-shrink:2;overscroll-behavior-y:contain;overflow-y:auto;-webkit-overflow-scrolling:touch;pointer-events:all;background:var(--background)}.action-sheet-group.sc-ion-action-sheet-ios::-webkit-scrollbar{display:none}.action-sheet-group-cancel.sc-ion-action-sheet-ios{flex-shrink:0;overflow:hidden}.action-sheet-button.sc-ion-action-sheet-ios::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.action-sheet-selected.sc-ion-action-sheet-ios{color:var(--button-color-selected)}.action-sheet-selected.sc-ion-action-sheet-ios::after{background:var(--button-background-selected);opacity:var(--button-background-selected-opacity)}.action-sheet-button.ion-activated.sc-ion-action-sheet-ios{color:var(--button-color-activated)}.action-sheet-button.ion-activated.sc-ion-action-sheet-ios::after{background:var(--button-background-activated);opacity:var(--button-background-activated-opacity)}.action-sheet-button.ion-focused.sc-ion-action-sheet-ios{color:var(--button-color-focused)}.action-sheet-button.ion-focused.sc-ion-action-sheet-ios::after{background:var(--button-background-focused);opacity:var(--button-background-focused-opacity)}@media (any-hover: hover){.action-sheet-button.sc-ion-action-sheet-ios:hover{color:var(--button-color-hover)}.action-sheet-button.sc-ion-action-sheet-ios:hover::after{background:var(--button-background-hover);opacity:var(--button-background-hover-opacity)}}.sc-ion-action-sheet-ios-h{--background:var(--ion-overlay-background-color, var(--ion-color-step-100, #f9f9f9));--backdrop-opacity:var(--ion-backdrop-opacity, 0.4);--button-background:linear-gradient(0deg, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08), rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08) 50%, transparent 50%) bottom/100% 1px no-repeat transparent;--button-background-activated:var(--ion-text-color, #000);--button-background-activated-opacity:.08;--button-background-hover:currentColor;--button-background-hover-opacity:.04;--button-background-focused:currentColor;--button-background-focused-opacity:.12;--button-background-selected:var(--ion-color-step-150, var(--ion-background-color, #fff));--button-background-selected-opacity:1;--button-color:var(--ion-color-primary, #3880ff);--color:var(--ion-color-step-400, #999999);text-align:center}.action-sheet-wrapper.sc-ion-action-sheet-ios{margin-left:auto;margin-right:auto;margin-top:var(--ion-safe-area-top, 0);margin-bottom:var(--ion-safe-area-bottom, 0)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.action-sheet-wrapper.sc-ion-action-sheet-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.action-sheet-container.sc-ion-action-sheet-ios{padding-left:8px;padding-right:8px;padding-top:0;padding-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.action-sheet-container.sc-ion-action-sheet-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px}}.action-sheet-group.sc-ion-action-sheet-ios{border-radius:13px;margin-bottom:8px}.action-sheet-group.sc-ion-action-sheet-ios:first-child{margin-top:10px}.action-sheet-group.sc-ion-action-sheet-ios:last-child{margin-bottom:10px}@supports (backdrop-filter: blur(0)){.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-group.sc-ion-action-sheet-ios{background-color:transparent;backdrop-filter:saturate(280%) blur(20px)}.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-title.sc-ion-action-sheet-ios,.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-button.sc-ion-action-sheet-ios{background-color:transparent;background-image:linear-gradient(0deg, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8), rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8) 100%), linear-gradient(0deg, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.4), rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.4) 50%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8) 50%);background-repeat:no-repeat;background-position:top, bottom;background-size:100% calc(100% - 1px), 100% 1px;backdrop-filter:saturate(120%)}.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-button.ion-activated.sc-ion-action-sheet-ios{background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.7);background-image:none}.action-sheet-translucent.sc-ion-action-sheet-ios-h .action-sheet-cancel.sc-ion-action-sheet-ios{background:var(--button-background-selected)}}.action-sheet-title.sc-ion-action-sheet-ios{background:linear-gradient(0deg, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08), rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.08) 50%, transparent 50%) bottom/100% 1px no-repeat transparent}.action-sheet-title.sc-ion-action-sheet-ios{padding-left:10px;padding-right:10px;padding-top:14px;padding-bottom:13px;color:var(--color, var(--ion-color-step-400, #999999));font-size:13px;font-weight:400;text-align:center}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.action-sheet-title.sc-ion-action-sheet-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:10px;padding-inline-start:10px;-webkit-padding-end:10px;padding-inline-end:10px}}.action-sheet-title.action-sheet-has-sub-title.sc-ion-action-sheet-ios{font-weight:600}.action-sheet-sub-title.sc-ion-action-sheet-ios{padding-left:0;padding-right:0;padding-top:6px;padding-bottom:0;font-size:13px;font-weight:400}.action-sheet-button.sc-ion-action-sheet-ios{padding-left:18px;padding-right:18px;padding-top:18px;padding-bottom:18px;height:56px;font-size:20px;contain:strict}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.action-sheet-button.sc-ion-action-sheet-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:18px;padding-inline-start:18px;-webkit-padding-end:18px;padding-inline-end:18px}}.action-sheet-button.sc-ion-action-sheet-ios .action-sheet-icon.sc-ion-action-sheet-ios{margin-right:0.3em;font-size:28px;pointer-events:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.action-sheet-button.sc-ion-action-sheet-ios .action-sheet-icon.sc-ion-action-sheet-ios{margin-right:unset;-webkit-margin-end:0.3em;margin-inline-end:0.3em}}.action-sheet-button.sc-ion-action-sheet-ios:last-child{background-image:none}.action-sheet-selected.sc-ion-action-sheet-ios{font-weight:bold}.action-sheet-cancel.sc-ion-action-sheet-ios{font-weight:600}.action-sheet-cancel.sc-ion-action-sheet-ios::after{background:var(--button-background-selected);opacity:var(--button-background-selected-opacity)}.action-sheet-destructive.sc-ion-action-sheet-ios,.action-sheet-destructive.ion-activated.sc-ion-action-sheet-ios,.action-sheet-destructive.ion-focused.sc-ion-action-sheet-ios{color:var(--ion-color-danger, #eb445a)}@media (any-hover: hover){.action-sheet-destructive.sc-ion-action-sheet-ios:hover{color:var(--ion-color-danger, #eb445a)}}';

    const actionSheetMdCss =
      '.sc-ion-action-sheet-md-h{--color:initial;--button-color-activated:var(--button-color);--button-color-focused:var(--button-color);--button-color-hover:var(--button-color);--button-color-selected:var(--button-color);--min-width:auto;--width:100%;--max-width:500px;--min-height:auto;--height:100%;--max-height:calc(100% - (var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:block;position:fixed;outline:none;font-family:var(--ion-font-family, inherit);touch-action:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-action-sheet-md-h{display:none}.action-sheet-wrapper.sc-ion-action-sheet-md{left:0;right:0;bottom:0;margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;transform:translate3d(0,  100%,  0);display:block;position:absolute;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);z-index:10;pointer-events:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.action-sheet-wrapper.sc-ion-action-sheet-md{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.action-sheet-button.sc-ion-action-sheet-md{display:block;position:relative;width:100%;border:0;outline:none;background:var(--button-background);color:var(--button-color);font-family:inherit;overflow:hidden}.action-sheet-button-inner.sc-ion-action-sheet-md{display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;pointer-events:none;width:100%;height:100%;z-index:1}.action-sheet-container.sc-ion-action-sheet-md{display:flex;flex-flow:column;justify-content:flex-end;height:100%;max-height:100%}.action-sheet-group.sc-ion-action-sheet-md{flex-shrink:2;overscroll-behavior-y:contain;overflow-y:auto;-webkit-overflow-scrolling:touch;pointer-events:all;background:var(--background)}.action-sheet-group.sc-ion-action-sheet-md::-webkit-scrollbar{display:none}.action-sheet-group-cancel.sc-ion-action-sheet-md{flex-shrink:0;overflow:hidden}.action-sheet-button.sc-ion-action-sheet-md::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}.action-sheet-selected.sc-ion-action-sheet-md{color:var(--button-color-selected)}.action-sheet-selected.sc-ion-action-sheet-md::after{background:var(--button-background-selected);opacity:var(--button-background-selected-opacity)}.action-sheet-button.ion-activated.sc-ion-action-sheet-md{color:var(--button-color-activated)}.action-sheet-button.ion-activated.sc-ion-action-sheet-md::after{background:var(--button-background-activated);opacity:var(--button-background-activated-opacity)}.action-sheet-button.ion-focused.sc-ion-action-sheet-md{color:var(--button-color-focused)}.action-sheet-button.ion-focused.sc-ion-action-sheet-md::after{background:var(--button-background-focused);opacity:var(--button-background-focused-opacity)}@media (any-hover: hover){.action-sheet-button.sc-ion-action-sheet-md:hover{color:var(--button-color-hover)}.action-sheet-button.sc-ion-action-sheet-md:hover::after{background:var(--button-background-hover);opacity:var(--button-background-hover-opacity)}}.sc-ion-action-sheet-md-h{--background:var(--ion-overlay-background-color, var(--ion-background-color, #fff));--backdrop-opacity:var(--ion-backdrop-opacity, 0.32);--button-background:transparent;--button-background-selected:currentColor;--button-background-selected-opacity:0;--button-background-activated:transparent;--button-background-activated-opacity:0;--button-background-hover:currentColor;--button-background-hover-opacity:.04;--button-background-focused:currentColor;--button-background-focused-opacity:.12;--button-color:var(--ion-color-step-850, #262626);--color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54)}.action-sheet-title.sc-ion-action-sheet-md{padding-left:16px;padding-right:16px;padding-top:20px;padding-bottom:17px;min-height:60px;color:var(--color, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54));font-size:16px;text-align:start}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.action-sheet-title.sc-ion-action-sheet-md{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.action-sheet-sub-title.sc-ion-action-sheet-md{padding-left:0;padding-right:0;padding-top:16px;padding-bottom:0;font-size:14px}.action-sheet-group.sc-ion-action-sheet-md:first-child{padding-top:0}.action-sheet-group.sc-ion-action-sheet-md:last-child{padding-bottom:0}.action-sheet-button.sc-ion-action-sheet-md{padding-left:16px;padding-right:16px;padding-top:0;padding-bottom:0;position:relative;height:52px;font-size:16px;text-align:start;contain:strict;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.action-sheet-button.sc-ion-action-sheet-md{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.action-sheet-icon.sc-ion-action-sheet-md{padding-bottom:4px;margin-left:0;margin-right:32px;margin-top:0;margin-bottom:0;color:var(--color);font-size:24px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.action-sheet-icon.sc-ion-action-sheet-md{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:32px;margin-inline-end:32px}}.action-sheet-button-inner.sc-ion-action-sheet-md{justify-content:flex-start}.action-sheet-selected.sc-ion-action-sheet-md{font-weight:bold}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class ActionSheet {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.didPresent = createEvent(this, 'ionActionSheetDidPresent', 7);
        this.willPresent = createEvent(this, 'ionActionSheetWillPresent', 7);
        this.willDismiss = createEvent(this, 'ionActionSheetWillDismiss', 7);
        this.didDismiss = createEvent(this, 'ionActionSheetDidDismiss', 7);
        this.presented = false;
        /**
         * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
         */
        this.keyboardClose = true;
        /**
         * An array of buttons for the action sheet.
         */
        this.buttons = [];
        /**
         * If `true`, the action sheet will be dismissed when the backdrop is clicked.
         */
        this.backdropDismiss = true;
        /**
         * If `true`, the action sheet will be translucent.
         * Only applies when the mode is `"ios"` and the device supports
         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
         */
        this.translucent = false;
        /**
         * If `true`, the action sheet will animate.
         */
        this.animated = true;
        this.onBackdropTap = () => {
          this.dismiss(undefined, BACKDROP);
        };
        this.dispatchCancelHandler = ev => {
          const role = ev.detail.role;
          if (isCancel(role)) {
            const cancelButton = this.getButtons().find(b => b.role === 'cancel');
            this.callButtonHandler(cancelButton);
          }
        };
      }
      /**
       * Present the action sheet overlay after it has been created.
       */
      present() {
        return present(this, 'actionSheetEnter', iosEnterAnimation$6, mdEnterAnimation$5);
      }
      connectedCallback() {
        prepareOverlay(this.el);
      }
      /**
       * Dismiss the action sheet overlay after it has been presented.
       *
       * @param data Any data to emit in the dismiss events.
       * @param role The role of the element that is dismissing the action sheet.
       * This can be useful in a button handler for determining which button was
       * clicked to dismiss the action sheet.
       * Some examples include: ``"cancel"`, `"destructive"`, "selected"`, and `"backdrop"`.
       */
      dismiss(data, role) {
        return dismiss(this, data, role, 'actionSheetLeave', iosLeaveAnimation$6, mdLeaveAnimation$5);
      }
      /**
       * Returns a promise that resolves when the action sheet did dismiss.
       */
      onDidDismiss() {
        return eventMethod(this.el, 'ionActionSheetDidDismiss');
      }
      /**
       * Returns a promise that resolves when the action sheet will dismiss.
       *
       */
      onWillDismiss() {
        return eventMethod(this.el, 'ionActionSheetWillDismiss');
      }
      async buttonClick(button) {
        const role = button.role;
        if (isCancel(role)) {
          return this.dismiss(undefined, role);
        }
        const shouldDismiss = await this.callButtonHandler(button);
        if (shouldDismiss) {
          return this.dismiss(undefined, button.role);
        }
        return Promise.resolve();
      }
      async callButtonHandler(button) {
        if (button) {
          // a handler has been provided, execute it
          // pass the handler the values from the inputs
          const rtn = await safeCall(button.handler);
          if (rtn === false) {
            // if the return value of the handler is false then do not dismiss
            return false;
          }
        }
        return true;
      }
      getButtons() {
        return this.buttons.map(b => {
          return typeof b === 'string' ? { text: b } : b;
        });
      }
      disconnectedCallback() {
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
      }
      componentDidLoad() {
        /**
         * Do not create gesture if:
         * 1. A gesture already exists
         * 2. App is running in MD mode
         * 3. A wrapper ref does not exist
         */
        const { groupEl, wrapperEl } = this;
        if (this.gesture || getIonMode$1(this) === 'md' || !wrapperEl || !groupEl) {
          return;
        }
        readTask(() => {
          const isScrollable = groupEl.scrollHeight > groupEl.clientHeight;
          if (!isScrollable) {
            this.gesture = createButtonActiveGesture(wrapperEl, refEl => refEl.classList.contains('action-sheet-button'));
            this.gesture.enable(true);
          }
        });
      }
      render() {
        const { htmlAttributes } = this;
        const mode = getIonMode$1(this);
        const allButtons = this.getButtons();
        const cancelButton = allButtons.find(b => b.role === 'cancel');
        const buttons = allButtons.filter(b => b.role !== 'cancel');
        return hAsync(
          Host,
          Object.assign({ 'role': 'dialog', 'aria-modal': 'true', 'tabindex': '-1' }, htmlAttributes, {
            style: {
              zIndex: `${20000 + this.overlayIndex}`,
            },
            class: Object.assign(Object.assign({ [mode]: true }, getClassMap(this.cssClass)), { 'action-sheet-translucent': this.translucent }),
            onIonActionSheetWillDismiss: this.dispatchCancelHandler,
            onIonBackdropTap: this.onBackdropTap,
          }),
          hAsync('ion-backdrop', { tappable: this.backdropDismiss }),
          hAsync('div', { tabindex: '0' }),
          hAsync(
            'div',
            { class: 'action-sheet-wrapper ion-overlay-wrapper', role: 'dialog', ref: el => (this.wrapperEl = el) },
            hAsync(
              'div',
              { class: 'action-sheet-container' },
              hAsync(
                'div',
                { class: 'action-sheet-group', ref: el => (this.groupEl = el) },
                this.header !== undefined &&
                  hAsync(
                    'div',
                    {
                      class: {
                        'action-sheet-title': true,
                        'action-sheet-has-sub-title': this.subHeader !== undefined,
                      },
                    },
                    this.header,
                    this.subHeader && hAsync('div', { class: 'action-sheet-sub-title' }, this.subHeader),
                  ),
                buttons.map(b =>
                  hAsync(
                    'button',
                    { type: 'button', class: buttonClass$3(b), onClick: () => this.buttonClick(b) },
                    hAsync('span', { class: 'action-sheet-button-inner' }, b.icon && hAsync('ion-icon', { icon: b.icon, lazy: false, class: 'action-sheet-icon' }), b.text),
                    mode === 'md' && hAsync('ion-ripple-effect', null),
                  ),
                ),
              ),
              cancelButton &&
                hAsync(
                  'div',
                  { class: 'action-sheet-group action-sheet-group-cancel' },
                  hAsync(
                    'button',
                    { type: 'button', class: buttonClass$3(cancelButton), onClick: () => this.buttonClick(cancelButton) },
                    hAsync(
                      'span',
                      { class: 'action-sheet-button-inner' },
                      cancelButton.icon && hAsync('ion-icon', { icon: cancelButton.icon, lazy: false, class: 'action-sheet-icon' }),
                      cancelButton.text,
                    ),
                    mode === 'md' && hAsync('ion-ripple-effect', null),
                  ),
                ),
            ),
          ),
          hAsync('div', { tabindex: '0' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: actionSheetIosCss,
          md: actionSheetMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-action-sheet',
          $members$: {
            overlayIndex: [2, 'overlay-index'],
            keyboardClose: [4, 'keyboard-close'],
            enterAnimation: [16],
            leaveAnimation: [16],
            buttons: [16],
            cssClass: [1, 'css-class'],
            backdropDismiss: [4, 'backdrop-dismiss'],
            header: [1],
            subHeader: [1, 'sub-header'],
            translucent: [4],
            animated: [4],
            htmlAttributes: [16],
            present: [64],
            dismiss: [64],
            onDidDismiss: [64],
            onWillDismiss: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const buttonClass$3 = button => {
      return Object.assign(
        { 'action-sheet-button': true, 'ion-activatable': true, 'ion-focusable': true, [`action-sheet-${button.role}`]: button.role !== undefined },
        getClassMap(button.cssClass),
      );
    };

    /**
     * Does a simple sanitization of all elements
     * in an untrusted string
     */
    const sanitizeDOMString = untrustedString => {
      try {
        if (untrustedString instanceof IonicSafeString) {
          return untrustedString.value;
        }
        if (!isSanitizerEnabled() || typeof untrustedString !== 'string' || untrustedString === '') {
          return untrustedString;
        }
        /**
         * Create a document fragment
         * separate from the main DOM,
         * create a div to do our work in
         */
        const documentFragment = document.createDocumentFragment();
        const workingDiv = document.createElement('div');
        documentFragment.appendChild(workingDiv);
        workingDiv.innerHTML = untrustedString;
        /**
         * Remove any elements
         * that are blocked
         */
        blockedTags.forEach(blockedTag => {
          const getElementsToRemove = documentFragment.querySelectorAll(blockedTag);
          for (let elementIndex = getElementsToRemove.length - 1; elementIndex >= 0; elementIndex--) {
            const element = getElementsToRemove[elementIndex];
            if (element.parentNode) {
              element.parentNode.removeChild(element);
            } else {
              documentFragment.removeChild(element);
            }
            /**
             * We still need to sanitize
             * the children of this element
             * as they are left behind
             */
            const childElements = getElementChildren(element);
            /* tslint:disable-next-line */
            for (let childIndex = 0; childIndex < childElements.length; childIndex++) {
              sanitizeElement(childElements[childIndex]);
            }
          }
        });
        /**
         * Go through remaining elements and remove
         * non-allowed attribs
         */
        // IE does not support .children on document fragments, only .childNodes
        const dfChildren = getElementChildren(documentFragment);
        /* tslint:disable-next-line */
        for (let childIndex = 0; childIndex < dfChildren.length; childIndex++) {
          sanitizeElement(dfChildren[childIndex]);
        }
        // Append document fragment to div
        const fragmentDiv = document.createElement('div');
        fragmentDiv.appendChild(documentFragment);
        // First child is always the div we did our work in
        const getInnerDiv = fragmentDiv.querySelector('div');
        return getInnerDiv !== null ? getInnerDiv.innerHTML : fragmentDiv.innerHTML;
      } catch (err) {
        console.error(err);
        return '';
      }
    };
    /**
     * Clean up current element based on allowed attributes
     * and then recursively dig down into any child elements to
     * clean those up as well
     */
    const sanitizeElement = element => {
      // IE uses childNodes, so ignore nodes that are not elements
      if (element.nodeType && element.nodeType !== 1) {
        return;
      }
      for (let i = element.attributes.length - 1; i >= 0; i--) {
        const attribute = element.attributes.item(i);
        const attributeName = attribute.name;
        // remove non-allowed attribs
        if (!allowedAttributes.includes(attributeName.toLowerCase())) {
          element.removeAttribute(attributeName);
          continue;
        }
        // clean up any allowed attribs
        // that attempt to do any JS funny-business
        const attributeValue = attribute.value;
        /* tslint:disable-next-line */
        if (attributeValue != null && attributeValue.toLowerCase().includes('javascript:')) {
          element.removeAttribute(attributeName);
        }
      }
      /**
       * Sanitize any nested children
       */
      const childElements = getElementChildren(element);
      /* tslint:disable-next-line */
      for (let i = 0; i < childElements.length; i++) {
        sanitizeElement(childElements[i]);
      }
    };
    /**
     * IE doesn't always support .children
     * so we revert to .childNodes instead
     */
    const getElementChildren = el => {
      return el.children != null ? el.children : el.childNodes;
    };
    const isSanitizerEnabled = () => {
      const win = window;
      const config = win && win.Ionic && win.Ionic.config;
      if (config) {
        if (config.get) {
          return config.get('sanitizerEnabled', true);
        } else {
          return config.sanitizerEnabled === true || config.sanitizerEnabled === undefined;
        }
      }
      return true;
    };
    const allowedAttributes = ['class', 'id', 'href', 'src', 'name', 'slot'];
    const blockedTags = ['script', 'style', 'iframe', 'meta', 'link', 'object', 'embed'];
    class IonicSafeString {
      constructor(value) {
        this.value = value;
      }
    }

    /**
     * iOS Alert Enter Animation
     */
    const iosEnterAnimation$5 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      wrapperAnimation.addElement(baseEl.querySelector('.alert-wrapper')).keyframes([
        { offset: 0, opacity: '0.01', transform: 'scale(1.1)' },
        { offset: 1, opacity: '1', transform: 'scale(1)' },
      ]);
      return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * iOS Alert Leave Animation
     */
    const iosLeaveAnimation$5 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);
      wrapperAnimation.addElement(baseEl.querySelector('.alert-wrapper')).keyframes([
        { offset: 0, opacity: 0.99, transform: 'scale(1)' },
        { offset: 1, opacity: 0, transform: 'scale(0.9)' },
      ]);
      return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * Md Alert Enter Animation
     */
    const mdEnterAnimation$4 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      wrapperAnimation.addElement(baseEl.querySelector('.alert-wrapper')).keyframes([
        { offset: 0, opacity: '0.01', transform: 'scale(0.9)' },
        { offset: 1, opacity: '1', transform: 'scale(1)' },
      ]);
      return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(150).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * Md Alert Leave Animation
     */
    const mdLeaveAnimation$4 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);
      wrapperAnimation.addElement(baseEl.querySelector('.alert-wrapper')).fromTo('opacity', 0.99, 0);
      return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(150).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    const alertIosCss =
      '.sc-ion-alert-ios-h{--min-width:250px;--width:auto;--min-height:auto;--height:auto;--max-height:90%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:flex;position:absolute;align-items:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;touch-action:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-alert-ios-h{display:none}.alert-top.sc-ion-alert-ios-h{padding-top:50px;align-items:flex-start}.alert-wrapper.sc-ion-alert-ios{display:flex;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:content;opacity:0;z-index:10}.alert-title.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-sub-title.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-weight:normal}.alert-message.sc-ion-alert-ios{box-sizing:border-box;-webkit-overflow-scrolling:touch;overflow-y:auto;overscroll-behavior-y:contain}.alert-checkbox-group.sc-ion-alert-ios::-webkit-scrollbar,.alert-radio-group.sc-ion-alert-ios::-webkit-scrollbar,.alert-message.sc-ion-alert-ios::-webkit-scrollbar{display:none}.alert-input.sc-ion-alert-ios{padding-left:0;padding-right:0;padding-top:10px;padding-bottom:10px;width:100%;border:0;background:inherit;font:inherit;box-sizing:border-box}.alert-button-group.sc-ion-alert-ios{display:flex;flex-direction:row;width:100%}.alert-button-group-vertical.sc-ion-alert-ios{flex-direction:column;flex-wrap:nowrap}.alert-button.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;border:0;font-size:14px;line-height:20px;z-index:0}.alert-button.ion-focused.sc-ion-alert-ios,.alert-tappable.ion-focused.sc-ion-alert-ios{background:var(--ion-color-step-100, #e6e6e6)}.alert-button-inner.sc-ion-alert-ios{display:flex;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%}.alert-input-disabled.sc-ion-alert-ios,.alert-checkbox-button-disabled.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios,.alert-radio-button-disabled.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios{cursor:default;opacity:0.5;pointer-events:none}.alert-tappable.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:flex;width:100%;border:0;background:transparent;font-size:inherit;line-height:initial;text-align:start;appearance:none;contain:strict}.alert-button.sc-ion-alert-ios,.alert-checkbox.sc-ion-alert-ios,.alert-input.sc-ion-alert-ios,.alert-radio.sc-ion-alert-ios{outline:none}.alert-radio-icon.sc-ion-alert-ios,.alert-checkbox-icon.sc-ion-alert-ios,.alert-checkbox-inner.sc-ion-alert-ios{box-sizing:border-box}textarea.alert-input.sc-ion-alert-ios{min-height:37px;resize:none}.sc-ion-alert-ios-h{--background:var(--ion-overlay-background-color, var(--ion-color-step-100, #f9f9f9));--max-width:270px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.3);font-size:14px}.alert-wrapper.sc-ion-alert-ios{border-radius:13px;box-shadow:none;overflow:hidden}.alert-button.sc-ion-alert-ios .alert-button-inner.sc-ion-alert-ios{pointer-events:none}@supports (backdrop-filter: blur(0)){.alert-translucent.sc-ion-alert-ios-h .alert-wrapper.sc-ion-alert-ios{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.9);backdrop-filter:saturate(180%) blur(20px)}}.alert-head.sc-ion-alert-ios{padding-left:16px;padding-right:16px;padding-top:12px;padding-bottom:7px;text-align:center}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-head.sc-ion-alert-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.alert-title.sc-ion-alert-ios{margin-top:8px;color:var(--ion-text-color, #000);font-size:17px;font-weight:600}.alert-sub-title.sc-ion-alert-ios{color:var(--ion-color-step-600, #666666);font-size:14px}.alert-message.sc-ion-alert-ios,.alert-input-group.sc-ion-alert-ios{padding-left:16px;padding-right:16px;padding-top:0;padding-bottom:21px;color:var(--ion-text-color, #000);font-size:13px;text-align:center}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-message.sc-ion-alert-ios,.alert-input-group.sc-ion-alert-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.alert-message.sc-ion-alert-ios{max-height:240px}.alert-message.sc-ion-alert-ios:empty{padding-left:0;padding-right:0;padding-top:0;padding-bottom:12px}.alert-input.sc-ion-alert-ios{border-radius:4px;margin-top:10px;padding-left:6px;padding-right:6px;padding-top:6px;padding-bottom:6px;border:0.55px solid var(--ion-color-step-250, #bfbfbf);background-color:var(--ion-background-color, #fff);appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-input.sc-ion-alert-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px}}.alert-input.sc-ion-alert-ios::placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-ios::-ms-clear{display:none}.alert-radio-group.sc-ion-alert-ios,.alert-checkbox-group.sc-ion-alert-ios{overscroll-behavior:contain;max-height:240px;border-top:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);overflow-y:auto;-webkit-overflow-scrolling:touch}.alert-tappable.sc-ion-alert-ios{height:44px}.alert-radio-label.sc-ion-alert-ios{padding-left:13px;padding-right:13px;padding-top:13px;padding-bottom:13px;flex:1;order:0;color:var(--ion-text-color, #000);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-radio-label.sc-ion-alert-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:13px;padding-inline-start:13px;-webkit-padding-end:13px;padding-inline-end:13px}}[aria-checked=true].sc-ion-alert-ios .alert-radio-label.sc-ion-alert-ios{color:var(--ion-color-primary, #3880ff)}.alert-radio-icon.sc-ion-alert-ios{position:relative;order:1;min-width:30px}[aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{left:7px;top:-7px;position:absolute;width:6px;height:12px;transform:rotate(45deg);border-width:2px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-color-primary, #3880ff)}[dir=rtl].sc-ion-alert-ios [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios,[dir=rtl].sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios,[dir=rtl] .sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-radio-inner.sc-ion-alert-ios{left:unset;right:unset;right:7px}.alert-checkbox-label.sc-ion-alert-ios{padding-left:13px;padding-right:13px;padding-top:13px;padding-bottom:13px;flex:1;color:var(--ion-text-color, #000);text-overflow:ellipsis;white-space:nowrap;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-checkbox-label.sc-ion-alert-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:13px;padding-inline-start:13px;-webkit-padding-end:13px;padding-inline-end:13px}}.alert-checkbox-icon.sc-ion-alert-ios{border-radius:50%;margin-left:16px;margin-right:6px;margin-top:10px;margin-bottom:10px;position:relative;width:24px;height:24px;border-width:1px;border-style:solid;border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));background-color:var(--ion-item-background, var(--ion-background-color, #fff));contain:strict}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-checkbox-icon.sc-ion-alert-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:6px;margin-inline-end:6px}}[aria-checked=true].sc-ion-alert-ios .alert-checkbox-icon.sc-ion-alert-ios{border-color:var(--ion-color-primary, #3880ff);background-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{left:9px;top:4px;position:absolute;width:5px;height:12px;transform:rotate(45deg);border-width:1px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-background-color, #fff)}[dir=rtl].sc-ion-alert-ios [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios,[dir=rtl].sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios,[dir=rtl] .sc-ion-alert-ios-h [aria-checked=true].sc-ion-alert-ios .alert-checkbox-inner.sc-ion-alert-ios{left:unset;right:unset;right:9px}.alert-button-group.sc-ion-alert-ios{margin-right:-0.55px;flex-wrap:wrap}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-button-group.sc-ion-alert-ios{margin-right:unset;-webkit-margin-end:-0.55px;margin-inline-end:-0.55px}}.alert-button.sc-ion-alert-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border-radius:0;flex:1 1 auto;min-width:50%;height:44px;border-top:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2);background-color:transparent;color:var(--ion-color-primary, #3880ff);font-size:17px;overflow:hidden}[dir=rtl].sc-ion-alert-ios .alert-button.sc-ion-alert-ios:first-child,[dir=rtl].sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:first-child,[dir=rtl] .sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:first-child{border-right:0}.alert-button.sc-ion-alert-ios:last-child{border-right:0;font-weight:bold}[dir=rtl].sc-ion-alert-ios .alert-button.sc-ion-alert-ios:last-child,[dir=rtl].sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:last-child,[dir=rtl] .sc-ion-alert-ios-h .alert-button.sc-ion-alert-ios:last-child{border-right:0.55px solid rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2)}.alert-button.ion-activated.sc-ion-alert-ios{background-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1)}.alert-button-role-destructive.sc-ion-alert-ios,.alert-button-role-destructive.ion-activated.sc-ion-alert-ios,.alert-button-role-destructive.ion-focused.sc-ion-alert-ios{color:var(--ion-color-danger, #eb445a)}';

    const alertMdCss =
      '.sc-ion-alert-md-h{--min-width:250px;--width:auto;--min-height:auto;--height:auto;--max-height:90%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:flex;position:absolute;align-items:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;touch-action:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-alert-md-h{display:none}.alert-top.sc-ion-alert-md-h{padding-top:50px;align-items:flex-start}.alert-wrapper.sc-ion-alert-md{display:flex;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:content;opacity:0;z-index:10}.alert-title.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-sub-title.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-weight:normal}.alert-message.sc-ion-alert-md{box-sizing:border-box;-webkit-overflow-scrolling:touch;overflow-y:auto;overscroll-behavior-y:contain}.alert-checkbox-group.sc-ion-alert-md::-webkit-scrollbar,.alert-radio-group.sc-ion-alert-md::-webkit-scrollbar,.alert-message.sc-ion-alert-md::-webkit-scrollbar{display:none}.alert-input.sc-ion-alert-md{padding-left:0;padding-right:0;padding-top:10px;padding-bottom:10px;width:100%;border:0;background:inherit;font:inherit;box-sizing:border-box}.alert-button-group.sc-ion-alert-md{display:flex;flex-direction:row;width:100%}.alert-button-group-vertical.sc-ion-alert-md{flex-direction:column;flex-wrap:nowrap}.alert-button.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;border:0;font-size:14px;line-height:20px;z-index:0}.alert-button.ion-focused.sc-ion-alert-md,.alert-tappable.ion-focused.sc-ion-alert-md{background:var(--ion-color-step-100, #e6e6e6)}.alert-button-inner.sc-ion-alert-md{display:flex;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%}.alert-input-disabled.sc-ion-alert-md,.alert-checkbox-button-disabled.sc-ion-alert-md .alert-button-inner.sc-ion-alert-md,.alert-radio-button-disabled.sc-ion-alert-md .alert-button-inner.sc-ion-alert-md{cursor:default;opacity:0.5;pointer-events:none}.alert-tappable.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:flex;width:100%;border:0;background:transparent;font-size:inherit;line-height:initial;text-align:start;appearance:none;contain:strict}.alert-button.sc-ion-alert-md,.alert-checkbox.sc-ion-alert-md,.alert-input.sc-ion-alert-md,.alert-radio.sc-ion-alert-md{outline:none}.alert-radio-icon.sc-ion-alert-md,.alert-checkbox-icon.sc-ion-alert-md,.alert-checkbox-inner.sc-ion-alert-md{box-sizing:border-box}textarea.alert-input.sc-ion-alert-md{min-height:37px;resize:none}.sc-ion-alert-md-h{--background:var(--ion-overlay-background-color, var(--ion-background-color, #fff));--max-width:280px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.32);font-size:14px}.alert-wrapper.sc-ion-alert-md{border-radius:4px;box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14), 0 9px 46px 8px rgba(0, 0, 0, 0.12)}.alert-head.sc-ion-alert-md{padding-left:23px;padding-right:23px;padding-top:20px;padding-bottom:15px;text-align:start}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-head.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:23px;padding-inline-start:23px;-webkit-padding-end:23px;padding-inline-end:23px}}.alert-title.sc-ion-alert-md{color:var(--ion-text-color, #000);font-size:20px;font-weight:500}.alert-sub-title.sc-ion-alert-md{color:var(--ion-text-color, #000);font-size:16px}.alert-message.sc-ion-alert-md,.alert-input-group.sc-ion-alert-md{padding-left:24px;padding-right:24px;padding-top:20px;padding-bottom:20px;color:var(--ion-color-step-550, #737373)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-message.sc-ion-alert-md,.alert-input-group.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:24px;padding-inline-start:24px;-webkit-padding-end:24px;padding-inline-end:24px}}.alert-message.sc-ion-alert-md{max-height:266px;font-size:16px}.alert-message.sc-ion-alert-md:empty{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}.alert-head.sc-ion-alert-md+.alert-message.sc-ion-alert-md{padding-top:0}.alert-input.sc-ion-alert-md{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:5px;border-bottom:1px solid var(--ion-color-step-150, #d9d9d9);color:var(--ion-text-color, #000)}.alert-input.sc-ion-alert-md::placeholder{color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));font-family:inherit;font-weight:inherit}.alert-input.sc-ion-alert-md::-ms-clear{display:none}.alert-input.sc-ion-alert-md:focus{margin-bottom:4px;border-bottom:2px solid var(--ion-color-primary, #3880ff)}.alert-radio-group.sc-ion-alert-md,.alert-checkbox-group.sc-ion-alert-md{position:relative;max-height:266px;border-top:1px solid var(--ion-color-step-150, #d9d9d9);border-bottom:1px solid var(--ion-color-step-150, #d9d9d9);overflow:auto}.alert-tappable.sc-ion-alert-md{position:relative;height:48px;overflow:hidden}.alert-radio-label.sc-ion-alert-md{padding-left:52px;padding-right:26px;padding-top:13px;padding-bottom:13px;flex:1;color:var(--ion-color-step-850, #262626);font-size:16px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-radio-label.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:52px;padding-inline-start:52px;-webkit-padding-end:26px;padding-inline-end:26px}}.alert-radio-icon.sc-ion-alert-md{left:26px;top:0;border-radius:50%;display:block;position:relative;width:20px;height:20px;border-width:2px;border-style:solid;border-color:var(--ion-color-step-550, #737373)}[dir=rtl].sc-ion-alert-md .alert-radio-icon.sc-ion-alert-md,[dir=rtl].sc-ion-alert-md-h .alert-radio-icon.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-radio-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}.alert-radio-inner.sc-ion-alert-md{left:3px;top:3px;border-radius:50%;position:absolute;width:10px;height:10px;transform:scale3d(0, 0, 0);transition:transform 280ms cubic-bezier(0.4, 0, 0.2, 1);background-color:var(--ion-color-primary, #3880ff)}[dir=rtl].sc-ion-alert-md .alert-radio-inner.sc-ion-alert-md,[dir=rtl].sc-ion-alert-md-h .alert-radio-inner.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-radio-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}[aria-checked=true].sc-ion-alert-md .alert-radio-label.sc-ion-alert-md{color:var(--ion-color-step-850, #262626)}[aria-checked=true].sc-ion-alert-md .alert-radio-icon.sc-ion-alert-md{border-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-md .alert-radio-inner.sc-ion-alert-md{transform:scale3d(1, 1, 1)}.alert-checkbox-label.sc-ion-alert-md{padding-left:53px;padding-right:26px;padding-top:13px;padding-bottom:13px;flex:1;color:var(--ion-color-step-850, #262626);font-size:16px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-checkbox-label.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:53px;padding-inline-start:53px;-webkit-padding-end:26px;padding-inline-end:26px}}.alert-checkbox-icon.sc-ion-alert-md{left:26px;top:0;border-radius:2px;position:relative;width:16px;height:16px;border-width:2px;border-style:solid;border-color:var(--ion-color-step-550, #737373);contain:strict}[dir=rtl].sc-ion-alert-md .alert-checkbox-icon.sc-ion-alert-md,[dir=rtl].sc-ion-alert-md-h .alert-checkbox-icon.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h .alert-checkbox-icon.sc-ion-alert-md{left:unset;right:unset;right:26px}[aria-checked=true].sc-ion-alert-md .alert-checkbox-icon.sc-ion-alert-md{border-color:var(--ion-color-primary, #3880ff);background-color:var(--ion-color-primary, #3880ff)}[aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{left:3px;top:0;position:absolute;width:6px;height:10px;transform:rotate(45deg);border-width:2px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--ion-color-primary-contrast, #fff)}[dir=rtl].sc-ion-alert-md [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md,[dir=rtl].sc-ion-alert-md-h [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md,[dir=rtl] .sc-ion-alert-md-h [aria-checked=true].sc-ion-alert-md .alert-checkbox-inner.sc-ion-alert-md{left:unset;right:unset;right:3px}.alert-button-group.sc-ion-alert-md{padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:8px;box-sizing:border-box;flex-wrap:wrap-reverse;justify-content:flex-end}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-button-group.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px}}.alert-button.sc-ion-alert-md{border-radius:2px;margin-left:0;margin-right:8px;margin-top:0;margin-bottom:0;padding-left:10px;padding-right:10px;padding-top:10px;padding-bottom:10px;position:relative;background-color:transparent;color:var(--ion-color-primary, #3880ff);font-weight:500;text-align:end;text-transform:uppercase;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-button.sc-ion-alert-md{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.alert-button.sc-ion-alert-md{padding-left:unset;padding-right:unset;-webkit-padding-start:10px;padding-inline-start:10px;-webkit-padding-end:10px;padding-inline-end:10px}}.alert-button-inner.sc-ion-alert-md{justify-content:flex-end}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Alert {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.didPresent = createEvent(this, 'ionAlertDidPresent', 7);
        this.willPresent = createEvent(this, 'ionAlertWillPresent', 7);
        this.willDismiss = createEvent(this, 'ionAlertWillDismiss', 7);
        this.didDismiss = createEvent(this, 'ionAlertDidDismiss', 7);
        this.processedInputs = [];
        this.processedButtons = [];
        this.presented = false;
        /**
         * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
         */
        this.keyboardClose = true;
        /**
         * Array of buttons to be added to the alert.
         */
        this.buttons = [];
        /**
         * Array of input to show in the alert.
         */
        this.inputs = [];
        /**
         * If `true`, the alert will be dismissed when the backdrop is clicked.
         */
        this.backdropDismiss = true;
        /**
         * If `true`, the alert will be translucent.
         * Only applies when the mode is `"ios"` and the device supports
         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
         */
        this.translucent = false;
        /**
         * If `true`, the alert will animate.
         */
        this.animated = true;
        this.onBackdropTap = () => {
          this.dismiss(undefined, BACKDROP);
        };
        this.dispatchCancelHandler = ev => {
          const role = ev.detail.role;
          if (isCancel(role)) {
            const cancelButton = this.processedButtons.find(b => b.role === 'cancel');
            this.callButtonHandler(cancelButton);
          }
        };
      }
      onKeydown(ev) {
        const inputTypes = new Set(this.processedInputs.map(i => i.type));
        // The only inputs we want to navigate between using arrow keys are the radios
        // ignore the keydown event if it is not on a radio button
        if (!inputTypes.has('radio') || (ev.target && !this.el.contains(ev.target)) || ev.target.classList.contains('alert-button')) {
          return;
        }
        // Get all radios inside of the radio group and then
        // filter out disabled radios since we need to skip those
        const query = this.el.querySelectorAll('.alert-radio');
        const radios = Array.from(query).filter(radio => !radio.disabled);
        // The focused radio is the one that shares the same id as
        // the event target
        const index = radios.findIndex(radio => radio.id === ev.target.id);
        // We need to know what the next radio element should
        // be in order to change the focus
        let nextEl;
        // If hitting arrow down or arrow right, move to the next radio
        // If we're on the last radio, move to the first radio
        if (['ArrowDown', 'ArrowRight'].includes(ev.code)) {
          nextEl = index === radios.length - 1 ? radios[0] : radios[index + 1];
        }
        // If hitting arrow up or arrow left, move to the previous radio
        // If we're on the first radio, move to the last radio
        if (['ArrowUp', 'ArrowLeft'].includes(ev.code)) {
          nextEl = index === 0 ? radios[radios.length - 1] : radios[index - 1];
        }
        if (nextEl && radios.includes(nextEl)) {
          const nextProcessed = this.processedInputs.find(input => input.id === (nextEl === null || nextEl === void 0 ? void 0 : nextEl.id));
          if (nextProcessed) {
            this.rbClick(nextProcessed);
            nextEl.focus();
          }
        }
      }
      buttonsChanged() {
        const buttons = this.buttons;
        this.processedButtons = buttons.map(btn => {
          return typeof btn === 'string' ? { text: btn, role: btn.toLowerCase() === 'cancel' ? 'cancel' : undefined } : btn;
        });
      }
      inputsChanged() {
        const inputs = this.inputs;
        // Get the first input that is not disabled and the checked one
        // If an enabled checked input exists, set it to be the focusable input
        // otherwise we default to focus the first input
        // This will only be used when the input is type radio
        const first = inputs.find(input => !input.disabled);
        const checked = inputs.find(input => input.checked && !input.disabled);
        const focusable = checked || first;
        // An alert can be created with several different inputs. Radios,
        // checkboxes and inputs are all accepted, but they cannot be mixed.
        const inputTypes = new Set(inputs.map(i => i.type));
        if (inputTypes.has('checkbox') && inputTypes.has('radio')) {
          console.warn(`Alert cannot mix input types: ${Array.from(inputTypes.values()).join('/')}. Please see alert docs for more info.`);
        }
        this.inputType = inputTypes.values().next().value;
        this.processedInputs = inputs.map((i, index) => ({
          type: i.type || 'text',
          name: i.name || `${index}`,
          placeholder: i.placeholder || '',
          value: i.value,
          label: i.label,
          checked: !!i.checked,
          disabled: !!i.disabled,
          id: i.id || `alert-input-${this.overlayIndex}-${index}`,
          handler: i.handler,
          min: i.min,
          max: i.max,
          cssClass: i.cssClass || '',
          attributes: i.attributes || {},
          tabindex: i.type === 'radio' && i !== focusable ? -1 : 0,
        }));
      }
      connectedCallback() {
        prepareOverlay(this.el);
      }
      componentWillLoad() {
        this.inputsChanged();
        this.buttonsChanged();
      }
      disconnectedCallback() {
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
      }
      componentDidLoad() {
        /**
         * Do not create gesture if:
         * 1. A gesture already exists
         * 2. App is running in MD mode
         * 3. A wrapper ref does not exist
         */
        if (this.gesture || getIonMode$1(this) === 'md' || !this.wrapperEl) {
          return;
        }
        this.gesture = createButtonActiveGesture(this.wrapperEl, refEl => refEl.classList.contains('alert-button'));
        this.gesture.enable(true);
      }
      /**
       * Present the alert overlay after it has been created.
       */
      present() {
        return present(this, 'alertEnter', iosEnterAnimation$5, mdEnterAnimation$4);
      }
      /**
       * Dismiss the alert overlay after it has been presented.
       *
       * @param data Any data to emit in the dismiss events.
       * @param role The role of the element that is dismissing the alert.
       * This can be useful in a button handler for determining which button was
       * clicked to dismiss the alert.
       * Some examples include: ``"cancel"`, `"destructive"`, "selected"`, and `"backdrop"`.
       */
      dismiss(data, role) {
        return dismiss(this, data, role, 'alertLeave', iosLeaveAnimation$5, mdLeaveAnimation$4);
      }
      /**
       * Returns a promise that resolves when the alert did dismiss.
       */
      onDidDismiss() {
        return eventMethod(this.el, 'ionAlertDidDismiss');
      }
      /**
       * Returns a promise that resolves when the alert will dismiss.
       */
      onWillDismiss() {
        return eventMethod(this.el, 'ionAlertWillDismiss');
      }
      rbClick(selectedInput) {
        for (const input of this.processedInputs) {
          input.checked = input === selectedInput;
          input.tabindex = input === selectedInput ? 0 : -1;
        }
        this.activeId = selectedInput.id;
        safeCall(selectedInput.handler, selectedInput);
        forceUpdate$1(this);
      }
      cbClick(selectedInput) {
        selectedInput.checked = !selectedInput.checked;
        safeCall(selectedInput.handler, selectedInput);
        forceUpdate$1(this);
      }
      buttonClick(button) {
        const role = button.role;
        const values = this.getValues();
        if (isCancel(role)) {
          return this.dismiss({ values }, role);
        }
        const returnData = this.callButtonHandler(button, values);
        if (returnData !== false) {
          return this.dismiss(Object.assign({ values }, returnData), button.role);
        }
        return Promise.resolve(false);
      }
      callButtonHandler(button, data) {
        if (button && button.handler) {
          // a handler has been provided, execute it
          // pass the handler the values from the inputs
          const returnData = safeCall(button.handler, data);
          if (returnData === false) {
            // if the return value of the handler is false then do not dismiss
            return false;
          }
          if (typeof returnData === 'object') {
            return returnData;
          }
        }
        return {};
      }
      getValues() {
        if (this.processedInputs.length === 0) {
          // this is an alert without any options/inputs at all
          return undefined;
        }
        if (this.inputType === 'radio') {
          // this is an alert with radio buttons (single value select)
          // return the one value which is checked, otherwise undefined
          const checkedInput = this.processedInputs.find(i => !!i.checked);
          return checkedInput ? checkedInput.value : undefined;
        }
        if (this.inputType === 'checkbox') {
          // this is an alert with checkboxes (multiple value select)
          // return an array of all the checked values
          return this.processedInputs.filter(i => i.checked).map(i => i.value);
        }
        // this is an alert with text inputs
        // return an object of all the values with the input name as the key
        const values = {};
        this.processedInputs.forEach(i => {
          values[i.name] = i.value || '';
        });
        return values;
      }
      renderAlertInputs() {
        switch (this.inputType) {
          case 'checkbox':
            return this.renderCheckbox();
          case 'radio':
            return this.renderRadio();
          default:
            return this.renderInput();
        }
      }
      renderCheckbox() {
        const inputs = this.processedInputs;
        const mode = getIonMode$1(this);
        if (inputs.length === 0) {
          return null;
        }
        return hAsync(
          'div',
          { class: 'alert-checkbox-group' },
          inputs.map(i =>
            hAsync(
              'button',
              {
                'type': 'button',
                'onClick': () => this.cbClick(i),
                'aria-checked': `${i.checked}`,
                'id': i.id,
                'disabled': i.disabled,
                'tabIndex': i.tabindex,
                'role': 'checkbox',
                'class': Object.assign(Object.assign({}, getClassMap(i.cssClass)), {
                  'alert-tappable': true,
                  'alert-checkbox': true,
                  'alert-checkbox-button': true,
                  'ion-focusable': true,
                  'alert-checkbox-button-disabled': i.disabled || false,
                }),
              },
              hAsync(
                'div',
                { class: 'alert-button-inner' },
                hAsync('div', { class: 'alert-checkbox-icon' }, hAsync('div', { class: 'alert-checkbox-inner' })),
                hAsync('div', { class: 'alert-checkbox-label' }, i.label),
              ),
              mode === 'md' && hAsync('ion-ripple-effect', null),
            ),
          ),
        );
      }
      renderRadio() {
        const inputs = this.processedInputs;
        if (inputs.length === 0) {
          return null;
        }
        return hAsync(
          'div',
          { 'class': 'alert-radio-group', 'role': 'radiogroup', 'aria-activedescendant': this.activeId },
          inputs.map(i =>
            hAsync(
              'button',
              {
                'type': 'button',
                'onClick': () => this.rbClick(i),
                'aria-checked': `${i.checked}`,
                'disabled': i.disabled,
                'id': i.id,
                'tabIndex': i.tabindex,
                'class': Object.assign(Object.assign({}, getClassMap(i.cssClass)), {
                  'alert-radio-button': true,
                  'alert-tappable': true,
                  'alert-radio': true,
                  'ion-focusable': true,
                  'alert-radio-button-disabled': i.disabled || false,
                }),
                'role': 'radio',
              },
              hAsync(
                'div',
                { class: 'alert-button-inner' },
                hAsync('div', { class: 'alert-radio-icon' }, hAsync('div', { class: 'alert-radio-inner' })),
                hAsync('div', { class: 'alert-radio-label' }, i.label),
              ),
            ),
          ),
        );
      }
      renderInput() {
        const inputs = this.processedInputs;
        if (inputs.length === 0) {
          return null;
        }
        return hAsync(
          'div',
          { class: 'alert-input-group' },
          inputs.map(i => {
            var _a, _b, _c, _d;
            if (i.type === 'textarea') {
              return hAsync(
                'div',
                { class: 'alert-input-wrapper' },
                hAsync(
                  'textarea',
                  Object.assign({ placeholder: i.placeholder, value: i.value, id: i.id, tabIndex: i.tabindex }, i.attributes, {
                    disabled: (_b = (_a = i.attributes) === null || _a === void 0 ? void 0 : _a.disabled) !== null && _b !== void 0 ? _b : i.disabled,
                    class: inputClass(i),
                    onInput: e => {
                      var _a;
                      i.value = e.target.value;
                      if ((_a = i.attributes) === null || _a === void 0 ? void 0 : _a.onInput) {
                        i.attributes.onInput(e);
                      }
                    },
                  }),
                ),
              );
            } else {
              return hAsync(
                'div',
                { class: 'alert-input-wrapper' },
                hAsync(
                  'input',
                  Object.assign({ placeholder: i.placeholder, type: i.type, min: i.min, max: i.max, value: i.value, id: i.id, tabIndex: i.tabindex }, i.attributes, {
                    disabled: (_d = (_c = i.attributes) === null || _c === void 0 ? void 0 : _c.disabled) !== null && _d !== void 0 ? _d : i.disabled,
                    class: inputClass(i),
                    onInput: e => {
                      var _a;
                      i.value = e.target.value;
                      if ((_a = i.attributes) === null || _a === void 0 ? void 0 : _a.onInput) {
                        i.attributes.onInput(e);
                      }
                    },
                  }),
                ),
              );
            }
          }),
        );
      }
      renderAlertButtons() {
        const buttons = this.processedButtons;
        const mode = getIonMode$1(this);
        const alertButtonGroupClass = {
          'alert-button-group': true,
          'alert-button-group-vertical': buttons.length > 2,
        };
        return hAsync(
          'div',
          { class: alertButtonGroupClass },
          buttons.map(button =>
            hAsync(
              'button',
              { type: 'button', class: buttonClass$2(button), tabIndex: 0, onClick: () => this.buttonClick(button) },
              hAsync('span', { class: 'alert-button-inner' }, button.text),
              mode === 'md' && hAsync('ion-ripple-effect', null),
            ),
          ),
        );
      }
      render() {
        const { overlayIndex, header, subHeader, htmlAttributes } = this;
        const mode = getIonMode$1(this);
        const hdrId = `alert-${overlayIndex}-hdr`;
        const subHdrId = `alert-${overlayIndex}-sub-hdr`;
        const msgId = `alert-${overlayIndex}-msg`;
        const role = this.inputs.length > 0 || this.buttons.length > 0 ? 'alertdialog' : 'alert';
        return hAsync(
          Host,
          Object.assign({ 'role': role, 'aria-modal': 'true', 'tabindex': '-1' }, htmlAttributes, {
            style: {
              zIndex: `${20000 + overlayIndex}`,
            },
            class: Object.assign(Object.assign({}, getClassMap(this.cssClass)), { [mode]: true, 'alert-translucent': this.translucent }),
            onIonAlertWillDismiss: this.dispatchCancelHandler,
            onIonBackdropTap: this.onBackdropTap,
          }),
          hAsync('ion-backdrop', { tappable: this.backdropDismiss }),
          hAsync('div', { tabindex: '0' }),
          hAsync(
            'div',
            { class: 'alert-wrapper ion-overlay-wrapper', ref: el => (this.wrapperEl = el) },
            hAsync(
              'div',
              { class: 'alert-head' },
              header && hAsync('h2', { id: hdrId, class: 'alert-title' }, header),
              subHeader && hAsync('h2', { id: subHdrId, class: 'alert-sub-title' }, subHeader),
            ),
            hAsync('div', { id: msgId, class: 'alert-message', innerHTML: sanitizeDOMString(this.message) }),
            this.renderAlertInputs(),
            this.renderAlertButtons(),
          ),
          hAsync('div', { tabindex: '0' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          buttons: ['buttonsChanged'],
          inputs: ['inputsChanged'],
        };
      }
      static get style() {
        return {
          ios: alertIosCss,
          md: alertMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-alert',
          $members$: {
            overlayIndex: [2, 'overlay-index'],
            keyboardClose: [4, 'keyboard-close'],
            enterAnimation: [16],
            leaveAnimation: [16],
            cssClass: [1, 'css-class'],
            header: [1],
            subHeader: [1, 'sub-header'],
            message: [1],
            buttons: [16],
            inputs: [1040],
            backdropDismiss: [4, 'backdrop-dismiss'],
            translucent: [4],
            animated: [4],
            htmlAttributes: [16],
            present: [64],
            dismiss: [64],
            onDidDismiss: [64],
            onWillDismiss: [64],
          },
          $listeners$: [[4, 'keydown', 'onKeydown']],
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const inputClass = input => {
      var _a, _b, _c;
      return Object.assign(
        Object.assign(
          {
            'alert-input': true,
            'alert-input-disabled': ((_b = (_a = input.attributes) === null || _a === void 0 ? void 0 : _a.disabled) !== null && _b !== void 0 ? _b : input.disabled) || false,
          },
          getClassMap(input.cssClass),
        ),
        getClassMap(input.attributes ? ((_c = input.attributes.class) === null || _c === void 0 ? void 0 : _c.toString()) : ''),
      );
    };
    const buttonClass$2 = button => {
      return Object.assign(
        { 'alert-button': true, 'ion-focusable': true, 'ion-activatable': true, [`alert-button-role-${button.role}`]: button.role !== undefined },
        getClassMap(button.cssClass),
      );
    };

    const appCss = 'html.plt-mobile ion-app{user-select:none}html.plt-mobile ion-app [contenteditable]{user-select:text}ion-app.force-statusbar-padding{--ion-safe-area-top:20px}';

    class App {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      componentDidLoad() {}
      render() {
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          class: {
            [mode]: true,
            'ion-page': true,
            'force-statusbar-padding': config$2.getBoolean('_forceStatusbarPadding'),
          },
        });
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return appCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-app',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const avatarIosCss =
      '/*!@:host*/.sc-ion-avatar-ios-h{border-radius:var(--border-radius);display:block}/*!@::slotted(ion-img),\n::slotted(img)*/.sc-ion-avatar-ios-s>ion-img,.sc-ion-avatar-ios-s>img{border-radius:var(--border-radius);width:100%;height:100%;object-fit:cover;overflow:hidden}/*!@:host*/.sc-ion-avatar-ios-h{--border-radius:50%;width:48px;height:48px}';

    const avatarMdCss =
      '/*!@:host*/.sc-ion-avatar-md-h{border-radius:var(--border-radius);display:block}/*!@::slotted(ion-img),\n::slotted(img)*/.sc-ion-avatar-md-s>ion-img,.sc-ion-avatar-md-s>img{border-radius:var(--border-radius);width:100%;height:100%;object-fit:cover;overflow:hidden}/*!@:host*/.sc-ion-avatar-md-h{--border-radius:50%;width:64px;height:64px}';

    class Avatar {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return hAsync(Host, { class: getIonMode$1(this) }, hAsync('slot', null));
      }
      static get style() {
        return {
          ios: avatarIosCss,
          md: avatarMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-avatar',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const backButtonIosCss =
      '/*!@:host*/.sc-ion-back-button-ios-h{--background:transparent;--color-focused:currentColor;--color-hover:currentColor;--icon-margin-top:0;--icon-margin-bottom:0;--icon-padding-top:0;--icon-padding-end:0;--icon-padding-bottom:0;--icon-padding-start:0;--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--min-width:auto;--min-height:auto;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--opacity:1;--ripple-color:currentColor;--transition:background-color, opacity 100ms linear;display:none;min-width:var(--min-width);min-height:var(--min-height);color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;text-transform:none;white-space:nowrap;user-select:none;font-kerning:none}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-back-button-ios{color:var(--ripple-color)}/*!@:host(.ion-color) .button-native*/.ion-color.sc-ion-back-button-ios-h .button-native.sc-ion-back-button-ios{color:var(--ion-color-base)}/*!@:host(.show-back-button)*/.show-back-button.sc-ion-back-button-ios-h{display:block}/*!@:host(.back-button-disabled)*/.back-button-disabled.sc-ion-back-button-ios-h{cursor:default;opacity:0.5;pointer-events:none}/*!@.button-native*/.button-native.sc-ion-back-button-ios{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:var(--margin-start);margin-right:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;min-height:inherit;transition:var(--transition);border:0;outline:none;background:var(--background);line-height:1;cursor:pointer;opacity:var(--opacity);overflow:hidden;user-select:none;z-index:0;appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-back-button-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end)}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-back-button-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.button-inner*/.button-inner.sc-ion-back-button-ios{display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%;z-index:1}/*!@ion-icon*/ion-icon.sc-ion-back-button-ios{padding-left:var(--icon-padding-start);padding-right:var(--icon-padding-end);padding-top:var(--icon-padding-top);padding-bottom:var(--icon-padding-bottom);margin-left:var(--icon-margin-start);margin-right:var(--icon-margin-end);margin-top:var(--icon-margin-top);margin-bottom:var(--icon-margin-bottom);display:inherit;font-size:var(--icon-font-size);font-weight:var(--icon-font-weight);pointer-events:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@ion-icon*/ion-icon.sc-ion-back-button-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--icon-padding-start);padding-inline-start:var(--icon-padding-start);-webkit-padding-end:var(--icon-padding-end);padding-inline-end:var(--icon-padding-end)}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@ion-icon*/ion-icon.sc-ion-back-button-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:var(--icon-margin-start);margin-inline-start:var(--icon-margin-start);-webkit-margin-end:var(--icon-margin-end);margin-inline-end:var(--icon-margin-end)}}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-back-button-ios-h .button-native.sc-ion-back-button-ios{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-back-button-ios-h .button-native.sc-ion-back-button-ios::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}/*!@.button-native::after*/.button-native.sc-ion-back-button-ios::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}@media (any-hover: hover){/*!@:host(:hover) .button-native*/.sc-ion-back-button-ios-h:hover .button-native.sc-ion-back-button-ios{color:var(--color-hover)}/*!@:host(:hover) .button-native::after*/.sc-ion-back-button-ios-h:hover .button-native.sc-ion-back-button-ios::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}/*!@:host(.ion-color.ion-focused) .button-native*/.ion-color.ion-focused.sc-ion-back-button-ios-h .button-native.sc-ion-back-button-ios{color:var(--ion-color-base)}@media (any-hover: hover){/*!@:host(.ion-color:hover) .button-native*/.ion-color.sc-ion-back-button-ios-h:hover .button-native.sc-ion-back-button-ios{color:var(--ion-color-base)}}/*!@:host(.in-toolbar:not(.in-toolbar-color))*/.in-toolbar.sc-ion-back-button-ios-h:not(.in-toolbar-color){color:var(--ion-toolbar-color, var(--color))}/*!@:host*/.sc-ion-back-button-ios-h{--background-hover:transparent;--background-hover-opacity:1;--background-focused:currentColor;--background-focused-opacity:.1;--border-radius:4px;--color:var(--ion-color-primary, #3880ff);--icon-margin-end:-5px;--icon-margin-start:-4px;--icon-font-size:1.85em;--min-height:32px;font-size:17px}/*!@.button-native*/.button-native.sc-ion-back-button-ios{transform:translateZ(0);overflow:visible;z-index:99}/*!@:host(.ion-activated) .button-native*/.ion-activated.sc-ion-back-button-ios-h .button-native.sc-ion-back-button-ios{opacity:0.4}@media (any-hover: hover){/*!@:host(:hover)*/.sc-ion-back-button-ios-h:hover{opacity:0.6}}/*!@:host(.ion-color.ion-focused) .button-native::after*/.ion-color.ion-focused.sc-ion-back-button-ios-h .button-native.sc-ion-back-button-ios::after{background:var(--ion-color-base)}';

    const backButtonMdCss =
      '/*!@:host*/.sc-ion-back-button-md-h{--background:transparent;--color-focused:currentColor;--color-hover:currentColor;--icon-margin-top:0;--icon-margin-bottom:0;--icon-padding-top:0;--icon-padding-end:0;--icon-padding-bottom:0;--icon-padding-start:0;--margin-top:0;--margin-end:0;--margin-bottom:0;--margin-start:0;--min-width:auto;--min-height:auto;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--opacity:1;--ripple-color:currentColor;--transition:background-color, opacity 100ms linear;display:none;min-width:var(--min-width);min-height:var(--min-height);color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;text-transform:none;white-space:nowrap;user-select:none;font-kerning:none}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-back-button-md{color:var(--ripple-color)}/*!@:host(.ion-color) .button-native*/.ion-color.sc-ion-back-button-md-h .button-native.sc-ion-back-button-md{color:var(--ion-color-base)}/*!@:host(.show-back-button)*/.show-back-button.sc-ion-back-button-md-h{display:block}/*!@:host(.back-button-disabled)*/.back-button-disabled.sc-ion-back-button-md-h{cursor:default;opacity:0.5;pointer-events:none}/*!@.button-native*/.button-native.sc-ion-back-button-md{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:var(--margin-start);margin-right:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;min-height:inherit;transition:var(--transition);border:0;outline:none;background:var(--background);line-height:1;cursor:pointer;opacity:var(--opacity);overflow:hidden;user-select:none;z-index:0;appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-back-button-md{margin-left:unset;margin-right:unset;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end)}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-back-button-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.button-inner*/.button-inner.sc-ion-back-button-md{display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%;z-index:1}/*!@ion-icon*/ion-icon.sc-ion-back-button-md{padding-left:var(--icon-padding-start);padding-right:var(--icon-padding-end);padding-top:var(--icon-padding-top);padding-bottom:var(--icon-padding-bottom);margin-left:var(--icon-margin-start);margin-right:var(--icon-margin-end);margin-top:var(--icon-margin-top);margin-bottom:var(--icon-margin-bottom);display:inherit;font-size:var(--icon-font-size);font-weight:var(--icon-font-weight);pointer-events:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@ion-icon*/ion-icon.sc-ion-back-button-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--icon-padding-start);padding-inline-start:var(--icon-padding-start);-webkit-padding-end:var(--icon-padding-end);padding-inline-end:var(--icon-padding-end)}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@ion-icon*/ion-icon.sc-ion-back-button-md{margin-left:unset;margin-right:unset;-webkit-margin-start:var(--icon-margin-start);margin-inline-start:var(--icon-margin-start);-webkit-margin-end:var(--icon-margin-end);margin-inline-end:var(--icon-margin-end)}}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-back-button-md-h .button-native.sc-ion-back-button-md{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-back-button-md-h .button-native.sc-ion-back-button-md::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}/*!@.button-native::after*/.button-native.sc-ion-back-button-md::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}@media (any-hover: hover){/*!@:host(:hover) .button-native*/.sc-ion-back-button-md-h:hover .button-native.sc-ion-back-button-md{color:var(--color-hover)}/*!@:host(:hover) .button-native::after*/.sc-ion-back-button-md-h:hover .button-native.sc-ion-back-button-md::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}/*!@:host(.ion-color.ion-focused) .button-native*/.ion-color.ion-focused.sc-ion-back-button-md-h .button-native.sc-ion-back-button-md{color:var(--ion-color-base)}@media (any-hover: hover){/*!@:host(.ion-color:hover) .button-native*/.ion-color.sc-ion-back-button-md-h:hover .button-native.sc-ion-back-button-md{color:var(--ion-color-base)}}/*!@:host(.in-toolbar:not(.in-toolbar-color))*/.in-toolbar.sc-ion-back-button-md-h:not(.in-toolbar-color){color:var(--ion-toolbar-color, var(--color))}/*!@:host*/.sc-ion-back-button-md-h{--border-radius:4px;--background-focused:currentColor;--background-focused-opacity:.12;--background-hover:currentColor;--background-hover-opacity:0.04;--color:currentColor;--icon-margin-end:0;--icon-margin-start:0;--icon-font-size:24px;--icon-font-weight:normal;--min-height:32px;--min-width:44px;--padding-start:12px;--padding-end:12px;font-size:14px;font-weight:500;text-transform:uppercase}/*!@:host(.back-button-has-icon-only)*/.back-button-has-icon-only.sc-ion-back-button-md-h{--border-radius:50%;min-width:48px;height:48px}/*!@.button-native*/.button-native.sc-ion-back-button-md{box-shadow:none}/*!@.button-text*/.button-text.sc-ion-back-button-md{padding-left:4px;padding-right:4px;padding-top:0;padding-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-text*/.button-text.sc-ion-back-button-md{padding-left:unset;padding-right:unset;-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px}}/*!@ion-icon*/ion-icon.sc-ion-back-button-md{line-height:0.67;text-align:start}@media (any-hover: hover){/*!@:host(.ion-color:hover) .button-native::after*/.ion-color.sc-ion-back-button-md-h:hover .button-native.sc-ion-back-button-md::after{background:var(--ion-color-base)}}/*!@:host(.ion-color.ion-focused) .button-native::after*/.ion-color.ion-focused.sc-ion-back-button-md-h .button-native.sc-ion-back-button-md::after{background:var(--ion-color-base)}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part native - The native HTML button element that wraps all child elements.
     * @part icon - The back button icon (uses ion-icon).
     * @part text - The back button text.
     */
    class BackButton {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.inheritedAttributes = {};
        /**
         * If `true`, the user cannot interact with the button.
         */
        this.disabled = false;
        /**
         * The type of the button.
         */
        this.type = 'button';
        this.onClick = async ev => {
          const nav = this.el.closest('ion-nav');
          ev.preventDefault();
          if (nav && (await nav.canGoBack())) {
            return nav.pop({ animationBuilder: this.routerAnimation, skipIfBusy: true });
          }
          return openURL(this.defaultHref, ev, 'back', this.routerAnimation);
        };
      }
      componentWillLoad() {
        this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);
        if (this.defaultHref === undefined) {
          this.defaultHref = config$2.get('backButtonDefaultHref');
        }
      }
      get backButtonIcon() {
        const icon = this.icon;
        if (icon != null) {
          // icon is set on the component or by the config
          return icon;
        }
        if (getIonMode$1(this) === 'ios') {
          // default ios back button icon
          return config$2.get('backButtonIcon', 'chevron-back');
        }
        // default md back button icon
        return config$2.get('backButtonIcon', 'arrow-back-sharp');
      }
      get backButtonText() {
        const defaultBackButtonText = getIonMode$1(this) === 'ios' ? 'Back' : null;
        return this.text != null ? this.text : config$2.get('backButtonText', defaultBackButtonText);
      }
      get hasIconOnly() {
        return this.backButtonIcon && !this.backButtonText;
      }
      get rippleType() {
        // If the button only has an icon we use the unbounded
        // "circular" ripple effect
        if (this.hasIconOnly) {
          return 'unbounded';
        }
        return 'bounded';
      }
      render() {
        const { color, defaultHref, disabled, type, hasIconOnly, backButtonIcon, backButtonText, inheritedAttributes } = this;
        const showBackButton = defaultHref !== undefined;
        const mode = getIonMode$1(this);
        const ariaLabel = inheritedAttributes['aria-label'] || backButtonText || 'back';
        return hAsync(
          Host,
          {
            onClick: this.onClick,
            class: createColorClasses$1(color, {
              [mode]: true,
              'button': true,
              'back-button-disabled': disabled,
              'back-button-has-icon-only': hasIconOnly,
              'in-toolbar': hostContext('ion-toolbar', this.el),
              'in-toolbar-color': hostContext('ion-toolbar[color]', this.el),
              'ion-activatable': true,
              'ion-focusable': true,
              'show-back-button': showBackButton,
            }),
          },
          hAsync(
            'button',
            { 'type': type, 'disabled': disabled, 'class': 'button-native', 'part': 'native', 'aria-label': ariaLabel },
            hAsync(
              'span',
              { class: 'button-inner' },
              backButtonIcon && hAsync('ion-icon', { 'part': 'icon', 'icon': backButtonIcon, 'aria-hidden': 'true', 'lazy': false }),
              backButtonText && hAsync('span', { 'part': 'text', 'aria-hidden': 'true', 'class': 'button-text' }, backButtonText),
            ),
            mode === 'md' && hAsync('ion-ripple-effect', { type: this.rippleType }),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: backButtonIosCss,
          md: backButtonMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-back-button',
          $members$: {
            color: [513],
            defaultHref: [1025, 'default-href'],
            disabled: [516],
            icon: [1],
            text: [1],
            type: [1],
            routerAnimation: [16],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [
            ['color', 'color'],
            ['disabled', 'disabled'],
          ],
        };
      }
    }

    const backdropIosCss =
      '/*!@:host*/.sc-ion-backdrop-ios-h{left:0;right:0;top:0;bottom:0;display:block;position:absolute;transform:translateZ(0);contain:strict;cursor:pointer;opacity:0.01;touch-action:none;z-index:2}/*!@:host(.backdrop-hide)*/.backdrop-hide.sc-ion-backdrop-ios-h{background:transparent}/*!@:host(.backdrop-no-tappable)*/.backdrop-no-tappable.sc-ion-backdrop-ios-h{cursor:auto}/*!@:host*/.sc-ion-backdrop-ios-h{background-color:var(--ion-backdrop-color, #000)}';

    const backdropMdCss =
      '/*!@:host*/.sc-ion-backdrop-md-h{left:0;right:0;top:0;bottom:0;display:block;position:absolute;transform:translateZ(0);contain:strict;cursor:pointer;opacity:0.01;touch-action:none;z-index:2}/*!@:host(.backdrop-hide)*/.backdrop-hide.sc-ion-backdrop-md-h{background:transparent}/*!@:host(.backdrop-no-tappable)*/.backdrop-no-tappable.sc-ion-backdrop-md-h{cursor:auto}/*!@:host*/.sc-ion-backdrop-md-h{background-color:var(--ion-backdrop-color, #000)}';

    class Backdrop {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionBackdropTap = createEvent(this, 'ionBackdropTap', 7);
        this.blocker = GESTURE_CONTROLLER.createBlocker({
          disableScroll: true,
        });
        /**
         * If `true`, the backdrop will be visible.
         */
        this.visible = true;
        /**
         * If `true`, the backdrop will can be clicked and will emit the `ionBackdropTap` event.
         */
        this.tappable = true;
        /**
         * If `true`, the backdrop will stop propagation on tap.
         */
        this.stopPropagation = true;
      }
      connectedCallback() {
        if (this.stopPropagation) {
          this.blocker.block();
        }
      }
      disconnectedCallback() {
        this.blocker.unblock();
      }
      onMouseDown(ev) {
        this.emitTap(ev);
      }
      emitTap(ev) {
        if (this.stopPropagation) {
          ev.preventDefault();
          ev.stopPropagation();
        }
        if (this.tappable) {
          this.ionBackdropTap.emit();
        }
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          'tabindex': '-1',
          'aria-hidden': 'true',
          'class': {
            [mode]: true,
            'backdrop-hide': !this.visible,
            'backdrop-no-tappable': !this.tappable,
          },
        });
      }
      static get style() {
        return {
          ios: backdropIosCss,
          md: backdropMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-backdrop',
          $members$: {
            visible: [4],
            tappable: [4],
            stopPropagation: [4, 'stop-propagation'],
          },
          $listeners$: [[2, 'click', 'onMouseDown']],
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const badgeIosCss =
      '/*!@:host*/.sc-ion-badge-ios-h{--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff);--padding-top:3px;--padding-end:8px;--padding-bottom:3px;--padding-start:8px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:inline-block;min-width:10px;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);font-size:13px;font-weight:bold;line-height:1;text-align:center;white-space:nowrap;contain:content;vertical-align:baseline}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-badge-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@:host(.ion-color)*/.ion-color.sc-ion-badge-ios-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(:empty)*/.sc-ion-badge-ios-h:empty{display:none}/*!@:host*/.sc-ion-badge-ios-h{border-radius:10px}';

    const badgeMdCss =
      '/*!@:host*/.sc-ion-badge-md-h{--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff);--padding-top:3px;--padding-end:8px;--padding-bottom:3px;--padding-start:8px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:inline-block;min-width:10px;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);font-size:13px;font-weight:bold;line-height:1;text-align:center;white-space:nowrap;contain:content;vertical-align:baseline}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-badge-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@:host(.ion-color)*/.ion-color.sc-ion-badge-md-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(:empty)*/.sc-ion-badge-md-h:empty{display:none}/*!@:host*/.sc-ion-badge-md-h{--padding-top:3px;--padding-end:4px;--padding-bottom:4px;--padding-start:4px;border-radius:4px}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Badge {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: createColorClasses$1(this.color, {
              [mode]: true,
            }),
          },
          hAsync('slot', null),
        );
      }
      static get style() {
        return {
          ios: badgeIosCss,
          md: badgeMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-badge',
          $members$: {
            color: [513],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const buttonIosCss =
      '/*!@:host*/.sc-ion-button-ios-h{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;font-kerning:none}/*!@:host(.button-disabled)*/.button-disabled.sc-ion-button-ios-h{cursor:default;opacity:0.5;pointer-events:none}/*!@:host(.button-solid)*/.button-solid.sc-ion-button-ios-h{--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff)}/*!@:host(.button-outline)*/.button-outline.sc-ion-button-ios-h{--border-color:var(--ion-color-primary, #3880ff);--background:transparent;--color:var(--ion-color-primary, #3880ff)}/*!@:host(.button-clear)*/.button-clear.sc-ion-button-ios-h{--border-width:0;--background:transparent;--color:var(--ion-color-primary, #3880ff)}/*!@:host(.button-block)*/.button-block.sc-ion-button-ios-h{display:block}/*!@:host(.button-block) .button-native*/.button-block.sc-ion-button-ios-h .button-native.sc-ion-button-ios{margin-left:0;margin-right:0;display:block;width:100%;clear:both;contain:content}/*!@:host(.button-block) .button-native::after*/.button-block.sc-ion-button-ios-h .button-native.sc-ion-button-ios::after{clear:both}/*!@:host(.button-full)*/.button-full.sc-ion-button-ios-h{display:block}/*!@:host(.button-full) .button-native*/.button-full.sc-ion-button-ios-h .button-native.sc-ion-button-ios{margin-left:0;margin-right:0;display:block;width:100%;contain:content}/*!@:host(.button-full:not(.button-round)) .button-native*/.button-full.sc-ion-button-ios-h:not(.button-round) .button-native.sc-ion-button-ios{border-radius:0;border-right-width:0;border-left-width:0}/*!@.button-native*/.button-native.sc-ion-button-ios{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;box-sizing:border-box;appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-button-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.button-native::-moz-focus-inner*/.button-native.sc-ion-button-ios::-moz-focus-inner{border:0}/*!@.button-inner*/.button-inner.sc-ion-button-ios{display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%;z-index:1}/*!@::slotted(ion-icon)*/.sc-ion-button-ios-s>ion-icon{font-size:1.4em;pointer-events:none}/*!@::slotted(ion-icon[slot=start])*/.sc-ion-button-ios-s>ion-icon[slot=start]{margin-left:-0.3em;margin-right:0.3em;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon[slot=start])*/.sc-ion-button-ios-s>ion-icon[slot=start]{margin-left:unset;margin-right:unset;-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em}}/*!@::slotted(ion-icon[slot=end])*/.sc-ion-button-ios-s>ion-icon[slot=end]{margin-left:0.3em;margin-right:-0.2em;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon[slot=end])*/.sc-ion-button-ios-s>ion-icon[slot=end]{margin-left:unset;margin-right:unset;-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em}}/*!@::slotted(ion-icon[slot=icon-only])*/.sc-ion-button-ios-s>ion-icon[slot=icon-only]{font-size:1.8em}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-button-ios{color:var(--ripple-color)}/*!@.button-native::after*/.button-native.sc-ion-button-ios::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}/*!@:host(.ion-activated)*/.ion-activated.sc-ion-button-ios-h{color:var(--color-activated)}/*!@:host(.ion-activated) .button-native::after*/.ion-activated.sc-ion-button-ios-h .button-native.sc-ion-button-ios::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}/*!@:host(.ion-focused)*/.ion-focused.sc-ion-button-ios-h{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-button-ios-h .button-native.sc-ion-button-ios::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){/*!@:host(:hover)*/.sc-ion-button-ios-h:hover{color:var(--color-hover)}/*!@:host(:hover) .button-native::after*/.sc-ion-button-ios-h:hover .button-native.sc-ion-button-ios::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}/*!@:host(.button-solid.ion-color) .button-native*/.button-solid.ion-color.sc-ion-button-ios-h .button-native.sc-ion-button-ios{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(.button-outline.ion-color) .button-native*/.button-outline.ion-color.sc-ion-button-ios-h .button-native.sc-ion-button-ios{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}/*!@:host(.button-clear.ion-color) .button-native*/.button-clear.ion-color.sc-ion-button-ios-h .button-native.sc-ion-button-ios{background:transparent;color:var(--ion-color-base)}/*!@:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native*/.in-toolbar.sc-ion-button-ios-h:not(.ion-color):not(.in-toolbar-color) .button-native.sc-ion-button-ios{color:var(--ion-toolbar-color, var(--color))}/*!@:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native*/.button-outline.in-toolbar.sc-ion-button-ios-h:not(.ion-color):not(.in-toolbar-color) .button-native.sc-ion-button-ios{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}/*!@:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native*/.button-solid.in-toolbar.sc-ion-button-ios-h:not(.ion-color):not(.in-toolbar-color) .button-native.sc-ion-button-ios{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}/*!@:host*/.sc-ion-button-ios-h{--border-radius:10px;--padding-top:0;--padding-bottom:0;--padding-start:1em;--padding-end:1em;--transition:background-color, opacity 100ms linear;margin-left:2px;margin-right:2px;margin-top:4px;margin-bottom:4px;height:2.8em;font-size:16px;font-weight:500;letter-spacing:-0.03em}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-button-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px}}/*!@:host(.button-solid)*/.button-solid.sc-ion-button-ios-h{--background-activated:var(--ion-color-primary-shade, #3171e0);--background-focused:var(--ion-color-primary-shade, #3171e0);--background-hover:var(--ion-color-primary-tint, #4c8dff);--background-activated-opacity:1;--background-focused-opacity:1;--background-hover-opacity:1}/*!@:host(.button-outline)*/.button-outline.sc-ion-button-ios-h{--border-radius:10px;--border-width:1px;--border-style:solid;--background-activated:var(--ion-color-primary, #3880ff);--background-focused:var(--ion-color-primary, #3880ff);--background-hover:transparent;--background-focused-opacity:.1;--color-activated:var(--ion-color-primary-contrast, #fff)}/*!@:host(.button-clear)*/.button-clear.sc-ion-button-ios-h{--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:transparent;--background-focused-opacity:.1;font-size:17px;font-weight:normal;letter-spacing:0}/*!@:host(.button-large)*/.button-large.sc-ion-button-ios-h{--border-radius:12px;--padding-top:0;--padding-start:1em;--padding-end:1em;--padding-bottom:0;height:2.8em;font-size:20px}/*!@:host(.button-small)*/.button-small.sc-ion-button-ios-h{--border-radius:6px;--padding-top:0;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:0;height:2.1em;font-size:13px}/*!@:host(.button-round)*/.button-round.sc-ion-button-ios-h{--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}/*!@:host(.button-strong)*/.button-strong.sc-ion-button-ios-h{font-weight:600}/*!@:host(.button-clear.ion-activated)*/.button-clear.ion-activated.sc-ion-button-ios-h{opacity:0.4}/*!@:host(.button-outline.ion-activated.ion-color) .button-native*/.button-outline.ion-activated.ion-color.sc-ion-button-ios-h .button-native.sc-ion-button-ios{color:var(--ion-color-contrast)}/*!@:host(.button-outline.ion-activated.ion-color) .button-native::after*/.button-outline.ion-activated.ion-color.sc-ion-button-ios-h .button-native.sc-ion-button-ios::after{background:var(--ion-color-base)}/*!@:host(.button-solid.ion-color.ion-activated) .button-native::after*/.button-solid.ion-color.ion-activated.sc-ion-button-ios-h .button-native.sc-ion-button-ios::after{background:var(--ion-color-shade)}/*!@:host(.button-outline.ion-focused.ion-color) .button-native,\n:host(.button-clear.ion-focused.ion-color) .button-native*/.button-outline.ion-focused.ion-color.sc-ion-button-ios-h .button-native.sc-ion-button-ios,.button-clear.ion-focused.ion-color.sc-ion-button-ios-h .button-native.sc-ion-button-ios{color:var(--ion-color-base)}/*!@:host(.button-outline.ion-focused.ion-color) .button-native::after,\n:host(.button-clear.ion-focused.ion-color) .button-native::after*/.button-outline.ion-focused.ion-color.sc-ion-button-ios-h .button-native.sc-ion-button-ios::after,.button-clear.ion-focused.ion-color.sc-ion-button-ios-h .button-native.sc-ion-button-ios::after{background:var(--ion-color-base)}/*!@:host(.button-solid.ion-color.ion-focused) .button-native::after*/.button-solid.ion-color.ion-focused.sc-ion-button-ios-h .button-native.sc-ion-button-ios::after{background:var(--ion-color-shade)}@media (any-hover: hover){/*!@:host(.button-clear:hover),\n:host(.button-outline:hover)*/.button-clear.sc-ion-button-ios-h:hover,.button-outline.sc-ion-button-ios-h:hover{opacity:0.6}/*!@:host(.button-clear.ion-color:hover) .button-native,\n:host(.button-outline.ion-color:hover) .button-native*/.button-clear.ion-color.sc-ion-button-ios-h:hover .button-native.sc-ion-button-ios,.button-outline.ion-color.sc-ion-button-ios-h:hover .button-native.sc-ion-button-ios{color:var(--ion-color-base)}/*!@:host(.button-clear.ion-color:hover) .button-native::after,\n:host(.button-outline.ion-color:hover) .button-native::after*/.button-clear.ion-color.sc-ion-button-ios-h:hover .button-native.sc-ion-button-ios::after,.button-outline.ion-color.sc-ion-button-ios-h:hover .button-native.sc-ion-button-ios::after{background:transparent}/*!@:host(.button-solid.ion-color:hover) .button-native::after*/.button-solid.ion-color.sc-ion-button-ios-h:hover .button-native.sc-ion-button-ios::after{background:var(--ion-color-tint)}/*!@:host(:hover.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native::after*/.sc-ion-button-ios-h:hover.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color) .button-native.sc-ion-button-ios::after{background:#fff;opacity:0.1}}';

    const buttonMdCss =
      '/*!@:host*/.sc-ion-button-md-h{--overflow:hidden;--ripple-color:currentColor;--border-width:initial;--border-color:initial;--border-style:initial;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--box-shadow:none;display:inline-block;width:auto;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:center;text-decoration:none;text-overflow:ellipsis;white-space:nowrap;user-select:none;vertical-align:top;vertical-align:-webkit-baseline-middle;font-kerning:none}/*!@:host(.button-disabled)*/.button-disabled.sc-ion-button-md-h{cursor:default;opacity:0.5;pointer-events:none}/*!@:host(.button-solid)*/.button-solid.sc-ion-button-md-h{--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff)}/*!@:host(.button-outline)*/.button-outline.sc-ion-button-md-h{--border-color:var(--ion-color-primary, #3880ff);--background:transparent;--color:var(--ion-color-primary, #3880ff)}/*!@:host(.button-clear)*/.button-clear.sc-ion-button-md-h{--border-width:0;--background:transparent;--color:var(--ion-color-primary, #3880ff)}/*!@:host(.button-block)*/.button-block.sc-ion-button-md-h{display:block}/*!@:host(.button-block) .button-native*/.button-block.sc-ion-button-md-h .button-native.sc-ion-button-md{margin-left:0;margin-right:0;display:block;width:100%;clear:both;contain:content}/*!@:host(.button-block) .button-native::after*/.button-block.sc-ion-button-md-h .button-native.sc-ion-button-md::after{clear:both}/*!@:host(.button-full)*/.button-full.sc-ion-button-md-h{display:block}/*!@:host(.button-full) .button-native*/.button-full.sc-ion-button-md-h .button-native.sc-ion-button-md{margin-left:0;margin-right:0;display:block;width:100%;contain:content}/*!@:host(.button-full:not(.button-round)) .button-native*/.button-full.sc-ion-button-md-h:not(.button-round) .button-native.sc-ion-button-md{border-radius:0;border-right-width:0;border-left-width:0}/*!@.button-native*/.button-native.sc-ion-button-md{border-radius:var(--border-radius);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);line-height:1;box-shadow:var(--box-shadow);contain:layout style;cursor:pointer;opacity:var(--opacity);overflow:var(--overflow);z-index:0;box-sizing:border-box;appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-button-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.button-native::-moz-focus-inner*/.button-native.sc-ion-button-md::-moz-focus-inner{border:0}/*!@.button-inner*/.button-inner.sc-ion-button-md{display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%;z-index:1}/*!@::slotted(ion-icon)*/.sc-ion-button-md-s>ion-icon{font-size:1.4em;pointer-events:none}/*!@::slotted(ion-icon[slot=start])*/.sc-ion-button-md-s>ion-icon[slot=start]{margin-left:-0.3em;margin-right:0.3em;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon[slot=start])*/.sc-ion-button-md-s>ion-icon[slot=start]{margin-left:unset;margin-right:unset;-webkit-margin-start:-0.3em;margin-inline-start:-0.3em;-webkit-margin-end:0.3em;margin-inline-end:0.3em}}/*!@::slotted(ion-icon[slot=end])*/.sc-ion-button-md-s>ion-icon[slot=end]{margin-left:0.3em;margin-right:-0.2em;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon[slot=end])*/.sc-ion-button-md-s>ion-icon[slot=end]{margin-left:unset;margin-right:unset;-webkit-margin-start:0.3em;margin-inline-start:0.3em;-webkit-margin-end:-0.2em;margin-inline-end:-0.2em}}/*!@::slotted(ion-icon[slot=icon-only])*/.sc-ion-button-md-s>ion-icon[slot=icon-only]{font-size:1.8em}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-button-md{color:var(--ripple-color)}/*!@.button-native::after*/.button-native.sc-ion-button-md::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}/*!@:host(.ion-activated)*/.ion-activated.sc-ion-button-md-h{color:var(--color-activated)}/*!@:host(.ion-activated) .button-native::after*/.ion-activated.sc-ion-button-md-h .button-native.sc-ion-button-md::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}/*!@:host(.ion-focused)*/.ion-focused.sc-ion-button-md-h{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-button-md-h .button-native.sc-ion-button-md::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){/*!@:host(:hover)*/.sc-ion-button-md-h:hover{color:var(--color-hover)}/*!@:host(:hover) .button-native::after*/.sc-ion-button-md-h:hover .button-native.sc-ion-button-md::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}/*!@:host(.button-solid.ion-color) .button-native*/.button-solid.ion-color.sc-ion-button-md-h .button-native.sc-ion-button-md{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(.button-outline.ion-color) .button-native*/.button-outline.ion-color.sc-ion-button-md-h .button-native.sc-ion-button-md{border-color:var(--ion-color-base);background:transparent;color:var(--ion-color-base)}/*!@:host(.button-clear.ion-color) .button-native*/.button-clear.ion-color.sc-ion-button-md-h .button-native.sc-ion-button-md{background:transparent;color:var(--ion-color-base)}/*!@:host(.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native*/.in-toolbar.sc-ion-button-md-h:not(.ion-color):not(.in-toolbar-color) .button-native.sc-ion-button-md{color:var(--ion-toolbar-color, var(--color))}/*!@:host(.button-outline.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native*/.button-outline.in-toolbar.sc-ion-button-md-h:not(.ion-color):not(.in-toolbar-color) .button-native.sc-ion-button-md{border-color:var(--ion-toolbar-color, var(--color, var(--border-color)))}/*!@:host(.button-solid.in-toolbar:not(.ion-color):not(.in-toolbar-color)) .button-native*/.button-solid.in-toolbar.sc-ion-button-md-h:not(.ion-color):not(.in-toolbar-color) .button-native.sc-ion-button-md{background:var(--ion-toolbar-color, var(--background));color:var(--ion-toolbar-background, var(--color))}/*!@:host*/.sc-ion-button-md-h{--border-radius:4px;--padding-top:0;--padding-bottom:0;--padding-start:1.1em;--padding-end:1.1em;--transition:box-shadow 280ms cubic-bezier(.4, 0, .2, 1),\n                background-color 15ms linear,\n                color 15ms linear;margin-left:2px;margin-right:2px;margin-top:4px;margin-bottom:4px;height:36px;font-size:14px;font-weight:500;letter-spacing:0.06em;text-transform:uppercase}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-button-md-h{margin-left:unset;margin-right:unset;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px}}/*!@:host(.button-solid)*/.button-solid.sc-ion-button-md-h{--background-activated:transparent;--background-hover:var(--ion-color-primary-contrast, #fff);--background-focused:var(--ion-color-primary-contrast, #fff);--background-activated-opacity:0;--background-focused-opacity:.24;--background-hover-opacity:.08;--box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}/*!@:host(.button-solid.ion-activated)*/.button-solid.ion-activated.sc-ion-button-md-h{--box-shadow:0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12)}/*!@:host(.button-outline)*/.button-outline.sc-ion-button-md-h{--border-width:2px;--border-style:solid;--box-shadow:none;--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:var(--ion-color-primary, #3880ff);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}/*!@:host(.button-outline.ion-activated.ion-color) .button-native*/.button-outline.ion-activated.ion-color.sc-ion-button-md-h .button-native.sc-ion-button-md{background:transparent}/*!@:host(.button-clear)*/.button-clear.sc-ion-button-md-h{--background-activated:transparent;--background-focused:var(--ion-color-primary, #3880ff);--background-hover:var(--ion-color-primary, #3880ff);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04}/*!@:host(.button-round)*/.button-round.sc-ion-button-md-h{--border-radius:64px;--padding-top:0;--padding-start:26px;--padding-end:26px;--padding-bottom:0}/*!@:host(.button-large)*/.button-large.sc-ion-button-md-h{--padding-top:0;--padding-start:1em;--padding-end:1em;--padding-bottom:0;height:2.8em;font-size:20px}/*!@:host(.button-small)*/.button-small.sc-ion-button-md-h{--padding-top:0;--padding-start:0.9em;--padding-end:0.9em;--padding-bottom:0;height:2.1em;font-size:13px}/*!@:host(.button-strong)*/.button-strong.sc-ion-button-md-h{font-weight:bold}/*!@::slotted(ion-icon[slot=icon-only])*/.sc-ion-button-md-s>ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0}/*!@:host(.button-solid.ion-color.ion-focused) .button-native::after*/.button-solid.ion-color.ion-focused.sc-ion-button-md-h .button-native.sc-ion-button-md::after{background:var(--ion-color-contrast)}/*!@:host(.button-clear.ion-color.ion-focused) .button-native::after,\n:host(.button-outline.ion-color.ion-focused) .button-native::after*/.button-clear.ion-color.ion-focused.sc-ion-button-md-h .button-native.sc-ion-button-md::after,.button-outline.ion-color.ion-focused.sc-ion-button-md-h .button-native.sc-ion-button-md::after{background:var(--ion-color-base)}@media (any-hover: hover){/*!@:host(.button-solid.ion-color:hover) .button-native::after*/.button-solid.ion-color.sc-ion-button-md-h:hover .button-native.sc-ion-button-md::after{background:var(--ion-color-contrast)}/*!@:host(.button-clear.ion-color:hover) .button-native::after,\n:host(.button-outline.ion-color:hover) .button-native::after*/.button-clear.ion-color.sc-ion-button-md-h:hover .button-native.sc-ion-button-md::after,.button-outline.ion-color.sc-ion-button-md-h:hover .button-native.sc-ion-button-md::after{background:var(--ion-color-base)}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @slot - Content is placed between the named slots if provided without a slot.
     * @slot icon-only - Should be used on an icon in a button that has no text.
     * @slot start - Content is placed to the left of the button text in LTR, and to the right in RTL.
     * @slot end - Content is placed to the right of the button text in LTR, and to the left in RTL.
     *
     * @part native - The native HTML button or anchor element that wraps all child elements.
     */
    class Button {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        this.inItem = false;
        this.inListHeader = false;
        this.inToolbar = false;
        this.inheritedAttributes = {};
        /**
         * The type of button.
         */
        this.buttonType = 'button';
        /**
         * If `true`, the user cannot interact with the button.
         */
        this.disabled = false;
        /**
         * When using a router, it specifies the transition direction when navigating to
         * another page using `href`.
         */
        this.routerDirection = 'forward';
        /**
         * If `true`, activates a button with a heavier font weight.
         */
        this.strong = false;
        /**
         * The type of the button.
         */
        this.type = 'button';
        this.handleClick = ev => {
          if (this.type === 'button') {
            openURL(this.href, ev, this.routerDirection, this.routerAnimation);
          } else if (hasShadowDom(this.el)) {
            // this button wants to specifically submit a form
            // climb up the dom to see if we're in a <form>
            // and if so, then use JS to submit it
            const form = this.el.closest('form');
            if (form) {
              ev.preventDefault();
              const fakeButton = document.createElement('button');
              fakeButton.type = this.type;
              fakeButton.style.display = 'none';
              form.appendChild(fakeButton);
              fakeButton.click();
              fakeButton.remove();
            }
          }
        };
        this.onFocus = () => {
          this.ionFocus.emit();
        };
        this.onBlur = () => {
          this.ionBlur.emit();
        };
      }
      componentWillLoad() {
        this.inToolbar = !!this.el.closest('ion-buttons');
        this.inListHeader = !!this.el.closest('ion-list-header');
        this.inItem = !!this.el.closest('ion-item') || !!this.el.closest('ion-item-divider');
        this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);
      }
      get hasIconOnly() {
        return !!this.el.querySelector('[slot="icon-only"]');
      }
      get rippleType() {
        const hasClearFill = this.fill === undefined || this.fill === 'clear';
        // If the button is in a toolbar, has a clear fill (which is the default)
        // and only has an icon we use the unbounded "circular" ripple effect
        if (hasClearFill && this.hasIconOnly && this.inToolbar) {
          return 'unbounded';
        }
        return 'bounded';
      }
      render() {
        const mode = getIonMode$1(this);
        const { buttonType, type, disabled, rel, target, size, href, color, expand, hasIconOnly, shape, strong, inheritedAttributes } = this;
        const finalSize = size === undefined && this.inItem ? 'small' : size;
        const TagType = href === undefined ? 'button' : 'a';
        const attrs =
          TagType === 'button'
            ? { type }
            : {
                download: this.download,
                href,
                rel,
                target,
              };
        let fill = this.fill;
        if (fill === undefined) {
          fill = this.inToolbar || this.inListHeader ? 'clear' : 'solid';
        }
        return hAsync(
          Host,
          {
            'onClick': this.handleClick,
            'aria-disabled': disabled ? 'true' : null,
            'class': createColorClasses$1(color, {
              [mode]: true,
              [buttonType]: true,
              [`${buttonType}-${expand}`]: expand !== undefined,
              [`${buttonType}-${finalSize}`]: finalSize !== undefined,
              [`${buttonType}-${shape}`]: shape !== undefined,
              [`${buttonType}-${fill}`]: true,
              [`${buttonType}-strong`]: strong,
              'in-toolbar': hostContext('ion-toolbar', this.el),
              'in-toolbar-color': hostContext('ion-toolbar[color]', this.el),
              'button-has-icon-only': hasIconOnly,
              'button-disabled': disabled,
              'ion-activatable': true,
              'ion-focusable': true,
            }),
          },
          hAsync(
            TagType,
            Object.assign({}, attrs, { class: 'button-native', part: 'native', disabled: disabled, onFocus: this.onFocus, onBlur: this.onBlur }, inheritedAttributes),
            hAsync(
              'span',
              { class: 'button-inner' },
              hAsync('slot', { name: 'icon-only' }),
              hAsync('slot', { name: 'start' }),
              hAsync('slot', null),
              hAsync('slot', { name: 'end' }),
            ),
            mode === 'md' && hAsync('ion-ripple-effect', { type: this.rippleType }),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: buttonIosCss,
          md: buttonMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-button',
          $members$: {
            color: [513],
            buttonType: [1025, 'button-type'],
            disabled: [516],
            expand: [513],
            fill: [1537],
            routerDirection: [1, 'router-direction'],
            routerAnimation: [16],
            download: [1],
            href: [1],
            rel: [1],
            shape: [513],
            size: [513],
            strong: [4],
            target: [1],
            type: [1],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [
            ['color', 'color'],
            ['disabled', 'disabled'],
            ['expand', 'expand'],
            ['fill', 'fill'],
            ['shape', 'shape'],
            ['size', 'size'],
          ],
        };
      }
    }

    const buttonsIosCss =
      '.sc-ion-buttons-ios-h{display:flex;align-items:center;transform:translateZ(0);z-index:99}.sc-ion-buttons-ios-s ion-button{--padding-top:0;--padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-buttons-ios-s ion-button{--padding-start:5px;--padding-end:5px;margin-left:2px;margin-right:2px;height:32px;font-size:17px;font-weight:400}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.sc-ion-buttons-ios-s ion-button{margin-left:unset;margin-right:unset;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px}}.sc-ion-buttons-ios-s ion-button:not(.button-round){--border-radius:4px}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button{--color:initial;--border-color:initial;--background-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-solid,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-solid{--background:var(--ion-color-contrast);--background-focused:#000;--background-focused-opacity:.12;--background-activated:#000;--background-activated-opacity:.12;--background-hover:var(--ion-color-base);--background-hover-opacity:0.45;--color:var(--ion-color-base);--color-focused:var(--ion-color-base)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-clear,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-clear{--color-activated:var(--ion-color-contrast);--color-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-h.ion-color.sc-ion-buttons-ios-s .button-outline,.ion-color .sc-ion-buttons-ios-h.sc-ion-buttons-ios-s .button-outline{--color-activated:var(--ion-color-base);--color-focused:var(--ion-color-contrast)}.sc-ion-buttons-ios-s .button-clear,.sc-ion-buttons-ios-s .button-outline{--background-activated:transparent;--background-focused:currentColor;--background-hover:transparent}.sc-ion-buttons-ios-s .button-solid:not(.ion-color){--background-focused:#000;--background-focused-opacity:.12;--background-activated:#000;--background-activated-opacity:.12}.sc-ion-buttons-ios-s ion-icon[slot=start]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;margin-right:0.3em;font-size:24px;line-height:0.67}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.sc-ion-buttons-ios-s ion-icon[slot=start]{margin-right:unset;-webkit-margin-end:0.3em;margin-inline-end:0.3em}}.sc-ion-buttons-ios-s ion-icon[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;margin-left:0.4em;font-size:24px;line-height:0.67}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.sc-ion-buttons-ios-s ion-icon[slot=end]{margin-left:unset;-webkit-margin-start:0.4em;margin-inline-start:0.4em}}.sc-ion-buttons-ios-s ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:28px;line-height:0.67}';

    const buttonsMdCss =
      '.sc-ion-buttons-md-h{display:flex;align-items:center;transform:translateZ(0);z-index:99}.sc-ion-buttons-md-s ion-button{--padding-top:0;--padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-buttons-md-s ion-button{--padding-top:0;--padding-bottom:0;--padding-start:8px;--padding-end:8px;--box-shadow:none;margin-left:2px;margin-right:2px;height:32px;font-size:14px;font-weight:500}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.sc-ion-buttons-md-s ion-button{margin-left:unset;margin-right:unset;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:2px;margin-inline-end:2px}}.sc-ion-buttons-md-s ion-button:not(.button-round){--border-radius:2px}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button{--color:initial;--color-focused:var(--ion-color-contrast);--color-hover:var(--ion-color-contrast);--background-activated:transparent;--background-focused:var(--ion-color-contrast);--background-hover:var(--ion-color-contrast)}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button-solid,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button-solid{--background:var(--ion-color-contrast);--background-activated:transparent;--background-focused:var(--ion-color-shade);--background-hover:var(--ion-color-base);--color:var(--ion-color-base);--color-focused:var(--ion-color-base);--color-hover:var(--ion-color-base)}.sc-ion-buttons-md-h.ion-color.sc-ion-buttons-md-s .button-outline,.ion-color .sc-ion-buttons-md-h.sc-ion-buttons-md-s .button-outline{--border-color:var(--ion-color-contrast)}.sc-ion-buttons-md-s .button-has-icon-only.button-clear{--padding-top:12px;--padding-end:12px;--padding-bottom:12px;--padding-start:12px;--border-radius:50%;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;width:48px;height:48px}.sc-ion-buttons-md-s .button{--background-hover:currentColor}.sc-ion-buttons-md-s .button-solid{--color:var(--ion-toolbar-background, var(--ion-background-color, #fff));--background:var(--ion-toolbar-color, var(--ion-text-color, #424242));--background-activated:transparent;--background-focused:currentColor}.sc-ion-buttons-md-s .button-outline{--color:initial;--background:transparent;--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--border-color:currentColor}.sc-ion-buttons-md-s .button-clear{--color:initial;--background:transparent;--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor}.sc-ion-buttons-md-s ion-icon[slot=start]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;margin-right:0.3em;font-size:1.4em}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.sc-ion-buttons-md-s ion-icon[slot=start]{margin-right:unset;-webkit-margin-end:0.3em;margin-inline-end:0.3em}}.sc-ion-buttons-md-s ion-icon[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;margin-left:0.4em;font-size:1.4em}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.sc-ion-buttons-md-s ion-icon[slot=end]{margin-left:unset;-webkit-margin-start:0.4em;margin-inline-start:0.4em}}.sc-ion-buttons-md-s ion-icon[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:1.8em}';

    class Buttons {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If true, buttons will disappear when its
         * parent toolbar has fully collapsed if the toolbar
         * is not the first toolbar. If the toolbar is the
         * first toolbar, the buttons will be hidden and will
         * only be shown once all toolbars have fully collapsed.
         *
         * Only applies in `ios` mode with `collapse` set to
         * `true` on `ion-header`.
         *
         * Typically used for [Collapsible Large Titles](https://ionicframework.com/docs/api/title#collapsible-large-titles)
         */
        this.collapse = false;
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          class: {
            [mode]: true,
            ['buttons-collapse']: this.collapse,
          },
        });
      }
      static get style() {
        return {
          ios: buttonsIosCss,
          md: buttonsMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-buttons',
          $members$: {
            collapse: [4],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const cardIosCss =
      '/*!@:host*/.sc-ion-card-ios-h{--ion-safe-area-left:0px;--ion-safe-area-right:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);overflow:hidden}/*!@:host(.ion-color)*/.ion-color.sc-ion-card-ios-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(.card-disabled)*/.card-disabled.sc-ion-card-ios-h{cursor:default;opacity:0.3;pointer-events:none}/*!@.card-native*/.card-native.sc-ion-card-ios{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:100%;min-height:var(--min-height);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:inherit}/*!@.card-native::-moz-focus-inner*/.card-native.sc-ion-card-ios::-moz-focus-inner{border:0}/*!@button, a*/button.sc-ion-card-ios,a.sc-ion-card-ios{cursor:pointer;user-select:none;-webkit-user-drag:none}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-card-ios{color:var(--ripple-color)}/*!@:host*/.sc-ion-card-ios-h{--background:var(--ion-card-background, var(--ion-item-background, var(--ion-background-color, #fff)));--color:var(--ion-card-color, var(--ion-item-color, var(--ion-color-step-600, #666666)));margin-left:16px;margin-right:16px;margin-top:24px;margin-bottom:24px;border-radius:8px;transform:translateZ(0);transition:transform 500ms cubic-bezier(0.12, 0.72, 0.29, 1);font-size:14px;box-shadow:0 4px 16px rgba(0, 0, 0, 0.12)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-card-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px}}/*!@:host(.ion-activated)*/.ion-activated.sc-ion-card-ios-h{transform:scale3d(0.97, 0.97, 1)}';

    const cardMdCss =
      '/*!@:host*/.sc-ion-card-md-h{--ion-safe-area-left:0px;--ion-safe-area-right:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);overflow:hidden}/*!@:host(.ion-color)*/.ion-color.sc-ion-card-md-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(.card-disabled)*/.card-disabled.sc-ion-card-md-h{cursor:default;opacity:0.3;pointer-events:none}/*!@.card-native*/.card-native.sc-ion-card-md{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:100%;min-height:var(--min-height);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:inherit}/*!@.card-native::-moz-focus-inner*/.card-native.sc-ion-card-md::-moz-focus-inner{border:0}/*!@button, a*/button.sc-ion-card-md,a.sc-ion-card-md{cursor:pointer;user-select:none;-webkit-user-drag:none}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-card-md{color:var(--ripple-color)}/*!@:host*/.sc-ion-card-md-h{--background:var(--ion-card-background, var(--ion-item-background, var(--ion-background-color, #fff)));--color:var(--ion-card-color, var(--ion-item-color, var(--ion-color-step-550, #737373)));margin-left:10px;margin-right:10px;margin-top:10px;margin-bottom:10px;border-radius:4px;font-size:14px;box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-card-md-h{margin-left:unset;margin-right:unset;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part native - The native HTML button, anchor, or div element that wraps all child elements.
     */
    class Card {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If `true`, a button tag will be rendered and the card will be tappable.
         */
        this.button = false;
        /**
         * The type of the button. Only used when an `onclick` or `button` property is present.
         */
        this.type = 'button';
        /**
         * If `true`, the user cannot interact with the card.
         */
        this.disabled = false;
        /**
         * When using a router, it specifies the transition direction when navigating to
         * another page using `href`.
         */
        this.routerDirection = 'forward';
      }
      isClickable() {
        return this.href !== undefined || this.button;
      }
      renderCard(mode) {
        const clickable = this.isClickable();
        if (!clickable) {
          return [hAsync('slot', null)];
        }
        const { href, routerAnimation, routerDirection } = this;
        const TagType = clickable ? (href === undefined ? 'button' : 'a') : 'div';
        const attrs =
          TagType === 'button'
            ? { type: this.type }
            : {
                download: this.download,
                href: this.href,
                rel: this.rel,
                target: this.target,
              };
        return hAsync(
          TagType,
          Object.assign({}, attrs, { class: 'card-native', part: 'native', disabled: this.disabled, onClick: ev => openURL(href, ev, routerDirection, routerAnimation) }),
          hAsync('slot', null),
          clickable && mode === 'md' && hAsync('ion-ripple-effect', null),
        );
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: createColorClasses$1(this.color, {
              [mode]: true,
              'card-disabled': this.disabled,
              'ion-activatable': this.isClickable(),
            }),
          },
          this.renderCard(mode),
        );
      }
      static get style() {
        return {
          ios: cardIosCss,
          md: cardMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-card',
          $members$: {
            color: [513],
            button: [4],
            type: [1],
            disabled: [4],
            download: [1],
            href: [1],
            rel: [1],
            routerDirection: [1, 'router-direction'],
            routerAnimation: [16],
            target: [1],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const cardContentIosCss =
      'ion-card-content{display:block;position:relative}.card-content-ios{padding-left:20px;padding-right:20px;padding-top:20px;padding-bottom:20px;font-size:16px;line-height:1.4}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.card-content-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px}}.card-content-ios h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}.card-content-ios h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}.card-content-ios h3,.card-content-ios h4,.card-content-ios h5,.card-content-ios h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal}.card-content-ios p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px}ion-card-header+.card-content-ios{padding-top:0}';

    const cardContentMdCss =
      'ion-card-content{display:block;position:relative}.card-content-md{padding-left:16px;padding-right:16px;padding-top:13px;padding-bottom:13px;font-size:14px;line-height:1.5}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.card-content-md{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}.card-content-md h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}.card-content-md h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}.card-content-md h3,.card-content-md h4,.card-content-md h5,.card-content-md h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal}.card-content-md p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;font-weight:normal;line-height:1.5}ion-card-header+.card-content-md{padding-top:0}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class CardContent {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          class: {
            [mode]: true,
            // Used internally for styling
            [`card-content-${mode}`]: true,
          },
        });
      }
      static get style() {
        return {
          ios: cardContentIosCss,
          md: cardContentMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 32,
          $tagName$: 'ion-card-content',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const cardHeaderIosCss =
      '/*!@:host*/.sc-ion-card-header-ios-h{--background:transparent;--color:inherit;display:block;position:relative;background:var(--background);color:var(--color)}/*!@:host(.ion-color)*/.ion-color.sc-ion-card-header-ios-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host*/.sc-ion-card-header-ios-h{padding-left:20px;padding-right:20px;padding-top:20px;padding-bottom:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-card-header-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px}}@supports (backdrop-filter: blur(0)){/*!@:host(.card-header-translucent)*/.card-header-translucent.sc-ion-card-header-ios-h{background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.9);backdrop-filter:saturate(180%) blur(30px)}}';

    const cardHeaderMdCss =
      '/*!@:host*/.sc-ion-card-header-md-h{--background:transparent;--color:inherit;display:block;position:relative;background:var(--background);color:var(--color)}/*!@:host(.ion-color)*/.ion-color.sc-ion-card-header-md-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host*/.sc-ion-card-header-md-h{padding-left:16px;padding-right:16px;padding-top:16px;padding-bottom:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-card-header-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}/*!@::slotted(ion-card-title:not(:first-child)),\n::slotted(ion-card-subtitle:not(:first-child))*/.sc-ion-card-header-md-s>ion-card-title:not(:first-child),.sc-ion-card-header-md-s>ion-card-subtitle:not(:first-child){margin-top:8px}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class CardHeader {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If `true`, the card header will be translucent.
         * Only applies when the mode is `"ios"` and the device supports
         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
         */
        this.translucent = false;
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: createColorClasses$1(this.color, {
              'card-header-translucent': this.translucent,
              'ion-inherit-color': true,
              [mode]: true,
            }),
          },
          hAsync('slot', null),
        );
      }
      static get style() {
        return {
          ios: cardHeaderIosCss,
          md: cardHeaderMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-card-header',
          $members$: {
            color: [513],
            translucent: [4],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const cardSubtitleIosCss =
      '/*!@:host*/.sc-ion-card-subtitle-ios-h{display:block;position:relative;color:var(--color)}/*!@:host(.ion-color)*/.ion-color.sc-ion-card-subtitle-ios-h{color:var(--ion-color-base)}/*!@:host*/.sc-ion-card-subtitle-ios-h{--color:var(--ion-color-step-600, #666666);margin-left:0;margin-right:0;margin-top:0;margin-bottom:4px;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-size:12px;font-weight:700;letter-spacing:0.4px;text-transform:uppercase}';

    const cardSubtitleMdCss =
      '/*!@:host*/.sc-ion-card-subtitle-md-h{display:block;position:relative;color:var(--color)}/*!@:host(.ion-color)*/.ion-color.sc-ion-card-subtitle-md-h{color:var(--ion-color-base)}/*!@:host*/.sc-ion-card-subtitle-md-h{--color:var(--ion-color-step-550, #737373);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-size:14px;font-weight:500}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class CardSubtitle {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            'role': 'heading',
            'aria-level': '3',
            'class': createColorClasses$1(this.color, {
              'ion-inherit-color': true,
              [mode]: true,
            }),
          },
          hAsync('slot', null),
        );
      }
      static get style() {
        return {
          ios: cardSubtitleIosCss,
          md: cardSubtitleMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-card-subtitle',
          $members$: {
            color: [513],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const cardTitleIosCss =
      '/*!@:host*/.sc-ion-card-title-ios-h{display:block;position:relative;color:var(--color)}/*!@:host(.ion-color)*/.ion-color.sc-ion-card-title-ios-h{color:var(--ion-color-base)}/*!@:host*/.sc-ion-card-title-ios-h{--color:var(--ion-text-color, #000);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-size:28px;font-weight:700;line-height:1.2}';

    const cardTitleMdCss =
      '/*!@:host*/.sc-ion-card-title-md-h{display:block;position:relative;color:var(--color)}/*!@:host(.ion-color)*/.ion-color.sc-ion-card-title-md-h{color:var(--ion-color-base)}/*!@:host*/.sc-ion-card-title-md-h{--color:var(--ion-color-step-850, #262626);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;font-size:20px;font-weight:500;line-height:1.2}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class CardTitle {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            'role': 'heading',
            'aria-level': '2',
            'class': createColorClasses$1(this.color, {
              'ion-inherit-color': true,
              [mode]: true,
            }),
          },
          hAsync('slot', null),
        );
      }
      static get style() {
        return {
          ios: cardTitleIosCss,
          md: cardTitleMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-card-title',
          $members$: {
            color: [513],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const checkboxIosCss =
      '/*!@:host*/.sc-ion-checkbox-ios-h{--background-checked:var(--ion-color-primary, #3880ff);--border-color-checked:var(--ion-color-primary, #3880ff);--checkmark-color:var(--ion-color-primary-contrast, #fff);--checkmark-width:1;--transition:none;display:inline-block;position:relative;user-select:none;z-index:2}/*!@:host(.ion-color)*/.ion-color.sc-ion-checkbox-ios-h{--background-checked:var(--ion-color-base);--border-color-checked:var(--ion-color-base);--checkmark-color:var(--ion-color-contrast)}/*!@label*/label.sc-ion-checkbox-ios{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;appearance:none;outline:none;display:flex;align-items:center;opacity:0}/*!@[dir=rtl] label, :host-context([dir=rtl]) label*/[dir=rtl].sc-ion-checkbox-ios label.sc-ion-checkbox-ios,[dir=rtl].sc-ion-checkbox-ios-h label.sc-ion-checkbox-ios,[dir=rtl] .sc-ion-checkbox-ios-h label.sc-ion-checkbox-ios{left:unset;right:unset;right:0}/*!@label::-moz-focus-inner*/label.sc-ion-checkbox-ios::-moz-focus-inner{border:0}/*!@input*/input.sc-ion-checkbox-ios{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}/*!@.checkbox-icon*/.checkbox-icon.sc-ion-checkbox-ios{border-radius:var(--border-radius);display:block;position:relative;width:100%;height:100%;transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);box-sizing:border-box}/*!@.checkbox-icon path*/.checkbox-icon.sc-ion-checkbox-ios path.sc-ion-checkbox-ios{fill:none;stroke:var(--checkmark-color);stroke-width:var(--checkmark-width);opacity:0}/*!@:host(.checkbox-checked) .checkbox-icon,\n:host(.checkbox-indeterminate) .checkbox-icon*/.checkbox-checked.sc-ion-checkbox-ios-h .checkbox-icon.sc-ion-checkbox-ios,.checkbox-indeterminate.sc-ion-checkbox-ios-h .checkbox-icon.sc-ion-checkbox-ios{border-color:var(--border-color-checked);background:var(--background-checked)}/*!@:host(.checkbox-checked) .checkbox-icon path,\n:host(.checkbox-indeterminate) .checkbox-icon path*/.checkbox-checked.sc-ion-checkbox-ios-h .checkbox-icon.sc-ion-checkbox-ios path.sc-ion-checkbox-ios,.checkbox-indeterminate.sc-ion-checkbox-ios-h .checkbox-icon.sc-ion-checkbox-ios path.sc-ion-checkbox-ios{opacity:1}/*!@:host(.checkbox-disabled)*/.checkbox-disabled.sc-ion-checkbox-ios-h{pointer-events:none}/*!@:host*/.sc-ion-checkbox-ios-h{--border-radius:50%;--border-width:1px;--border-style:solid;--border-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.23);--background:var(--ion-item-background, var(--ion-background-color, #fff));--size:26px;width:var(--size);height:var(--size)}/*!@:host(.checkbox-disabled)*/.checkbox-disabled.sc-ion-checkbox-ios-h{opacity:0.3}/*!@:host(.in-item)*/.in-item.sc-ion-checkbox-ios-h{margin-left:0;margin-right:8px;margin-top:10px;margin-bottom:9px;display:block;position:static}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-item)*/.in-item.sc-ion-checkbox-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px}}/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-checkbox-ios-h{margin-left:2px;margin-right:20px;margin-top:8px;margin-bottom:8px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-checkbox-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:20px;margin-inline-end:20px}}';

    const checkboxMdCss =
      '/*!@:host*/.sc-ion-checkbox-md-h{--background-checked:var(--ion-color-primary, #3880ff);--border-color-checked:var(--ion-color-primary, #3880ff);--checkmark-color:var(--ion-color-primary-contrast, #fff);--checkmark-width:1;--transition:none;display:inline-block;position:relative;user-select:none;z-index:2}/*!@:host(.ion-color)*/.ion-color.sc-ion-checkbox-md-h{--background-checked:var(--ion-color-base);--border-color-checked:var(--ion-color-base);--checkmark-color:var(--ion-color-contrast)}/*!@label*/label.sc-ion-checkbox-md{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;appearance:none;outline:none;display:flex;align-items:center;opacity:0}/*!@[dir=rtl] label, :host-context([dir=rtl]) label*/[dir=rtl].sc-ion-checkbox-md label.sc-ion-checkbox-md,[dir=rtl].sc-ion-checkbox-md-h label.sc-ion-checkbox-md,[dir=rtl] .sc-ion-checkbox-md-h label.sc-ion-checkbox-md{left:unset;right:unset;right:0}/*!@label::-moz-focus-inner*/label.sc-ion-checkbox-md::-moz-focus-inner{border:0}/*!@input*/input.sc-ion-checkbox-md{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}/*!@.checkbox-icon*/.checkbox-icon.sc-ion-checkbox-md{border-radius:var(--border-radius);display:block;position:relative;width:100%;height:100%;transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);box-sizing:border-box}/*!@.checkbox-icon path*/.checkbox-icon.sc-ion-checkbox-md path.sc-ion-checkbox-md{fill:none;stroke:var(--checkmark-color);stroke-width:var(--checkmark-width);opacity:0}/*!@:host(.checkbox-checked) .checkbox-icon,\n:host(.checkbox-indeterminate) .checkbox-icon*/.checkbox-checked.sc-ion-checkbox-md-h .checkbox-icon.sc-ion-checkbox-md,.checkbox-indeterminate.sc-ion-checkbox-md-h .checkbox-icon.sc-ion-checkbox-md{border-color:var(--border-color-checked);background:var(--background-checked)}/*!@:host(.checkbox-checked) .checkbox-icon path,\n:host(.checkbox-indeterminate) .checkbox-icon path*/.checkbox-checked.sc-ion-checkbox-md-h .checkbox-icon.sc-ion-checkbox-md path.sc-ion-checkbox-md,.checkbox-indeterminate.sc-ion-checkbox-md-h .checkbox-icon.sc-ion-checkbox-md path.sc-ion-checkbox-md{opacity:1}/*!@:host(.checkbox-disabled)*/.checkbox-disabled.sc-ion-checkbox-md-h{pointer-events:none}/*!@:host*/.sc-ion-checkbox-md-h{--border-radius:calc(var(--size) * .125);--border-width:2px;--border-style:solid;--border-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.51);--checkmark-width:3;--background:var(--ion-item-background, var(--ion-background-color, #fff));--transition:background 180ms cubic-bezier(0.4, 0, 0.2, 1);--size:18px;width:var(--size);height:var(--size)}/*!@.checkbox-icon path*/.checkbox-icon.sc-ion-checkbox-md path.sc-ion-checkbox-md{stroke-dasharray:30;stroke-dashoffset:30}/*!@:host(.checkbox-checked) .checkbox-icon path,\n:host(.checkbox-indeterminate) .checkbox-icon path*/.checkbox-checked.sc-ion-checkbox-md-h .checkbox-icon.sc-ion-checkbox-md path.sc-ion-checkbox-md,.checkbox-indeterminate.sc-ion-checkbox-md-h .checkbox-icon.sc-ion-checkbox-md path.sc-ion-checkbox-md{stroke-dashoffset:0;transition:stroke-dashoffset 90ms linear 90ms}/*!@:host(.checkbox-disabled)*/.checkbox-disabled.sc-ion-checkbox-md-h{opacity:0.3}/*!@:host(.in-item)*/.in-item.sc-ion-checkbox-md-h{margin-left:0;margin-right:0;margin-top:18px;margin-bottom:18px;display:block;position:static}/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-checkbox-md-h{margin-left:4px;margin-right:36px;margin-top:18px;margin-bottom:18px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-checkbox-md-h{margin-left:unset;margin-right:unset;-webkit-margin-start:4px;margin-inline-start:4px;-webkit-margin-end:36px;margin-inline-end:36px}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part container - The container for the checkbox mark.
     * @part mark - The checkmark used to indicate the checked state.
     */
    class Checkbox {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionChange = createEvent(this, 'ionChange', 7);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.inputId = `ion-cb-${checkboxIds++}`;
        /**
         * The name of the control, which is submitted with the form data.
         */
        this.name = this.inputId;
        /**
         * If `true`, the checkbox is selected.
         */
        this.checked = false;
        /**
         * If `true`, the checkbox will visually appear as indeterminate.
         */
        this.indeterminate = false;
        /**
         * If `true`, the user cannot interact with the checkbox.
         */
        this.disabled = false;
        /**
         * The value of the checkbox does not mean if it's checked or not, use the `checked`
         * property for that.
         *
         * The value of a checkbox is analogous to the value of an `<input type="checkbox">`,
         * it's only used when the checkbox participates in a native `<form>`.
         */
        this.value = 'on';
        this.onClick = ev => {
          ev.preventDefault();
          this.setFocus();
          this.checked = !this.checked;
          this.indeterminate = false;
        };
        this.onFocus = () => {
          this.ionFocus.emit();
        };
        this.onBlur = () => {
          this.ionBlur.emit();
        };
      }
      componentWillLoad() {
        this.emitStyle();
      }
      checkedChanged(isChecked) {
        this.ionChange.emit({
          checked: isChecked,
          value: this.value,
        });
        this.emitStyle();
      }
      disabledChanged() {
        this.emitStyle();
      }
      emitStyle() {
        this.ionStyle.emit({
          'checkbox-checked': this.checked,
          'interactive-disabled': this.disabled,
        });
      }
      setFocus() {
        if (this.focusEl) {
          this.focusEl.focus();
        }
      }
      render() {
        const { color, checked, disabled, el, indeterminate, inputId, name, value } = this;
        const mode = getIonMode$1(this);
        const { label, labelId, labelText } = getAriaLabel(el, inputId);
        renderHiddenInput(true, el, name, checked ? value : '', disabled);
        let path = indeterminate ? hAsync('path', { d: 'M6 12L18 12', part: 'mark' }) : hAsync('path', { d: 'M5.9,12.5l3.8,3.8l8.8-8.8', part: 'mark' });
        if (mode === 'md') {
          path = indeterminate ? hAsync('path', { d: 'M2 12H22', part: 'mark' }) : hAsync('path', { d: 'M1.73,12.91 8.1,19.28 22.79,4.59', part: 'mark' });
        }
        return hAsync(
          Host,
          {
            'onClick': this.onClick,
            'aria-labelledby': label ? labelId : null,
            'aria-checked': `${checked}`,
            'aria-hidden': disabled ? 'true' : null,
            'role': 'checkbox',
            'class': createColorClasses$1(color, {
              [mode]: true,
              'in-item': hostContext('ion-item', el),
              'checkbox-checked': checked,
              'checkbox-disabled': disabled,
              'checkbox-indeterminate': indeterminate,
              'interactive': true,
            }),
          },
          hAsync('svg', { class: 'checkbox-icon', viewBox: '0 0 24 24', part: 'container' }, path),
          hAsync('label', { htmlFor: inputId }, labelText),
          hAsync('input', {
            'type': 'checkbox',
            'aria-checked': `${checked}`,
            'disabled': disabled,
            'id': inputId,
            'onFocus': () => this.onFocus(),
            'onBlur': () => this.onBlur(),
            'ref': focusEl => (this.focusEl = focusEl),
          }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          checked: ['checkedChanged'],
          disabled: ['disabledChanged'],
        };
      }
      static get style() {
        return {
          ios: checkboxIosCss,
          md: checkboxMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-checkbox',
          $members$: {
            color: [513],
            name: [1],
            checked: [1028],
            indeterminate: [1028],
            disabled: [4],
            value: [1],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }
    let checkboxIds = 0;

    const chipIosCss =
      '/*!@:host*/.sc-ion-chip-ios-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.12);--color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.87);border-radius:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:4px;margin-right:4px;margin-top:4px;margin-bottom:4px;padding-left:12px;padding-right:12px;padding-top:7px;padding-bottom:7px;display:inline-flex;position:relative;align-items:center;height:32px;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);font-size:14px;line-height:1;cursor:pointer;overflow:hidden;vertical-align:middle;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-chip-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:4px;margin-inline-start:4px;-webkit-margin-end:4px;margin-inline-end:4px}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-chip-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px}}/*!@:host(.chip-disabled)*/.chip-disabled.sc-ion-chip-ios-h{cursor:default;opacity:0.4;pointer-events:none}/*!@:host(.ion-color)*/.ion-color.sc-ion-chip-ios-h{background:rgba(var(--ion-color-base-rgb), 0.08);color:var(--ion-color-shade)}/*!@:host(.ion-color:focus)*/.ion-color.sc-ion-chip-ios-h:focus{background:rgba(var(--ion-color-base-rgb), 0.12)}/*!@:host(.ion-color.ion-activated)*/.ion-color.ion-activated.sc-ion-chip-ios-h{background:rgba(var(--ion-color-base-rgb), 0.16)}/*!@:host(.chip-outline)*/.chip-outline.sc-ion-chip-ios-h{border-width:1px;border-style:solid}/*!@:host(.chip-outline)*/.chip-outline.sc-ion-chip-ios-h{border-color:rgba(0, 0, 0, 0.32);background:transparent}/*!@:host(.chip-outline.ion-color)*/.chip-outline.ion-color.sc-ion-chip-ios-h{border-color:rgba(var(--ion-color-base-rgb), 0.32)}/*!@:host(.chip-outline:not(.ion-color):focus)*/.chip-outline.sc-ion-chip-ios-h:not(.ion-color):focus{background:rgba(0, 0, 0, 0.04)}/*!@:host(.chip-outline.ion-activated:not(.ion-color))*/.chip-outline.ion-activated.sc-ion-chip-ios-h:not(.ion-color){background:rgba(0, 0, 0, 0.08)}/*!@::slotted(ion-icon)*/.sc-ion-chip-ios-s>ion-icon{font-size:20px}/*!@:host(:not(.ion-color)) ::slotted(ion-icon)*/.sc-ion-chip-ios-h:not(.ion-color) .sc-ion-chip-ios-s>ion-icon{color:rgba(0, 0, 0, 0.54)}/*!@::slotted(ion-icon:first-child)*/.sc-ion-chip-ios-s>ion-icon:first-child{margin-left:-4px;margin-right:8px;margin-top:-4px;margin-bottom:-4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon:first-child)*/.sc-ion-chip-ios-s>ion-icon:first-child{margin-left:unset;margin-right:unset;-webkit-margin-start:-4px;margin-inline-start:-4px;-webkit-margin-end:8px;margin-inline-end:8px}}/*!@::slotted(ion-icon:last-child)*/.sc-ion-chip-ios-s>ion-icon:last-child{margin-left:8px;margin-right:-4px;margin-top:-4px;margin-bottom:-4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon:last-child)*/.sc-ion-chip-ios-s>ion-icon:last-child{margin-left:unset;margin-right:unset;-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:-4px;margin-inline-end:-4px}}/*!@::slotted(ion-avatar)*/.sc-ion-chip-ios-s>ion-avatar{width:24px;height:24px}/*!@::slotted(ion-avatar:first-child)*/.sc-ion-chip-ios-s>ion-avatar:first-child{margin-left:-8px;margin-right:8px;margin-top:-4px;margin-bottom:-4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-avatar:first-child)*/.sc-ion-chip-ios-s>ion-avatar:first-child{margin-left:unset;margin-right:unset;-webkit-margin-start:-8px;margin-inline-start:-8px;-webkit-margin-end:8px;margin-inline-end:8px}}/*!@::slotted(ion-avatar:last-child)*/.sc-ion-chip-ios-s>ion-avatar:last-child{margin-left:8px;margin-right:-8px;margin-top:-4px;margin-bottom:-4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-avatar:last-child)*/.sc-ion-chip-ios-s>ion-avatar:last-child{margin-left:unset;margin-right:unset;-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:-8px;margin-inline-end:-8px}}/*!@:host(:focus)*/.sc-ion-chip-ios-h:focus{outline:none}/*!@:host(:focus)*/.sc-ion-chip-ios-h:focus{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.16)}/*!@:host(.ion-activated)*/.ion-activated.sc-ion-chip-ios-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2)}@media (any-hover: hover){/*!@:host(:hover)*/.sc-ion-chip-ios-h:hover{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.16)}/*!@:host(.ion-color:hover)*/.ion-color.sc-ion-chip-ios-h:hover{background:rgba(var(--ion-color-base-rgb), 0.12)}/*!@:host(.chip-outline:not(.ion-color):hover)*/.chip-outline.sc-ion-chip-ios-h:not(.ion-color):hover{background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.04)}}';

    const chipMdCss =
      '/*!@:host*/.sc-ion-chip-md-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.12);--color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.87);border-radius:16px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:4px;margin-right:4px;margin-top:4px;margin-bottom:4px;padding-left:12px;padding-right:12px;padding-top:7px;padding-bottom:7px;display:inline-flex;position:relative;align-items:center;height:32px;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);font-size:14px;line-height:1;cursor:pointer;overflow:hidden;vertical-align:middle;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-chip-md-h{margin-left:unset;margin-right:unset;-webkit-margin-start:4px;margin-inline-start:4px;-webkit-margin-end:4px;margin-inline-end:4px}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-chip-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px}}/*!@:host(.chip-disabled)*/.chip-disabled.sc-ion-chip-md-h{cursor:default;opacity:0.4;pointer-events:none}/*!@:host(.ion-color)*/.ion-color.sc-ion-chip-md-h{background:rgba(var(--ion-color-base-rgb), 0.08);color:var(--ion-color-shade)}/*!@:host(.ion-color:focus)*/.ion-color.sc-ion-chip-md-h:focus{background:rgba(var(--ion-color-base-rgb), 0.12)}/*!@:host(.ion-color.ion-activated)*/.ion-color.ion-activated.sc-ion-chip-md-h{background:rgba(var(--ion-color-base-rgb), 0.16)}/*!@:host(.chip-outline)*/.chip-outline.sc-ion-chip-md-h{border-width:1px;border-style:solid}/*!@:host(.chip-outline)*/.chip-outline.sc-ion-chip-md-h{border-color:rgba(0, 0, 0, 0.32);background:transparent}/*!@:host(.chip-outline.ion-color)*/.chip-outline.ion-color.sc-ion-chip-md-h{border-color:rgba(var(--ion-color-base-rgb), 0.32)}/*!@:host(.chip-outline:not(.ion-color):focus)*/.chip-outline.sc-ion-chip-md-h:not(.ion-color):focus{background:rgba(0, 0, 0, 0.04)}/*!@:host(.chip-outline.ion-activated:not(.ion-color))*/.chip-outline.ion-activated.sc-ion-chip-md-h:not(.ion-color){background:rgba(0, 0, 0, 0.08)}/*!@::slotted(ion-icon)*/.sc-ion-chip-md-s>ion-icon{font-size:20px}/*!@:host(:not(.ion-color)) ::slotted(ion-icon)*/.sc-ion-chip-md-h:not(.ion-color) .sc-ion-chip-md-s>ion-icon{color:rgba(0, 0, 0, 0.54)}/*!@::slotted(ion-icon:first-child)*/.sc-ion-chip-md-s>ion-icon:first-child{margin-left:-4px;margin-right:8px;margin-top:-4px;margin-bottom:-4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon:first-child)*/.sc-ion-chip-md-s>ion-icon:first-child{margin-left:unset;margin-right:unset;-webkit-margin-start:-4px;margin-inline-start:-4px;-webkit-margin-end:8px;margin-inline-end:8px}}/*!@::slotted(ion-icon:last-child)*/.sc-ion-chip-md-s>ion-icon:last-child{margin-left:8px;margin-right:-4px;margin-top:-4px;margin-bottom:-4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon:last-child)*/.sc-ion-chip-md-s>ion-icon:last-child{margin-left:unset;margin-right:unset;-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:-4px;margin-inline-end:-4px}}/*!@::slotted(ion-avatar)*/.sc-ion-chip-md-s>ion-avatar{width:24px;height:24px}/*!@::slotted(ion-avatar:first-child)*/.sc-ion-chip-md-s>ion-avatar:first-child{margin-left:-8px;margin-right:8px;margin-top:-4px;margin-bottom:-4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-avatar:first-child)*/.sc-ion-chip-md-s>ion-avatar:first-child{margin-left:unset;margin-right:unset;-webkit-margin-start:-8px;margin-inline-start:-8px;-webkit-margin-end:8px;margin-inline-end:8px}}/*!@::slotted(ion-avatar:last-child)*/.sc-ion-chip-md-s>ion-avatar:last-child{margin-left:8px;margin-right:-8px;margin-top:-4px;margin-bottom:-4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-avatar:last-child)*/.sc-ion-chip-md-s>ion-avatar:last-child{margin-left:unset;margin-right:unset;-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:-8px;margin-inline-end:-8px}}/*!@:host(:focus)*/.sc-ion-chip-md-h:focus{outline:none}/*!@:host(:focus)*/.sc-ion-chip-md-h:focus{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.16)}/*!@:host(.ion-activated)*/.ion-activated.sc-ion-chip-md-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.2)}@media (any-hover: hover){/*!@:host(:hover)*/.sc-ion-chip-md-h:hover{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.16)}/*!@:host(.ion-color:hover)*/.ion-color.sc-ion-chip-md-h:hover{background:rgba(var(--ion-color-base-rgb), 0.12)}/*!@:host(.chip-outline:not(.ion-color):hover)*/.chip-outline.sc-ion-chip-md-h:not(.ion-color):hover{background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.04)}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Chip {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * Display an outline style button.
         */
        this.outline = false;
        /**
         * If `true`, the user cannot interact with the chip.
         */
        this.disabled = false;
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            'aria-disabled': this.disabled ? 'true' : null,
            'class': createColorClasses$1(this.color, {
              [mode]: true,
              'chip-outline': this.outline,
              'chip-disabled': this.disabled,
              'ion-activatable': true,
            }),
          },
          hAsync('slot', null),
          mode === 'md' && hAsync('ion-ripple-effect', null),
        );
      }
      static get style() {
        return {
          ios: chipIosCss,
          md: chipMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-chip',
          $members$: {
            color: [513],
            outline: [4],
            disabled: [4],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const SIZE_TO_MEDIA = {
      xs: '(min-width: 0px)',
      sm: '(min-width: 576px)',
      md: '(min-width: 768px)',
      lg: '(min-width: 992px)',
      xl: '(min-width: 1200px)',
    };
    // Check if the window matches the media query
    // at the breakpoint passed
    // e.g. matchBreakpoint('sm') => true if screen width exceeds 576px
    const matchBreakpoint = breakpoint => {
      if (breakpoint === undefined || breakpoint === '') {
        return true;
      }
      if (window.matchMedia) {
        const mediaQuery = SIZE_TO_MEDIA[breakpoint];
        return window.matchMedia(mediaQuery).matches;
      }
      return false;
    };

    const colCss =
      '/*!@:host*/.sc-ion-col-h{padding-left:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-right:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;box-sizing:border-box;position:relative;flex-basis:0;flex-grow:1;width:100%;max-width:100%;min-height:1px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-col-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-xs, var(--ion-grid-column-padding, 5px))}}@media (min-width: 576px){/*!@:host*/.sc-ion-col-h{padding-left:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-right:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px))}/*!@@supports (margin-inline-start: 0) or (-webkit-margin-start: 0)*/@supports .sc-ion-col (margin-inline-start.sc-ion-col: 0).sc-ion-col or.sc-ion-col (-webkit-margin-start.sc-ion-col: 0).sc-ion-col{.sc-ion-col-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-sm, var(--ion-grid-column-padding, 5px))}}}@media (min-width: 768px){/*!@:host*/.sc-ion-col-h{padding-left:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-right:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px))}/*!@@supports (margin-inline-start: 0) or (-webkit-margin-start: 0)*/@supports .sc-ion-col (margin-inline-start.sc-ion-col: 0).sc-ion-col or.sc-ion-col (-webkit-margin-start.sc-ion-col: 0).sc-ion-col{.sc-ion-col-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-md, var(--ion-grid-column-padding, 5px))}}}@media (min-width: 992px){/*!@:host*/.sc-ion-col-h{padding-left:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-right:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px))}/*!@@supports (margin-inline-start: 0) or (-webkit-margin-start: 0)*/@supports .sc-ion-col (margin-inline-start.sc-ion-col: 0).sc-ion-col or.sc-ion-col (-webkit-margin-start.sc-ion-col: 0).sc-ion-col{.sc-ion-col-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-lg, var(--ion-grid-column-padding, 5px))}}}@media (min-width: 1200px){/*!@:host*/.sc-ion-col-h{padding-left:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-right:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-top:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-bottom:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px))}/*!@@supports (margin-inline-start: 0) or (-webkit-margin-start: 0)*/@supports .sc-ion-col (margin-inline-start.sc-ion-col: 0).sc-ion-col or.sc-ion-col (-webkit-margin-start.sc-ion-col: 0).sc-ion-col{.sc-ion-col-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-inline-start:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));-webkit-padding-end:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px));padding-inline-end:var(--ion-grid-column-padding-xl, var(--ion-grid-column-padding, 5px))}}}';

    const win$1 = window;
    const SUPPORTS_VARS = !!(win$1.CSS && win$1.CSS.supports && win$1.CSS.supports('--a: 0'));
    const BREAKPOINTS = ['', 'xs', 'sm', 'md', 'lg', 'xl'];
    class Col {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      onResize() {
        forceUpdate$1(this);
      }
      // Loop through all of the breakpoints to see if the media query
      // matches and grab the column value from the relevant prop if so
      getColumns(property) {
        let matched;
        for (const breakpoint of BREAKPOINTS) {
          const matches = matchBreakpoint(breakpoint);
          // Grab the value of the property, if it exists and our
          // media query matches we return the value
          const columns = this[property + breakpoint.charAt(0).toUpperCase() + breakpoint.slice(1)];
          if (matches && columns !== undefined) {
            matched = columns;
          }
        }
        // Return the last matched columns since the breakpoints
        // increase in size and we want to return the largest match
        return matched;
      }
      calculateSize() {
        const columns = this.getColumns('size');
        // If size wasn't set for any breakpoint
        // or if the user set the size without a value
        // it means we need to stick with the default and return
        // e.g. <ion-col size-md>
        if (!columns || columns === '') {
          return;
        }
        // If the size is set to auto then don't calculate a size
        const colSize =
          columns === 'auto'
            ? 'auto'
            : // If CSS supports variables we should use the grid columns var
            SUPPORTS_VARS
            ? `calc(calc(${columns} / var(--ion-grid-columns, 12)) * 100%)`
            : // Convert the columns to a percentage by dividing by the total number
              // of columns (12) and then multiplying by 100
              (columns / 12) * 100 + '%';
        return {
          'flex': `0 0 ${colSize}`,
          'width': `${colSize}`,
          'max-width': `${colSize}`,
        };
      }
      // Called by push, pull, and offset since they use the same calculations
      calculatePosition(property, modifier) {
        const columns = this.getColumns(property);
        if (!columns) {
          return;
        }
        // If the number of columns passed are greater than 0 and less than
        // 12 we can position the column, else default to auto
        const amount = SUPPORTS_VARS
          ? // If CSS supports variables we should use the grid columns var
            `calc(calc(${columns} / var(--ion-grid-columns, 12)) * 100%)`
          : // Convert the columns to a percentage by dividing by the total number
          // of columns (12) and then multiplying by 100
          columns > 0 && columns < 12
          ? (columns / 12) * 100 + '%'
          : 'auto';
        return {
          [modifier]: amount,
        };
      }
      calculateOffset(isRTL) {
        return this.calculatePosition('offset', isRTL ? 'margin-right' : 'margin-left');
      }
      calculatePull(isRTL) {
        return this.calculatePosition('pull', isRTL ? 'left' : 'right');
      }
      calculatePush(isRTL) {
        return this.calculatePosition('push', isRTL ? 'right' : 'left');
      }
      render() {
        const isRTL = document.dir === 'rtl';
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: {
              [mode]: true,
            },
            style: Object.assign(
              Object.assign(Object.assign(Object.assign({}, this.calculateOffset(isRTL)), this.calculatePull(isRTL)), this.calculatePush(isRTL)),
              this.calculateSize(),
            ),
          },
          hAsync('slot', null),
        );
      }
      static get style() {
        return colCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-col',
          $members$: {
            offset: [1],
            offsetXs: [1, 'offset-xs'],
            offsetSm: [1, 'offset-sm'],
            offsetMd: [1, 'offset-md'],
            offsetLg: [1, 'offset-lg'],
            offsetXl: [1, 'offset-xl'],
            pull: [1],
            pullXs: [1, 'pull-xs'],
            pullSm: [1, 'pull-sm'],
            pullMd: [1, 'pull-md'],
            pullLg: [1, 'pull-lg'],
            pullXl: [1, 'pull-xl'],
            push: [1],
            pushXs: [1, 'push-xs'],
            pushSm: [1, 'push-sm'],
            pushMd: [1, 'push-md'],
            pushLg: [1, 'push-lg'],
            pushXl: [1, 'push-xl'],
            size: [1],
            sizeXs: [1, 'size-xs'],
            sizeSm: [1, 'size-sm'],
            sizeMd: [1, 'size-md'],
            sizeLg: [1, 'size-lg'],
            sizeXl: [1, 'size-xl'],
          },
          $listeners$: [[9, 'resize', 'onResize']],
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const contentCss =
      '/*!@:host*/.sc-ion-content-h{--background:var(--ion-background-color, #fff);--color:var(--ion-text-color, #000);--padding-top:0px;--padding-bottom:0px;--padding-start:0px;--padding-end:0px;--keyboard-offset:0px;--offset-top:0px;--offset-bottom:0px;--overflow:auto;display:block;position:relative;flex:1;width:100%;height:100%;margin:0 !important;padding:0 !important;font-family:var(--ion-font-family, inherit);contain:size style}/*!@:host(.ion-color) .inner-scroll*/.ion-color.sc-ion-content-h .inner-scroll.sc-ion-content{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(.outer-content)*/.outer-content.sc-ion-content-h{--background:var(--ion-color-step-50, #f2f2f2)}/*!@#background-content*/#background-content.sc-ion-content{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);position:absolute;background:var(--background)}/*!@.inner-scroll*/.inner-scroll.sc-ion-content{left:0px;right:0px;top:calc(var(--offset-top) * -1);bottom:calc(var(--offset-bottom) * -1);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:calc(var(--padding-top) + var(--offset-top));padding-bottom:calc(var(--padding-bottom) + var(--keyboard-offset) + var(--offset-bottom));position:absolute;color:var(--color);box-sizing:border-box;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.inner-scroll*/.inner-scroll.sc-ion-content{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.scroll-y,\n.scroll-x*/.scroll-y.sc-ion-content,.scroll-x.sc-ion-content{-webkit-overflow-scrolling:touch;z-index:0;will-change:scroll-position}/*!@.scroll-y*/.scroll-y.sc-ion-content{touch-action:pan-y;overflow-y:var(--overflow);overscroll-behavior-y:contain}/*!@.scroll-x*/.scroll-x.sc-ion-content{touch-action:pan-x;overflow-x:var(--overflow);overscroll-behavior-x:contain}/*!@.scroll-x.scroll-y*/.scroll-x.scroll-y.sc-ion-content{touch-action:auto}/*!@.overscroll::before,\n.overscroll::after*/.overscroll.sc-ion-content::before,.overscroll.sc-ion-content::after{position:absolute;width:1px;height:1px;content:""}/*!@.overscroll::before*/.overscroll.sc-ion-content::before{bottom:-1px}/*!@.overscroll::after*/.overscroll.sc-ion-content::after{top:-1px}/*!@:host(.content-sizing)*/.content-sizing.sc-ion-content-h{contain:none}/*!@:host(.content-sizing) .inner-scroll*/.content-sizing.sc-ion-content-h .inner-scroll.sc-ion-content{position:relative}/*!@.transition-effect*/.transition-effect.sc-ion-content{display:none;position:absolute;left:-100%;width:100%;height:100vh;opacity:0;pointer-events:none}/*!@.transition-cover*/.transition-cover.sc-ion-content{position:absolute;right:0;width:100%;height:100%;background:black;opacity:0.1}/*!@.transition-shadow*/.transition-shadow.sc-ion-content{display:block;position:absolute;right:0;width:10px;height:100%;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAgCAYAAAAIXrg4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyhpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQ1IDc5LjE2MzQ5OSwgMjAxOC8wOC8xMy0xNjo0MDoyMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MTE3MDgzRkQ5QTkyMTFFOUEwNzQ5MkJFREE1NUY2MjQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MTE3MDgzRkU5QTkyMTFFOUEwNzQ5MkJFREE1NUY2MjQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoxMTcwODNGQjlBOTIxMUU5QTA3NDkyQkVEQTU1RjYyNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoxMTcwODNGQzlBOTIxMUU5QTA3NDkyQkVEQTU1RjYyNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PmePEuQAAABNSURBVHjaYvz//z8DIxAwMDAwATGMhmFmPDQuOSZks0AMmoJBaQHjkPfB0Lfg/2gQjVow+HPy/yHvg9GiYjQfjMbBqAWjFgy/4hogwADYqwdzxy5BuwAAAABJRU5ErkJggg==);background-repeat:repeat-y;background-size:10px 16px}/*!@::slotted([slot=fixed])*/.sc-ion-content-s>[slot=fixed]{position:absolute}';

    /**
     * @slot - Content is placed in the scrollable area if provided without a slot.
     * @slot fixed - Should be used for fixed content that should not scroll.
     *
     * @part background - The background of the content.
     * @part scroll - The scrollable container of the content.
     */
    class Content {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionScrollStart = createEvent(this, 'ionScrollStart', 7);
        this.ionScroll = createEvent(this, 'ionScroll', 7);
        this.ionScrollEnd = createEvent(this, 'ionScrollEnd', 7);
        this.isScrolling = false;
        this.lastScroll = 0;
        this.queued = false;
        this.cTop = -1;
        this.cBottom = -1;
        this.isMainContent = true;
        // Detail is used in a hot loop in the scroll event, by allocating it here
        // V8 will be able to inline any read/write to it since it's a monomorphic class.
        // https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html
        this.detail = {
          scrollTop: 0,
          scrollLeft: 0,
          type: 'scroll',
          event: undefined,
          startX: 0,
          startY: 0,
          startTime: 0,
          currentX: 0,
          currentY: 0,
          velocityX: 0,
          velocityY: 0,
          deltaX: 0,
          deltaY: 0,
          currentTime: 0,
          data: undefined,
          isScrolling: true,
        };
        /**
         * If `true`, the content will scroll behind the headers
         * and footers. This effect can easily be seen by setting the toolbar
         * to transparent.
         */
        this.fullscreen = false;
        /**
         * If you want to enable the content scrolling in the X axis, set this property to `true`.
         */
        this.scrollX = false;
        /**
         * If you want to disable the content scrolling in the Y axis, set this property to `false`.
         */
        this.scrollY = true;
        /**
         * Because of performance reasons, ionScroll events are disabled by default, in order to enable them
         * and start listening from (ionScroll), set this property to `true`.
         */
        this.scrollEvents = false;
      }
      connectedCallback() {
        this.isMainContent = this.el.closest('ion-menu, ion-popover, ion-modal') === null;
      }
      disconnectedCallback() {
        this.onScrollEnd();
      }
      onAppLoad() {
        this.resize();
      }
      onClick(ev) {
        if (this.isScrolling) {
          ev.preventDefault();
          ev.stopPropagation();
        }
      }
      shouldForceOverscroll() {
        const { forceOverscroll } = this;
        const mode = getIonMode$1(this);
        return forceOverscroll === undefined ? mode === 'ios' && isPlatform('ios') : forceOverscroll;
      }
      resize() {
        if (this.fullscreen) {
          readTask(() => this.readDimensions());
        } else if (this.cTop !== 0 || this.cBottom !== 0) {
          this.cTop = this.cBottom = 0;
          forceUpdate$1(this);
        }
      }
      readDimensions() {
        const page = getPageElement(this.el);
        const top = Math.max(this.el.offsetTop, 0);
        const bottom = Math.max(page.offsetHeight - top - this.el.offsetHeight, 0);
        const dirty = top !== this.cTop || bottom !== this.cBottom;
        if (dirty) {
          this.cTop = top;
          this.cBottom = bottom;
          forceUpdate$1(this);
        }
      }
      onScroll(ev) {
        const timeStamp = Date.now();
        const shouldStart = !this.isScrolling;
        this.lastScroll = timeStamp;
        if (shouldStart) {
          this.onScrollStart();
        }
        if (!this.queued && this.scrollEvents) {
          this.queued = true;
          readTask(ts => {
            this.queued = false;
            this.detail.event = ev;
            updateScrollDetail(this.detail, this.scrollEl, ts, shouldStart);
            this.ionScroll.emit(this.detail);
          });
        }
      }
      /**
       * Get the element where the actual scrolling takes place.
       * This element can be used to subscribe to `scroll` events or manually modify
       * `scrollTop`. However, it's recommended to use the API provided by `ion-content`:
       *
       * i.e. Using `ionScroll`, `ionScrollStart`, `ionScrollEnd` for scrolling events
       * and `scrollToPoint()` to scroll the content into a certain point.
       */
      getScrollElement() {
        return Promise.resolve(this.scrollEl);
      }
      /**
       * Scroll to the top of the component.
       *
       * @param duration The amount of time to take scrolling to the top. Defaults to `0`.
       */
      scrollToTop(duration = 0) {
        return this.scrollToPoint(undefined, 0, duration);
      }
      /**
       * Scroll to the bottom of the component.
       *
       * @param duration The amount of time to take scrolling to the bottom. Defaults to `0`.
       */
      scrollToBottom(duration = 0) {
        const y = this.scrollEl.scrollHeight - this.scrollEl.clientHeight;
        return this.scrollToPoint(undefined, y, duration);
      }
      /**
       * Scroll by a specified X/Y distance in the component.
       *
       * @param x The amount to scroll by on the horizontal axis.
       * @param y The amount to scroll by on the vertical axis.
       * @param duration The amount of time to take scrolling by that amount.
       */
      scrollByPoint(x, y, duration) {
        return this.scrollToPoint(x + this.scrollEl.scrollLeft, y + this.scrollEl.scrollTop, duration);
      }
      /**
       * Scroll to a specified X/Y location in the component.
       *
       * @param x The point to scroll to on the horizontal axis.
       * @param y The point to scroll to on the vertical axis.
       * @param duration The amount of time to take scrolling to that point. Defaults to `0`.
       */
      async scrollToPoint(x, y, duration = 0) {
        const el = this.scrollEl;
        if (duration < 32) {
          if (y != null) {
            el.scrollTop = y;
          }
          if (x != null) {
            el.scrollLeft = x;
          }
          return;
        }
        let resolve;
        let startTime = 0;
        const promise = new Promise(r => (resolve = r));
        const fromY = el.scrollTop;
        const fromX = el.scrollLeft;
        const deltaY = y != null ? y - fromY : 0;
        const deltaX = x != null ? x - fromX : 0;
        // scroll loop
        const step = timeStamp => {
          const linearTime = Math.min(1, (timeStamp - startTime) / duration) - 1;
          const easedT = Math.pow(linearTime, 3) + 1;
          if (deltaY !== 0) {
            el.scrollTop = Math.floor(easedT * deltaY + fromY);
          }
          if (deltaX !== 0) {
            el.scrollLeft = Math.floor(easedT * deltaX + fromX);
          }
          if (easedT < 1) {
            // do not use DomController here
            // must use nativeRaf in order to fire in the next frame
            // TODO: remove as any
            requestAnimationFrame(step);
          } else {
            resolve();
          }
        };
        // chill out for a frame first
        requestAnimationFrame(ts => {
          startTime = ts;
          step(ts);
        });
        return promise;
      }
      onScrollStart() {
        this.isScrolling = true;
        this.ionScrollStart.emit({
          isScrolling: true,
        });
        if (this.watchDog) {
          clearInterval(this.watchDog);
        }
        // watchdog
        this.watchDog = setInterval(() => {
          if (this.lastScroll < Date.now() - 120) {
            this.onScrollEnd();
          }
        }, 100);
      }
      onScrollEnd() {
        clearInterval(this.watchDog);
        this.watchDog = null;
        if (this.isScrolling) {
          this.isScrolling = false;
          this.ionScrollEnd.emit({
            isScrolling: false,
          });
        }
      }
      render() {
        const { isMainContent, scrollX, scrollY } = this;
        const mode = getIonMode$1(this);
        const forceOverscroll = this.shouldForceOverscroll();
        const TagType = isMainContent ? 'main' : 'div';
        const transitionShadow = mode === 'ios' && config$2.getBoolean('experimentalTransitionShadow', true);
        this.resize();
        return hAsync(
          Host,
          {
            class: createColorClasses$1(this.color, {
              [mode]: true,
              'content-sizing': hostContext('ion-popover', this.el),
              'overscroll': forceOverscroll,
            }),
            style: {
              '--offset-top': `${this.cTop}px`,
              '--offset-bottom': `${this.cBottom}px`,
            },
          },
          hAsync('div', { id: 'background-content', part: 'background' }),
          hAsync(
            TagType,
            {
              class: {
                'inner-scroll': true,
                'scroll-x': scrollX,
                'scroll-y': scrollY,
                'overscroll': (scrollX || scrollY) && forceOverscroll,
              },
              ref: el => (this.scrollEl = el),
              onScroll: this.scrollEvents ? ev => this.onScroll(ev) : undefined,
              part: 'scroll',
            },
            hAsync('slot', null),
          ),
          transitionShadow ? hAsync('div', { class: 'transition-effect' }, hAsync('div', { class: 'transition-cover' }), hAsync('div', { class: 'transition-shadow' })) : null,
          hAsync('slot', { name: 'fixed' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return contentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-content',
          $members$: {
            color: [513],
            fullscreen: [4],
            forceOverscroll: [1028, 'force-overscroll'],
            scrollX: [4, 'scroll-x'],
            scrollY: [4, 'scroll-y'],
            scrollEvents: [4, 'scroll-events'],
            getScrollElement: [64],
            scrollToTop: [64],
            scrollToBottom: [64],
            scrollByPoint: [64],
            scrollToPoint: [64],
          },
          $listeners$: [
            [8, 'appload', 'onAppLoad'],
            [2, 'click', 'onClick'],
          ],
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }
    const getParentElement = el => {
      if (el.parentElement) {
        // normal element with a parent element
        return el.parentElement;
      }
      if (el.parentNode && el.parentNode.host) {
        // shadow dom's document fragment
        return el.parentNode.host;
      }
      return null;
    };
    const getPageElement = el => {
      const tabs = el.closest('ion-tabs');
      if (tabs) {
        return tabs;
      }
      const page = el.closest('ion-app,ion-page,.ion-page,page-inner');
      if (page) {
        return page;
      }
      return getParentElement(el);
    };
    // ******** DOM READ ****************
    const updateScrollDetail = (detail, el, timestamp, shouldStart) => {
      const prevX = detail.currentX;
      const prevY = detail.currentY;
      const prevT = detail.currentTime;
      const currentX = el.scrollLeft;
      const currentY = el.scrollTop;
      const timeDelta = timestamp - prevT;
      if (shouldStart) {
        // remember the start positions
        detail.startTime = timestamp;
        detail.startX = currentX;
        detail.startY = currentY;
        detail.velocityX = detail.velocityY = 0;
      }
      detail.currentTime = timestamp;
      detail.currentX = detail.scrollLeft = currentX;
      detail.currentY = detail.scrollTop = currentY;
      detail.deltaX = currentX - detail.startX;
      detail.deltaY = currentY - detail.startY;
      if (timeDelta > 0 && timeDelta < 100) {
        const velocityX = (currentX - prevX) / timeDelta;
        const velocityY = (currentY - prevY) / timeDelta;
        detail.velocityX = velocityX * 0.7 + detail.velocityX * 0.3;
        detail.velocityY = velocityY * 0.7 + detail.velocityY * 0.3;
      }
    };

    /**
     * Gets a date value given a format
     * Defaults to the current date if
     * no date given
     */
    const getDateValue = (date, format) => {
      const getValue = getValueFromFormat(date, format);
      if (getValue !== undefined) {
        if (format === FORMAT_A || format === FORMAT_a) {
          date.ampm = getValue;
        }
        return getValue;
      }
      const defaultDate = parseDate(new Date().toISOString());
      return getValueFromFormat(defaultDate, format);
    };
    const renderDatetime = (template, value, locale) => {
      if (value === undefined) {
        return undefined;
      }
      const tokens = [];
      let hasText = false;
      FORMAT_KEYS.forEach((format, index) => {
        if (template.indexOf(format.f) > -1) {
          const token = '{' + index + '}';
          const text = renderTextFormat(format.f, value[format.k], value, locale);
          if (!hasText && text !== undefined && value[format.k] != null) {
            hasText = true;
          }
          tokens.push(token, text || '');
          template = template.replace(format.f, token);
        }
      });
      if (!hasText) {
        return undefined;
      }
      for (let i = 0; i < tokens.length; i += 2) {
        template = template.replace(tokens[i], tokens[i + 1]);
      }
      return template;
    };
    const renderTextFormat = (format, value, date, locale) => {
      if (format === FORMAT_DDDD || format === FORMAT_DDD) {
        try {
          value = new Date(date.year, date.month - 1, date.day).getDay();
          if (format === FORMAT_DDDD) {
            return (locale.dayNames ? locale.dayNames : DAY_NAMES)[value];
          }
          return (locale.dayShortNames ? locale.dayShortNames : DAY_SHORT_NAMES)[value];
        } catch (e) {
          // ignore
        }
        return undefined;
      }
      if (format === FORMAT_A) {
        return date !== undefined && date.hour !== undefined ? (date.hour < 12 ? 'AM' : 'PM') : value ? value.toUpperCase() : '';
      }
      if (format === FORMAT_a) {
        return date !== undefined && date.hour !== undefined ? (date.hour < 12 ? 'am' : 'pm') : value || '';
      }
      if (value == null) {
        return '';
      }
      if (format === FORMAT_YY || format === FORMAT_MM || format === FORMAT_DD || format === FORMAT_HH || format === FORMAT_mm || format === FORMAT_ss) {
        return twoDigit(value);
      }
      if (format === FORMAT_YYYY) {
        return fourDigit(value);
      }
      if (format === FORMAT_MMMM) {
        return (locale.monthNames ? locale.monthNames : MONTH_NAMES)[value - 1];
      }
      if (format === FORMAT_MMM) {
        return (locale.monthShortNames ? locale.monthShortNames : MONTH_SHORT_NAMES)[value - 1];
      }
      if (format === FORMAT_hh || format === FORMAT_h) {
        if (value === 0) {
          return '12';
        }
        if (value > 12) {
          value -= 12;
        }
        if (format === FORMAT_hh && value < 10) {
          return '0' + value;
        }
      }
      return value.toString();
    };
    const dateValueRange = (format, min, max) => {
      const opts = [];
      if (format === FORMAT_YYYY || format === FORMAT_YY) {
        // year
        if (max.year === undefined || min.year === undefined) {
          throw new Error('min and max year is undefined');
        }
        for (let i = max.year; i >= min.year; i--) {
          opts.push(i);
        }
      } else if (format === FORMAT_MMMM || format === FORMAT_MMM || format === FORMAT_MM || format === FORMAT_M || format === FORMAT_hh || format === FORMAT_h) {
        // month or 12-hour
        for (let i = 1; i < 13; i++) {
          opts.push(i);
        }
      } else if (format === FORMAT_DDDD || format === FORMAT_DDD || format === FORMAT_DD || format === FORMAT_D) {
        // day
        for (let i = 1; i < 32; i++) {
          opts.push(i);
        }
      } else if (format === FORMAT_HH || format === FORMAT_H) {
        // 24-hour
        for (let i = 0; i < 24; i++) {
          opts.push(i);
        }
      } else if (format === FORMAT_mm || format === FORMAT_m) {
        // minutes
        for (let i = 0; i < 60; i++) {
          opts.push(i);
        }
      } else if (format === FORMAT_ss || format === FORMAT_s) {
        // seconds
        for (let i = 0; i < 60; i++) {
          opts.push(i);
        }
      } else if (format === FORMAT_A || format === FORMAT_a) {
        // AM/PM
        opts.push('am', 'pm');
      }
      return opts;
    };
    const dateSortValue = (year, month, day, hour = 0, minute = 0) => {
      return parseInt(`1${fourDigit(year)}${twoDigit(month)}${twoDigit(day)}${twoDigit(hour)}${twoDigit(minute)}`, 10);
    };
    const dateDataSortValue = data => {
      return dateSortValue(data.year, data.month, data.day, data.hour, data.minute);
    };
    const daysInMonth = (month, year) => {
      return month === 4 || month === 6 || month === 9 || month === 11 ? 30 : month === 2 ? (isLeapYear(year) ? 29 : 28) : 31;
    };
    const isLeapYear = year => {
      return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    };
    const ISO_8601_REGEXP = /^(\d{4}|[+\-]\d{6})(?:-(\d{2})(?:-(\d{2}))?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
    const TIME_REGEXP = /^((\d{2}):(\d{2})(?::(\d{2})(?:\.(\d{3}))?)?(?:(Z)|([+\-])(\d{2})(?::(\d{2}))?)?)?$/;
    const parseDate = val => {
      // manually parse IS0 cuz Date.parse cannot be trusted
      // ISO 8601 format: 1994-12-15T13:47:20Z
      let parse = null;
      if (val != null && val !== '') {
        // try parsing for just time first, HH:MM
        parse = TIME_REGEXP.exec(val);
        if (parse) {
          // adjust the array so it fits nicely with the datetime parse
          parse.unshift(undefined, undefined);
          parse[2] = parse[3] = undefined;
        } else {
          // try parsing for full ISO datetime
          parse = ISO_8601_REGEXP.exec(val);
        }
      }
      if (parse === null) {
        // wasn't able to parse the ISO datetime
        return undefined;
      }
      // ensure all the parse values exist with at least 0
      for (let i = 1; i < 8; i++) {
        parse[i] = parse[i] !== undefined ? parseInt(parse[i], 10) : undefined;
      }
      let tzOffset = 0;
      if (parse[9] && parse[10]) {
        // hours
        tzOffset = parseInt(parse[10], 10) * 60;
        if (parse[11]) {
          // minutes
          tzOffset += parseInt(parse[11], 10);
        }
        if (parse[9] === '-') {
          // + or -
          tzOffset *= -1;
        }
      }
      return {
        year: parse[1],
        month: parse[2],
        day: parse[3],
        hour: parse[4],
        minute: parse[5],
        second: parse[6],
        millisecond: parse[7],
        tzOffset,
      };
    };
    /**
     * Converts a valid UTC datetime string to JS Date time object.
     * By default uses the users local timezone, but an optional
     * timezone can be provided.
     * Note: This is not meant for time strings
     * such as "01:47"
     */
    const getDateTime = (dateString = '', timeZone = '') => {
      /**
       * If user passed in undefined
       * or null, convert it to the
       * empty string since the rest
       * of this functions expects
       * a string
       */
      if (dateString === undefined || dateString === null) {
        dateString = '';
      }
      /**
       * Ensures that YYYY-MM-DD, YYYY-MM,
       * YYYY-DD, YYYY, etc does not get affected
       * by timezones and stays on the day/month
       * that the user provided
       */
      if (dateString.length === 10 || dateString.length === 7 || dateString.length === 4) {
        dateString += ' ';
      }
      const date = typeof dateString === 'string' && dateString.length > 0 ? new Date(dateString) : new Date();
      const localDateTime = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
      if (timeZone && timeZone.length > 0) {
        return new Date(date.getTime() - getTimezoneOffset(localDateTime, timeZone));
      }
      return localDateTime;
    };
    const getTimezoneOffset = (localDate, timeZone) => {
      const utcDateTime = new Date(localDate.toLocaleString('en-US', { timeZone: 'utc' }));
      const tzDateTime = new Date(localDate.toLocaleString('en-US', { timeZone }));
      return utcDateTime.getTime() - tzDateTime.getTime();
    };
    const updateDate = (existingData, newData, displayTimezone) => {
      if (!newData || typeof newData === 'string') {
        const dateTime = getDateTime(newData, displayTimezone);
        if (!Number.isNaN(dateTime.getTime())) {
          newData = dateTime.toISOString();
        }
      }
      if (newData && newData !== '') {
        if (typeof newData === 'string') {
          // new date is a string, and hopefully in the ISO format
          // convert it to our DatetimeData if a valid ISO
          newData = parseDate(newData);
          if (newData) {
            // successfully parsed the ISO string to our DatetimeData
            Object.assign(existingData, newData);
            return true;
          }
        } else if (newData.year || newData.hour || newData.month || newData.day || newData.minute || newData.second) {
          // newData is from the datetime picker's selected values
          // update the existing datetimeValue with the new values
          if (newData.ampm !== undefined && newData.hour !== undefined) {
            // change the value of the hour based on whether or not it is am or pm
            // if the meridiem is pm and equal to 12, it remains 12
            // otherwise we add 12 to the hour value
            // if the meridiem is am and equal to 12, we change it to 0
            // otherwise we use its current hour value
            // for example: 8 pm becomes 20, 12 am becomes 0, 4 am becomes 4
            newData.hour.value = newData.ampm.value === 'pm' ? (newData.hour.value === 12 ? 12 : newData.hour.value + 12) : newData.hour.value === 12 ? 0 : newData.hour.value;
          }
          // merge new values from the picker's selection
          // to the existing DatetimeData values
          for (const key of Object.keys(newData)) {
            existingData[key] = newData[key].value;
          }
          return true;
        } else if (newData.ampm) {
          // Even though in the picker column hour values are between 1 and 12, the hour value is actually normalized
          // to [0, 23] interval. Because of this when changing between AM and PM we have to update the hour so it points
          // to the correct HH hour
          newData.hour = {
            value: newData.hour
              ? newData.hour.value
              : newData.ampm.value === 'pm'
              ? existingData.hour < 12
                ? existingData.hour + 12
                : existingData.hour
              : existingData.hour >= 12
              ? existingData.hour - 12
              : existingData.hour,
          };
          existingData['hour'] = newData['hour'].value;
          existingData['ampm'] = newData['ampm'].value;
          return true;
        }
        // eww, invalid data
        console.warn(`Error parsing date: "${newData}". Please provide a valid ISO 8601 datetime format: https://www.w3.org/TR/NOTE-datetime`);
      } else {
        // blank data, clear everything out
        for (const k in existingData) {
          if (existingData.hasOwnProperty(k)) {
            delete existingData[k];
          }
        }
      }
      return false;
    };
    const parseTemplate = template => {
      const formats = [];
      template = template.replace(/[^\w\s]/gi, ' ');
      FORMAT_KEYS.forEach(format => {
        if (format.f.length > 1 && template.indexOf(format.f) > -1 && template.indexOf(format.f + format.f.charAt(0)) < 0) {
          template = template.replace(format.f, ' ' + format.f + ' ');
        }
      });
      const words = template.split(' ').filter(w => w.length > 0);
      words.forEach((word, i) => {
        FORMAT_KEYS.forEach(format => {
          if (word === format.f) {
            if (word === FORMAT_A || word === FORMAT_a) {
              // this format is an am/pm format, so it's an "a" or "A"
              if ((formats.indexOf(FORMAT_h) < 0 && formats.indexOf(FORMAT_hh) < 0) || VALID_AMPM_PREFIX.indexOf(words[i - 1]) === -1) {
                // template does not already have a 12-hour format
                // or this am/pm format doesn't have a hour, minute, or second format immediately before it
                // so do not treat this word "a" or "A" as the am/pm format
                return;
              }
            }
            formats.push(word);
          }
        });
      });
      return formats;
    };
    const getValueFromFormat = (date, format) => {
      if (format === FORMAT_A || format === FORMAT_a) {
        return date.hour < 12 ? 'am' : 'pm';
      }
      if (format === FORMAT_hh || format === FORMAT_h) {
        return date.hour > 12 ? date.hour - 12 : date.hour === 0 ? 12 : date.hour;
      }
      return date[convertFormatToKey(format)];
    };
    const convertFormatToKey = format => {
      for (const k in FORMAT_KEYS) {
        if (FORMAT_KEYS[k].f === format) {
          return FORMAT_KEYS[k].k;
        }
      }
      return undefined;
    };
    const convertDataToISO = data => {
      // https://www.w3.org/TR/NOTE-datetime
      let rtn = '';
      if (data.year !== undefined) {
        // YYYY
        rtn = fourDigit(data.year);
        if (data.month !== undefined) {
          // YYYY-MM
          rtn += '-' + twoDigit(data.month);
          if (data.day !== undefined) {
            // YYYY-MM-DD
            rtn += '-' + twoDigit(data.day);
            if (data.hour !== undefined) {
              // YYYY-MM-DDTHH:mm:SS
              rtn += `T${twoDigit(data.hour)}:${twoDigit(data.minute)}:${twoDigit(data.second)}`;
              if (data.millisecond > 0) {
                // YYYY-MM-DDTHH:mm:SS.SSS
                rtn += '.' + threeDigit(data.millisecond);
              }
              if (data.tzOffset === undefined) {
                // YYYY-MM-DDTHH:mm:SSZ
                rtn += 'Z';
              } else {
                // YYYY-MM-DDTHH:mm:SS+/-HH:mm
                rtn += (data.tzOffset > 0 ? '+' : '-') + twoDigit(Math.floor(Math.abs(data.tzOffset / 60))) + ':' + twoDigit(data.tzOffset % 60);
              }
            }
          }
        }
      } else if (data.hour !== undefined) {
        // HH:mm
        rtn = twoDigit(data.hour) + ':' + twoDigit(data.minute);
        if (data.second !== undefined) {
          // HH:mm:SS
          rtn += ':' + twoDigit(data.second);
          if (data.millisecond !== undefined) {
            // HH:mm:SS.SSS
            rtn += '.' + threeDigit(data.millisecond);
          }
        }
      }
      return rtn;
    };
    /**
     * Use to convert a string of comma separated strings or
     * an array of strings, and clean up any user input
     */
    const convertToArrayOfStrings = (input, type) => {
      if (input == null) {
        return undefined;
      }
      if (typeof input === 'string') {
        // convert the string to an array of strings
        // auto remove any [] characters
        input = input.replace(/\[|\]/g, '').split(',');
      }
      let values;
      if (Array.isArray(input)) {
        // trim up each string value
        values = input.map(val => val.toString().trim());
      }
      if (values === undefined || values.length === 0) {
        console.warn(`Invalid "${type}Names". Must be an array of strings, or a comma separated string.`);
      }
      return values;
    };
    /**
     * Use to convert a string of comma separated numbers or
     * an array of numbers, and clean up any user input
     */
    const convertToArrayOfNumbers = (input, type) => {
      if (typeof input === 'string') {
        // convert the string to an array of strings
        // auto remove any whitespace and [] characters
        input = input.replace(/\[|\]|\s/g, '').split(',');
      }
      let values;
      if (Array.isArray(input)) {
        // ensure each value is an actual number in the returned array
        values = input.map(num => parseInt(num, 10)).filter(isFinite);
      } else {
        values = [input];
      }
      if (values.length === 0) {
        console.warn(`Invalid "${type}Values". Must be an array of numbers, or a comma separated string of numbers.`);
      }
      return values;
    };
    const twoDigit = val => {
      return ('0' + (val !== undefined ? Math.abs(val) : '0')).slice(-2);
    };
    const threeDigit = val => {
      return ('00' + (val !== undefined ? Math.abs(val) : '0')).slice(-3);
    };
    const fourDigit = val => {
      return ('000' + (val !== undefined ? Math.abs(val) : '0')).slice(-4);
    };
    const FORMAT_YYYY = 'YYYY';
    const FORMAT_YY = 'YY';
    const FORMAT_MMMM = 'MMMM';
    const FORMAT_MMM = 'MMM';
    const FORMAT_MM = 'MM';
    const FORMAT_M = 'M';
    const FORMAT_DDDD = 'DDDD';
    const FORMAT_DDD = 'DDD';
    const FORMAT_DD = 'DD';
    const FORMAT_D = 'D';
    const FORMAT_HH = 'HH';
    const FORMAT_H = 'H';
    const FORMAT_hh = 'hh';
    const FORMAT_h = 'h';
    const FORMAT_mm = 'mm';
    const FORMAT_m = 'm';
    const FORMAT_ss = 'ss';
    const FORMAT_s = 's';
    const FORMAT_A = 'A';
    const FORMAT_a = 'a';
    const FORMAT_KEYS = [
      { f: FORMAT_YYYY, k: 'year' },
      { f: FORMAT_MMMM, k: 'month' },
      { f: FORMAT_DDDD, k: 'day' },
      { f: FORMAT_MMM, k: 'month' },
      { f: FORMAT_DDD, k: 'day' },
      { f: FORMAT_YY, k: 'year' },
      { f: FORMAT_MM, k: 'month' },
      { f: FORMAT_DD, k: 'day' },
      { f: FORMAT_HH, k: 'hour' },
      { f: FORMAT_hh, k: 'hour' },
      { f: FORMAT_mm, k: 'minute' },
      { f: FORMAT_ss, k: 'second' },
      { f: FORMAT_M, k: 'month' },
      { f: FORMAT_D, k: 'day' },
      { f: FORMAT_H, k: 'hour' },
      { f: FORMAT_h, k: 'hour' },
      { f: FORMAT_m, k: 'minute' },
      { f: FORMAT_s, k: 'second' },
      { f: FORMAT_A, k: 'ampm' },
      { f: FORMAT_a, k: 'ampm' },
    ];
    const DAY_NAMES = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const DAY_SHORT_NAMES = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const MONTH_NAMES = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    const MONTH_SHORT_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    const VALID_AMPM_PREFIX = [FORMAT_hh, FORMAT_h, FORMAT_mm, FORMAT_m, FORMAT_ss, FORMAT_s];

    const datetimeIosCss =
      '/*!@:host*/.sc-ion-datetime-ios-h{padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:flex;position:relative;min-width:16px;min-height:1.2em;font-family:var(--ion-font-family, inherit);text-overflow:ellipsis;white-space:nowrap;overflow:hidden;z-index:2}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-datetime-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@:host(.in-item)*/.in-item.sc-ion-datetime-ios-h{position:static}/*!@:host(.datetime-placeholder)*/.datetime-placeholder.sc-ion-datetime-ios-h{color:var(--placeholder-color)}/*!@:host(.datetime-disabled)*/.datetime-disabled.sc-ion-datetime-ios-h{opacity:0.3;pointer-events:none}/*!@:host(.datetime-readonly)*/.datetime-readonly.sc-ion-datetime-ios-h{pointer-events:none}/*!@button*/button.sc-ion-datetime-ios{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;appearance:none;outline:none}/*!@[dir=rtl] button, :host-context([dir=rtl]) button*/[dir=rtl].sc-ion-datetime-ios button.sc-ion-datetime-ios,[dir=rtl].sc-ion-datetime-ios-h button.sc-ion-datetime-ios,[dir=rtl] .sc-ion-datetime-ios-h button.sc-ion-datetime-ios{left:unset;right:unset;right:0}/*!@button::-moz-focus-inner*/button.sc-ion-datetime-ios::-moz-focus-inner{border:0}/*!@.datetime-text*/.datetime-text.sc-ion-datetime-ios{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;flex:1;min-height:inherit;direction:ltr;overflow:inherit}/*!@[dir=rtl] .datetime-text, :host-context([dir=rtl]) .datetime-text*/[dir=rtl].sc-ion-datetime-ios .datetime-text.sc-ion-datetime-ios,[dir=rtl].sc-ion-datetime-ios-h .datetime-text.sc-ion-datetime-ios,[dir=rtl] .sc-ion-datetime-ios-h .datetime-text.sc-ion-datetime-ios{direction:rtl}/*!@:host*/.sc-ion-datetime-ios-h{--placeholder-color:var(--ion-color-step-400, #999999);--padding-top:10px;--padding-end:10px;--padding-bottom:10px;--padding-start:20px}';

    const datetimeMdCss =
      '/*!@:host*/.sc-ion-datetime-md-h{padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:flex;position:relative;min-width:16px;min-height:1.2em;font-family:var(--ion-font-family, inherit);text-overflow:ellipsis;white-space:nowrap;overflow:hidden;z-index:2}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-datetime-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@:host(.in-item)*/.in-item.sc-ion-datetime-md-h{position:static}/*!@:host(.datetime-placeholder)*/.datetime-placeholder.sc-ion-datetime-md-h{color:var(--placeholder-color)}/*!@:host(.datetime-disabled)*/.datetime-disabled.sc-ion-datetime-md-h{opacity:0.3;pointer-events:none}/*!@:host(.datetime-readonly)*/.datetime-readonly.sc-ion-datetime-md-h{pointer-events:none}/*!@button*/button.sc-ion-datetime-md{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;appearance:none;outline:none}/*!@[dir=rtl] button, :host-context([dir=rtl]) button*/[dir=rtl].sc-ion-datetime-md button.sc-ion-datetime-md,[dir=rtl].sc-ion-datetime-md-h button.sc-ion-datetime-md,[dir=rtl] .sc-ion-datetime-md-h button.sc-ion-datetime-md{left:unset;right:unset;right:0}/*!@button::-moz-focus-inner*/button.sc-ion-datetime-md::-moz-focus-inner{border:0}/*!@.datetime-text*/.datetime-text.sc-ion-datetime-md{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;flex:1;min-height:inherit;direction:ltr;overflow:inherit}/*!@[dir=rtl] .datetime-text, :host-context([dir=rtl]) .datetime-text*/[dir=rtl].sc-ion-datetime-md .datetime-text.sc-ion-datetime-md,[dir=rtl].sc-ion-datetime-md-h .datetime-text.sc-ion-datetime-md,[dir=rtl] .sc-ion-datetime-md-h .datetime-text.sc-ion-datetime-md{direction:rtl}/*!@:host*/.sc-ion-datetime-md-h{--placeholder-color:var(--ion-placeholder-color, var(--ion-color-step-400, #999999));--padding-top:10px;--padding-end:0;--padding-bottom:11px;--padding-start:16px}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part text - The value of the datetime.
     * @part placeholder - The placeholder of the datetime.
     */
    class Datetime {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionCancel = createEvent(this, 'ionCancel', 7);
        this.ionChange = createEvent(this, 'ionChange', 7);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.inputId = `ion-dt-${datetimeIds++}`;
        this.locale = {};
        this.datetimeMin = {};
        this.datetimeMax = {};
        this.datetimeValue = {};
        this.isExpanded = false;
        /**
         * The name of the control, which is submitted with the form data.
         */
        this.name = this.inputId;
        /**
         * If `true`, the user cannot interact with the datetime.
         */
        this.disabled = false;
        /**
         * If `true`, the datetime appears normal but is not interactive.
         */
        this.readonly = false;
        /**
         * The display format of the date and time as text that shows
         * within the item. When the `pickerFormat` input is not used, then the
         * `displayFormat` is used for both display the formatted text, and determining
         * the datetime picker's columns. See the `pickerFormat` input description for
         * more info. Defaults to `MMM D, YYYY`.
         */
        this.displayFormat = 'MMM D, YYYY';
        /**
         * The text to display on the picker's cancel button.
         */
        this.cancelText = 'Cancel';
        /**
         * The text to display on the picker's "Done" button.
         */
        this.doneText = 'Done';
        this.onClick = () => {
          this.setFocus();
          this.open();
        };
        this.onFocus = () => {
          this.ionFocus.emit();
        };
        this.onBlur = () => {
          this.ionBlur.emit();
        };
      }
      disabledChanged() {
        this.emitStyle();
      }
      /**
       * Update the datetime value when the value changes
       */
      valueChanged() {
        this.updateDatetimeValue(this.value);
        this.emitStyle();
        this.ionChange.emit({
          value: this.value,
        });
      }
      componentWillLoad() {
        // first see if locale names were provided in the inputs
        // then check to see if they're in the config
        // if neither were provided then it will use default English names
        this.locale = {
          // this.locale[type] = convertToArrayOfStrings((this[type] ? this[type] : this.config.get(type), type);
          monthNames: convertToArrayOfStrings(this.monthNames, 'monthNames'),
          monthShortNames: convertToArrayOfStrings(this.monthShortNames, 'monthShortNames'),
          dayNames: convertToArrayOfStrings(this.dayNames, 'dayNames'),
          dayShortNames: convertToArrayOfStrings(this.dayShortNames, 'dayShortNames'),
        };
        this.updateDatetimeValue(this.value);
        this.emitStyle();
      }
      /**
       * Opens the datetime overlay.
       */
      async open() {
        if (this.disabled || this.isExpanded) {
          return;
        }
        const pickerOptions = this.generatePickerOptions();
        const picker = await pickerController.create(pickerOptions);
        this.isExpanded = true;
        picker.onDidDismiss().then(() => {
          this.isExpanded = false;
          this.setFocus();
        });
        addEventListener(picker, 'ionPickerColChange', async event => {
          const data = event.detail;
          const colSelectedIndex = data.selectedIndex;
          const colOptions = data.options;
          const changeData = {};
          changeData[data.name] = {
            value: colOptions[colSelectedIndex].value,
          };
          if (data.name !== 'ampm' && this.datetimeValue.ampm !== undefined) {
            changeData['ampm'] = {
              value: this.datetimeValue.ampm,
            };
          }
          this.updateDatetimeValue(changeData);
          picker.columns = this.generateColumns();
        });
        await picker.present();
      }
      emitStyle() {
        this.ionStyle.emit({
          'interactive': true,
          'datetime': true,
          'has-placeholder': this.placeholder != null,
          'has-value': this.hasValue(),
          'interactive-disabled': this.disabled,
        });
      }
      updateDatetimeValue(value) {
        updateDate(this.datetimeValue, value, this.displayTimezone);
      }
      generatePickerOptions() {
        const mode = getIonMode$1(this);
        this.locale = {
          monthNames: convertToArrayOfStrings(this.monthNames, 'monthNames'),
          monthShortNames: convertToArrayOfStrings(this.monthShortNames, 'monthShortNames'),
          dayNames: convertToArrayOfStrings(this.dayNames, 'dayNames'),
          dayShortNames: convertToArrayOfStrings(this.dayShortNames, 'dayShortNames'),
        };
        const pickerOptions = Object.assign(Object.assign({ mode }, this.pickerOptions), { columns: this.generateColumns() });
        // If the user has not passed in picker buttons,
        // add a cancel and ok button to the picker
        const buttons = pickerOptions.buttons;
        if (!buttons || buttons.length === 0) {
          pickerOptions.buttons = [
            {
              text: this.cancelText,
              role: 'cancel',
              handler: () => {
                this.updateDatetimeValue(this.value);
                this.ionCancel.emit();
              },
            },
            {
              text: this.doneText,
              handler: data => {
                this.updateDatetimeValue(data);
                /**
                 * Prevent convertDataToISO from doing any
                 * kind of transformation based on timezone
                 * This cancels out any change it attempts to make
                 *
                 * Important: Take the timezone offset based on
                 * the date that is currently selected, otherwise
                 * there can be 1 hr difference when dealing w/ DST
                 */
                const date = new Date(convertDataToISO(this.datetimeValue));
                // If a custom display timezone is provided, use that tzOffset value instead
                this.datetimeValue.tzOffset =
                  this.displayTimezone !== undefined && this.displayTimezone.length > 0
                    ? (getTimezoneOffset(date, this.displayTimezone) / 1000 / 60) * -1
                    : date.getTimezoneOffset() * -1;
                this.value = convertDataToISO(this.datetimeValue);
              },
            },
          ];
        }
        return pickerOptions;
      }
      generateColumns() {
        // if a picker format wasn't provided, then fallback
        // to use the display format
        let template = this.pickerFormat || this.displayFormat || DEFAULT_FORMAT;
        if (template.length === 0) {
          return [];
        }
        // make sure we've got up to date sizing information
        this.calcMinMax();
        // does not support selecting by day name
        // automatically remove any day name formats
        template = template.replace('DDDD', '{~}').replace('DDD', '{~}');
        if (template.indexOf('D') === -1) {
          // there is not a day in the template
          // replace the day name with a numeric one if it exists
          template = template.replace('{~}', 'D');
        }
        // make sure no day name replacer is left in the string
        template = template.replace(/{~}/g, '');
        // parse apart the given template into an array of "formats"
        const columns = parseTemplate(template).map(format => {
          // loop through each format in the template
          // create a new picker column to build up with data
          const key = convertFormatToKey(format);
          let values;
          // check if they have exact values to use for this date part
          // otherwise use the default date part values
          const self = this;
          values = self[key + 'Values'] ? convertToArrayOfNumbers(self[key + 'Values'], key) : dateValueRange(format, this.datetimeMin, this.datetimeMax);
          const colOptions = values.map(val => {
            return {
              value: val,
              text: renderTextFormat(format, val, undefined, this.locale),
            };
          });
          // cool, we've loaded up the columns with options
          // preselect the option for this column
          const optValue = getDateValue(this.datetimeValue, format);
          const selectedIndex = colOptions.findIndex(opt => opt.value === optValue);
          return {
            name: key,
            selectedIndex: selectedIndex >= 0 ? selectedIndex : 0,
            options: colOptions,
          };
        });
        // Normalize min/max
        const min = this.datetimeMin;
        const max = this.datetimeMax;
        ['month', 'day', 'hour', 'minute']
          .filter(name => !columns.find(column => column.name === name))
          .forEach(name => {
            min[name] = 0;
            max[name] = 0;
          });
        return this.validateColumns(divyColumns(columns));
      }
      validateColumns(columns) {
        const today = new Date();
        const minCompareVal = dateDataSortValue(this.datetimeMin);
        const maxCompareVal = dateDataSortValue(this.datetimeMax);
        const yearCol = columns.find(c => c.name === 'year');
        let selectedYear = today.getFullYear();
        if (yearCol) {
          // default to the first value if the current year doesn't exist in the options
          if (!yearCol.options.find(col => col.value === today.getFullYear())) {
            selectedYear = yearCol.options[0].value;
          }
          const selectedIndex = yearCol.selectedIndex;
          if (selectedIndex !== undefined) {
            const yearOpt = yearCol.options[selectedIndex];
            if (yearOpt) {
              // they have a selected year value
              selectedYear = yearOpt.value;
            }
          }
        }
        const selectedMonth = this.validateColumn(columns, 'month', 1, minCompareVal, maxCompareVal, [selectedYear, 0, 0, 0, 0], [selectedYear, 12, 31, 23, 59]);
        const numDaysInMonth = daysInMonth(selectedMonth, selectedYear);
        const selectedDay = this.validateColumn(
          columns,
          'day',
          2,
          minCompareVal,
          maxCompareVal,
          [selectedYear, selectedMonth, 0, 0, 0],
          [selectedYear, selectedMonth, numDaysInMonth, 23, 59],
        );
        const selectedHour = this.validateColumn(
          columns,
          'hour',
          3,
          minCompareVal,
          maxCompareVal,
          [selectedYear, selectedMonth, selectedDay, 0, 0],
          [selectedYear, selectedMonth, selectedDay, 23, 59],
        );
        this.validateColumn(
          columns,
          'minute',
          4,
          minCompareVal,
          maxCompareVal,
          [selectedYear, selectedMonth, selectedDay, selectedHour, 0],
          [selectedYear, selectedMonth, selectedDay, selectedHour, 59],
        );
        return columns;
      }
      calcMinMax() {
        const todaysYear = new Date().getFullYear();
        if (this.yearValues !== undefined) {
          const years = convertToArrayOfNumbers(this.yearValues, 'year');
          if (this.min === undefined) {
            this.min = Math.min(...years).toString();
          }
          if (this.max === undefined) {
            this.max = Math.max(...years).toString();
          }
        } else {
          if (this.min === undefined) {
            this.min = (todaysYear - 100).toString();
          }
          if (this.max === undefined) {
            this.max = todaysYear.toString();
          }
        }
        const min = (this.datetimeMin = parseDate(this.min));
        const max = (this.datetimeMax = parseDate(this.max));
        min.year = min.year || todaysYear;
        max.year = max.year || todaysYear;
        min.month = min.month || 1;
        max.month = max.month || 12;
        min.day = min.day || 1;
        max.day = max.day || 31;
        min.hour = min.hour || 0;
        max.hour = max.hour === undefined ? 23 : max.hour;
        min.minute = min.minute || 0;
        max.minute = max.minute === undefined ? 59 : max.minute;
        min.second = min.second || 0;
        max.second = max.second === undefined ? 59 : max.second;
        // Ensure min/max constraints
        if (min.year > max.year) {
          console.error('min.year > max.year');
          min.year = max.year - 100;
        }
        if (min.year === max.year) {
          if (min.month > max.month) {
            console.error('min.month > max.month');
            min.month = 1;
          } else if (min.month === max.month && min.day > max.day) {
            console.error('min.day > max.day');
            min.day = 1;
          }
        }
      }
      validateColumn(columns, name, index, min, max, lowerBounds, upperBounds) {
        const column = columns.find(c => c.name === name);
        if (!column) {
          return 0;
        }
        const lb = lowerBounds.slice();
        const ub = upperBounds.slice();
        const options = column.options;
        let indexMin = options.length - 1;
        let indexMax = 0;
        for (let i = 0; i < options.length; i++) {
          const opts = options[i];
          const value = opts.value;
          lb[index] = opts.value;
          ub[index] = opts.value;
          const disabled = (opts.disabled =
            value < lowerBounds[index] ||
            value > upperBounds[index] ||
            dateSortValue(ub[0], ub[1], ub[2], ub[3], ub[4]) < min ||
            dateSortValue(lb[0], lb[1], lb[2], lb[3], lb[4]) > max);
          if (!disabled) {
            indexMin = Math.min(indexMin, i);
            indexMax = Math.max(indexMax, i);
          }
        }
        const selectedIndex = (column.selectedIndex = clamp(indexMin, column.selectedIndex, indexMax));
        const opt = column.options[selectedIndex];
        if (opt) {
          return opt.value;
        }
        return 0;
      }
      get text() {
        // create the text of the formatted data
        const template = this.displayFormat || this.pickerFormat || DEFAULT_FORMAT;
        if (this.value === undefined || this.value === null || this.value.length === 0) {
          return;
        }
        return renderDatetime(template, this.datetimeValue, this.locale);
      }
      hasValue() {
        return this.text !== undefined;
      }
      setFocus() {
        if (this.buttonEl) {
          this.buttonEl.focus();
        }
      }
      render() {
        const { inputId, text, disabled, readonly, isExpanded, el, placeholder } = this;
        const mode = getIonMode$1(this);
        const labelId = inputId + '-lbl';
        const label = findItemLabel(el);
        const addPlaceholderClass = text === undefined && placeholder != null ? true : false;
        // If selected text has been passed in, use that first
        // otherwise use the placeholder
        const datetimeText = text === undefined ? (placeholder != null ? placeholder : '') : text;
        const datetimeTextPart = text === undefined ? (placeholder != null ? 'placeholder' : undefined) : 'text';
        if (label) {
          label.id = labelId;
        }
        renderHiddenInput(true, el, this.name, this.value, this.disabled);
        return hAsync(
          Host,
          {
            'onClick': this.onClick,
            'aria-disabled': disabled ? 'true' : null,
            'aria-expanded': `${isExpanded}`,
            'aria-haspopup': 'true',
            'aria-labelledby': label ? labelId : null,
            'class': {
              [mode]: true,
              'datetime-disabled': disabled,
              'datetime-readonly': readonly,
              'datetime-placeholder': addPlaceholderClass,
              'in-item': hostContext('ion-item', el),
            },
          },
          hAsync('div', { class: 'datetime-text', part: datetimeTextPart }, datetimeText),
          hAsync('button', { type: 'button', onFocus: this.onFocus, onBlur: this.onBlur, disabled: this.disabled, ref: btnEl => (this.buttonEl = btnEl) }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          disabled: ['disabledChanged'],
          value: ['valueChanged'],
        };
      }
      static get style() {
        return {
          ios: datetimeIosCss,
          md: datetimeMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-datetime',
          $members$: {
            name: [1],
            disabled: [4],
            readonly: [4],
            min: [1025],
            max: [1025],
            displayFormat: [1, 'display-format'],
            displayTimezone: [1, 'display-timezone'],
            pickerFormat: [1, 'picker-format'],
            cancelText: [1, 'cancel-text'],
            doneText: [1, 'done-text'],
            yearValues: [8, 'year-values'],
            monthValues: [8, 'month-values'],
            dayValues: [8, 'day-values'],
            hourValues: [8, 'hour-values'],
            minuteValues: [8, 'minute-values'],
            monthNames: [1, 'month-names'],
            monthShortNames: [1, 'month-short-names'],
            dayNames: [1, 'day-names'],
            dayShortNames: [1, 'day-short-names'],
            pickerOptions: [16],
            placeholder: [1],
            value: [1025],
            isExpanded: [32],
            open: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const divyColumns = columns => {
      const columnsWidth = [];
      let col;
      let width;
      for (let i = 0; i < columns.length; i++) {
        col = columns[i];
        columnsWidth.push(0);
        for (const option of col.options) {
          width = option.text.length;
          if (width > columnsWidth[i]) {
            columnsWidth[i] = width;
          }
        }
      }
      if (columnsWidth.length === 2) {
        width = Math.max(columnsWidth[0], columnsWidth[1]);
        columns[0].align = 'right';
        columns[1].align = 'left';
        columns[0].optionsWidth = columns[1].optionsWidth = `${width * 17}px`;
      } else if (columnsWidth.length === 3) {
        width = Math.max(columnsWidth[0], columnsWidth[2]);
        columns[0].align = 'right';
        columns[1].columnWidth = `${columnsWidth[1] * 17}px`;
        columns[0].optionsWidth = columns[2].optionsWidth = `${width * 17}px`;
        columns[2].align = 'left';
      }
      return columns;
    };
    const DEFAULT_FORMAT = 'MMM D, YYYY';
    let datetimeIds = 0;

    const fabCss =
      '/*!@:host*/.sc-ion-fab-h{position:absolute;z-index:999}/*!@:host(.fab-horizontal-center)*/.fab-horizontal-center.sc-ion-fab-h{left:50%;margin-left:-28px}/*!@:host-context([dir=rtl]):host(.fab-horizontal-center), :host-context([dir=rtl]).fab-horizontal-center*/[dir=rtl].sc-ion-fab-h -no-combinator.fab-horizontal-center.sc-ion-fab-h,[dir=rtl] .sc-ion-fab-h -no-combinator.fab-horizontal-center.sc-ion-fab-h,[dir=rtl].fab-horizontal-center.sc-ion-fab-h,[dir=rtl] .fab-horizontal-center.sc-ion-fab-h{left:unset;right:unset;right:50%}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.fab-horizontal-center)*/.fab-horizontal-center.sc-ion-fab-h{margin-left:unset;-webkit-margin-start:-28px;margin-inline-start:-28px}}/*!@:host(.fab-horizontal-start)*/.fab-horizontal-start.sc-ion-fab-h{left:calc(10px + var(--ion-safe-area-left, 0px))}/*!@:host-context([dir=rtl]):host(.fab-horizontal-start), :host-context([dir=rtl]).fab-horizontal-start*/[dir=rtl].sc-ion-fab-h -no-combinator.fab-horizontal-start.sc-ion-fab-h,[dir=rtl] .sc-ion-fab-h -no-combinator.fab-horizontal-start.sc-ion-fab-h,[dir=rtl].fab-horizontal-start.sc-ion-fab-h,[dir=rtl] .fab-horizontal-start.sc-ion-fab-h{left:unset;right:unset;right:calc(10px + var(--ion-safe-area-left, 0px))}/*!@:host(.fab-horizontal-end)*/.fab-horizontal-end.sc-ion-fab-h{right:calc(10px + var(--ion-safe-area-right, 0px))}/*!@:host-context([dir=rtl]):host(.fab-horizontal-end), :host-context([dir=rtl]).fab-horizontal-end*/[dir=rtl].sc-ion-fab-h -no-combinator.fab-horizontal-end.sc-ion-fab-h,[dir=rtl] .sc-ion-fab-h -no-combinator.fab-horizontal-end.sc-ion-fab-h,[dir=rtl].fab-horizontal-end.sc-ion-fab-h,[dir=rtl] .fab-horizontal-end.sc-ion-fab-h{left:unset;right:unset;left:calc(10px + var(--ion-safe-area-right, 0px))}/*!@:host(.fab-vertical-top)*/.fab-vertical-top.sc-ion-fab-h{top:10px}/*!@:host(.fab-vertical-top.fab-edge)*/.fab-vertical-top.fab-edge.sc-ion-fab-h{top:-28px}/*!@:host(.fab-vertical-bottom)*/.fab-vertical-bottom.sc-ion-fab-h{bottom:10px}/*!@:host(.fab-vertical-bottom.fab-edge)*/.fab-vertical-bottom.fab-edge.sc-ion-fab-h{bottom:-28px}/*!@:host(.fab-vertical-center)*/.fab-vertical-center.sc-ion-fab-h{margin-top:-28px;top:50%}';

    class Fab {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If `true`, the fab will display on the edge of the header if
         * `vertical` is `"top"`, and on the edge of the footer if
         * it is `"bottom"`. Should be used with a `fixed` slot.
         */
        this.edge = false;
        /**
         * If `true`, both the `ion-fab-button` and all `ion-fab-list` inside `ion-fab` will become active.
         * That means `ion-fab-button` will become a `close` icon and `ion-fab-list` will become visible.
         */
        this.activated = false;
        this.onClick = () => {
          const hasList = !!this.el.querySelector('ion-fab-list');
          const getButton = this.getFab();
          const isButtonDisabled = getButton && getButton.disabled;
          if (hasList && !isButtonDisabled) {
            this.activated = !this.activated;
          }
        };
      }
      activatedChanged() {
        const activated = this.activated;
        const fab = this.getFab();
        if (fab) {
          fab.activated = activated;
        }
        Array.from(this.el.querySelectorAll('ion-fab-list')).forEach(list => {
          list.activated = activated;
        });
      }
      componentDidLoad() {
        if (this.activated) {
          this.activatedChanged();
        }
      }
      /**
       * Close an active FAB list container.
       */
      async close() {
        this.activated = false;
      }
      getFab() {
        return this.el.querySelector('ion-fab-button');
      }
      render() {
        const { horizontal, vertical, edge } = this;
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            onClick: this.onClick,
            class: {
              [mode]: true,
              [`fab-horizontal-${horizontal}`]: horizontal !== undefined,
              [`fab-vertical-${vertical}`]: vertical !== undefined,
              'fab-edge': edge,
            },
          },
          hAsync('slot', null),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          activated: ['activatedChanged'],
        };
      }
      static get style() {
        return fabCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-fab',
          $members$: {
            horizontal: [1],
            vertical: [1],
            edge: [4],
            activated: [1028],
            close: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const fabButtonIosCss =
      '/*!@:host*/.sc-ion-fab-button-ios-h{--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--background-hover:var(--ion-color-primary-contrast, #fff);--background-hover-opacity:.08;--transition:background-color, opacity 100ms linear;--ripple-color:currentColor;--border-radius:50%;--border-width:0;--border-style:none;--border-color:initial;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:56px;height:56px;font-size:14px;text-align:center;text-overflow:ellipsis;text-transform:none;white-space:nowrap;font-kerning:none}/*!@.button-native*/.button-native.sc-ion-fab-button-ios{border-radius:var(--border-radius);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;transform:var(--transform);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);background-clip:padding-box;color:var(--color);box-shadow:var(--box-shadow);contain:strict;cursor:pointer;overflow:hidden;z-index:0;appearance:none;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-fab-button-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@::slotted(ion-icon)*/.sc-ion-fab-button-ios-s>ion-icon{line-height:1}/*!@.button-native::after*/.button-native.sc-ion-fab-button-ios::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}/*!@.button-inner*/.button-inner.sc-ion-fab-button-ios{left:0;right:0;top:0;display:flex;position:absolute;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;height:100%;transition:all ease-in-out 300ms;transition-property:transform, opacity;z-index:1}/*!@:host(.fab-button-disabled)*/.fab-button-disabled.sc-ion-fab-button-ios-h{cursor:default;opacity:0.5;pointer-events:none}@media (any-hover: hover){/*!@:host(:hover) .button-native*/.sc-ion-fab-button-ios-h:hover .button-native.sc-ion-fab-button-ios{color:var(--color-hover)}/*!@:host(:hover) .button-native::after*/.sc-ion-fab-button-ios-h:hover .button-native.sc-ion-fab-button-ios::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}/*!@:host(.ion-activated) .button-native*/.ion-activated.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios{color:var(--color-activated)}/*!@:host(.ion-activated) .button-native::after*/.ion-activated.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}/*!@::slotted(ion-icon)*/.sc-ion-fab-button-ios-s>ion-icon{line-height:1}/*!@:host(.fab-button-small)*/.fab-button-small.sc-ion-fab-button-ios-h{margin-left:8px;margin-right:8px;margin-top:8px;margin-bottom:8px;width:40px;height:40px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.fab-button-small)*/.fab-button-small.sc-ion-fab-button-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:8px;margin-inline-end:8px}}/*!@.close-icon*/.close-icon.sc-ion-fab-button-ios{margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;left:0;right:0;top:0;position:absolute;height:100%;transform:scale(0.4) rotateZ(-45deg);transition:all ease-in-out 300ms;transition-property:transform, opacity;font-size:var(--close-icon-font-size);opacity:0;z-index:1}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.close-icon*/.close-icon.sc-ion-fab-button-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}/*!@:host(.fab-button-close-active) .close-icon*/.fab-button-close-active.sc-ion-fab-button-ios-h .close-icon.sc-ion-fab-button-ios{transform:scale(1) rotateZ(0deg);opacity:1}/*!@:host(.fab-button-close-active) .button-inner*/.fab-button-close-active.sc-ion-fab-button-ios-h .button-inner.sc-ion-fab-button-ios{transform:scale(0.4) rotateZ(45deg);opacity:0}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-fab-button-ios{color:var(--ripple-color)}@supports (backdrop-filter: blur(0)){/*!@:host(.fab-button-translucent) .button-native*/.fab-button-translucent.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios{backdrop-filter:var(--backdrop-filter)}}/*!@:host(.ion-color) .button-native*/.ion-color.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host*/.sc-ion-fab-button-ios-h{--background:var(--ion-color-primary, #3880ff);--background-activated:var(--ion-color-primary-shade, #3171e0);--background-focused:var(--ion-color-primary-shade, #3171e0);--background-hover:var(--ion-color-primary-tint, #4c8dff);--background-activated-opacity:1;--background-focused-opacity:1;--background-hover-opacity:1;--color:var(--ion-color-primary-contrast, #fff);--box-shadow:0 4px 16px rgba(0, 0, 0, 0.12);--transition:0.2s transform cubic-bezier(0.25, 1.11, 0.78, 1.59);--close-icon-font-size:28px}/*!@:host(.ion-activated)*/.ion-activated.sc-ion-fab-button-ios-h{--box-shadow:0 4px 16px rgba(0, 0, 0, 0.12);--transform:scale(1.1);--transition:0.2s transform ease-out}/*!@::slotted(ion-icon)*/.sc-ion-fab-button-ios-s>ion-icon{font-size:28px}/*!@:host(.fab-button-in-list)*/.fab-button-in-list.sc-ion-fab-button-ios-h{--background:var(--ion-color-light, #f4f5f8);--background-activated:var(--ion-color-light-shade, #d7d8da);--background-focused:var(--background-activated);--background-hover:var(--ion-color-light-tint, #f5f6f9);--color:var(--ion-color-light-contrast, #000);--color-activated:var(--ion-color-light-contrast, #000);--color-focused:var(--color-activated);--transition:transform 200ms ease 10ms, opacity 200ms ease 10ms}/*!@:host(.fab-button-in-list) ::slotted(ion-icon)*/.sc-ion-fab-button-ios-h.fab-button-in-list .sc-ion-fab-button-ios-s>ion-icon{font-size:18px}/*!@:host(.ion-color.ion-focused) .button-native::after*/.ion-color.ion-focused.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios::after{background:var(--ion-color-shade)}/*!@:host(.ion-color.ion-focused) .button-native,\n:host(.ion-color.ion-activated) .button-native*/.ion-color.ion-focused.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios,.ion-color.ion-activated.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios{color:var(--ion-color-contrast)}/*!@:host(.ion-color.ion-focused) .button-native::after,\n:host(.ion-color.ion-activated) .button-native::after*/.ion-color.ion-focused.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios::after,.ion-color.ion-activated.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios::after{background:var(--ion-color-shade)}@media (any-hover: hover){/*!@:host(.ion-color:hover) .button-native*/.ion-color.sc-ion-fab-button-ios-h:hover .button-native.sc-ion-fab-button-ios{color:var(--ion-color-contrast)}/*!@:host(.ion-color:hover) .button-native::after*/.ion-color.sc-ion-fab-button-ios-h:hover .button-native.sc-ion-fab-button-ios::after{background:var(--ion-color-tint)}}@supports (backdrop-filter: blur(0)){/*!@:host(.fab-button-translucent)*/.fab-button-translucent.sc-ion-fab-button-ios-h{--background:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.9);--background-hover:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.8);--background-focused:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.82);--backdrop-filter:saturate(180%) blur(20px)}/*!@:host(.fab-button-translucent-in-list)*/.fab-button-translucent-in-list.sc-ion-fab-button-ios-h{--background:rgba(var(--ion-color-light-rgb, 244, 245, 248), 0.9);--background-hover:rgba(var(--ion-color-light-rgb, 244, 245, 248), 0.8);--background-focused:rgba(var(--ion-color-light-rgb, 244, 245, 248), 0.82)}}@supports (backdrop-filter: blur(0)){/*!@@media (any-hover: hover)*/@media .sc-ion-fab-button-ios (any-hover.sc-ion-fab-button-ios: hover).sc-ion-fab-button-ios{.sc-ion-fab-button-ios-h.fab-button-translucent.ion-color:hover .button-native{background:rgba(var(--ion-color-base-rgb), 0.8)}}/*!@:host(.ion-color.fab-button-translucent) .button-native*/.ion-color.fab-button-translucent.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios{background:rgba(var(--ion-color-base-rgb), 0.9)}/*!@:host(.ion-color.ion-focused.fab-button-translucent) .button-native,\n:host(.ion-color.ion-activated.fab-button-translucent) .button-native*/.ion-color.ion-focused.fab-button-translucent.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios,.ion-color.ion-activated.fab-button-translucent.sc-ion-fab-button-ios-h .button-native.sc-ion-fab-button-ios{background:var(--ion-color-base)}}';

    const fabButtonMdCss =
      '/*!@:host*/.sc-ion-fab-button-md-h{--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--background-hover:var(--ion-color-primary-contrast, #fff);--background-hover-opacity:.08;--transition:background-color, opacity 100ms linear;--ripple-color:currentColor;--border-radius:50%;--border-width:0;--border-style:none;--border-color:initial;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:block;width:56px;height:56px;font-size:14px;text-align:center;text-overflow:ellipsis;text-transform:none;white-space:nowrap;font-kerning:none}/*!@.button-native*/.button-native.sc-ion-fab-button-md{border-radius:var(--border-radius);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;position:relative;width:100%;height:100%;transform:var(--transform);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);background-clip:padding-box;color:var(--color);box-shadow:var(--box-shadow);contain:strict;cursor:pointer;overflow:hidden;z-index:0;appearance:none;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-fab-button-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@::slotted(ion-icon)*/.sc-ion-fab-button-md-s>ion-icon{line-height:1}/*!@.button-native::after*/.button-native.sc-ion-fab-button-md::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}/*!@.button-inner*/.button-inner.sc-ion-fab-button-md{left:0;right:0;top:0;display:flex;position:absolute;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;height:100%;transition:all ease-in-out 300ms;transition-property:transform, opacity;z-index:1}/*!@:host(.fab-button-disabled)*/.fab-button-disabled.sc-ion-fab-button-md-h{cursor:default;opacity:0.5;pointer-events:none}@media (any-hover: hover){/*!@:host(:hover) .button-native*/.sc-ion-fab-button-md-h:hover .button-native.sc-ion-fab-button-md{color:var(--color-hover)}/*!@:host(:hover) .button-native::after*/.sc-ion-fab-button-md-h:hover .button-native.sc-ion-fab-button-md::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-fab-button-md-h .button-native.sc-ion-fab-button-md{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-fab-button-md-h .button-native.sc-ion-fab-button-md::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}/*!@:host(.ion-activated) .button-native*/.ion-activated.sc-ion-fab-button-md-h .button-native.sc-ion-fab-button-md{color:var(--color-activated)}/*!@:host(.ion-activated) .button-native::after*/.ion-activated.sc-ion-fab-button-md-h .button-native.sc-ion-fab-button-md::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}/*!@::slotted(ion-icon)*/.sc-ion-fab-button-md-s>ion-icon{line-height:1}/*!@:host(.fab-button-small)*/.fab-button-small.sc-ion-fab-button-md-h{margin-left:8px;margin-right:8px;margin-top:8px;margin-bottom:8px;width:40px;height:40px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.fab-button-small)*/.fab-button-small.sc-ion-fab-button-md-h{margin-left:unset;margin-right:unset;-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:8px;margin-inline-end:8px}}/*!@.close-icon*/.close-icon.sc-ion-fab-button-md{margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;left:0;right:0;top:0;position:absolute;height:100%;transform:scale(0.4) rotateZ(-45deg);transition:all ease-in-out 300ms;transition-property:transform, opacity;font-size:var(--close-icon-font-size);opacity:0;z-index:1}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.close-icon*/.close-icon.sc-ion-fab-button-md{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}/*!@:host(.fab-button-close-active) .close-icon*/.fab-button-close-active.sc-ion-fab-button-md-h .close-icon.sc-ion-fab-button-md{transform:scale(1) rotateZ(0deg);opacity:1}/*!@:host(.fab-button-close-active) .button-inner*/.fab-button-close-active.sc-ion-fab-button-md-h .button-inner.sc-ion-fab-button-md{transform:scale(0.4) rotateZ(45deg);opacity:0}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-fab-button-md{color:var(--ripple-color)}@supports (backdrop-filter: blur(0)){/*!@:host(.fab-button-translucent) .button-native*/.fab-button-translucent.sc-ion-fab-button-md-h .button-native.sc-ion-fab-button-md{backdrop-filter:var(--backdrop-filter)}}/*!@:host(.ion-color) .button-native*/.ion-color.sc-ion-fab-button-md-h .button-native.sc-ion-fab-button-md{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host*/.sc-ion-fab-button-md-h{--background:var(--ion-color-primary, #3880ff);--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--background-activated-opacity:0;--background-focused-opacity:.24;--background-hover-opacity:.08;--color:var(--ion-color-primary-contrast, #fff);--box-shadow:0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12);--transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1), background-color 280ms cubic-bezier(0.4, 0, 0.2, 1), color 280ms cubic-bezier(0.4, 0, 0.2, 1), opacity 15ms linear 30ms, transform 270ms cubic-bezier(0, 0, 0.2, 1) 0ms;--close-icon-font-size:24px}/*!@:host(.ion-activated)*/.ion-activated.sc-ion-fab-button-md-h{--box-shadow:0 7px 8px -4px rgba(0, 0, 0, 0.2), 0 12px 17px 2px rgba(0, 0, 0, 0.14), 0 5px 22px 4px rgba(0, 0, 0, 0.12)}/*!@::slotted(ion-icon)*/.sc-ion-fab-button-md-s>ion-icon{font-size:24px}/*!@:host(.fab-button-in-list)*/.fab-button-in-list.sc-ion-fab-button-md-h{--color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);--color-activated:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);--color-focused:var(--color-activated);--background:var(--ion-color-light, #f4f5f8);--background-activated:transparent;--background-focused:var(--ion-color-light-shade, #d7d8da);--background-hover:var(--ion-color-light-tint, #f5f6f9)}/*!@:host(.fab-button-in-list) ::slotted(ion-icon)*/.sc-ion-fab-button-md-h.fab-button-in-list .sc-ion-fab-button-md-s>ion-icon{font-size:18px}/*!@:host(.ion-color.ion-focused) .button-native*/.ion-color.ion-focused.sc-ion-fab-button-md-h .button-native.sc-ion-fab-button-md{color:var(--ion-color-contrast)}/*!@:host(.ion-color.ion-focused) .button-native::after*/.ion-color.ion-focused.sc-ion-fab-button-md-h .button-native.sc-ion-fab-button-md::after{background:var(--ion-color-contrast)}/*!@:host(.ion-color.ion-activated) .button-native*/.ion-color.ion-activated.sc-ion-fab-button-md-h .button-native.sc-ion-fab-button-md{color:var(--ion-color-contrast)}/*!@:host(.ion-color.ion-activated) .button-native::after*/.ion-color.ion-activated.sc-ion-fab-button-md-h .button-native.sc-ion-fab-button-md::after{background:transparent}@media (any-hover: hover){/*!@:host(.ion-color:hover) .button-native*/.ion-color.sc-ion-fab-button-md-h:hover .button-native.sc-ion-fab-button-md{color:var(--ion-color-contrast)}/*!@:host(.ion-color:hover) .button-native::after*/.ion-color.sc-ion-fab-button-md-h:hover .button-native.sc-ion-fab-button-md::after{background:var(--ion-color-contrast)}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part native - The native HTML button or anchor element that wraps all child elements.
     * @part close-icon - The close icon that is displayed when a fab list opens (uses ion-icon).
     */
    class FabButton {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        /**
         * If `true`, the fab button will be show a close icon.
         */
        this.activated = false;
        /**
         * If `true`, the user cannot interact with the fab button.
         */
        this.disabled = false;
        /**
         * When using a router, it specifies the transition direction when navigating to
         * another page using `href`.
         */
        this.routerDirection = 'forward';
        /**
         * If `true`, the fab button will show when in a fab-list.
         */
        this.show = false;
        /**
         * If `true`, the fab button will be translucent.
         * Only applies when the mode is `"ios"` and the device supports
         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
         */
        this.translucent = false;
        /**
         * The type of the button.
         */
        this.type = 'button';
        /**
         * The icon name to use for the close icon. This will appear when the fab button
         * is pressed. Only applies if it is the main button inside of a fab containing a
         * fab list.
         */
        this.closeIcon = 'close';
        this.onFocus = () => {
          this.ionFocus.emit();
        };
        this.onBlur = () => {
          this.ionBlur.emit();
        };
      }
      render() {
        const { el, disabled, color, href, activated, show, translucent, size } = this;
        const inList = hostContext('ion-fab-list', el);
        const mode = getIonMode$1(this);
        const TagType = href === undefined ? 'button' : 'a';
        const attrs =
          TagType === 'button'
            ? { type: this.type }
            : {
                download: this.download,
                href,
                rel: this.rel,
                target: this.target,
              };
        return hAsync(
          Host,
          {
            'aria-disabled': disabled ? 'true' : null,
            'class': createColorClasses$1(color, {
              [mode]: true,
              'fab-button-in-list': inList,
              'fab-button-translucent-in-list': inList && translucent,
              'fab-button-close-active': activated,
              'fab-button-show': show,
              'fab-button-disabled': disabled,
              'fab-button-translucent': translucent,
              'ion-activatable': true,
              'ion-focusable': true,
              [`fab-button-${size}`]: size !== undefined,
            }),
          },
          hAsync(
            TagType,
            Object.assign({}, attrs, {
              class: 'button-native',
              part: 'native',
              disabled: disabled,
              onFocus: this.onFocus,
              onBlur: this.onBlur,
              onClick: ev => openURL(href, ev, this.routerDirection, this.routerAnimation),
            }),
            hAsync('ion-icon', { icon: this.closeIcon, part: 'close-icon', class: 'close-icon', lazy: false }),
            hAsync('span', { class: 'button-inner' }, hAsync('slot', null)),
            mode === 'md' && hAsync('ion-ripple-effect', null),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: fabButtonIosCss,
          md: fabButtonMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-fab-button',
          $members$: {
            color: [513],
            activated: [4],
            disabled: [4],
            download: [1],
            href: [1],
            rel: [1],
            routerDirection: [1, 'router-direction'],
            routerAnimation: [16],
            target: [1],
            show: [4],
            translucent: [4],
            type: [1],
            size: [1],
            closeIcon: [1, 'close-icon'],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const fabListCss =
      '/*!@:host*/.sc-ion-fab-list-h{margin-left:0;margin-right:0;margin-top:66px;margin-bottom:66px;display:none;position:absolute;top:0;flex-direction:column;align-items:center;min-width:56px;min-height:56px}/*!@:host(.fab-list-active)*/.fab-list-active.sc-ion-fab-list-h{display:flex}/*!@::slotted(.fab-button-in-list)*/.sc-ion-fab-list-s>.fab-button-in-list{margin-left:0;margin-right:0;margin-top:8px;margin-bottom:8px;width:40px;height:40px;transform:scale(0);opacity:0;visibility:hidden}/*!@:host(.fab-list-side-top) ::slotted(.fab-button-in-list),\n:host(.fab-list-side-bottom) ::slotted(.fab-button-in-list)*/.sc-ion-fab-list-h.fab-list-side-top .sc-ion-fab-list-s>.fab-button-in-list,.sc-ion-fab-list-h.fab-list-side-bottom .sc-ion-fab-list-s>.fab-button-in-list{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:5px}/*!@:host(.fab-list-side-start) ::slotted(.fab-button-in-list),\n:host(.fab-list-side-end) ::slotted(.fab-button-in-list)*/.sc-ion-fab-list-h.fab-list-side-start .sc-ion-fab-list-s>.fab-button-in-list,.sc-ion-fab-list-h.fab-list-side-end .sc-ion-fab-list-s>.fab-button-in-list{margin-left:5px;margin-right:5px;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.fab-list-side-start) ::slotted(.fab-button-in-list),\n:host(.fab-list-side-end) ::slotted(.fab-button-in-list)*/.sc-ion-fab-list-h.fab-list-side-start .sc-ion-fab-list-s>.fab-button-in-list,.sc-ion-fab-list-h.fab-list-side-end .sc-ion-fab-list-s>.fab-button-in-list{margin-left:unset;margin-right:unset;-webkit-margin-start:5px;margin-inline-start:5px;-webkit-margin-end:5px;margin-inline-end:5px}}/*!@::slotted(.fab-button-in-list.fab-button-show)*/.sc-ion-fab-list-s>.fab-button-in-list.fab-button-show{transform:scale(1);opacity:1;visibility:visible}/*!@:host(.fab-list-side-top)*/.fab-list-side-top.sc-ion-fab-list-h{top:auto;bottom:0;flex-direction:column-reverse}/*!@:host(.fab-list-side-start)*/.fab-list-side-start.sc-ion-fab-list-h{margin-left:66px;margin-right:66px;margin-top:0;margin-bottom:0;right:0;flex-direction:row-reverse}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.fab-list-side-start)*/.fab-list-side-start.sc-ion-fab-list-h{margin-left:unset;margin-right:unset;-webkit-margin-start:66px;margin-inline-start:66px;-webkit-margin-end:66px;margin-inline-end:66px}}/*!@:host-context([dir=rtl]):host(.fab-list-side-start), :host-context([dir=rtl]).fab-list-side-start*/[dir=rtl].sc-ion-fab-list-h -no-combinator.fab-list-side-start.sc-ion-fab-list-h,[dir=rtl] .sc-ion-fab-list-h -no-combinator.fab-list-side-start.sc-ion-fab-list-h,[dir=rtl].fab-list-side-start.sc-ion-fab-list-h,[dir=rtl] .fab-list-side-start.sc-ion-fab-list-h{left:unset;right:unset;left:0}/*!@:host(.fab-list-side-end)*/.fab-list-side-end.sc-ion-fab-list-h{margin-left:66px;margin-right:66px;margin-top:0;margin-bottom:0;left:0;flex-direction:row}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.fab-list-side-end)*/.fab-list-side-end.sc-ion-fab-list-h{margin-left:unset;margin-right:unset;-webkit-margin-start:66px;margin-inline-start:66px;-webkit-margin-end:66px;margin-inline-end:66px}}/*!@:host-context([dir=rtl]):host(.fab-list-side-end), :host-context([dir=rtl]).fab-list-side-end*/[dir=rtl].sc-ion-fab-list-h -no-combinator.fab-list-side-end.sc-ion-fab-list-h,[dir=rtl] .sc-ion-fab-list-h -no-combinator.fab-list-side-end.sc-ion-fab-list-h,[dir=rtl].fab-list-side-end.sc-ion-fab-list-h,[dir=rtl] .fab-list-side-end.sc-ion-fab-list-h{left:unset;right:unset;right:0}';

    class FabList {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If `true`, the fab list will show all fab buttons in the list.
         */
        this.activated = false;
        /**
         * The side the fab list will show on relative to the main fab button.
         */
        this.side = 'bottom';
      }
      activatedChanged(activated) {
        const fabs = Array.from(this.el.querySelectorAll('ion-fab-button'));
        // if showing the fabs add a timeout, else show immediately
        const timeout = activated ? 30 : 0;
        fabs.forEach((fab, i) => {
          setTimeout(() => (fab.show = activated), i * timeout);
        });
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: {
              [mode]: true,
              'fab-list-active': this.activated,
              [`fab-list-side-${this.side}`]: true,
            },
          },
          hAsync('slot', null),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          activated: ['activatedChanged'],
        };
      }
      static get style() {
        return fabListCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-fab-list',
          $members$: {
            activated: [4],
            side: [1],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    var commonjsGlobal =
      typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
      return (
        (module = {
          path: basedir,
          exports: {},
          require: function (path, base) {
            return commonjsRequire();
          },
        }),
        fn(module, module.exports),
        module.exports
      );
    }

    function getAugmentedNamespace(n) {
      if (n.__esModule) return n;
      var a = Object.defineProperty({}, '__esModule', { value: true });
      Object.keys(n).forEach(function (k) {
        var d = Object.getOwnPropertyDescriptor(n, k);
        Object.defineProperty(
          a,
          k,
          d.get
            ? d
            : {
                enumerable: true,
                get: function () {
                  return n[k];
                },
              },
        );
      });
      return a;
    }

    function commonjsRequire() {
      throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var language = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Language = void 0;
      (function (Language) {
        Language['en'] = 'en';
        Language['ru'] = 'ru';
        Language['th'] = 'th';
        Language['ch'] = 'ch';
        Language['default'] = 'en';
      })(exports.Language || (exports.Language = {}));
    });

    var collection = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Collection = void 0;
      class Collection {
        constructor(collection) {
          this.items = [];
          if (isCollectionServerInterface(collection)) {
            this.total = collection.total;
            this.items = collection.items;
          } else {
            this.items = collection;
            this.total = collection.length;
          }
        }
        hasMore() {
          return this.total > this.items.length;
        }
      }
      exports.Collection = Collection;
      function isCollectionServerInterface(model) {
        return model.total !== undefined && Array.isArray(model.items);
      }
    });

    var sports = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Sports = void 0;
      (function (Sports) {
        Sports['football'] = 'football';
        Sports['basketball'] = 'basketball';
        Sports['volleyball'] = 'volleyball';
        Sports['beach_soccer'] = 'beach-soccer';
        Sports['water_polo'] = 'water-polo';
        Sports['hockey'] = 'hockey';
      })(exports.Sports || (exports.Sports = {}));
    });

    var cupRound = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.CupRounds = void 0;
      (function (CupRounds) {
        CupRounds[(CupRounds['final'] = 0)] = 'final';
        CupRounds[(CupRounds['1/2'] = 1)] = '1/2';
        CupRounds[(CupRounds['1/4'] = 2)] = '1/4';
        CupRounds[(CupRounds['1/8'] = 3)] = '1/8';
        CupRounds[(CupRounds['1/16'] = 4)] = '1/16';
        CupRounds[(CupRounds['1/32'] = 5)] = '1/32';
        CupRounds[(CupRounds['1/64'] = 6)] = '1/64';
        CupRounds[(CupRounds['1/128'] = 7)] = '1/128';
        CupRounds[(CupRounds['1/3'] = 8)] = '1/3';
        CupRounds[(CupRounds['1/6'] = 9)] = '1/6';
        CupRounds[(CupRounds['1/12'] = 10)] = '1/12';
        CupRounds[(CupRounds['3rd_place'] = 11)] = '3rd_place';
      })(exports.CupRounds || (exports.CupRounds = {}));
    });

    var baseModel = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.BaseModel = void 0;
      class BaseModel {
        // todo add no constructor support in transformer
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model._id) != undefined) {
            this._id = model._id;
          }
          if ((model === null || model === void 0 ? void 0 : model.show) != undefined) {
            this.show = model.show;
          }
        }
      }
      exports.BaseModel = BaseModel;
    });

    var sortableModel = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.SortableModel = void 0;

      class SortableModel extends baseModel.BaseModel {
        constructor(model) {
          super(model);
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.sortIdx) != undefined) {
            this.sortIdx = model.sortIdx;
          }
        }
      }
      exports.SortableModel = SortableModel;
    });

    var dayjs_min = createCommonjsModule(function (module, exports) {
      !(function (t, e) {
        module.exports = e();
      })(commonjsGlobal, function () {
        var t = 1e3,
          e = 6e4,
          n = 36e5,
          r = 'millisecond',
          i = 'second',
          s = 'minute',
          u = 'hour',
          a = 'day',
          o = 'week',
          f = 'month',
          h = 'quarter',
          c = 'year',
          d = 'date',
          $ = 'Invalid Date',
          l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
          y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
          M = {
            name: 'en',
            weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
            months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
          },
          m = function (t, e, n) {
            var r = String(t);
            return !r || r.length >= e ? t : '' + Array(e + 1 - r.length).join(n) + t;
          },
          g = {
            s: m,
            z: function (t) {
              var e = -t.utcOffset(),
                n = Math.abs(e),
                r = Math.floor(n / 60),
                i = n % 60;
              return (e <= 0 ? '+' : '-') + m(r, 2, '0') + ':' + m(i, 2, '0');
            },
            m: function t(e, n) {
              if (e.date() < n.date()) return -t(n, e);
              var r = 12 * (n.year() - e.year()) + (n.month() - e.month()),
                i = e.clone().add(r, f),
                s = n - i < 0,
                u = e.clone().add(r + (s ? -1 : 1), f);
              return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
            },
            a: function (t) {
              return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
            },
            p: function (t) {
              return (
                { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h }[t] ||
                String(t || '')
                  .toLowerCase()
                  .replace(/s$/, '')
              );
            },
            u: function (t) {
              return void 0 === t;
            },
          },
          D = 'en',
          v = {};
        v[D] = M;
        var p = function (t) {
            return t instanceof _;
          },
          S = function (t, e, n) {
            var r;
            if (!t) return D;
            if ('string' == typeof t) v[t] && (r = t), e && ((v[t] = e), (r = t));
            else {
              var i = t.name;
              (v[i] = t), (r = i);
            }
            return !n && r && (D = r), r || (!n && D);
          },
          w = function (t, e) {
            if (p(t)) return t.clone();
            var n = 'object' == typeof e ? e : {};
            return (n.date = t), (n.args = arguments), new _(n);
          },
          O = g;
        (O.l = S),
          (O.i = p),
          (O.w = function (t, e) {
            return w(t, { locale: e.$L, utc: e.$u, x: e.$x, $offset: e.$offset });
          });
        var _ = (function () {
            function M(t) {
              (this.$L = S(t.locale, null, !0)), this.parse(t);
            }
            var m = M.prototype;
            return (
              (m.parse = function (t) {
                (this.$d = (function (t) {
                  var e = t.date,
                    n = t.utc;
                  if (null === e) return new Date(NaN);
                  if (O.u(e)) return new Date();
                  if (e instanceof Date) return new Date(e);
                  if ('string' == typeof e && !/Z$/i.test(e)) {
                    var r = e.match(l);
                    if (r) {
                      var i = r[2] - 1 || 0,
                        s = (r[7] || '0').substring(0, 3);
                      return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
                    }
                  }
                  return new Date(e);
                })(t)),
                  (this.$x = t.x || {}),
                  this.init();
              }),
              (m.init = function () {
                var t = this.$d;
                (this.$y = t.getFullYear()),
                  (this.$M = t.getMonth()),
                  (this.$D = t.getDate()),
                  (this.$W = t.getDay()),
                  (this.$H = t.getHours()),
                  (this.$m = t.getMinutes()),
                  (this.$s = t.getSeconds()),
                  (this.$ms = t.getMilliseconds());
              }),
              (m.$utils = function () {
                return O;
              }),
              (m.isValid = function () {
                return !(this.$d.toString() === $);
              }),
              (m.isSame = function (t, e) {
                var n = w(t);
                return this.startOf(e) <= n && n <= this.endOf(e);
              }),
              (m.isAfter = function (t, e) {
                return w(t) < this.startOf(e);
              }),
              (m.isBefore = function (t, e) {
                return this.endOf(e) < w(t);
              }),
              (m.$g = function (t, e, n) {
                return O.u(t) ? this[e] : this.set(n, t);
              }),
              (m.unix = function () {
                return Math.floor(this.valueOf() / 1e3);
              }),
              (m.valueOf = function () {
                return this.$d.getTime();
              }),
              (m.startOf = function (t, e) {
                var n = this,
                  r = !!O.u(e) || e,
                  h = O.p(t),
                  $ = function (t, e) {
                    var i = O.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
                    return r ? i : i.endOf(a);
                  },
                  l = function (t, e) {
                    return O.w(n.toDate()[t].apply(n.toDate('s'), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), n);
                  },
                  y = this.$W,
                  M = this.$M,
                  m = this.$D,
                  g = 'set' + (this.$u ? 'UTC' : '');
                switch (h) {
                  case c:
                    return r ? $(1, 0) : $(31, 11);
                  case f:
                    return r ? $(1, M) : $(0, M + 1);
                  case o:
                    var D = this.$locale().weekStart || 0,
                      v = (y < D ? y + 7 : y) - D;
                    return $(r ? m - v : m + (6 - v), M);
                  case a:
                  case d:
                    return l(g + 'Hours', 0);
                  case u:
                    return l(g + 'Minutes', 1);
                  case s:
                    return l(g + 'Seconds', 2);
                  case i:
                    return l(g + 'Milliseconds', 3);
                  default:
                    return this.clone();
                }
              }),
              (m.endOf = function (t) {
                return this.startOf(t, !1);
              }),
              (m.$set = function (t, e) {
                var n,
                  o = O.p(t),
                  h = 'set' + (this.$u ? 'UTC' : ''),
                  $ = ((n = {}),
                  (n[a] = h + 'Date'),
                  (n[d] = h + 'Date'),
                  (n[f] = h + 'Month'),
                  (n[c] = h + 'FullYear'),
                  (n[u] = h + 'Hours'),
                  (n[s] = h + 'Minutes'),
                  (n[i] = h + 'Seconds'),
                  (n[r] = h + 'Milliseconds'),
                  n)[o],
                  l = o === a ? this.$D + (e - this.$W) : e;
                if (o === f || o === c) {
                  var y = this.clone().set(d, 1);
                  y.$d[$](l), y.init(), (this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d);
                } else $ && this.$d[$](l);
                return this.init(), this;
              }),
              (m.set = function (t, e) {
                return this.clone().$set(t, e);
              }),
              (m.get = function (t) {
                return this[O.p(t)]();
              }),
              (m.add = function (r, h) {
                var d,
                  $ = this;
                r = Number(r);
                var l = O.p(h),
                  y = function (t) {
                    var e = w($);
                    return O.w(e.date(e.date() + Math.round(t * r)), $);
                  };
                if (l === f) return this.set(f, this.$M + r);
                if (l === c) return this.set(c, this.$y + r);
                if (l === a) return y(1);
                if (l === o) return y(7);
                var M = ((d = {}), (d[s] = e), (d[u] = n), (d[i] = t), d)[l] || 1,
                  m = this.$d.getTime() + r * M;
                return O.w(m, this);
              }),
              (m.subtract = function (t, e) {
                return this.add(-1 * t, e);
              }),
              (m.format = function (t) {
                var e = this,
                  n = this.$locale();
                if (!this.isValid()) return n.invalidDate || $;
                var r = t || 'YYYY-MM-DDTHH:mm:ssZ',
                  i = O.z(this),
                  s = this.$H,
                  u = this.$m,
                  a = this.$M,
                  o = n.weekdays,
                  f = n.months,
                  h = function (t, n, i, s) {
                    return (t && (t[n] || t(e, r))) || i[n].substr(0, s);
                  },
                  c = function (t) {
                    return O.s(s % 12 || 12, t, '0');
                  },
                  d =
                    n.meridiem ||
                    function (t, e, n) {
                      var r = t < 12 ? 'AM' : 'PM';
                      return n ? r.toLowerCase() : r;
                    },
                  l = {
                    YY: String(this.$y).slice(-2),
                    YYYY: this.$y,
                    M: a + 1,
                    MM: O.s(a + 1, 2, '0'),
                    MMM: h(n.monthsShort, a, f, 3),
                    MMMM: h(f, a),
                    D: this.$D,
                    DD: O.s(this.$D, 2, '0'),
                    d: String(this.$W),
                    dd: h(n.weekdaysMin, this.$W, o, 2),
                    ddd: h(n.weekdaysShort, this.$W, o, 3),
                    dddd: o[this.$W],
                    H: String(s),
                    HH: O.s(s, 2, '0'),
                    h: c(1),
                    hh: c(2),
                    a: d(s, u, !0),
                    A: d(s, u, !1),
                    m: String(u),
                    mm: O.s(u, 2, '0'),
                    s: String(this.$s),
                    ss: O.s(this.$s, 2, '0'),
                    SSS: O.s(this.$ms, 3, '0'),
                    Z: i,
                  };
                return r.replace(y, function (t, e) {
                  return e || l[t] || i.replace(':', '');
                });
              }),
              (m.utcOffset = function () {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
              }),
              (m.diff = function (r, d, $) {
                var l,
                  y = O.p(d),
                  M = w(r),
                  m = (M.utcOffset() - this.utcOffset()) * e,
                  g = this - M,
                  D = O.m(this, M);
                return (
                  (D =
                    ((l = {}), (l[c] = D / 12), (l[f] = D), (l[h] = D / 3), (l[o] = (g - m) / 6048e5), (l[a] = (g - m) / 864e5), (l[u] = g / n), (l[s] = g / e), (l[i] = g / t), l)[
                      y
                    ] || g),
                  $ ? D : O.a(D)
                );
              }),
              (m.daysInMonth = function () {
                return this.endOf(f).$D;
              }),
              (m.$locale = function () {
                return v[this.$L];
              }),
              (m.locale = function (t, e) {
                if (!t) return this.$L;
                var n = this.clone(),
                  r = S(t, e, !0);
                return r && (n.$L = r), n;
              }),
              (m.clone = function () {
                return O.w(this.$d, this);
              }),
              (m.toDate = function () {
                return new Date(this.valueOf());
              }),
              (m.toJSON = function () {
                return this.isValid() ? this.toISOString() : null;
              }),
              (m.toISOString = function () {
                return this.$d.toISOString();
              }),
              (m.toString = function () {
                return this.$d.toUTCString();
              }),
              M
            );
          })(),
          b = _.prototype;
        return (
          (w.prototype = b),
          [
            ['$ms', r],
            ['$s', i],
            ['$m', s],
            ['$H', u],
            ['$W', a],
            ['$M', f],
            ['$y', c],
            ['$D', d],
          ].forEach(function (t) {
            b[t[1]] = function (e) {
              return this.$g(e, t[0], t[1]);
            };
          }),
          (w.extend = function (t, e) {
            return t.$i || (t(e, _, w), (t.$i = !0)), w;
          }),
          (w.locale = S),
          (w.isDayjs = p),
          (w.unix = function (t) {
            return w(1e3 * t);
          }),
          (w.en = v[D]),
          (w.Ls = v),
          (w.p = {}),
          w
        );
      });
    });

    var city_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.City = void 0;

      class City extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.leagues = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.flag) != undefined) {
            this.flag = model.flag;
          }
          if ((model === null || model === void 0 ? void 0 : model.lat) != undefined) {
            this.lat = model.lat;
          }
          if ((model === null || model === void 0 ? void 0 : model.long) != undefined) {
            this.long = model.long;
          }
          if ((model === null || model === void 0 ? void 0 : model.show) != undefined) {
            this.show = model.show;
          }
          if ((model === null || model === void 0 ? void 0 : model.leagues) != undefined) {
            this.leagues = model.leagues.map(__v => new league_model.League(__v));
          }
        }
      }
      exports.City = City;
    });

    var country_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Country = void 0;

      class Country extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.teams = [];
          this.champs = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.founded) != undefined) {
            this.founded = model.founded;
          }
          if ((model === null || model === void 0 ? void 0 : model.flag) != undefined) {
            this.flag = model.flag;
          }
          if ((model === null || model === void 0 ? void 0 : model.socialVk) != undefined) {
            this.socialVk = model.socialVk;
          }
          if ((model === null || model === void 0 ? void 0 : model.socialFb) != undefined) {
            this.socialFb = model.socialFb;
          }
          if ((model === null || model === void 0 ? void 0 : model.socialIg) != undefined) {
            this.socialIg = model.socialIg;
          }
          if ((model === null || model === void 0 ? void 0 : model.photoId) != undefined) {
            this.photoId = model.photoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.league) != undefined) {
            this.league = new league_model.League(model.league);
          }
          if ((model === null || model === void 0 ? void 0 : model.teams) != undefined) {
            this.teams = model.teams.map(__v => new team_model.Team(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.champs) != undefined) {
            this.champs = model.champs.map(__v => new champ_model.Champ(__v));
          }
        }
        get seasons() {
          var _a;
          return (_a = this.champs) === null || _a === void 0
            ? void 0
            : _a.reduce((seasons, champ) => {
                return [...seasons, ...(champ.seasons || [])];
              }, []);
        }
        get stages() {
          var _a;
          return (_a = this.seasons) === null || _a === void 0
            ? void 0
            : _a.reduce((stages, season) => {
                return [...stages, ...(season.stages || [])];
              }, []);
        }
      }
      exports.Country = Country;
    });

    var pitch_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Pitch = void 0;

      class Pitch extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.games = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.description) != undefined) {
            this.description = model.description;
          }
          if ((model === null || model === void 0 ? void 0 : model.hasPhoto) != undefined) {
            this.hasPhoto = model.hasPhoto;
          }
          if ((model === null || model === void 0 ? void 0 : model.photoId) != undefined) {
            this.photoId = model.photoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.stadium) != undefined) {
            this.stadium = new stadium_model.Stadium(model.stadium);
          }
          if ((model === null || model === void 0 ? void 0 : model.games) != undefined) {
            this.games = model.games.map(__v => new game_model.Game(__v));
          }
        }
        get league() {
          var _a;
          return (_a = this.stadium) === null || _a === void 0 ? void 0 : _a.league;
        }
      }
      exports.Pitch = Pitch;
    });

    var stadium_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Stadium = void 0;

      class Stadium extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.pitches = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.address) != undefined) {
            this.address = model.address;
          }
          if ((model === null || model === void 0 ? void 0 : model.description) != undefined) {
            this.description = model.description;
          }
          if ((model === null || model === void 0 ? void 0 : model.lat) != undefined) {
            this.lat = model.lat;
          }
          if ((model === null || model === void 0 ? void 0 : model.long) != undefined) {
            this.long = model.long;
          }
          if ((model === null || model === void 0 ? void 0 : model.photoId) != undefined) {
            this.photoId = model.photoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.league) != undefined) {
            this.league = new league_model.League(model.league);
          }
          if ((model === null || model === void 0 ? void 0 : model.pitches) != undefined) {
            this.pitches = model.pitches.map(__v => new pitch_model.Pitch(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.games) != undefined) {
            this.games = new collection.Collection({ total: model.games.total, items: model.games.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.upcomingGames) != undefined) {
            this.upcomingGames = new collection.Collection({ total: model.upcomingGames.total, items: model.upcomingGames.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.playedGames) != undefined) {
            this.playedGames = new collection.Collection({ total: model.playedGames.total, items: model.playedGames.items.map(_v => new game_model.Game(_v)) });
          }
        }
      }
      exports.Stadium = Stadium;
    });

    var transferRequest_model = createCommonjsModule(function (module, exports) {
      var __createBinding =
        (commonjsGlobal && commonjsGlobal.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (commonjsGlobal && commonjsGlobal.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, 'default', { enumerable: true, value: v });
            }
          : function (o, v) {
              o['default'] = v;
            });
      var __importStar =
        (commonjsGlobal && commonjsGlobal.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.TransferRequest = exports.TransferRequestState = exports.TransferRequestType = void 0;

      const dayjs_1 = __importStar(dayjs_min);
      (function (TransferRequestType) {
        TransferRequestType['create'] = 'create';
        TransferRequestType['transfer'] = 'transfer';
        TransferRequestType['free_transfer'] = 'free_transfer';
        TransferRequestType['combine'] = 'combine';
        TransferRequestType['remove'] = 'roster_remove';
      })(exports.TransferRequestType || (exports.TransferRequestType = {}));
      (function (TransferRequestState) {
        TransferRequestState[(TransferRequestState['sent'] = 0)] = 'sent';
        TransferRequestState[(TransferRequestState['capConfirmed'] = 1)] = 'capConfirmed';
        TransferRequestState[(TransferRequestState['adminConfirmed'] = 2)] = 'adminConfirmed';
        TransferRequestState[(TransferRequestState['declined'] = 3)] = 'declined';
      })(exports.TransferRequestState || (exports.TransferRequestState = {}));
      class TransferRequest extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.fromTeam) != undefined) {
            this.fromTeam = new team_model.Team(model.fromTeam);
          }
          if ((model === null || model === void 0 ? void 0 : model.toTeam) != undefined) {
            this.toTeam = new team_model.Team(model.toTeam);
          }
          if ((model === null || model === void 0 ? void 0 : model.player) != undefined) {
            this.player = new player_model.Player(model.player);
          }
          if ((model === null || model === void 0 ? void 0 : model.state) != undefined) {
            this.state = model.state;
          }
          if ((model === null || model === void 0 ? void 0 : model.type) != undefined) {
            this.type = model.type;
          }
          if ((model === null || model === void 0 ? void 0 : model.createdDate) != undefined) {
            this.createdDate = new dayjs_1.Dayjs(model.createdDate);
          }
          if ((model === null || model === void 0 ? void 0 : model.createdBy) != undefined) {
            this.createdBy = new user_model.User(model.createdBy);
          }
          if ((model === null || model === void 0 ? void 0 : model.capApprovedTimestamp) != undefined) {
            this.capApprovedDate = (d => dayjs_1.default(d * 1000))(model.capApprovedTimestamp);
          }
          if ((model === null || model === void 0 ? void 0 : model.capApprovedBy) != undefined) {
            this.capApprovedBy = new user_model.User(model.capApprovedBy);
          }
          if ((model === null || model === void 0 ? void 0 : model.adminConfirmedTimestamp) != undefined) {
            this.adminConfirmedDate = (d => dayjs_1.default(d * 1000))(model.adminConfirmedTimestamp);
          }
          if ((model === null || model === void 0 ? void 0 : model.adminConfirmedBy) != undefined) {
            this.adminConfirmedBy = new user_model.User(model.adminConfirmedBy);
          }
          if ((model === null || model === void 0 ? void 0 : model.declinedTimestamp) != undefined) {
            this.declinedDate = (d => dayjs_1.default(d * 1000))(model.declinedTimestamp);
          }
          if ((model === null || model === void 0 ? void 0 : model.declinedBy) != undefined) {
            this.declinedBy = new user_model.User(model.declinedBy);
          }
        }
      }
      exports.TransferRequest = TransferRequest;
    });

    var disqualification_model = createCommonjsModule(function (module, exports) {
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.DisqualificationType = exports.DisqualificationTime = exports.DisqualificationGames = exports.Disqualification = void 0;

      const dayjs_1 = __importDefault(dayjs_min);
      class Disqualification extends baseModel.BaseModel {
        constructor(model) {
          super(model);
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.mode) != undefined) {
            this.mode = model.mode;
          }
          if ((model === null || model === void 0 ? void 0 : model.player) != undefined) {
            this.player = new player_model.Player(model.player);
          }
          if ((model === null || model === void 0 ? void 0 : model.champ) != undefined) {
            this.champ = new champ_model.Champ(model.champ);
          }
          if ((model === null || model === void 0 ? void 0 : model.comment) != undefined) {
            this.comment = model.comment;
          }
        }
      }
      exports.Disqualification = Disqualification;
      class DisqualificationGames extends Disqualification {
        constructor(model) {
          super(model);
          this.mode = DisqualificationType.games;
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.mode) != undefined) {
            this.mode = model.mode;
          }
          if ((model === null || model === void 0 ? void 0 : model.games) != undefined) {
            this.games = model.games;
          }
          if ((model === null || model === void 0 ? void 0 : model.gamesLeft) != undefined) {
            this.gamesLeft = model.gamesLeft;
          }
        }
      }
      exports.DisqualificationGames = DisqualificationGames;
      class DisqualificationTime extends Disqualification {
        constructor(model) {
          super(model);
          this.mode = DisqualificationType.time;
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.mode) != undefined) {
            this.mode = model.mode;
          }
          if ((model === null || model === void 0 ? void 0 : model.until) != undefined) {
            this.until = (d => dayjs_1.default(d))(model.until);
          }
        }
      }
      exports.DisqualificationTime = DisqualificationTime;
      var DisqualificationType;
      (function (DisqualificationType) {
        DisqualificationType['games'] = 'games';
        DisqualificationType['time'] = 'time';
      })((DisqualificationType = exports.DisqualificationType || (exports.DisqualificationType = {})));
    });

    var blacklistRecord_model = createCommonjsModule(function (module, exports) {
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.BlacklistRecord = void 0;

      const dayjs_1 = __importDefault(dayjs_min);

      class BlacklistRecord extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.active) != undefined) {
            this.active = model.active;
          }
          if ((model === null || model === void 0 ? void 0 : model.comment) != undefined) {
            this.comment = model.comment;
          }
          if ((model === null || model === void 0 ? void 0 : model.date) != undefined) {
            this.date = (d => dayjs_1.default(d))(model.date);
          }
          if ((model === null || model === void 0 ? void 0 : model.by) != undefined) {
            this.by = new user_model.User(model.by);
          }
        }
      }
      exports.BlacklistRecord = BlacklistRecord;
    });

    var playerCareer_model = createCommonjsModule(function (module, exports) {
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.PlayerCareer = void 0;

      const dayjs_1 = __importDefault(dayjs_min);

      class PlayerCareer {
        constructor(model) {
          this.played = 0;
          this.goals = 0;
          this.assists = 0;
          this.winPercent = 0;
          this.yellowCards = 0;
          this.redCards = 0;
          this.points = 0;
          this.teams = [];
          this.seasons = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.played) != undefined) {
            this.played = model.played;
          }
          if ((model === null || model === void 0 ? void 0 : model.goals) != undefined) {
            this.goals = model.goals;
          }
          if ((model === null || model === void 0 ? void 0 : model.assists) != undefined) {
            this.assists = model.assists;
          }
          if ((model === null || model === void 0 ? void 0 : model.winPercent) != undefined) {
            this.winPercent = model.winPercent;
          }
          if ((model === null || model === void 0 ? void 0 : model.yellowCards) != undefined) {
            this.yellowCards = model.yellowCards;
          }
          if ((model === null || model === void 0 ? void 0 : model.redCards) != undefined) {
            this.redCards = model.redCards;
          }
          if ((model === null || model === void 0 ? void 0 : model.points) != undefined) {
            this.points = model.points;
          }
          if ((model === null || model === void 0 ? void 0 : model.teams) != undefined) {
            this.teams = model.teams.map(__v => new PlayerCareerTeam(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.seasons) != undefined) {
            this.seasons = model.seasons.map(__v => new PlayerCareerSeason(__v));
          }
        }
      }
      exports.PlayerCareer = PlayerCareer;
      class PlayerCareerTeam {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.team) != undefined) {
            this.team = new team_model.Team(model.team);
          }
          if ((model === null || model === void 0 ? void 0 : model.stats) != undefined) {
            this.stats = model.stats;
          }
          if ((model === null || model === void 0 ? void 0 : model.from) != undefined) {
            this.from = (d => dayjs_1.default(d))(model.from);
          }
          if ((model === null || model === void 0 ? void 0 : model.till) != undefined) {
            this.till = (d => dayjs_1.default(d))(model.till);
          }
        }
      }
      class PlayerCareerSeason {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.season) != undefined) {
            this.season = new season_model.Season(model.season);
          }
          if ((model === null || model === void 0 ? void 0 : model.teams) != undefined) {
            this.teams = model.teams.map(__v => new team_model.Team(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.stats) != undefined) {
            this.stats = model.stats;
          }
          if ((model === null || model === void 0 ? void 0 : model.from) != undefined) {
            this.from = (d => dayjs_1.default(d))(model.from);
          }
          if ((model === null || model === void 0 ? void 0 : model.till) != undefined) {
            this.till = (d => dayjs_1.default(d))(model.till);
          }
        }
      }
    });

    var playerGame_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.PlayerGame = void 0;

      class PlayerGame {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.game) != undefined) {
            this.game = new game_model.Game(model.game);
          }
          if ((model === null || model === void 0 ? void 0 : model.stats) != undefined) {
            this.stats = model.stats;
          }
        }
      }
      exports.PlayerGame = PlayerGame;
    });

    var customParseFormat = createCommonjsModule(function (module, exports) {
      !(function (t, e) {
        module.exports = e();
      })(commonjsGlobal, function () {
        var t = { LTS: 'h:mm:ss A', LT: 'h:mm A', L: 'MM/DD/YYYY', LL: 'MMMM D, YYYY', LLL: 'MMMM D, YYYY h:mm A', LLLL: 'dddd, MMMM D, YYYY h:mm A' },
          e = /(\[[^[]*\])|([-:/.()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
          n = /\d\d/,
          r = /\d\d?/,
          i = /\d*[^\s\d-_:/()]+/,
          o = {},
          s = function (t) {
            return (t = +t) + (t > 68 ? 1900 : 2e3);
          };
        var a = function (t) {
            return function (e) {
              this[t] = +e;
            };
          },
          f = [
            /[+-]\d\d:?(\d\d)?|Z/,
            function (t) {
              (this.zone || (this.zone = {})).offset = (function (t) {
                if (!t) return 0;
                if ('Z' === t) return 0;
                var e = t.match(/([+-]|\d\d)/g),
                  n = 60 * e[1] + (+e[2] || 0);
                return 0 === n ? 0 : '+' === e[0] ? -n : n;
              })(t);
            },
          ],
          u = function (t) {
            var e = o[t];
            return e && (e.indexOf ? e : e.s.concat(e.f));
          },
          h = function (t, e) {
            var n,
              r = o.meridiem;
            if (r) {
              for (var i = 1; i <= 24; i += 1)
                if (t.indexOf(r(i, 0, e)) > -1) {
                  n = i > 12;
                  break;
                }
            } else n = t === (e ? 'pm' : 'PM');
            return n;
          },
          d = {
            A: [
              i,
              function (t) {
                this.afternoon = h(t, !1);
              },
            ],
            a: [
              i,
              function (t) {
                this.afternoon = h(t, !0);
              },
            ],
            S: [
              /\d/,
              function (t) {
                this.milliseconds = 100 * +t;
              },
            ],
            SS: [
              n,
              function (t) {
                this.milliseconds = 10 * +t;
              },
            ],
            SSS: [
              /\d{3}/,
              function (t) {
                this.milliseconds = +t;
              },
            ],
            s: [r, a('seconds')],
            ss: [r, a('seconds')],
            m: [r, a('minutes')],
            mm: [r, a('minutes')],
            H: [r, a('hours')],
            h: [r, a('hours')],
            HH: [r, a('hours')],
            hh: [r, a('hours')],
            D: [r, a('day')],
            DD: [n, a('day')],
            Do: [
              i,
              function (t) {
                var e = o.ordinal,
                  n = t.match(/\d+/);
                if (((this.day = n[0]), e)) for (var r = 1; r <= 31; r += 1) e(r).replace(/\[|\]/g, '') === t && (this.day = r);
              },
            ],
            M: [r, a('month')],
            MM: [n, a('month')],
            MMM: [
              i,
              function (t) {
                var e = u('months'),
                  n =
                    (
                      u('monthsShort') ||
                      e.map(function (t) {
                        return t.substr(0, 3);
                      })
                    ).indexOf(t) + 1;
                if (n < 1) throw new Error();
                this.month = n % 12 || n;
              },
            ],
            MMMM: [
              i,
              function (t) {
                var e = u('months').indexOf(t) + 1;
                if (e < 1) throw new Error();
                this.month = e % 12 || e;
              },
            ],
            Y: [/[+-]?\d+/, a('year')],
            YY: [
              n,
              function (t) {
                this.year = s(t);
              },
            ],
            YYYY: [/\d{4}/, a('year')],
            Z: f,
            ZZ: f,
          };
        function c(n) {
          var r, i;
          (r = n), (i = o && o.formats);
          for (
            var s = (n = r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (e, n, r) {
                var o = r && r.toUpperCase();
                return (
                  n ||
                  i[r] ||
                  t[r] ||
                  i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (t, e, n) {
                    return e || n.slice(1);
                  })
                );
              })).match(e),
              a = s.length,
              f = 0;
            f < a;
            f += 1
          ) {
            var u = s[f],
              h = d[u],
              c = h && h[0],
              l = h && h[1];
            s[f] = l ? { regex: c, parser: l } : u.replace(/^\[|\]$/g, '');
          }
          return function (t) {
            for (var e = {}, n = 0, r = 0; n < a; n += 1) {
              var i = s[n];
              if ('string' == typeof i) r += i.length;
              else {
                var o = i.regex,
                  f = i.parser,
                  u = t.substr(r),
                  h = o.exec(u)[0];
                f.call(e, h), (t = t.replace(h, ''));
              }
            }
            return (
              (function (t) {
                var e = t.afternoon;
                if (void 0 !== e) {
                  var n = t.hours;
                  e ? n < 12 && (t.hours += 12) : 12 === n && (t.hours = 0), delete t.afternoon;
                }
              })(e),
              e
            );
          };
        }
        return function (t, e, n) {
          (n.p.customParseFormat = !0), t && t.parseTwoDigitYear && (s = t.parseTwoDigitYear);
          var r = e.prototype,
            i = r.parse;
          r.parse = function (t) {
            var e = t.date,
              r = t.utc,
              s = t.args;
            this.$u = r;
            var a = s[1];
            if ('string' == typeof a) {
              var f = !0 === s[2],
                u = !0 === s[3],
                h = f || u,
                d = s[2];
              u && (d = s[2]),
                (o = this.$locale()),
                !f && d && (o = n.Ls[d]),
                (this.$d = (function (t, e, n) {
                  try {
                    if (['x', 'X'].indexOf(e) > -1) return new Date(('X' === e ? 1e3 : 1) * t);
                    var r = c(e)(t),
                      i = r.year,
                      o = r.month,
                      s = r.day,
                      a = r.hours,
                      f = r.minutes,
                      u = r.seconds,
                      h = r.milliseconds,
                      d = r.zone,
                      l = new Date(),
                      m = s || (i || o ? 1 : l.getDate()),
                      M = i || l.getFullYear(),
                      Y = 0;
                    (i && !o) || (Y = o > 0 ? o - 1 : l.getMonth());
                    var p = a || 0,
                      v = f || 0,
                      D = u || 0,
                      g = h || 0;
                    return d ? new Date(Date.UTC(M, Y, m, p, v, D, g + 60 * d.offset * 1e3)) : n ? new Date(Date.UTC(M, Y, m, p, v, D, g)) : new Date(M, Y, m, p, v, D, g);
                  } catch (t) {
                    return new Date('');
                  }
                })(e, a, r)),
                this.init(),
                d && !0 !== d && (this.$L = this.locale(d).$L),
                h && e != this.format(a) && (this.$d = new Date('')),
                (o = {});
            } else if (a instanceof Array)
              for (var l = a.length, m = 1; m <= l; m += 1) {
                s[1] = a[m - 1];
                var M = n.apply(this, s);
                if (M.isValid()) {
                  (this.$d = M.$d), (this.$L = M.$L), this.init();
                  break;
                }
                m === l && (this.$d = new Date(''));
              }
            else i.call(this, t);
          };
        };
      });
    });

    var player_model = createCommonjsModule(function (module, exports) {
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Player = void 0;

      const dayjs_1 = __importDefault(dayjs_min);

      dayjs_1.default.extend(customParseFormat);
      class Player extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.teams = [];
          this.requests = [];
          this.disqualifications = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.firstName) != undefined) {
            this.firstName = model.firstName;
          }
          if ((model === null || model === void 0 ? void 0 : model.middleName) != undefined) {
            this.middleName = model.middleName;
          }
          if ((model === null || model === void 0 ? void 0 : model.lastName) != undefined) {
            this.lastName = model.lastName;
          }
          if ((model === null || model === void 0 ? void 0 : model.position) != undefined) {
            this.position = model.position;
          }
          if ((model === null || model === void 0 ? void 0 : model.leg) != undefined) {
            this.leg = model.leg;
          }
          if ((model === null || model === void 0 ? void 0 : model.height) != undefined) {
            this.height = model.height;
          }
          if ((model === null || model === void 0 ? void 0 : model.weight) != undefined) {
            this.weight = model.weight;
          }
          if ((model === null || model === void 0 ? void 0 : model.photoId) != undefined) {
            this.photoId = model.photoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.number) != undefined) {
            this.number = model.number;
          }
          if ((model === null || model === void 0 ? void 0 : model.socialVk) != undefined) {
            this.socialVk = model.socialVk;
          }
          if ((model === null || model === void 0 ? void 0 : model.socialFb) != undefined) {
            this.socialFb = model.socialFb;
          }
          if ((model === null || model === void 0 ? void 0 : model.socialPhone) != undefined) {
            this.socialPhone = model.socialPhone;
          }
          if ((model === null || model === void 0 ? void 0 : model.league) != undefined) {
            this.league = new league_model.League(model.league);
          }
          if ((model === null || model === void 0 ? void 0 : model.teams) != undefined) {
            this.teams = model.teams.map(__v => new team_model.Team(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.blacklisted) != undefined) {
            this.blacklisted = new blacklistRecord_model.BlacklistRecord(model.blacklisted);
          }
          if ((model === null || model === void 0 ? void 0 : model.games) != undefined) {
            this.games = new collection.Collection({ total: model.games.total, items: model.games.items.map(_v => new playerGame_model.PlayerGame(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.news) != undefined) {
            this.news = new collection.Collection({ total: model.news.total, items: model.news.items.map(_v => new post_model.Post(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.gamesWithPhotos) != undefined) {
            this.gamesWithPhotos = new collection.Collection({ total: model.gamesWithPhotos.total, items: model.gamesWithPhotos.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.gamesWithVideos) != undefined) {
            this.gamesWithVideos = new collection.Collection({ total: model.gamesWithVideos.total, items: model.gamesWithVideos.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.transfers) != undefined) {
            this.transfers = new collection.Collection({ total: model.transfers.total, items: model.transfers.items.map(_v => new transferRequest_model.TransferRequest(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.requests) != undefined) {
            this.requests = model.requests.map(__v => new transferRequest_model.TransferRequest(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.disqualifications) != undefined) {
            this.disqualifications = (d =>
              d.mode === disqualification_model.DisqualificationType.games
                ? new disqualification_model.DisqualificationGames(d)
                : new disqualification_model.DisqualificationTime(d))(model.disqualifications);
          }
          if ((model === null || model === void 0 ? void 0 : model.career) != undefined) {
            this.career = new playerCareer_model.PlayerCareer(model.career);
          }
          if ((model === null || model === void 0 ? void 0 : model.globalProfile) != undefined) {
            this.globalProfile = (g => {
              var _a;
              return { _id: g._id, players: ((_a = g.players) === null || _a === void 0 ? void 0 : _a.map(p => new Player(p))) || [] };
            })(model.globalProfile);
          }
          this.mapBirthday(model);
          if (model === null || model === void 0 ? void 0 : model.blacklisted) {
            this.blacklisted = new blacklistRecord_model.BlacklistRecord({
              active: true,
              comment: model.blacklistedComment,
              date: model.blacklistedDate,
              by: model.blacklistedBy,
            });
          }
        }
        getAge() {
          if (!Boolean(this.birthday)) return;
          return dayjs_1.default().diff(this.birthday, 'y');
        }
        mapBirthday(model) {
          var _a;
          if (model === null || model === void 0 ? void 0 : model.birthdayDate) {
            this.birthday = dayjs_1.default(model.birthdayDate);
          } else if (model === null || model === void 0 ? void 0 : model.birthday) {
            if (model.birthday.match(/\d{4}-\d{2}-\d{2}/)) {
              this.birthday = dayjs_1.default(model.birthday, 'YYYY-MM-DD');
            } else if (model.birthday.match(/\d{2}.\d{2}.\d{4}/)) {
              this.birthday = dayjs_1.default(model.birthday, 'DD.MM.YYYY');
            }
          }
          if (!((_a = this.birthday) === null || _a === void 0 ? void 0 : _a.isValid())) {
            this.birthday = null;
          }
        }
      }
      exports.Player = Player;
    });

    var tag_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Tag = void 0;

      class Tag {
        constructor(tag) {
          this.isFtbModel = true;
          if ((tag === null || tag === void 0 ? void 0 : tag._id) != undefined) {
            this._id = tag._id;
          }
          if ((tag === null || tag === void 0 ? void 0 : tag.key) != undefined) {
            this.key = tag.key;
          }
          if ((tag === null || tag === void 0 ? void 0 : tag.city) != undefined) {
            this.city = new city_model.City(tag.city);
          }
          if ((tag === null || tag === void 0 ? void 0 : tag.league) != undefined) {
            this.league = new league_model.League(tag.league);
          }
          if ((tag === null || tag === void 0 ? void 0 : tag.champ) != undefined) {
            this.champ = new champ_model.Champ(tag.champ);
          }
          if ((tag === null || tag === void 0 ? void 0 : tag.team) != undefined) {
            this.team = new team_model.Team(tag.team);
          }
          if ((tag === null || tag === void 0 ? void 0 : tag.stadium) != undefined) {
            this.stadium = new stadium_model.Stadium(tag.stadium);
          }
          if ((tag === null || tag === void 0 ? void 0 : tag.game) != undefined) {
            this.game = new game_model.Game(tag.game);
          }
          if ((tag === null || tag === void 0 ? void 0 : tag.player) != undefined) {
            this.player = new player_model.Player(tag.player);
          }
        }
      }
      exports.Tag = Tag;
    });

    var marked = createCommonjsModule(function (module, exports) {
      /**
       * marked - a markdown parser
       * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)
       * https://github.com/markedjs/marked
       */

      /**
       * DO NOT EDIT THIS FILE
       * The code in this file is generated from files in ./src/
       */

      (function (global, factory) {
        module.exports = factory();
      })(commonjsGlobal, function () {
        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ('value' in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) _defineProperties(Constructor.prototype, protoProps);
          if (staticProps) _defineProperties(Constructor, staticProps);
          return Constructor;
        }

        function _unsupportedIterableToArray(o, minLen) {
          if (!o) return;
          if (typeof o === 'string') return _arrayLikeToArray(o, minLen);
          var n = Object.prototype.toString.call(o).slice(8, -1);
          if (n === 'Object' && o.constructor) n = o.constructor.name;
          if (n === 'Map' || n === 'Set') return Array.from(o);
          if (n === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }

        function _arrayLikeToArray(arr, len) {
          if (len == null || len > arr.length) len = arr.length;

          for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

          return arr2;
        }

        function _createForOfIteratorHelperLoose(o, allowArrayLike) {
          var it = (typeof Symbol !== 'undefined' && o[Symbol.iterator]) || o['@@iterator'];
          if (it) return (it = it.call(o)).next.bind(it);

          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || (allowArrayLike && o && typeof o.length === 'number')) {
            if (it) o = it;
            var i = 0;
            return function () {
              if (i >= o.length)
                return {
                  done: true,
                };
              return {
                done: false,
                value: o[i++],
              };
            };
          }

          throw new TypeError('Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
        }

        var defaults$5 = { exports: {} };

        function getDefaults$1() {
          return {
            baseUrl: null,
            breaks: false,
            extensions: null,
            gfm: true,
            headerIds: true,
            headerPrefix: '',
            highlight: null,
            langPrefix: 'language-',
            mangle: true,
            pedantic: false,
            renderer: null,
            sanitize: false,
            sanitizer: null,
            silent: false,
            smartLists: false,
            smartypants: false,
            tokenizer: null,
            walkTokens: null,
            xhtml: false,
          };
        }

        function changeDefaults$1(newDefaults) {
          defaults$5.exports.defaults = newDefaults;
        }

        defaults$5.exports = {
          defaults: getDefaults$1(),
          getDefaults: getDefaults$1,
          changeDefaults: changeDefaults$1,
        };

        /**
         * Helpers
         */
        var escapeTest = /[&<>"']/;
        var escapeReplace = /[&<>"']/g;
        var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
        var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
        var escapeReplacements = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
        };

        var getEscapeReplacement = function getEscapeReplacement(ch) {
          return escapeReplacements[ch];
        };

        function escape$2(html, encode) {
          if (encode) {
            if (escapeTest.test(html)) {
              return html.replace(escapeReplace, getEscapeReplacement);
            }
          } else {
            if (escapeTestNoEncode.test(html)) {
              return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
            }
          }

          return html;
        }

        var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;

        function unescape$1(html) {
          // explicitly match decimal, hex, and named HTML entities
          return html.replace(unescapeTest, function (_, n) {
            n = n.toLowerCase();
            if (n === 'colon') return ':';

            if (n.charAt(0) === '#') {
              return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
            }

            return '';
          });
        }

        var caret = /(^|[^\[])\^/g;

        function edit$1(regex, opt) {
          regex = regex.source || regex;
          opt = opt || '';
          var obj = {
            replace: function replace(name, val) {
              val = val.source || val;
              val = val.replace(caret, '$1');
              regex = regex.replace(name, val);
              return obj;
            },
            getRegex: function getRegex() {
              return new RegExp(regex, opt);
            },
          };
          return obj;
        }

        var nonWordAndColonTest = /[^\w:]/g;
        var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

        function cleanUrl$1(sanitize, base, href) {
          if (sanitize) {
            var prot;

            try {
              prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, '').toLowerCase();
            } catch (e) {
              return null;
            }

            if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
              return null;
            }
          }

          if (base && !originIndependentUrl.test(href)) {
            href = resolveUrl(base, href);
          }

          try {
            href = encodeURI(href).replace(/%25/g, '%');
          } catch (e) {
            return null;
          }

          return href;
        }

        var baseUrls = {};
        var justDomain = /^[^:]+:\/*[^/]*$/;
        var protocol = /^([^:]+:)[\s\S]*$/;
        var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;

        function resolveUrl(base, href) {
          if (!baseUrls[' ' + base]) {
            // we can ignore everything in base after the last slash of its path component,
            // but we might need to add _that_
            // https://tools.ietf.org/html/rfc3986#section-3
            if (justDomain.test(base)) {
              baseUrls[' ' + base] = base + '/';
            } else {
              baseUrls[' ' + base] = rtrim$1(base, '/', true);
            }
          }

          base = baseUrls[' ' + base];
          var relativeBase = base.indexOf(':') === -1;

          if (href.substring(0, 2) === '//') {
            if (relativeBase) {
              return href;
            }

            return base.replace(protocol, '$1') + href;
          } else if (href.charAt(0) === '/') {
            if (relativeBase) {
              return href;
            }

            return base.replace(domain, '$1') + href;
          } else {
            return base + href;
          }
        }

        var noopTest$1 = {
          exec: function noopTest() {},
        };

        function merge$2(obj) {
          var i = 1,
            target,
            key;

          for (; i < arguments.length; i++) {
            target = arguments[i];

            for (key in target) {
              if (Object.prototype.hasOwnProperty.call(target, key)) {
                obj[key] = target[key];
              }
            }
          }

          return obj;
        }

        function splitCells$1(tableRow, count) {
          // ensure that every cell-delimiting pipe has a space
          // before it to distinguish it from an escaped pipe
          var row = tableRow.replace(/\|/g, function (match, offset, str) {
              var escaped = false,
                curr = offset;

              while (--curr >= 0 && str[curr] === '\\') {
                escaped = !escaped;
              }

              if (escaped) {
                // odd number of slashes means | is escaped
                // so we leave it alone
                return '|';
              } else {
                // add space before unescaped |
                return ' |';
              }
            }),
            cells = row.split(/ \|/);
          var i = 0;

          if (cells.length > count) {
            cells.splice(count);
          } else {
            while (cells.length < count) {
              cells.push('');
            }
          }

          for (; i < cells.length; i++) {
            // leading or trailing whitespace is ignored per the gfm spec
            cells[i] = cells[i].trim().replace(/\\\|/g, '|');
          }

          return cells;
        } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
        // /c*$/ is vulnerable to REDOS.
        // invert: Remove suffix of non-c chars instead. Default falsey.

        function rtrim$1(str, c, invert) {
          var l = str.length;

          if (l === 0) {
            return '';
          } // Length of suffix matching the invert condition.

          var suffLen = 0; // Step left until we fail to match the invert condition.

          while (suffLen < l) {
            var currChar = str.charAt(l - suffLen - 1);

            if (currChar === c && !invert) {
              suffLen++;
            } else if (currChar !== c && invert) {
              suffLen++;
            } else {
              break;
            }
          }

          return str.substr(0, l - suffLen);
        }

        function findClosingBracket$1(str, b) {
          if (str.indexOf(b[1]) === -1) {
            return -1;
          }

          var l = str.length;
          var level = 0,
            i = 0;

          for (; i < l; i++) {
            if (str[i] === '\\') {
              i++;
            } else if (str[i] === b[0]) {
              level++;
            } else if (str[i] === b[1]) {
              level--;

              if (level < 0) {
                return i;
              }
            }
          }

          return -1;
        }

        function checkSanitizeDeprecation$1(opt) {
          if (opt && opt.sanitize && !opt.silent) {
            console.warn(
              'marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options',
            );
          }
        } // copied from https://stackoverflow.com/a/5450113/806777

        function repeatString$1(pattern, count) {
          if (count < 1) {
            return '';
          }

          var result = '';

          while (count > 1) {
            if (count & 1) {
              result += pattern;
            }

            count >>= 1;
            pattern += pattern;
          }

          return result + pattern;
        }

        var helpers = {
          escape: escape$2,
          unescape: unescape$1,
          edit: edit$1,
          cleanUrl: cleanUrl$1,
          resolveUrl: resolveUrl,
          noopTest: noopTest$1,
          merge: merge$2,
          splitCells: splitCells$1,
          rtrim: rtrim$1,
          findClosingBracket: findClosingBracket$1,
          checkSanitizeDeprecation: checkSanitizeDeprecation$1,
          repeatString: repeatString$1,
        };

        var defaults$4 = defaults$5.exports.defaults;
        var rtrim = helpers.rtrim,
          splitCells = helpers.splitCells,
          _escape = helpers.escape,
          findClosingBracket = helpers.findClosingBracket;

        function outputLink(cap, link, raw) {
          var href = link.href;
          var title = link.title ? _escape(link.title) : null;
          var text = cap[1].replace(/\\([\[\]])/g, '$1');

          if (cap[0].charAt(0) !== '!') {
            return {
              type: 'link',
              raw: raw,
              href: href,
              title: title,
              text: text,
            };
          } else {
            return {
              type: 'image',
              raw: raw,
              href: href,
              title: title,
              text: _escape(text),
            };
          }
        }

        function indentCodeCompensation(raw, text) {
          var matchIndentToCode = raw.match(/^(\s+)(?:```)/);

          if (matchIndentToCode === null) {
            return text;
          }

          var indentToCode = matchIndentToCode[1];
          return text
            .split('\n')
            .map(function (node) {
              var matchIndentInNode = node.match(/^\s+/);

              if (matchIndentInNode === null) {
                return node;
              }

              var indentInNode = matchIndentInNode[0];

              if (indentInNode.length >= indentToCode.length) {
                return node.slice(indentToCode.length);
              }

              return node;
            })
            .join('\n');
        }
        /**
         * Tokenizer
         */

        var Tokenizer_1 = /*#__PURE__*/ (function () {
          function Tokenizer(options) {
            this.options = options || defaults$4;
          }

          var _proto = Tokenizer.prototype;

          _proto.space = function space(src) {
            var cap = this.rules.block.newline.exec(src);

            if (cap) {
              if (cap[0].length > 1) {
                return {
                  type: 'space',
                  raw: cap[0],
                };
              }

              return {
                raw: '\n',
              };
            }
          };

          _proto.code = function code(src) {
            var cap = this.rules.block.code.exec(src);

            if (cap) {
              var text = cap[0].replace(/^ {1,4}/gm, '');
              return {
                type: 'code',
                raw: cap[0],
                codeBlockStyle: 'indented',
                text: !this.options.pedantic ? rtrim(text, '\n') : text,
              };
            }
          };

          _proto.fences = function fences(src) {
            var cap = this.rules.block.fences.exec(src);

            if (cap) {
              var raw = cap[0];
              var text = indentCodeCompensation(raw, cap[3] || '');
              return {
                type: 'code',
                raw: raw,
                lang: cap[2] ? cap[2].trim() : cap[2],
                text: text,
              };
            }
          };

          _proto.heading = function heading(src) {
            var cap = this.rules.block.heading.exec(src);

            if (cap) {
              var text = cap[2].trim(); // remove trailing #s

              if (/#$/.test(text)) {
                var trimmed = rtrim(text, '#');

                if (this.options.pedantic) {
                  text = trimmed.trim();
                } else if (!trimmed || / $/.test(trimmed)) {
                  // CommonMark requires space before trailing #s
                  text = trimmed.trim();
                }
              }

              return {
                type: 'heading',
                raw: cap[0],
                depth: cap[1].length,
                text: text,
              };
            }
          };

          _proto.nptable = function nptable(src) {
            var cap = this.rules.block.nptable.exec(src);

            if (cap) {
              var item = {
                type: 'table',
                header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
                align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
                raw: cap[0],
              };

              if (item.header.length === item.align.length) {
                var l = item.align.length;
                var i;

                for (i = 0; i < l; i++) {
                  if (/^ *-+: *$/.test(item.align[i])) {
                    item.align[i] = 'right';
                  } else if (/^ *:-+: *$/.test(item.align[i])) {
                    item.align[i] = 'center';
                  } else if (/^ *:-+ *$/.test(item.align[i])) {
                    item.align[i] = 'left';
                  } else {
                    item.align[i] = null;
                  }
                }

                l = item.cells.length;

                for (i = 0; i < l; i++) {
                  item.cells[i] = splitCells(item.cells[i], item.header.length);
                }

                return item;
              }
            }
          };

          _proto.hr = function hr(src) {
            var cap = this.rules.block.hr.exec(src);

            if (cap) {
              return {
                type: 'hr',
                raw: cap[0],
              };
            }
          };

          _proto.blockquote = function blockquote(src) {
            var cap = this.rules.block.blockquote.exec(src);

            if (cap) {
              var text = cap[0].replace(/^ *> ?/gm, '');
              return {
                type: 'blockquote',
                raw: cap[0],
                text: text,
              };
            }
          };

          _proto.list = function list(src) {
            var cap = this.rules.block.list.exec(src);

            if (cap) {
              var raw = cap[0];
              var bull = cap[2];
              var isordered = bull.length > 1;
              var list = {
                type: 'list',
                raw: raw,
                ordered: isordered,
                start: isordered ? +bull.slice(0, -1) : '',
                loose: false,
                items: [],
              }; // Get each top-level item.

              var itemMatch = cap[0].match(this.rules.block.item);
              var next = false,
                item,
                space,
                bcurr,
                bnext,
                addBack,
                loose,
                istask,
                ischecked,
                endMatch;
              var l = itemMatch.length;
              bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);

              for (var i = 0; i < l; i++) {
                item = itemMatch[i];
                raw = item;

                if (!this.options.pedantic) {
                  // Determine if current item contains the end of the list
                  endMatch = item.match(new RegExp('\\n\\s*\\n {0,' + (bcurr[0].length - 1) + '}\\S'));

                  if (endMatch) {
                    addBack = item.length - endMatch.index + itemMatch.slice(i + 1).join('\n').length;
                    list.raw = list.raw.substring(0, list.raw.length - addBack);
                    item = item.substring(0, endMatch.index);
                    raw = item;
                    l = i + 1;
                  }
                } // Determine whether the next list item belongs here.
                // Backpedal if it does not belong in this list.

                if (i !== l - 1) {
                  bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);

                  if (!this.options.pedantic ? bnext[1].length >= bcurr[0].length || bnext[1].length > 3 : bnext[1].length > bcurr[1].length) {
                    // nested list or continuation
                    itemMatch.splice(
                      i,
                      2,
                      itemMatch[i] + (!this.options.pedantic && bnext[1].length < bcurr[0].length && !itemMatch[i].match(/\n$/) ? '' : '\n') + itemMatch[i + 1],
                    );
                    i--;
                    l--;
                    continue;
                  } else if (
                    // different bullet style
                    !this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)
                  ) {
                    addBack = itemMatch.slice(i + 1).join('\n').length;
                    list.raw = list.raw.substring(0, list.raw.length - addBack);
                    i = l - 1;
                  }

                  bcurr = bnext;
                } // Remove the list item's bullet
                // so it is seen as the next token.

                space = item.length;
                item = item.replace(/^ *([*+-]|\d+[.)]) ?/, ''); // Outdent whatever the
                // list item contains. Hacky.

                if (~item.indexOf('\n ')) {
                  space -= item.length;
                  item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');
                } // trim item newlines at end

                item = rtrim(item, '\n');

                if (i !== l - 1) {
                  raw = raw + '\n';
                } // Determine whether item is loose or not.
                // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
                // for discount behavior.

                loose = next || /\n\n(?!\s*$)/.test(raw);

                if (i !== l - 1) {
                  next = raw.slice(-2) === '\n\n';
                  if (!loose) loose = next;
                }

                if (loose) {
                  list.loose = true;
                } // Check for task list items

                if (this.options.gfm) {
                  istask = /^\[[ xX]\] /.test(item);
                  ischecked = undefined;

                  if (istask) {
                    ischecked = item[1] !== ' ';
                    item = item.replace(/^\[[ xX]\] +/, '');
                  }
                }

                list.items.push({
                  type: 'list_item',
                  raw: raw,
                  task: istask,
                  checked: ischecked,
                  loose: loose,
                  text: item,
                });
              }

              return list;
            }
          };

          _proto.html = function html(src) {
            var cap = this.rules.block.html.exec(src);

            if (cap) {
              return {
                type: this.options.sanitize ? 'paragraph' : 'html',
                raw: cap[0],
                pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
                text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0])) : cap[0],
              };
            }
          };

          _proto.def = function def(src) {
            var cap = this.rules.block.def.exec(src);

            if (cap) {
              if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
              var tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
              return {
                type: 'def',
                tag: tag,
                raw: cap[0],
                href: cap[2],
                title: cap[3],
              };
            }
          };

          _proto.table = function table(src) {
            var cap = this.rules.block.table.exec(src);

            if (cap) {
              var item = {
                type: 'table',
                header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
                align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
                cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : [],
              };

              if (item.header.length === item.align.length) {
                item.raw = cap[0];
                var l = item.align.length;
                var i;

                for (i = 0; i < l; i++) {
                  if (/^ *-+: *$/.test(item.align[i])) {
                    item.align[i] = 'right';
                  } else if (/^ *:-+: *$/.test(item.align[i])) {
                    item.align[i] = 'center';
                  } else if (/^ *:-+ *$/.test(item.align[i])) {
                    item.align[i] = 'left';
                  } else {
                    item.align[i] = null;
                  }
                }

                l = item.cells.length;

                for (i = 0; i < l; i++) {
                  item.cells[i] = splitCells(item.cells[i].replace(/^ *\| *| *\| *$/g, ''), item.header.length);
                }

                return item;
              }
            }
          };

          _proto.lheading = function lheading(src) {
            var cap = this.rules.block.lheading.exec(src);

            if (cap) {
              return {
                type: 'heading',
                raw: cap[0],
                depth: cap[2].charAt(0) === '=' ? 1 : 2,
                text: cap[1],
              };
            }
          };

          _proto.paragraph = function paragraph(src) {
            var cap = this.rules.block.paragraph.exec(src);

            if (cap) {
              return {
                type: 'paragraph',
                raw: cap[0],
                text: cap[1].charAt(cap[1].length - 1) === '\n' ? cap[1].slice(0, -1) : cap[1],
              };
            }
          };

          _proto.text = function text(src) {
            var cap = this.rules.block.text.exec(src);

            if (cap) {
              return {
                type: 'text',
                raw: cap[0],
                text: cap[0],
              };
            }
          };

          _proto.escape = function escape(src) {
            var cap = this.rules.inline.escape.exec(src);

            if (cap) {
              return {
                type: 'escape',
                raw: cap[0],
                text: _escape(cap[1]),
              };
            }
          };

          _proto.tag = function tag(src, inLink, inRawBlock) {
            var cap = this.rules.inline.tag.exec(src);

            if (cap) {
              if (!inLink && /^<a /i.test(cap[0])) {
                inLink = true;
              } else if (inLink && /^<\/a>/i.test(cap[0])) {
                inLink = false;
              }

              if (!inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                inRawBlock = true;
              } else if (inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
                inRawBlock = false;
              }

              return {
                type: this.options.sanitize ? 'text' : 'html',
                raw: cap[0],
                inLink: inLink,
                inRawBlock: inRawBlock,
                text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0])) : cap[0],
              };
            }
          };

          _proto.link = function link(src) {
            var cap = this.rules.inline.link.exec(src);

            if (cap) {
              var trimmedUrl = cap[2].trim();

              if (!this.options.pedantic && /^</.test(trimmedUrl)) {
                // commonmark requires matching angle brackets
                if (!/>$/.test(trimmedUrl)) {
                  return;
                } // ending angle bracket cannot be escaped

                var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\');

                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
                  return;
                }
              } else {
                // find closing parenthesis
                var lastParenIndex = findClosingBracket(cap[2], '()');

                if (lastParenIndex > -1) {
                  var start = cap[0].indexOf('!') === 0 ? 5 : 4;
                  var linkLen = start + cap[1].length + lastParenIndex;
                  cap[2] = cap[2].substring(0, lastParenIndex);
                  cap[0] = cap[0].substring(0, linkLen).trim();
                  cap[3] = '';
                }
              }

              var href = cap[2];
              var title = '';

              if (this.options.pedantic) {
                // split pedantic href and title
                var link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

                if (link) {
                  href = link[1];
                  title = link[3];
                }
              } else {
                title = cap[3] ? cap[3].slice(1, -1) : '';
              }

              href = href.trim();

              if (/^</.test(href)) {
                if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
                  // pedantic allows starting angle bracket without ending angle bracket
                  href = href.slice(1);
                } else {
                  href = href.slice(1, -1);
                }
              }

              return outputLink(
                cap,
                {
                  href: href ? href.replace(this.rules.inline._escapes, '$1') : href,
                  title: title ? title.replace(this.rules.inline._escapes, '$1') : title,
                },
                cap[0],
              );
            }
          };

          _proto.reflink = function reflink(src, links) {
            var cap;

            if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
              var link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
              link = links[link.toLowerCase()];

              if (!link || !link.href) {
                var text = cap[0].charAt(0);
                return {
                  type: 'text',
                  raw: text,
                  text: text,
                };
              }

              return outputLink(cap, link, cap[0]);
            }
          };

          _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
            if (prevChar === void 0) {
              prevChar = '';
            }

            var match = this.rules.inline.emStrong.lDelim.exec(src);
            if (!match) return; // _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well

            if (
              match[3] &&
              prevChar.match(
                /(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/,
              )
            )
              return;
            var nextChar = match[1] || match[2] || '';

            if (!nextChar || (nextChar && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {
              var lLength = match[0].length - 1;
              var rDelim,
                rLength,
                delimTotal = lLength,
                midDelimTotal = 0;
              var endReg = match[0][0] === '*' ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
              endReg.lastIndex = 0; // Clip maskedSrc to same section of string as src (move to lexer?)

              maskedSrc = maskedSrc.slice(-1 * src.length + lLength);

              while ((match = endReg.exec(maskedSrc)) != null) {
                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
                if (!rDelim) continue; // skip single * in __abc*abc__

                rLength = rDelim.length;

                if (match[3] || match[4]) {
                  // found another Left Delim
                  delimTotal += rLength;
                  continue;
                } else if (match[5] || match[6]) {
                  // either Left or Right Delim
                  if (lLength % 3 && !((lLength + rLength) % 3)) {
                    midDelimTotal += rLength;
                    continue; // CommonMark Emphasis Rules 9-10
                  }
                }

                delimTotal -= rLength;
                if (delimTotal > 0) continue; // Haven't found enough closing delimiters
                // Remove extra characters. *a*** -> *a*

                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal); // Create `em` if smallest delimiter has odd char count. *a***

                if (Math.min(lLength, rLength) % 2) {
                  return {
                    type: 'em',
                    raw: src.slice(0, lLength + match.index + rLength + 1),
                    text: src.slice(1, lLength + match.index + rLength),
                  };
                } // Create 'strong' if smallest delimiter has even char count. **a***

                return {
                  type: 'strong',
                  raw: src.slice(0, lLength + match.index + rLength + 1),
                  text: src.slice(2, lLength + match.index + rLength - 1),
                };
              }
            }
          };

          _proto.codespan = function codespan(src) {
            var cap = this.rules.inline.code.exec(src);

            if (cap) {
              var text = cap[2].replace(/\n/g, ' ');
              var hasNonSpaceChars = /[^ ]/.test(text);
              var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);

              if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
                text = text.substring(1, text.length - 1);
              }

              text = _escape(text, true);
              return {
                type: 'codespan',
                raw: cap[0],
                text: text,
              };
            }
          };

          _proto.br = function br(src) {
            var cap = this.rules.inline.br.exec(src);

            if (cap) {
              return {
                type: 'br',
                raw: cap[0],
              };
            }
          };

          _proto.del = function del(src) {
            var cap = this.rules.inline.del.exec(src);

            if (cap) {
              return {
                type: 'del',
                raw: cap[0],
                text: cap[2],
              };
            }
          };

          _proto.autolink = function autolink(src, mangle) {
            var cap = this.rules.inline.autolink.exec(src);

            if (cap) {
              var text, href;

              if (cap[2] === '@') {
                text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);
                href = 'mailto:' + text;
              } else {
                text = _escape(cap[1]);
                href = text;
              }

              return {
                type: 'link',
                raw: cap[0],
                text: text,
                href: href,
                tokens: [
                  {
                    type: 'text',
                    raw: text,
                    text: text,
                  },
                ],
              };
            }
          };

          _proto.url = function url(src, mangle) {
            var cap;

            if ((cap = this.rules.inline.url.exec(src))) {
              var text, href;

              if (cap[2] === '@') {
                text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);
                href = 'mailto:' + text;
              } else {
                // do extended autolink path validation
                var prevCapZero;

                do {
                  prevCapZero = cap[0];
                  cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
                } while (prevCapZero !== cap[0]);

                text = _escape(cap[0]);

                if (cap[1] === 'www.') {
                  href = 'http://' + text;
                } else {
                  href = text;
                }
              }

              return {
                type: 'link',
                raw: cap[0],
                text: text,
                href: href,
                tokens: [
                  {
                    type: 'text',
                    raw: text,
                    text: text,
                  },
                ],
              };
            }
          };

          _proto.inlineText = function inlineText(src, inRawBlock, smartypants) {
            var cap = this.rules.inline.text.exec(src);

            if (cap) {
              var text;

              if (inRawBlock) {
                text = this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0])) : cap[0];
              } else {
                text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);
              }

              return {
                type: 'text',
                raw: cap[0],
                text: text,
              };
            }
          };

          return Tokenizer;
        })();

        var noopTest = helpers.noopTest,
          edit = helpers.edit,
          merge$1 = helpers.merge;
        /**
         * Block-Level Grammar
         */

        var block$1 = {
          newline: /^(?: *(?:\n|$))+/,
          code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
          fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
          hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
          heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
          blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
          list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?! {0,3}bull )\n*|\s*$)/,
          html:
            '^ {0,3}(?:' + // optional indentation
            '<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' + // (1)
            '|comment[^\\n]*(\\n+|$)' + // (2)
            '|<\\?[\\s\\S]*?(?:\\?>\\n*|$)' + // (3)
            '|<![A-Z][\\s\\S]*?(?:>\\n*|$)' + // (4)
            '|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)' + // (5)
            '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)' + // (6)
            '|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' + // (7) open tag
            '|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)' + // (7) closing tag
            ')',
          def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
          nptable: noopTest,
          table: noopTest,
          lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
          // regex template, placeholders will be replaced according to different paragraph
          // interruption rules of commonmark and the original markdown spec:
          _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
          text: /^[^\n]+/,
        };
        block$1._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
        block$1._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
        block$1.def = edit(block$1.def).replace('label', block$1._label).replace('title', block$1._title).getRegex();
        block$1.bullet = /(?:[*+-]|\d{1,9}[.)])/;
        block$1.item = /^( *)(bull) ?[^\n]*(?:\n(?! *bull ?)[^\n]*)*/;
        block$1.item = edit(block$1.item, 'gm').replace(/bull/g, block$1.bullet).getRegex();
        block$1.listItemStart = edit(/^( *)(bull) */)
          .replace('bull', block$1.bullet)
          .getRegex();
        block$1.list = edit(block$1.list)
          .replace(/bull/g, block$1.bullet)
          .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
          .replace('def', '\\n+(?=' + block$1.def.source + ')')
          .getRegex();
        block$1._tag =
          'address|article|aside|base|basefont|blockquote|body|caption' +
          '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' +
          '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' +
          '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' +
          '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' +
          '|track|ul';
        block$1._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
        block$1.html = edit(block$1.html, 'i')
          .replace('comment', block$1._comment)
          .replace('tag', block$1._tag)
          .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
          .getRegex();
        block$1.paragraph = edit(block$1._paragraph)
          .replace('hr', block$1.hr)
          .replace('heading', ' {0,3}#{1,6} ')
          .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
          .replace('blockquote', ' {0,3}>')
          .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
          .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
          .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
          .replace('tag', block$1._tag) // pars can be interrupted by type (6) html blocks
          .getRegex();
        block$1.blockquote = edit(block$1.blockquote).replace('paragraph', block$1.paragraph).getRegex();
        /**
         * Normal Block Grammar
         */

        block$1.normal = merge$1({}, block$1);
        /**
         * GFM Block Grammar
         */

        block$1.gfm = merge$1({}, block$1.normal, {
          nptable:
            '^ *([^|\\n ].*\\|.*)\\n' + // Header
            ' {0,3}([-:]+ *\\|[-| :]*)' + // Align
            '(?:\\n((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)',
          // Cells
          table:
            '^ *\\|(.+)\\n' + // Header
            ' {0,3}\\|?( *[-:]+[-| :]*)' + // Align
            '(?:\\n *((?:(?!\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)', // Cells
        });
        block$1.gfm.nptable = edit(block$1.gfm.nptable)
          .replace('hr', block$1.hr)
          .replace('heading', ' {0,3}#{1,6} ')
          .replace('blockquote', ' {0,3}>')
          .replace('code', ' {4}[^\\n]')
          .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
          .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
          .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
          .replace('tag', block$1._tag) // tables can be interrupted by type (6) html blocks
          .getRegex();
        block$1.gfm.table = edit(block$1.gfm.table)
          .replace('hr', block$1.hr)
          .replace('heading', ' {0,3}#{1,6} ')
          .replace('blockquote', ' {0,3}>')
          .replace('code', ' {4}[^\\n]')
          .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n')
          .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
          .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)')
          .replace('tag', block$1._tag) // tables can be interrupted by type (6) html blocks
          .getRegex();
        /**
         * Pedantic grammar (original John Gruber's loose markdown specification)
         */

        block$1.pedantic = merge$1({}, block$1.normal, {
          html: edit(
            '^ *(?:comment *(?:\\n|\\s*$)' +
              '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' + // closed tag
              '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))',
          )
            .replace('comment', block$1._comment)
            .replace(
              /tag/g,
              '(?!(?:' +
                'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' +
                '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' +
                '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b',
            )
            .getRegex(),
          def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
          heading: /^(#{1,6})(.*)(?:\n+|$)/,
          fences: noopTest,
          // fences not supported
          paragraph: edit(block$1.normal._paragraph)
            .replace('hr', block$1.hr)
            .replace('heading', ' *#{1,6} *[^\n]')
            .replace('lheading', block$1.lheading)
            .replace('blockquote', ' {0,3}>')
            .replace('|fences', '')
            .replace('|list', '')
            .replace('|html', '')
            .getRegex(),
        });
        /**
         * Inline-Level Grammar
         */

        var inline$1 = {
          escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
          autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
          url: noopTest,
          tag:
            '^comment' +
            '|^</[a-zA-Z][\\w:-]*\\s*>' + // self-closing tag
            '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' + // open tag
            '|^<\\?[\\s\\S]*?\\?>' + // processing instruction, e.g. <?php ?>
            '|^<![a-zA-Z]+\\s[\\s\\S]*?>' + // declaration, e.g. <!DOCTYPE html>
            '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>',
          // CDATA section
          link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
          reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
          nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
          reflinkSearch: 'reflink|nolink(?!\\()',
          emStrong: {
            lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
            //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
            //        () Skip other delimiter (1) #***                   (2) a***#, a***                   (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
            rDelimAst:
              /\_\_[^_*]*?\*[^_*]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
            rDelimUnd:
              /\*\*[^_*]*?\_[^_*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/, // ^- Not allowed for _
          },
          code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
          br: /^( {2,}|\\)\n(?!\s*$)/,
          del: noopTest,
          text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
          punctuation: /^([\spunctuation])/,
        }; // list of punctuation marks from CommonMark spec
        // without * and _ to handle the different emphasis markers * and _

        inline$1._punctuation = '!"#$%&\'()+\\-.,/:;<=>?@\\[\\]`^{|}~';
        inline$1.punctuation = edit(inline$1.punctuation)
          .replace(/punctuation/g, inline$1._punctuation)
          .getRegex(); // sequences em should skip over [title](link), `code`, <html>

        inline$1.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
        inline$1.escapedEmSt = /\\\*|\\_/g;
        inline$1._comment = edit(block$1._comment).replace('(?:-->|$)', '-->').getRegex();
        inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim).replace(/punct/g, inline$1._punctuation).getRegex();
        inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, 'g').replace(/punct/g, inline$1._punctuation).getRegex();
        inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, 'g').replace(/punct/g, inline$1._punctuation).getRegex();
        inline$1._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
        inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
        inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
        inline$1.autolink = edit(inline$1.autolink).replace('scheme', inline$1._scheme).replace('email', inline$1._email).getRegex();
        inline$1._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
        inline$1.tag = edit(inline$1.tag).replace('comment', inline$1._comment).replace('attribute', inline$1._attribute).getRegex();
        inline$1._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
        inline$1._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
        inline$1._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
        inline$1.link = edit(inline$1.link).replace('label', inline$1._label).replace('href', inline$1._href).replace('title', inline$1._title).getRegex();
        inline$1.reflink = edit(inline$1.reflink).replace('label', inline$1._label).getRegex();
        inline$1.reflinkSearch = edit(inline$1.reflinkSearch, 'g').replace('reflink', inline$1.reflink).replace('nolink', inline$1.nolink).getRegex();
        /**
         * Normal Inline Grammar
         */

        inline$1.normal = merge$1({}, inline$1);
        /**
         * Pedantic Inline Grammar
         */

        inline$1.pedantic = merge$1({}, inline$1.normal, {
          strong: {
            start: /^__|\*\*/,
            middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
            endAst: /\*\*(?!\*)/g,
            endUnd: /__(?!_)/g,
          },
          em: {
            start: /^_|\*/,
            middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
            endAst: /\*(?!\*)/g,
            endUnd: /_(?!_)/g,
          },
          link: edit(/^!?\[(label)\]\((.*?)\)/)
            .replace('label', inline$1._label)
            .getRegex(),
          reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
            .replace('label', inline$1._label)
            .getRegex(),
        });
        /**
         * GFM Inline Grammar
         */

        inline$1.gfm = merge$1({}, inline$1.normal, {
          escape: edit(inline$1.escape).replace('])', '~|])').getRegex(),
          _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
          url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
          _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
          del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
          text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
        });
        inline$1.gfm.url = edit(inline$1.gfm.url, 'i').replace('email', inline$1.gfm._extended_email).getRegex();
        /**
         * GFM + Line Breaks Inline Grammar
         */

        inline$1.breaks = merge$1({}, inline$1.gfm, {
          br: edit(inline$1.br).replace('{2,}', '*').getRegex(),
          text: edit(inline$1.gfm.text)
            .replace('\\b_', '\\b_| {2,}\\n')
            .replace(/\{2,\}/g, '*')
            .getRegex(),
        });
        var rules = {
          block: block$1,
          inline: inline$1,
        };

        var Tokenizer$1 = Tokenizer_1;
        var defaults$3 = defaults$5.exports.defaults;
        var block = rules.block,
          inline = rules.inline;
        var repeatString = helpers.repeatString;
        /**
         * smartypants text replacement
         */

        function smartypants(text) {
          return text // em-dashes
            .replace(/---/g, '\u2014') // en-dashes
            .replace(/--/g, '\u2013') // opening singles
            .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018') // closing singles & apostrophes
            .replace(/'/g, '\u2019') // opening doubles
            .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201C') // closing doubles
            .replace(/"/g, '\u201D') // ellipses
            .replace(/\.{3}/g, '\u2026');
        }
        /**
         * mangle email addresses
         */

        function mangle(text) {
          var out = '',
            i,
            ch;
          var l = text.length;

          for (i = 0; i < l; i++) {
            ch = text.charCodeAt(i);

            if (Math.random() > 0.5) {
              ch = 'x' + ch.toString(16);
            }

            out += '&#' + ch + ';';
          }

          return out;
        }
        /**
         * Block Lexer
         */

        var Lexer_1 = /*#__PURE__*/ (function () {
          function Lexer(options) {
            this.tokens = [];
            this.tokens.links = Object.create(null);
            this.options = options || defaults$3;
            this.options.tokenizer = this.options.tokenizer || new Tokenizer$1();
            this.tokenizer = this.options.tokenizer;
            this.tokenizer.options = this.options;
            var rules = {
              block: block.normal,
              inline: inline.normal,
            };

            if (this.options.pedantic) {
              rules.block = block.pedantic;
              rules.inline = inline.pedantic;
            } else if (this.options.gfm) {
              rules.block = block.gfm;

              if (this.options.breaks) {
                rules.inline = inline.breaks;
              } else {
                rules.inline = inline.gfm;
              }
            }

            this.tokenizer.rules = rules;
          }
          /**
           * Expose Rules
           */

          /**
           * Static Lex Method
           */
          Lexer.lex = function lex(src, options) {
            var lexer = new Lexer(options);
            return lexer.lex(src);
          };
          /**
           * Static Lex Inline Method
           */

          Lexer.lexInline = function lexInline(src, options) {
            var lexer = new Lexer(options);
            return lexer.inlineTokens(src);
          };
          /**
           * Preprocessing
           */

          var _proto = Lexer.prototype;

          _proto.lex = function lex(src) {
            src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ');
            this.blockTokens(src, this.tokens, true);
            this.inline(this.tokens);
            return this.tokens;
          };
          /**
           * Lexing
           */

          _proto.blockTokens = function blockTokens(src, tokens, top) {
            var _this = this;

            if (tokens === void 0) {
              tokens = [];
            }

            if (top === void 0) {
              top = true;
            }

            if (this.options.pedantic) {
              src = src.replace(/^ +$/gm, '');
            }

            var token, i, l, lastToken, cutSrc, lastParagraphClipped;

            while (src) {
              if (
                this.options.extensions &&
                this.options.extensions.block &&
                this.options.extensions.block.some(function (extTokenizer) {
                  if ((token = extTokenizer.call(_this, src, tokens))) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return true;
                  }

                  return false;
                })
              ) {
                continue;
              } // newline

              if ((token = this.tokenizer.space(src))) {
                src = src.substring(token.raw.length);

                if (token.type) {
                  tokens.push(token);
                }

                continue;
              } // code

              if ((token = this.tokenizer.code(src))) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.

                if (lastToken && lastToken.type === 'paragraph') {
                  lastToken.raw += '\n' + token.raw;
                  lastToken.text += '\n' + token.text;
                } else {
                  tokens.push(token);
                }

                continue;
              } // fences

              if ((token = this.tokenizer.fences(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // heading

              if ((token = this.tokenizer.heading(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // table no leading pipe (gfm)

              if ((token = this.tokenizer.nptable(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // hr

              if ((token = this.tokenizer.hr(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // blockquote

              if ((token = this.tokenizer.blockquote(src))) {
                src = src.substring(token.raw.length);
                token.tokens = this.blockTokens(token.text, [], top);
                tokens.push(token);
                continue;
              } // list

              if ((token = this.tokenizer.list(src))) {
                src = src.substring(token.raw.length);
                l = token.items.length;

                for (i = 0; i < l; i++) {
                  token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);
                }

                tokens.push(token);
                continue;
              } // html

              if ((token = this.tokenizer.html(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // def

              if (top && (token = this.tokenizer.def(src))) {
                src = src.substring(token.raw.length);

                if (!this.tokens.links[token.tag]) {
                  this.tokens.links[token.tag] = {
                    href: token.href,
                    title: token.title,
                  };
                }

                continue;
              } // table (gfm)

              if ((token = this.tokenizer.table(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // lheading

              if ((token = this.tokenizer.lheading(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // top-level paragraph
              // prevent paragraph consuming extensions by clipping 'src' to extension start

              cutSrc = src;

              if (this.options.extensions && this.options.extensions.startBlock) {
                (function () {
                  var startIndex = Infinity;
                  var tempSrc = src.slice(1);
                  var tempStart = void 0;

                  _this.options.extensions.startBlock.forEach(function (getStartIndex) {
                    tempStart = getStartIndex.call(this, tempSrc);

                    if (typeof tempStart === 'number' && tempStart >= 0) {
                      startIndex = Math.min(startIndex, tempStart);
                    }
                  });

                  if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                  }
                })();
              }

              if (top && (token = this.tokenizer.paragraph(cutSrc))) {
                lastToken = tokens[tokens.length - 1];

                if (lastParagraphClipped && lastToken.type === 'paragraph') {
                  lastToken.raw += '\n' + token.raw;
                  lastToken.text += '\n' + token.text;
                } else {
                  tokens.push(token);
                }

                lastParagraphClipped = cutSrc.length !== src.length;
                src = src.substring(token.raw.length);
                continue;
              } // text

              if ((token = this.tokenizer.text(src))) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];

                if (lastToken && lastToken.type === 'text') {
                  lastToken.raw += '\n' + token.raw;
                  lastToken.text += '\n' + token.text;
                } else {
                  tokens.push(token);
                }

                continue;
              }

              if (src) {
                var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

                if (this.options.silent) {
                  console.error(errMsg);
                  break;
                } else {
                  throw new Error(errMsg);
                }
              }
            }

            return tokens;
          };

          _proto.inline = function inline(tokens) {
            var i, j, k, l2, row, token;
            var l = tokens.length;

            for (i = 0; i < l; i++) {
              token = tokens[i];

              switch (token.type) {
                case 'paragraph':
                case 'text':
                case 'heading': {
                  token.tokens = [];
                  this.inlineTokens(token.text, token.tokens);
                  break;
                }

                case 'table': {
                  token.tokens = {
                    header: [],
                    cells: [],
                  }; // header

                  l2 = token.header.length;

                  for (j = 0; j < l2; j++) {
                    token.tokens.header[j] = [];
                    this.inlineTokens(token.header[j], token.tokens.header[j]);
                  } // cells

                  l2 = token.cells.length;

                  for (j = 0; j < l2; j++) {
                    row = token.cells[j];
                    token.tokens.cells[j] = [];

                    for (k = 0; k < row.length; k++) {
                      token.tokens.cells[j][k] = [];
                      this.inlineTokens(row[k], token.tokens.cells[j][k]);
                    }
                  }

                  break;
                }

                case 'blockquote': {
                  this.inline(token.tokens);
                  break;
                }

                case 'list': {
                  l2 = token.items.length;

                  for (j = 0; j < l2; j++) {
                    this.inline(token.items[j].tokens);
                  }

                  break;
                }
              }
            }

            return tokens;
          };
          /**
           * Lexing/Compiling
           */

          _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock) {
            var _this2 = this;

            if (tokens === void 0) {
              tokens = [];
            }

            if (inLink === void 0) {
              inLink = false;
            }

            if (inRawBlock === void 0) {
              inRawBlock = false;
            }

            var token, lastToken, cutSrc; // String with links masked to avoid interference with em and strong

            var maskedSrc = src;
            var match;
            var keepPrevChar, prevChar; // Mask out reflinks

            if (this.tokens.links) {
              var links = Object.keys(this.tokens.links);

              if (links.length > 0) {
                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
                  if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {
                    maskedSrc =
                      maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
                  }
                }
              }
            } // Mask out other blocks

            while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
            } // Mask out escaped em & strong delimiters

            while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
              maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
            }

            while (src) {
              if (!keepPrevChar) {
                prevChar = '';
              }

              keepPrevChar = false; // extensions

              if (
                this.options.extensions &&
                this.options.extensions.inline &&
                this.options.extensions.inline.some(function (extTokenizer) {
                  if ((token = extTokenizer.call(_this2, src, tokens))) {
                    src = src.substring(token.raw.length);
                    tokens.push(token);
                    return true;
                  }

                  return false;
                })
              ) {
                continue;
              } // escape

              if ((token = this.tokenizer.escape(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // tag

              if ((token = this.tokenizer.tag(src, inLink, inRawBlock))) {
                src = src.substring(token.raw.length);
                inLink = token.inLink;
                inRawBlock = token.inRawBlock;
                lastToken = tokens[tokens.length - 1];

                if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                  lastToken.raw += token.raw;
                  lastToken.text += token.text;
                } else {
                  tokens.push(token);
                }

                continue;
              } // link

              if ((token = this.tokenizer.link(src))) {
                src = src.substring(token.raw.length);

                if (token.type === 'link') {
                  token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
                }

                tokens.push(token);
                continue;
              } // reflink, nolink

              if ((token = this.tokenizer.reflink(src, this.tokens.links))) {
                src = src.substring(token.raw.length);
                lastToken = tokens[tokens.length - 1];

                if (token.type === 'link') {
                  token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);
                  tokens.push(token);
                } else if (lastToken && token.type === 'text' && lastToken.type === 'text') {
                  lastToken.raw += token.raw;
                  lastToken.text += token.text;
                } else {
                  tokens.push(token);
                }

                continue;
              } // em & strong

              if ((token = this.tokenizer.emStrong(src, maskedSrc, prevChar))) {
                src = src.substring(token.raw.length);
                token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
                tokens.push(token);
                continue;
              } // code

              if ((token = this.tokenizer.codespan(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // br

              if ((token = this.tokenizer.br(src))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // del (gfm)

              if ((token = this.tokenizer.del(src))) {
                src = src.substring(token.raw.length);
                token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);
                tokens.push(token);
                continue;
              } // autolink

              if ((token = this.tokenizer.autolink(src, mangle))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // url (gfm)

              if (!inLink && (token = this.tokenizer.url(src, mangle))) {
                src = src.substring(token.raw.length);
                tokens.push(token);
                continue;
              } // text
              // prevent inlineText consuming extensions by clipping 'src' to extension start

              cutSrc = src;

              if (this.options.extensions && this.options.extensions.startInline) {
                (function () {
                  var startIndex = Infinity;
                  var tempSrc = src.slice(1);
                  var tempStart = void 0;

                  _this2.options.extensions.startInline.forEach(function (getStartIndex) {
                    tempStart = getStartIndex.call(this, tempSrc);

                    if (typeof tempStart === 'number' && tempStart >= 0) {
                      startIndex = Math.min(startIndex, tempStart);
                    }
                  });

                  if (startIndex < Infinity && startIndex >= 0) {
                    cutSrc = src.substring(0, startIndex + 1);
                  }
                })();
              }

              if ((token = this.tokenizer.inlineText(cutSrc, inRawBlock, smartypants))) {
                src = src.substring(token.raw.length);

                if (token.raw.slice(-1) !== '_') {
                  // Track prevChar before string of ____ started
                  prevChar = token.raw.slice(-1);
                }

                keepPrevChar = true;
                lastToken = tokens[tokens.length - 1];

                if (lastToken && lastToken.type === 'text') {
                  lastToken.raw += token.raw;
                  lastToken.text += token.text;
                } else {
                  tokens.push(token);
                }

                continue;
              }

              if (src) {
                var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);

                if (this.options.silent) {
                  console.error(errMsg);
                  break;
                } else {
                  throw new Error(errMsg);
                }
              }
            }

            return tokens;
          };

          _createClass(Lexer, null, [
            {
              key: 'rules',
              get: function get() {
                return {
                  block: block,
                  inline: inline,
                };
              },
            },
          ]);

          return Lexer;
        })();

        var defaults$2 = defaults$5.exports.defaults;
        var cleanUrl = helpers.cleanUrl,
          escape$1 = helpers.escape;
        /**
         * Renderer
         */

        var Renderer_1 = /*#__PURE__*/ (function () {
          function Renderer(options) {
            this.options = options || defaults$2;
          }

          var _proto = Renderer.prototype;

          _proto.code = function code(_code, infostring, escaped) {
            var lang = (infostring || '').match(/\S*/)[0];

            if (this.options.highlight) {
              var out = this.options.highlight(_code, lang);

              if (out != null && out !== _code) {
                escaped = true;
                _code = out;
              }
            }

            _code = _code.replace(/\n$/, '') + '\n';

            if (!lang) {
              return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
            }

            return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\n';
          };

          _proto.blockquote = function blockquote(quote) {
            return '<blockquote>\n' + quote + '</blockquote>\n';
          };

          _proto.html = function html(_html) {
            return _html;
          };

          _proto.heading = function heading(text, level, raw, slugger) {
            if (this.options.headerIds) {
              return '<h' + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + '</h' + level + '>\n';
            } // ignore IDs

            return '<h' + level + '>' + text + '</h' + level + '>\n';
          };

          _proto.hr = function hr() {
            return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
          };

          _proto.list = function list(body, ordered, start) {
            var type = ordered ? 'ol' : 'ul',
              startatt = ordered && start !== 1 ? ' start="' + start + '"' : '';
            return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
          };

          _proto.listitem = function listitem(text) {
            return '<li>' + text + '</li>\n';
          };

          _proto.checkbox = function checkbox(checked) {
            return '<input ' + (checked ? 'checked="" ' : '') + 'disabled="" type="checkbox"' + (this.options.xhtml ? ' /' : '') + '> ';
          };

          _proto.paragraph = function paragraph(text) {
            return '<p>' + text + '</p>\n';
          };

          _proto.table = function table(header, body) {
            if (body) body = '<tbody>' + body + '</tbody>';
            return '<table>\n' + '<thead>\n' + header + '</thead>\n' + body + '</table>\n';
          };

          _proto.tablerow = function tablerow(content) {
            return '<tr>\n' + content + '</tr>\n';
          };

          _proto.tablecell = function tablecell(content, flags) {
            var type = flags.header ? 'th' : 'td';
            var tag = flags.align ? '<' + type + ' align="' + flags.align + '">' : '<' + type + '>';
            return tag + content + '</' + type + '>\n';
          }; // span level renderer

          _proto.strong = function strong(text) {
            return '<strong>' + text + '</strong>';
          };

          _proto.em = function em(text) {
            return '<em>' + text + '</em>';
          };

          _proto.codespan = function codespan(text) {
            return '<code>' + text + '</code>';
          };

          _proto.br = function br() {
            return this.options.xhtml ? '<br/>' : '<br>';
          };

          _proto.del = function del(text) {
            return '<del>' + text + '</del>';
          };

          _proto.link = function link(href, title, text) {
            href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

            if (href === null) {
              return text;
            }

            var out = '<a href="' + escape$1(href) + '"';

            if (title) {
              out += ' title="' + title + '"';
            }

            out += '>' + text + '</a>';
            return out;
          };

          _proto.image = function image(href, title, text) {
            href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);

            if (href === null) {
              return text;
            }

            var out = '<img src="' + href + '" alt="' + text + '"';

            if (title) {
              out += ' title="' + title + '"';
            }

            out += this.options.xhtml ? '/>' : '>';
            return out;
          };

          _proto.text = function text(_text) {
            return _text;
          };

          return Renderer;
        })();

        /**
         * TextRenderer
         * returns only the textual part of the token
         */

        var TextRenderer_1 = /*#__PURE__*/ (function () {
          function TextRenderer() {}

          var _proto = TextRenderer.prototype;

          // no need for block level renderers
          _proto.strong = function strong(text) {
            return text;
          };

          _proto.em = function em(text) {
            return text;
          };

          _proto.codespan = function codespan(text) {
            return text;
          };

          _proto.del = function del(text) {
            return text;
          };

          _proto.html = function html(text) {
            return text;
          };

          _proto.text = function text(_text) {
            return _text;
          };

          _proto.link = function link(href, title, text) {
            return '' + text;
          };

          _proto.image = function image(href, title, text) {
            return '' + text;
          };

          _proto.br = function br() {
            return '';
          };

          return TextRenderer;
        })();

        /**
         * Slugger generates header id
         */

        var Slugger_1 = /*#__PURE__*/ (function () {
          function Slugger() {
            this.seen = {};
          }

          var _proto = Slugger.prototype;

          _proto.serialize = function serialize(value) {
            return value
              .toLowerCase()
              .trim() // remove html tags
              .replace(/<[!\/a-z].*?>/gi, '') // remove unwanted chars
              .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
              .replace(/\s/g, '-');
          };
          /**
           * Finds the next safe (unique) slug to use
           */

          _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
            var slug = originalSlug;
            var occurenceAccumulator = 0;

            if (this.seen.hasOwnProperty(slug)) {
              occurenceAccumulator = this.seen[originalSlug];

              do {
                occurenceAccumulator++;
                slug = originalSlug + '-' + occurenceAccumulator;
              } while (this.seen.hasOwnProperty(slug));
            }

            if (!isDryRun) {
              this.seen[originalSlug] = occurenceAccumulator;
              this.seen[slug] = 0;
            }

            return slug;
          };
          /**
           * Convert string to unique id
           * @param {object} options
           * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.
           */

          _proto.slug = function slug(value, options) {
            if (options === void 0) {
              options = {};
            }

            var slug = this.serialize(value);
            return this.getNextSafeSlug(slug, options.dryrun);
          };

          return Slugger;
        })();

        var Renderer$1 = Renderer_1;
        var TextRenderer$1 = TextRenderer_1;
        var Slugger$1 = Slugger_1;
        var defaults$1 = defaults$5.exports.defaults;
        var unescape = helpers.unescape;
        /**
         * Parsing & Compiling
         */

        var Parser_1 = /*#__PURE__*/ (function () {
          function Parser(options) {
            this.options = options || defaults$1;
            this.options.renderer = this.options.renderer || new Renderer$1();
            this.renderer = this.options.renderer;
            this.renderer.options = this.options;
            this.textRenderer = new TextRenderer$1();
            this.slugger = new Slugger$1();
          }
          /**
           * Static Parse Method
           */

          Parser.parse = function parse(tokens, options) {
            var parser = new Parser(options);
            return parser.parse(tokens);
          };
          /**
           * Static Parse Inline Method
           */

          Parser.parseInline = function parseInline(tokens, options) {
            var parser = new Parser(options);
            return parser.parseInline(tokens);
          };
          /**
           * Parse Loop
           */

          var _proto = Parser.prototype;

          _proto.parse = function parse(tokens, top) {
            if (top === void 0) {
              top = true;
            }

            var out = '',
              i,
              j,
              k,
              l2,
              l3,
              row,
              cell,
              header,
              body,
              token,
              ordered,
              start,
              loose,
              itemBody,
              item,
              checked,
              task,
              checkbox,
              ret;
            var l = tokens.length;

            for (i = 0; i < l; i++) {
              token = tokens[i]; // Run any renderer extensions

              if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
                ret = this.options.extensions.renderers[token.type].call(this, token);

                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(token.type)) {
                  out += ret || '';
                  continue;
                }
              }

              switch (token.type) {
                case 'space': {
                  continue;
                }

                case 'hr': {
                  out += this.renderer.hr();
                  continue;
                }

                case 'heading': {
                  out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
                  continue;
                }

                case 'code': {
                  out += this.renderer.code(token.text, token.lang, token.escaped);
                  continue;
                }

                case 'table': {
                  header = ''; // header

                  cell = '';
                  l2 = token.header.length;

                  for (j = 0; j < l2; j++) {
                    cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {
                      header: true,
                      align: token.align[j],
                    });
                  }

                  header += this.renderer.tablerow(cell);
                  body = '';
                  l2 = token.cells.length;

                  for (j = 0; j < l2; j++) {
                    row = token.tokens.cells[j];
                    cell = '';
                    l3 = row.length;

                    for (k = 0; k < l3; k++) {
                      cell += this.renderer.tablecell(this.parseInline(row[k]), {
                        header: false,
                        align: token.align[k],
                      });
                    }

                    body += this.renderer.tablerow(cell);
                  }

                  out += this.renderer.table(header, body);
                  continue;
                }

                case 'blockquote': {
                  body = this.parse(token.tokens);
                  out += this.renderer.blockquote(body);
                  continue;
                }

                case 'list': {
                  ordered = token.ordered;
                  start = token.start;
                  loose = token.loose;
                  l2 = token.items.length;
                  body = '';

                  for (j = 0; j < l2; j++) {
                    item = token.items[j];
                    checked = item.checked;
                    task = item.task;
                    itemBody = '';

                    if (item.task) {
                      checkbox = this.renderer.checkbox(checked);

                      if (loose) {
                        if (item.tokens.length > 0 && item.tokens[0].type === 'text') {
                          item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;

                          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {
                            item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;
                          }
                        } else {
                          item.tokens.unshift({
                            type: 'text',
                            text: checkbox,
                          });
                        }
                      } else {
                        itemBody += checkbox;
                      }
                    }

                    itemBody += this.parse(item.tokens, loose);
                    body += this.renderer.listitem(itemBody, task, checked);
                  }

                  out += this.renderer.list(body, ordered, start);
                  continue;
                }

                case 'html': {
                  // TODO parse inline content if parameter markdown=1
                  out += this.renderer.html(token.text);
                  continue;
                }

                case 'paragraph': {
                  out += this.renderer.paragraph(this.parseInline(token.tokens));
                  continue;
                }

                case 'text': {
                  body = token.tokens ? this.parseInline(token.tokens) : token.text;

                  while (i + 1 < l && tokens[i + 1].type === 'text') {
                    token = tokens[++i];
                    body += '\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);
                  }

                  out += top ? this.renderer.paragraph(body) : body;
                  continue;
                }

                default: {
                  var errMsg = 'Token with "' + token.type + '" type was not found.';

                  if (this.options.silent) {
                    console.error(errMsg);
                    return;
                  } else {
                    throw new Error(errMsg);
                  }
                }
              }
            }

            return out;
          };
          /**
           * Parse Inline Tokens
           */

          _proto.parseInline = function parseInline(tokens, renderer) {
            renderer = renderer || this.renderer;
            var out = '',
              i,
              token,
              ret;
            var l = tokens.length;

            for (i = 0; i < l; i++) {
              token = tokens[i]; // Run any renderer extensions

              if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
                ret = this.options.extensions.renderers[token.type].call(this, token);

                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(token.type)) {
                  out += ret || '';
                  continue;
                }
              }

              switch (token.type) {
                case 'escape': {
                  out += renderer.text(token.text);
                  break;
                }

                case 'html': {
                  out += renderer.html(token.text);
                  break;
                }

                case 'link': {
                  out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
                  break;
                }

                case 'image': {
                  out += renderer.image(token.href, token.title, token.text);
                  break;
                }

                case 'strong': {
                  out += renderer.strong(this.parseInline(token.tokens, renderer));
                  break;
                }

                case 'em': {
                  out += renderer.em(this.parseInline(token.tokens, renderer));
                  break;
                }

                case 'codespan': {
                  out += renderer.codespan(token.text);
                  break;
                }

                case 'br': {
                  out += renderer.br();
                  break;
                }

                case 'del': {
                  out += renderer.del(this.parseInline(token.tokens, renderer));
                  break;
                }

                case 'text': {
                  out += renderer.text(token.text);
                  break;
                }

                default: {
                  var errMsg = 'Token with "' + token.type + '" type was not found.';

                  if (this.options.silent) {
                    console.error(errMsg);
                    return;
                  } else {
                    throw new Error(errMsg);
                  }
                }
              }
            }

            return out;
          };

          return Parser;
        })();

        var Lexer = Lexer_1;
        var Parser = Parser_1;
        var Tokenizer = Tokenizer_1;
        var Renderer = Renderer_1;
        var TextRenderer = TextRenderer_1;
        var Slugger = Slugger_1;
        var merge = helpers.merge,
          checkSanitizeDeprecation = helpers.checkSanitizeDeprecation,
          escape = helpers.escape;
        var getDefaults = defaults$5.exports.getDefaults,
          changeDefaults = defaults$5.exports.changeDefaults,
          defaults = defaults$5.exports.defaults;
        /**
         * Marked
         */

        function marked(src, opt, callback) {
          // throw error in case of non string input
          if (typeof src === 'undefined' || src === null) {
            throw new Error('marked(): input parameter is undefined or null');
          }

          if (typeof src !== 'string') {
            throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
          }

          if (typeof opt === 'function') {
            callback = opt;
            opt = null;
          }

          opt = merge({}, marked.defaults, opt || {});
          checkSanitizeDeprecation(opt);

          if (callback) {
            var highlight = opt.highlight;
            var tokens;

            try {
              tokens = Lexer.lex(src, opt);
            } catch (e) {
              return callback(e);
            }

            var done = function done(err) {
              var out;

              if (!err) {
                try {
                  if (opt.walkTokens) {
                    marked.walkTokens(tokens, opt.walkTokens);
                  }

                  out = Parser.parse(tokens, opt);
                } catch (e) {
                  err = e;
                }
              }

              opt.highlight = highlight;
              return err ? callback(err) : callback(null, out);
            };

            if (!highlight || highlight.length < 3) {
              return done();
            }

            delete opt.highlight;
            if (!tokens.length) return done();
            var pending = 0;
            marked.walkTokens(tokens, function (token) {
              if (token.type === 'code') {
                pending++;
                setTimeout(function () {
                  highlight(token.text, token.lang, function (err, code) {
                    if (err) {
                      return done(err);
                    }

                    if (code != null && code !== token.text) {
                      token.text = code;
                      token.escaped = true;
                    }

                    pending--;

                    if (pending === 0) {
                      done();
                    }
                  });
                }, 0);
              }
            });

            if (pending === 0) {
              done();
            }

            return;
          }

          try {
            var _tokens = Lexer.lex(src, opt);

            if (opt.walkTokens) {
              marked.walkTokens(_tokens, opt.walkTokens);
            }

            return Parser.parse(_tokens, opt);
          } catch (e) {
            e.message += '\nPlease report this to https://github.com/markedjs/marked.';

            if (opt.silent) {
              return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
            }

            throw e;
          }
        }
        /**
         * Options
         */

        marked.options = marked.setOptions = function (opt) {
          merge(marked.defaults, opt);
          changeDefaults(marked.defaults);
          return marked;
        };

        marked.getDefaults = getDefaults;
        marked.defaults = defaults;
        /**
         * Use Extension
         */

        marked.use = function () {
          var _this = this;

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var opts = merge.apply(void 0, [{}].concat(args));
          var extensions = marked.defaults.extensions || {
            renderers: {},
            childTokens: {},
          };
          var hasExtensions;
          args.forEach(function (pack) {
            // ==-- Parse "addon" extensions --== //
            if (pack.extensions) {
              hasExtensions = true;
              pack.extensions.forEach(function (ext) {
                if (!ext.name) {
                  throw new Error('extension name required');
                }

                if (ext.renderer) {
                  // Renderer extensions
                  var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;

                  if (prevRenderer) {
                    // Replace extension with func to run new extension but fall back if false
                    extensions.renderers[ext.name] = function () {
                      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                        args[_key2] = arguments[_key2];
                      }

                      var ret = ext.renderer.apply(this, args);

                      if (ret === false) {
                        ret = prevRenderer.apply(this, args);
                      }

                      return ret;
                    };
                  } else {
                    extensions.renderers[ext.name] = ext.renderer;
                  }
                }

                if (ext.tokenizer) {
                  // Tokenizer Extensions
                  if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {
                    throw new Error("extension level must be 'block' or 'inline'");
                  }

                  if (extensions[ext.level]) {
                    extensions[ext.level].unshift(ext.tokenizer);
                  } else {
                    extensions[ext.level] = [ext.tokenizer];
                  }

                  if (ext.start) {
                    // Function to check for start of token
                    if (ext.level === 'block') {
                      if (extensions.startBlock) {
                        extensions.startBlock.push(ext.start);
                      } else {
                        extensions.startBlock = [ext.start];
                      }
                    } else if (ext.level === 'inline') {
                      if (extensions.startInline) {
                        extensions.startInline.push(ext.start);
                      } else {
                        extensions.startInline = [ext.start];
                      }
                    }
                  }
                }

                if (ext.childTokens) {
                  // Child tokens to be visited by walkTokens
                  extensions.childTokens[ext.name] = ext.childTokens;
                }
              });
            } // ==-- Parse "overwrite" extensions --== //

            if (pack.renderer) {
              (function () {
                var renderer = marked.defaults.renderer || new Renderer();

                var _loop = function _loop(prop) {
                  var prevRenderer = renderer[prop]; // Replace renderer with func to run extension, but fall back if false

                  renderer[prop] = function () {
                    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                      args[_key3] = arguments[_key3];
                    }

                    var ret = pack.renderer[prop].apply(renderer, args);

                    if (ret === false) {
                      ret = prevRenderer.apply(renderer, args);
                    }

                    return ret;
                  };
                };

                for (var prop in pack.renderer) {
                  _loop(prop);
                }

                opts.renderer = renderer;
              })();
            }

            if (pack.tokenizer) {
              (function () {
                var tokenizer = marked.defaults.tokenizer || new Tokenizer();

                var _loop2 = function _loop2(prop) {
                  var prevTokenizer = tokenizer[prop]; // Replace tokenizer with func to run extension, but fall back if false

                  tokenizer[prop] = function () {
                    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                      args[_key4] = arguments[_key4];
                    }

                    var ret = pack.tokenizer[prop].apply(tokenizer, args);

                    if (ret === false) {
                      ret = prevTokenizer.apply(tokenizer, args);
                    }

                    return ret;
                  };
                };

                for (var prop in pack.tokenizer) {
                  _loop2(prop);
                }

                opts.tokenizer = tokenizer;
              })();
            } // ==-- Parse WalkTokens extensions --== //

            if (pack.walkTokens) {
              var walkTokens = marked.defaults.walkTokens;

              opts.walkTokens = function (token) {
                pack.walkTokens.call(_this, token);

                if (walkTokens) {
                  walkTokens(token);
                }
              };
            }

            if (hasExtensions) {
              opts.extensions = extensions;
            }

            marked.setOptions(opts);
          });
        };
        /**
         * Run callback for every token
         */

        marked.walkTokens = function (tokens, callback) {
          var _loop3 = function _loop3() {
            var token = _step.value;
            callback(token);

            switch (token.type) {
              case 'table': {
                for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done; ) {
                  var cell = _step2.value;
                  marked.walkTokens(cell, callback);
                }

                for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done; ) {
                  var row = _step3.value;

                  for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done; ) {
                    var _cell = _step4.value;
                    marked.walkTokens(_cell, callback);
                  }
                }

                break;
              }

              case 'list': {
                marked.walkTokens(token.items, callback);
                break;
              }

              default: {
                if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
                  // Walk any extensions
                  marked.defaults.extensions.childTokens[token.type].forEach(function (childTokens) {
                    marked.walkTokens(token[childTokens], callback);
                  });
                } else if (token.tokens) {
                  marked.walkTokens(token.tokens, callback);
                }
              }
            }
          };

          for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done; ) {
            _loop3();
          }
        };
        /**
         * Parse Inline
         */

        marked.parseInline = function (src, opt) {
          // throw error in case of non string input
          if (typeof src === 'undefined' || src === null) {
            throw new Error('marked.parseInline(): input parameter is undefined or null');
          }

          if (typeof src !== 'string') {
            throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');
          }

          opt = merge({}, marked.defaults, opt || {});
          checkSanitizeDeprecation(opt);

          try {
            var tokens = Lexer.lexInline(src, opt);

            if (opt.walkTokens) {
              marked.walkTokens(tokens, opt.walkTokens);
            }

            return Parser.parseInline(tokens, opt);
          } catch (e) {
            e.message += '\nPlease report this to https://github.com/markedjs/marked.';

            if (opt.silent) {
              return '<p>An error occurred:</p><pre>' + escape(e.message + '', true) + '</pre>';
            }

            throw e;
          }
        };
        /**
         * Expose
         */

        marked.Parser = Parser;
        marked.parser = Parser.parse;
        marked.Renderer = Renderer;
        marked.TextRenderer = TextRenderer;
        marked.Lexer = Lexer;
        marked.lexer = Lexer.lex;
        marked.Tokenizer = Tokenizer;
        marked.Slugger = Slugger;
        marked.parse = marked;
        var marked_1 = marked;

        return marked_1;
      });
    });

    var post_model = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Post = void 0;

      const dayjs_1 = __importDefault(dayjs_min);

      const getTokens = body => {
        try {
          return marked.lexer(body, { gfm: true });
        } catch (e) {
          return [{ type: 'text', text: body }];
        }
      };
      class Post extends baseModel.BaseModel {
        constructor(model) {
          super(model);
          this.title = '';
          this.tokens = [];
          this.tags = [];
          this.relatedPosts = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.title) != undefined) {
            this.title = model.title;
          }
          if ((model === null || model === void 0 ? void 0 : model.date) != undefined) {
            this.date = (d => dayjs_1.default(d))(model.date);
          }
          if ((model === null || model === void 0 ? void 0 : model.body) != undefined) {
            this.tokens = getTokens(model.body);
          }
          if ((model === null || model === void 0 ? void 0 : model.photoId) != undefined) {
            this.photoId = model.photoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.author) != undefined) {
            this.author = new user_model.User(model.author);
          }
          if ((model === null || model === void 0 ? void 0 : model.tags) != undefined) {
            this.tags = model.tags.map(__v => new tag_model.Tag(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.relatedPosts) != undefined) {
            this.relatedPosts = model.relatedPosts.map(__v => new Post(__v));
          }
        }
        getTokens() {
          return __awaiter(this, void 0, void 0, function* () {
            return [];
          });
        }
      }
      exports.Post = Post;
    });

    var seasonPlayerStats_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.SeasonPlayerStats = void 0;

      class SeasonPlayerStats {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.player) != undefined) {
            this.player = new player_model.Player(model.player);
          }
          if ((model === null || model === void 0 ? void 0 : model.played) != undefined) {
            this.played = model.played;
          }
          if ((model === null || model === void 0 ? void 0 : model.goals) != undefined) {
            this.goals = model.goals;
          }
          if ((model === null || model === void 0 ? void 0 : model.assists) != undefined) {
            this.assists = model.assists;
          }
          if ((model === null || model === void 0 ? void 0 : model.goals_assists) != undefined) {
            this.goals_assists = model.goals_assists;
          }
          if ((model === null || model === void 0 ? void 0 : model.points) != undefined) {
            this.points = model.points;
          }
          if ((model === null || model === void 0 ? void 0 : model.yellowCards) != undefined) {
            this.yellowCards = model.yellowCards;
          }
          if ((model === null || model === void 0 ? void 0 : model.redCards) != undefined) {
            this.redCards = model.redCards;
          }
          if ((model === null || model === void 0 ? void 0 : model.fouls) != undefined) {
            this.fouls = model.fouls;
          }
          if ((model === null || model === void 0 ? void 0 : model.technicalFouls) != undefined) {
            this.technicalFouls = model.technicalFouls;
          }
          if ((model === null || model === void 0 ? void 0 : model.allFouls) != undefined) {
            this.allFouls = model.allFouls;
          }
          if ((model === null || model === void 0 ? void 0 : model.losses) != undefined) {
            this.losses = model.losses;
          }
          if ((model === null || model === void 0 ? void 0 : model.steals) != undefined) {
            this.steals = model.steals;
          }
          if ((model === null || model === void 0 ? void 0 : model.reboundsA) != undefined) {
            this.reboundsA = model.reboundsA;
          }
          if ((model === null || model === void 0 ? void 0 : model.reboundsD) != undefined) {
            this.reboundsD = model.reboundsD;
          }
          if ((model === null || model === void 0 ? void 0 : model.rebounds) != undefined) {
            this.rebounds = model.rebounds;
          }
          if ((model === null || model === void 0 ? void 0 : model.missesOne) != undefined) {
            this.missesOne = model.missesOne;
          }
          if ((model === null || model === void 0 ? void 0 : model.missesTwo) != undefined) {
            this.missesTwo = model.missesTwo;
          }
          if ((model === null || model === void 0 ? void 0 : model.missesThree) != undefined) {
            this.missesThree = model.missesThree;
          }
          if ((model === null || model === void 0 ? void 0 : model.misses) != undefined) {
            this.misses = model.misses;
          }
          if ((model === null || model === void 0 ? void 0 : model.blocks) != undefined) {
            this.blocks = model.blocks;
          }
          if ((model === null || model === void 0 ? void 0 : model.aces) != undefined) {
            this.aces = model.aces;
          }
          this.player = new player_model.Player({
            _id: model._id,
            firstName: model.firstName,
            lastName: model.lastName,
            photoId: model.photoId,
            teams: model.teams,
          });
        }
      }
      exports.SeasonPlayerStats = SeasonPlayerStats;
    });

    var season_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Season = void 0;

      class Season extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.stages = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.inProgress) != undefined) {
            this.inProgress = model.inProgress;
          }
          if ((model === null || model === void 0 ? void 0 : model.champ) != undefined) {
            this.champ = new champ_model.Champ(model.champ);
          }
          if ((model === null || model === void 0 ? void 0 : model.stages) != undefined) {
            this.stages = model.stages.map(__v => new stage_model.Stage(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.calendar) != undefined) {
            this.calendar = new collection.Collection({ total: model.calendar.total, items: model.calendar.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.upcomingGames) != undefined) {
            this.upcomingGames = new collection.Collection({ total: model.upcomingGames.total, items: model.upcomingGames.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.playedGames) != undefined) {
            this.playedGames = new collection.Collection({ total: model.playedGames.total, items: model.playedGames.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.news) != undefined) {
            this.news = new collection.Collection({ total: model.news.total, items: model.news.items.map(_v => new post_model.Post(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.gamesWithPhotos) != undefined) {
            this.gamesWithPhotos = new collection.Collection({ total: model.gamesWithPhotos.total, items: model.gamesWithPhotos.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.gamesWithVideos) != undefined) {
            this.gamesWithVideos = new collection.Collection({ total: model.gamesWithVideos.total, items: model.gamesWithVideos.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.birthdays) != undefined) {
            this.birthdays = model.birthdays.map(__v => new player_model.Player(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.playersStats) != undefined) {
            this.playersStats = model.playersStats.map(__v => new seasonPlayerStats_model.SeasonPlayerStats(__v));
          }
        }
        get country() {
          var _a;
          return (_a = this.champ) === null || _a === void 0 ? void 0 : _a.country;
        }
        get league() {
          var _a;
          return (_a = this.champ) === null || _a === void 0 ? void 0 : _a.league;
        }
      }
      exports.Season = Season;
    });

    var teamTopPlayers_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.TeamTopPlayers = void 0;

      class TeamTopPlayers {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.goals) != undefined) {
            this.goals = model.goals.map(__v => new OnePlayerRow(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.assists) != undefined) {
            this.assists = model.assists.map(__v => new OnePlayerRow(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.goals_assists) != undefined) {
            this.goals_assists = model.goals_assists.map(__v => new OnePlayerRow(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.games) != undefined) {
            this.games = model.games.map(__v => new OnePlayerRow(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.connection) != undefined) {
            this.connection = model.connection.map(__v => new TwoPlayersRow(__v));
          }
        }
      }
      exports.TeamTopPlayers = TeamTopPlayers;
      class OnePlayerRow {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.value) != undefined) {
            this.value = model.value;
          }
          if ((model === null || model === void 0 ? void 0 : model.player) != undefined) {
            this.player = new player_model.Player(model.player);
          }
        }
      }
      class TwoPlayersRow {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.value) != undefined) {
            this.value = model.value;
          }
          if ((model === null || model === void 0 ? void 0 : model.firstPlayer) != undefined) {
            this.firstPlayer = new player_model.Player(model.firstPlayer);
          }
          if ((model === null || model === void 0 ? void 0 : model.secondPlayer) != undefined) {
            this.secondPlayer = new player_model.Player(model.secondPlayer);
          }
        }
      }
    });

    var teamStats_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.TeamStats = void 0;
      class TeamStats {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.games) != undefined) {
            this.games = model.games;
          }
          if ((model === null || model === void 0 ? void 0 : model.won) != undefined) {
            this.won = model.won;
          }
          if ((model === null || model === void 0 ? void 0 : model.draw) != undefined) {
            this.draw = model.draw;
          }
          if ((model === null || model === void 0 ? void 0 : model.lost) != undefined) {
            this.lost = model.lost;
          }
          if ((model === null || model === void 0 ? void 0 : model.scored) != undefined) {
            this.scored = model.scored;
          }
          if ((model === null || model === void 0 ? void 0 : model.conceded) != undefined) {
            this.conceded = model.conceded;
          }
        }
        get winPercent() {
          return Math.round((this.won * 100) / this.games);
        }
      }
      exports.TeamStats = TeamStats;
    });

    var teamPlayerStats_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.TeamPlayerStatsChemistry = exports.TeamPlayerStats = void 0;

      class TeamPlayerStats {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.player) != undefined) {
            this.player = new player_model.Player(model.player);
          }
          if ((model === null || model === void 0 ? void 0 : model.played) != undefined) {
            this.played = model.played;
          }
          if ((model === null || model === void 0 ? void 0 : model.won) != undefined) {
            this.won = model.won;
          }
          if ((model === null || model === void 0 ? void 0 : model.draw) != undefined) {
            this.draw = model.draw;
          }
          if ((model === null || model === void 0 ? void 0 : model.lost) != undefined) {
            this.lost = model.lost;
          }
          if ((model === null || model === void 0 ? void 0 : model.goals) != undefined) {
            this.goals = model.goals;
          }
          if ((model === null || model === void 0 ? void 0 : model.assists) != undefined) {
            this.assists = model.assists;
          }
          if ((model === null || model === void 0 ? void 0 : model.yellowCards) != undefined) {
            this.yellowCards = model.yellowCards;
          }
          if ((model === null || model === void 0 ? void 0 : model.redCards) != undefined) {
            this.redCards = model.redCards;
          }
          if ((model === null || model === void 0 ? void 0 : model.teamScored) != undefined) {
            this.teamScored = model.teamScored;
          }
          if ((model === null || model === void 0 ? void 0 : model.teamConceded) != undefined) {
            this.teamConceded = model.teamConceded;
          }
          if ((model === null || model === void 0 ? void 0 : model.winPercent) != undefined) {
            this.winPercent = model.winPercent;
          }
          if ((model === null || model === void 0 ? void 0 : model.chemistry) != undefined) {
            this.chemistry = new TeamPlayerStatsChemistry(model.chemistry);
          }
          if (model) {
            this.winPercent = model.won / model.played;
          }
        }
      }
      exports.TeamPlayerStats = TeamPlayerStats;
      class TeamPlayerStatsChemistry {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.player) != undefined) {
            this.player = new player_model.Player(model.player);
          }
          if ((model === null || model === void 0 ? void 0 : model.value) != undefined) {
            this.value = model.value;
          }
        }
      }
      exports.TeamPlayerStatsChemistry = TeamPlayerStatsChemistry;
    });

    var team_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Team = void 0;

      class Team extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.players = [];
          this.contacts = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.shortName) != undefined) {
            this.shortName = model.shortName;
          }
          if ((model === null || model === void 0 ? void 0 : model.founded) != undefined) {
            this.founded = model.founded;
          }
          if ((model === null || model === void 0 ? void 0 : model.rating) != undefined) {
            this.rating = model.rating;
          }
          if ((model === null || model === void 0 ? void 0 : model.photoId) != undefined) {
            this.photoId = model.photoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.hasPhoto) != undefined) {
            this.hasPhoto = model.hasPhoto;
          }
          if ((model === null || model === void 0 ? void 0 : model.logo) != undefined) {
            this.logo = model.logo;
          }
          if ((model === null || model === void 0 ? void 0 : model.logoId) != undefined) {
            this.logoId = model.logoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.league) != undefined) {
            this.league = new league_model.League(model.league);
          }
          if ((model === null || model === void 0 ? void 0 : model.country) != undefined) {
            this.country = new country_model.Country(model.country);
          }
          if ((model === null || model === void 0 ? void 0 : model.parentTeam) != undefined) {
            this.parentTeam = new Team(model.parentTeam);
          }
          if ((model === null || model === void 0 ? void 0 : model.reserveTeam) != undefined) {
            this.reserveTeam = new Team(model.reserveTeam);
          }
          if ((model === null || model === void 0 ? void 0 : model.players) != undefined) {
            this.players = model.players.map(__v => new player_model.Player(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.games) != undefined) {
            this.games = new collection.Collection({ total: model.games.total, items: model.games.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.seasons) != undefined) {
            this.seasons = new collection.Collection({ total: model.seasons.total, items: model.seasons.items.map(_v => new season_model.Season(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.transfers) != undefined) {
            this.transfers = new collection.Collection({ total: model.transfers.total, items: model.transfers.items.map(_v => new transferRequest_model.TransferRequest(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.news) != undefined) {
            this.news = new collection.Collection({ total: model.news.total, items: model.news.items.map(_v => new post_model.Post(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.gamesWithPhotos) != undefined) {
            this.gamesWithPhotos = new collection.Collection({ total: model.gamesWithPhotos.total, items: model.gamesWithPhotos.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.gamesWithVideos) != undefined) {
            this.gamesWithVideos = new collection.Collection({ total: model.gamesWithVideos.total, items: model.gamesWithVideos.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.contacts) != undefined) {
            this.contacts = model.contacts.map(__v => new player_model.Player(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.stats) != undefined) {
            this.stats = new teamStats_model.TeamStats(model.stats);
          }
          if ((model === null || model === void 0 ? void 0 : model.topPlayers) != undefined) {
            this.topPlayers = new teamTopPlayers_model.TeamTopPlayers(model.topPlayers);
          }
          if ((model === null || model === void 0 ? void 0 : model.fullPlayersStats) != undefined) {
            this.fullPlayersStats = model.fullPlayersStats.map(__v => new teamPlayerStats_model.TeamPlayerStats(__v));
          }
        }
        get avgAge() {
          var _a;
          return (_a = this.players) === null || _a === void 0
            ? void 0
            : _a.reduce(
                (stats, pl) => {
                  if (pl.getAge()) {
                    stats.sum += pl.getAge();
                    stats.total++;
                    stats.avg = Math.round((stats.sum / stats.total) * 10) / 10;
                  }
                  return stats;
                },
                { total: 0, sum: 0, avg: 0 },
              ).avg;
        }
      }
      exports.Team = Team;
    });

    var role_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Role = exports.RoleLevel = void 0;
      (function (RoleLevel) {
        RoleLevel['root'] = 'root';
        RoleLevel['head'] = 'head';
        RoleLevel['captain'] = 'captain';
        RoleLevel['referee'] = 'referee';
        RoleLevel['photographer'] = 'photographer';
        RoleLevel['journalist'] = 'journalist';
        RoleLevel['operator'] = 'operator';
      })(exports.RoleLevel || (exports.RoleLevel = {}));
      class Role extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.user) != undefined) {
            this.user = new user_model.User(model.user);
          }
          if ((model === null || model === void 0 ? void 0 : model.level) != undefined) {
            this.level = model.level;
          }
          if ((model === null || model === void 0 ? void 0 : model.league) != undefined) {
            this.league = new league_model.League(model.league);
          }
          if ((model === null || model === void 0 ? void 0 : model.team) != undefined) {
            this.team = new team_model.Team(model.team);
          }
        }
      }
      exports.Role = Role;
    });

    var userDevice_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.UserDevice = void 0;
      class UserDevice {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.uuid) != undefined) {
            this.uuid = model.uuid;
          }
          if ((model === null || model === void 0 ? void 0 : model.fbToken) != undefined) {
            this.fbToken = model.fbToken;
          }
        }
      }
      exports.UserDevice = UserDevice;
    });

    var ipData_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.IpData = void 0;
      class IpData {
        constructor(model) {
          this.filledWithDefaultValues = false;
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.filledWithDefaultValues) != undefined) {
            this.filledWithDefaultValues = model.filledWithDefaultValues;
          }
          if ((model === null || model === void 0 ? void 0 : model.ip) != undefined) {
            this.ip = model.ip;
          }
          if ((model === null || model === void 0 ? void 0 : model.type) != undefined) {
            this.type = model.type;
          }
          if ((model === null || model === void 0 ? void 0 : model.continent_code) != undefined) {
            this.continent_code = model.continent_code;
          }
          if ((model === null || model === void 0 ? void 0 : model.continent_name) != undefined) {
            this.continent_name = model.continent_name;
          }
          if ((model === null || model === void 0 ? void 0 : model.country_code) != undefined) {
            this.country_code = model.country_code;
          }
          if ((model === null || model === void 0 ? void 0 : model.country_name) != undefined) {
            this.country_name = model.country_name;
          }
          if ((model === null || model === void 0 ? void 0 : model.region_code) != undefined) {
            this.region_code = model.region_code;
          }
          if ((model === null || model === void 0 ? void 0 : model.region_name) != undefined) {
            this.region_name = model.region_name;
          }
          if ((model === null || model === void 0 ? void 0 : model.city) != undefined) {
            this.city = model.city;
          }
          if ((model === null || model === void 0 ? void 0 : model.zip) != undefined) {
            this.zip = model.zip;
          }
          if ((model === null || model === void 0 ? void 0 : model.latitude) != undefined) {
            this.latitude = model.latitude;
          }
          if ((model === null || model === void 0 ? void 0 : model.longitude) != undefined) {
            this.longitude = model.longitude;
          }
          if ((model === null || model === void 0 ? void 0 : model.location) != undefined) {
            this.location = model.location;
          }
          if ((model === null || model === void 0 ? void 0 : model.time_zone) != undefined) {
            this.time_zone = model.time_zone;
          }
          if ((model === null || model === void 0 ? void 0 : model.currency) != undefined) {
            this.currency = model.currency;
          }
        }
        isValid() {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
          return (
            !Boolean(this.filledWithDefaultValues) &&
            Boolean(this.ip) &&
            Boolean(this.type) &&
            Boolean(this.continent_code) &&
            Boolean(this.continent_name) &&
            Boolean(this.country_code) &&
            Boolean(this.country_name) &&
            Boolean(this.region_code) &&
            Boolean(this.region_name) &&
            Boolean(this.city) &&
            Boolean(this.zip) &&
            Boolean(this.latitude) &&
            Boolean(this.longitude) &&
            Boolean((_b = (_a = this.location) === null || _a === void 0 ? void 0 : _a.languages[0]) === null || _b === void 0 ? void 0 : _b.name) &&
            Boolean((_d = (_c = this.location) === null || _c === void 0 ? void 0 : _c.languages[0]) === null || _d === void 0 ? void 0 : _d.code) &&
            Boolean((_e = this.location) === null || _e === void 0 ? void 0 : _e.calling_code) &&
            Boolean((_f = this.time_zone) === null || _f === void 0 ? void 0 : _f._id) &&
            Boolean((_g = this.time_zone) === null || _g === void 0 ? void 0 : _g.currentTime) &&
            Boolean((_h = this.time_zone) === null || _h === void 0 ? void 0 : _h.gmt_offset) &&
            Boolean((_j = this.time_zone) === null || _j === void 0 ? void 0 : _j.code) &&
            Boolean((_k = this.currency) === null || _k === void 0 ? void 0 : _k.code) &&
            Boolean((_l = this.currency) === null || _l === void 0 ? void 0 : _l.name)
          );
        }
        setDefaulValues() {
          this.filledWithDefaultValues = true;
          this.continent_code = 'AS';
          this.continent_name = 'Asia';
          this.country_code = 'RU';
          this.country_name = 'Russia';
          this.region_code = 'MOW';
          this.region_name = 'Moscow';
          this.latitude = '55.8';
          this.longitude = '37.5';
          this.location = {
            languages: [{ name: 'Russian', code: 'RU' }],
            calling_code: '+7',
          };
          this.time_zone = {
            _id: '0.0.0.0',
            currentTime: '0',
            gmt_offset: '-180',
            code: '0',
          };
          this.currency = {
            code: 'RUR',
            name: 'Russian Rouble',
          };
        }
      }
      exports.IpData = IpData;
    });

    var userSubsciption_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.UserSubscription = void 0;

      class UserSubscription extends baseModel.BaseModel {
        constructor(model) {
          super(model);
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.player) != undefined) {
            this.player = new player_model.Player(model.player);
          }
          if ((model === null || model === void 0 ? void 0 : model.team) != undefined) {
            this.team = new team_model.Team(model.team);
          }
        }
      }
      exports.UserSubscription = UserSubscription;
    });

    var userRecommendation_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.UserRecommendation = void 0;

      class UserRecommendation extends baseModel.BaseModel {
        constructor(model) {
          super(model);
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.player) != undefined) {
            this.player = new player_model.Player(model.player);
          }
          if ((model === null || model === void 0 ? void 0 : model.team) != undefined) {
            this.team = new team_model.Team(model.team);
          }
          if ((model === null || model === void 0 ? void 0 : model.stadium) != undefined) {
            this.stadium = new stadium_model.Stadium(model.stadium);
          }
        }
      }
      exports.UserRecommendation = UserRecommendation;
    });

    var user_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.User = void 0;

      const isAdminRole = r => {
        return [
          role_model.RoleLevel.root,
          role_model.RoleLevel.journalist,
          role_model.RoleLevel.photographer,
          role_model.RoleLevel.referee,
          role_model.RoleLevel.operator,
        ].includes(r.level);
      };
      class User extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.language = language.Language.default;
          this.roles = [];
          this.players = [];
          this.devices = [];
          this.subscriptions = [];
          this.recommendations = [];
          this.isRoot = () => {
            var _a;
            return (_a = this.roles) === null || _a === void 0 ? void 0 : _a.some(r => r.level === role_model.RoleLevel.root);
          };
          this.isLeagueHead = () => {
            var _a;
            return this.isRoot() || ((_a = this.roles) === null || _a === void 0 ? void 0 : _a.some(r => r.level === role_model.RoleLevel.head));
          };
          this.isStaff = () => {
            var _a;
            return (_a = this.roles) === null || _a === void 0 ? void 0 : _a.some(isAdminRole);
          };
          this.isReferee = () => {
            var _a;
            return this.isLeagueHead() || ((_a = this.roles) === null || _a === void 0 ? void 0 : _a.some(r => r.level === role_model.RoleLevel.referee));
          };
          this.isCaptain = () => {
            var _a;
            return this.isLeagueHead() || ((_a = this.roles) === null || _a === void 0 ? void 0 : _a.some(r => r.level === role_model.RoleLevel.captain));
          };
          this.isJournalist = () => {
            var _a;
            return this.isLeagueHead() || ((_a = this.roles) === null || _a === void 0 ? void 0 : _a.some(r => r.level === role_model.RoleLevel.journalist));
          };
          this.isPhotographer = () => {
            var _a;
            return this.isLeagueHead() || ((_a = this.roles) === null || _a === void 0 ? void 0 : _a.some(r => r.level === role_model.RoleLevel.photographer));
          };
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.photoId) != undefined) {
            this.photoId = model.photoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.phone) != undefined) {
            this.phone = model.phone;
          }
          if ((model === null || model === void 0 ? void 0 : model.vk) != undefined) {
            this.vk = model.vk;
          }
          if ((model === null || model === void 0 ? void 0 : model.fb) != undefined) {
            this.fb = model.fb;
          }
          if ((model === null || model === void 0 ? void 0 : model.token) != undefined) {
            this.token = model.token;
          }
          if ((model === null || model === void 0 ? void 0 : model.timezoneOffset) != undefined) {
            this.timezoneOffset = model.timezoneOffset;
          }
          if ((model === null || model === void 0 ? void 0 : model.language) != undefined) {
            this.language = model.language;
          }
          if ((model === null || model === void 0 ? void 0 : model.league) != undefined) {
            this.league = new league_model.League(model.league);
          }
          if ((model === null || model === void 0 ? void 0 : model.roles) != undefined) {
            this.roles = model.roles.map(__v => new role_model.Role(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.players) != undefined) {
            this.players = model.players.map(__v => new player_model.Player(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.devices) != undefined) {
            this.devices = model.devices.map(__v => new userDevice_model.UserDevice(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.alerts) != undefined) {
            this.alerts = new collection.Collection({ total: model.alerts.total, items: model.alerts.items.map(_v => new alert_model.Alert(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.games) != undefined) {
            this.games = new collection.Collection({ total: model.games.total, items: model.games.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.ipData) != undefined) {
            this.ipData = new ipData_model.IpData(model.ipData);
          }
          if ((model === null || model === void 0 ? void 0 : model.subscriptions) != undefined) {
            this.subscriptions = model.subscriptions.map(__v => new userSubsciption_model.UserSubscription(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.recommendations) != undefined) {
            this.recommendations = model.recommendations.map(__v => new userRecommendation_model.UserRecommendation(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.notificationsAllowed) != undefined) {
            this.notificationsAllowed = model.notificationsAllowed;
          }
          if ((model === null || model === void 0 ? void 0 : model.licenseAccepted) != undefined) {
            this.licenseAccepted = model.licenseAccepted;
          }
          if ((model === null || model === void 0 ? void 0 : model.appTheme) != undefined) {
            this.appTheme = model.appTheme;
          }
          if ((model === null || model === void 0 ? void 0 : model.isRoot) != undefined) {
            this.isRoot = model.isRoot;
          }
          if ((model === null || model === void 0 ? void 0 : model.isLeagueHead) != undefined) {
            this.isLeagueHead = model.isLeagueHead;
          }
          if ((model === null || model === void 0 ? void 0 : model.isStaff) != undefined) {
            this.isStaff = model.isStaff;
          }
          if ((model === null || model === void 0 ? void 0 : model.isReferee) != undefined) {
            this.isReferee = model.isReferee;
          }
          if ((model === null || model === void 0 ? void 0 : model.isCaptain) != undefined) {
            this.isCaptain = model.isCaptain;
          }
          if ((model === null || model === void 0 ? void 0 : model.isJournalist) != undefined) {
            this.isJournalist = model.isJournalist;
          }
          if ((model === null || model === void 0 ? void 0 : model.isPhotographer) != undefined) {
            this.isPhotographer = model.isPhotographer;
          }
        }
        hasAdminAccessToLeague(league) {
          var _a;
          return (_a = this.roles) === null || _a === void 0 ? void 0 : _a.some(r => isAdminRole(r) && r.league._id === league._id);
        }
        hasHeadAccessToLeague(league) {
          var _a;
          return this.isRoot() || ((_a = this.roles) === null || _a === void 0 ? void 0 : _a.some(r => r.level === role_model.RoleLevel.head && r.league._id === league._id));
        }
        hasAdminAccessToTeam(team) {
          var _a;
          return (
            this.hasHeadAccessToLeague(team.league) ||
            ((_a = this.roles) === null || _a === void 0 ? void 0 : _a.some(r => r.level === role_model.RoleLevel.captain && r.team._id === team._id))
          );
        }
      }
      exports.User = User;
    });

    var champContact_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.ChampContact = void 0;

      class ChampContact extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.description) != undefined) {
            this.description = model.description;
          }
          if ((model === null || model === void 0 ? void 0 : model.user) != undefined) {
            this.user = new user_model.User(model.user);
          }
        }
      }
      exports.ChampContact = ChampContact;
    });

    var champ_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Champ = void 0;

      class Champ extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.seasons = [];
          this.contacts = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.inProgress) != undefined) {
            this.inProgress = model.inProgress;
          }
          if ((model === null || model === void 0 ? void 0 : model.calcRating) != undefined) {
            this.calculateRating = model.calcRating;
          }
          if ((model === null || model === void 0 ? void 0 : model.logoId) != undefined) {
            this.logoId = model.logoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.disqualifier) != undefined) {
            this.disqualifier = model.disqualifier;
          }
          if ((model === null || model === void 0 ? void 0 : model.windowScheduler) != undefined) {
            this.windowScheduler = model.windowScheduler;
          }
          if ((model === null || model === void 0 ? void 0 : model.country) != undefined) {
            this.country = new country_model.Country(model.country);
          }
          if ((model === null || model === void 0 ? void 0 : model.seasons) != undefined) {
            this.seasons = model.seasons.map(__v => new season_model.Season(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.contacts) != undefined) {
            this.contacts = model.contacts.map(__v => new champContact_model.ChampContact(__v));
          }
          if (model) {
            if (model.disqualYC) {
              this.disqualifier = {
                enabled: model === null || model === void 0 ? void 0 : model.disqualEnabled,
                YC: model === null || model === void 0 ? void 0 : model.disqualYC,
              };
            }
            if (model.windowSchedulerEnabled !== undefined) {
              this.windowScheduler = {
                enabled: model.windowSchedulerEnabled,
                from: {
                  day: model.windowSchedulerDayFrom,
                  time: model.windowSchedulerTimeFrom,
                },
                to: {
                  day: model.windowSchedulerDayTo,
                  time: model.windowSchedulerTimeTo,
                },
              };
            }
          }
        }
        get league() {
          var _a;
          return (_a = this.country) === null || _a === void 0 ? void 0 : _a.league;
        }
        get stages() {
          var _a;
          return (_a = this.seasons) === null || _a === void 0
            ? void 0
            : _a.reduce((stages, season) => {
                return [...stages, ...(season.stages || [])];
              }, []);
        }
      }
      exports.Champ = Champ;
    });

    var appClient_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.AppClient = void 0;

      class AppClient extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.leagues = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.key) != undefined) {
            this.key = model.key;
          }
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.leagues) != undefined) {
            this.leagues = model.leagues.map(__v => new league_model.League(__v));
          }
        }
      }
      exports.AppClient = AppClient;
    });

    var document_model = createCommonjsModule(function (module, exports) {
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Document = void 0;

      const dayjs_1 = __importDefault(dayjs_min);
      class Document extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.title = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.author) != undefined) {
            this.author = new user_model.User(model.author);
          }
          if ((model === null || model === void 0 ? void 0 : model.league) != undefined) {
            this.league = new league_model.League(model.league);
          }
          if ((model === null || model === void 0 ? void 0 : model.size) != undefined) {
            this.size = model.size;
          }
          if ((model === null || model === void 0 ? void 0 : model.extension) != undefined) {
            this.extension = model.extension;
          }
          if ((model === null || model === void 0 ? void 0 : model.date) != undefined) {
            this.date = (d => dayjs_1.default(d))(model.date);
          }
        }
      }
      exports.Document = Document;
    });

    var partner_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Partner = void 0;

      class Partner extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.photoId) != undefined) {
            this.photoId = model.photoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.link) != undefined) {
            this.link = model.link;
          }
          if ((model === null || model === void 0 ? void 0 : model.description) != undefined) {
            this.description = model.description;
          }
          if ((model === null || model === void 0 ? void 0 : model.league) != undefined) {
            this.league = new league_model.League(model.league);
          }
        }
      }
      exports.Partner = Partner;
    });

    var league_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.League = void 0;

      class League extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.stats = { champs: 0, teams: 0, rating: 0, players: 0, stadiums: 0, games: 0 };
          this.champs = [];
          this.contacts = [];
          this.partners = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.sports) != undefined) {
            this.sports = model.sports;
          }
          if ((model === null || model === void 0 ? void 0 : model.linkVk) != undefined) {
            this.linkVk = model.linkVk;
          }
          if ((model === null || model === void 0 ? void 0 : model.linkFb) != undefined) {
            this.linkFb = model.linkFb;
          }
          if ((model === null || model === void 0 ? void 0 : model.linkWeb) != undefined) {
            this.linkWeb = model.linkWeb;
          }
          if ((model === null || model === void 0 ? void 0 : model.linkIg) != undefined) {
            this.linkIg = model.linkIg;
          }
          if ((model === null || model === void 0 ? void 0 : model.linkYoutube) != undefined) {
            this.linkYoutube = model.linkYoutube;
          }
          if ((model === null || model === void 0 ? void 0 : model.linkTelegram) != undefined) {
            this.linkTelegram = model.linkTelegram;
          }
          if ((model === null || model === void 0 ? void 0 : model.foundedYear) != undefined) {
            this.foundedYear = model.foundedYear;
          }
          if ((model === null || model === void 0 ? void 0 : model.logoId) != undefined) {
            this.logoId = model.logoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.stats) != undefined) {
            this.stats = model.stats;
          }
          if ((model === null || model === void 0 ? void 0 : model.city) != undefined) {
            this.city = new city_model.City(model.city);
          }
          if ((model === null || model === void 0 ? void 0 : model.client) != undefined) {
            this.appClient = new appClient_model.AppClient(model.client);
          }
          if ((model === null || model === void 0 ? void 0 : model.champs) != undefined) {
            this.champs = model.champs.map(__v => new champ_model.Champ(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.teams) != undefined) {
            this.teams = new collection.Collection({ total: model.teams.total, items: model.teams.items.map(_v => new team_model.Team(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.stadiums) != undefined) {
            this.stadiums = new collection.Collection({ total: model.stadiums.total, items: model.stadiums.items.map(_v => new stadium_model.Stadium(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.news) != undefined) {
            this.news = new collection.Collection({ total: model.news.total, items: model.news.items.map(_v => new post_model.Post(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.gamesWithPhotos) != undefined) {
            this.gamesWithPhotos = new collection.Collection({ total: model.gamesWithPhotos.total, items: model.gamesWithPhotos.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.gamesWithVideos) != undefined) {
            this.gamesWithVideos = new collection.Collection({ total: model.gamesWithVideos.total, items: model.gamesWithVideos.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.documents) != undefined) {
            this.documents = new collection.Collection({ total: model.documents.total, items: model.documents.items.map(_v => new document_model.Document(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.disqualifications) != undefined) {
            this.disqualifications = new collection.Collection({
              total: model.disqualifications.total,
              items: model.disqualifications.items.map(_v => new disqualification_model.Disqualification(_v)),
            });
          }
          if ((model === null || model === void 0 ? void 0 : model.birthdays) != undefined) {
            this.birthdays = model.birthdays.map(__v => new player_model.Player(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.contacts) != undefined) {
            this.contacts = model.contacts.map(__v => new champContact_model.ChampContact(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.partners) != undefined) {
            this.partners = model.partners.map(__v => new partner_model.Partner(__v));
          }
        }
        get countries() {
          var _a;
          const countriesMap =
            (_a = this.champs) === null || _a === void 0
              ? void 0
              : _a.reduce((countriesMap, champ) => {
                  var _a;
                  var _b;
                  (_a = countriesMap[(_b = champ.country._id)]) !== null && _a !== void 0 ? _a : (countriesMap[_b] = champ.country);
                  countriesMap[champ.country._id].champs.push(champ);
                  return countriesMap;
                }, {});
          return Object.values(countriesMap);
        }
      }
      exports.League = League;
    });

    var stageEvent_model = createCommonjsModule(function (module, exports) {
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.StageEvent = exports.StageEventType = void 0;
      const dayjs_1 = __importDefault(dayjs_min);
      (function (StageEventType) {
        StageEventType['replace'] = 'TEAM_REPLACED';
        StageEventType['disqual'] = 'TEAM_DISQUALIFIED';
        StageEventType['penalty'] = 'TEAM_PENALIZED';
      })(exports.StageEventType || (exports.StageEventType = {}));
      class StageEvent {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.type) != undefined) {
            this.type = model.type;
          }
          if ((model === null || model === void 0 ? void 0 : model.league) != undefined) {
            this.league = new league_model.League(model.league);
          }
          if ((model === null || model === void 0 ? void 0 : model.team) != undefined) {
            this.team = new team_model.Team(model.team);
          }
          if ((model === null || model === void 0 ? void 0 : model.toTeam) != undefined) {
            this.toTeam = new team_model.Team(model.toTeam);
          }
          if ((model === null || model === void 0 ? void 0 : model.points) != undefined) {
            this.points = model.points;
          }
          if ((model === null || model === void 0 ? void 0 : model.date) != undefined) {
            this.date = (d => dayjs_1.default(d))(model.date);
          }
        }
      }
      exports.StageEvent = StageEvent;
    });

    var tableRow_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.TableRow = void 0;

      class TableRow {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model._id) != undefined) {
            this._id = model._id;
          }
          if ((model === null || model === void 0 ? void 0 : model.label) != undefined) {
            this.label = model.label;
          }
          if ((model === null || model === void 0 ? void 0 : model.position) != undefined) {
            this.position = model.position;
          }
          if ((model === null || model === void 0 ? void 0 : model.games) != undefined) {
            this.games = model.games;
          }
          if ((model === null || model === void 0 ? void 0 : model.w) != undefined) {
            this.w = model.w;
          }
          if ((model === null || model === void 0 ? void 0 : model.d) != undefined) {
            this.d = model.d;
          }
          if ((model === null || model === void 0 ? void 0 : model.l) != undefined) {
            this.l = model.l;
          }
          if ((model === null || model === void 0 ? void 0 : model.winPercent) != undefined) {
            this.winPercent = model.winPercent;
          }
          if ((model === null || model === void 0 ? void 0 : model.scored) != undefined) {
            this.scored = model.scored;
          }
          if ((model === null || model === void 0 ? void 0 : model.conceded) != undefined) {
            this.conceded = model.conceded;
          }
          if ((model === null || model === void 0 ? void 0 : model.points) != undefined) {
            this.points = model.points;
          }
          if ((model === null || model === void 0 ? void 0 : model.form) != undefined) {
            this.form = model.form;
          }
          if ((model === null || model === void 0 ? void 0 : model.team) != undefined) {
            this.team = new team_model.Team(model.team);
          }
          if (model) {
            this.team = new team_model.Team({
              _id: model._id,
              name: model.name,
              shortName: model.shortName,
              logo: model.logo,
              logoId: model.logoId,
            });
          }
        }
      }
      exports.TableRow = TableRow;
    });

    var stage_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Stage = exports.StagePositionPriority = exports.StageFormat = void 0;
      (function (StageFormat) {
        StageFormat['league'] = 'league';
        StageFormat['free'] = 'free';
        StageFormat['cup'] = 'cup';
      })(exports.StageFormat || (exports.StageFormat = {}));
      (function (StagePositionPriority) {
        StagePositionPriority['goals'] = 'goals';
        StagePositionPriority['games'] = 'games';
      })(exports.StagePositionPriority || (exports.StagePositionPriority = {}));
      class Stage extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.teams = [];
          this.events = [];
          this.table = [];
          this.cupNet = []; // same as games, but exists only if stage format is 'cup'
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.format) != undefined) {
            this.format = model.format;
          }
          if ((model === null || model === void 0 ? void 0 : model.definePosition) != undefined) {
            this.definePosition = model.definePosition;
          }
          if ((model === null || model === void 0 ? void 0 : model.season) != undefined) {
            this.season = new season_model.Season(model.season);
          }
          if ((model === null || model === void 0 ? void 0 : model.teams) != undefined) {
            this.teams = model.teams.map(__v => new team_model.Team(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.events) != undefined) {
            this.events = model.events.map(__v => new stageEvent_model.StageEvent(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.games) != undefined) {
            this.games = new collection.Collection({ total: model.games.total, items: model.games.items.map(_v => new game_model.Game(_v)) });
          }
          if ((model === null || model === void 0 ? void 0 : model.table) != undefined) {
            this.table = model.table.map(__v => new tableRow_model.TableRow(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.cupNet) != undefined) {
            this.cupNet = model.cupNet.map(__v => new game_model.Game(__v));
          }
        }
        get champ() {
          var _a;
          return (_a = this.season) === null || _a === void 0 ? void 0 : _a.champ;
        }
        get country() {
          var _a;
          return (_a = this.champ) === null || _a === void 0 ? void 0 : _a.country;
        }
        get league() {
          var _a;
          return (_a = this.country) === null || _a === void 0 ? void 0 : _a.league;
        }
      }
      exports.Stage = Stage;
    });

    var gameStaff_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GameStaff = void 0;

      class GameStaff {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.role) != undefined) {
            this.role = model.role;
          }
          if ((model === null || model === void 0 ? void 0 : model.user) != undefined) {
            this.user = new user_model.User(model.user);
          }
          if ((model === null || model === void 0 ? void 0 : model.game) != undefined) {
            this.game = new game_model.Game(model.game);
          }
        }
      }
      exports.GameStaff = GameStaff;
    });

    var gamePhoto_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GamePhoto = exports.GamePhotoImg = void 0;
      class GamePhotoImg {
        constructor(url) {
          this.url = url;
          const size = this.url.split('size=')[1].split('&')[0];
          [this.width, this.height] = size.split('x').map(s => parseInt(s));
        }
      }
      exports.GamePhotoImg = GamePhotoImg;
      class GamePhoto {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.thumb) != undefined) {
            this.thumb = new GamePhotoImg(model.thumb);
          }
          if ((model === null || model === void 0 ? void 0 : model.middle) != undefined) {
            this.middle = new GamePhotoImg(model.middle);
          }
          if ((model === null || model === void 0 ? void 0 : model.full) != undefined) {
            this.full = new GamePhotoImg(model.full);
          }
          if ((model === null || model === void 0 ? void 0 : model.hd) != undefined) {
            this.hd = new GamePhotoImg(model.hd);
          }
        }
      }
      exports.GamePhoto = GamePhoto;
    });

    var gamePhotoset_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GamePhotoset = void 0;

      class GamePhotoset {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.url) != undefined) {
            this.url = model.url;
          }
          if ((model === null || model === void 0 ? void 0 : model.cover) != undefined) {
            this.cover = model.cover;
          }
          if ((model === null || model === void 0 ? void 0 : model.photos) != undefined) {
            this.photos = new collection.Collection({ total: model.photos.total, items: model.photos.items.map(_v => new gamePhoto_model.GamePhoto(_v)) });
          }
        }
      }
      exports.GamePhotoset = GamePhotoset;
    });

    var gameEvent_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GameEvent = exports.GameEventExtra = exports.GameEventType = void 0;
      (function (GameEventType) {
        GameEventType[(GameEventType['GAME_STARTED'] = 1)] = 'GAME_STARTED';
        GameEventType[(GameEventType['PART_ENDED'] = 2)] = 'PART_ENDED';
        GameEventType[(GameEventType['GAME_ENDED'] = 3)] = 'GAME_ENDED';
        GameEventType[(GameEventType['COMMENT'] = 9)] = 'COMMENT';
        GameEventType[(GameEventType['F_GOAL'] = 101)] = 'F_GOAL';
        GameEventType[(GameEventType['F_YELLOW'] = 111)] = 'F_YELLOW';
        GameEventType[(GameEventType['F_SECOND_YELLOW'] = 112)] = 'F_SECOND_YELLOW';
        GameEventType[(GameEventType['F_RED'] = 113)] = 'F_RED';
        GameEventType[(GameEventType['F_SHOT'] = 121)] = 'F_SHOT';
        GameEventType[(GameEventType['F_SHOT_MISSED'] = 122)] = 'F_SHOT_MISSED';
        GameEventType[(GameEventType['F_CORNER'] = 123)] = 'F_CORNER';
        GameEventType[(GameEventType['F_DANGER'] = 124)] = 'F_DANGER';
        GameEventType[(GameEventType['F_FOUL'] = 125)] = 'F_FOUL';
        GameEventType[(GameEventType['B_FOUL'] = 211)] = 'B_FOUL';
        GameEventType[(GameEventType['B_TECHNICAL_FOUL'] = 212)] = 'B_TECHNICAL_FOUL';
        GameEventType[(GameEventType['B_SHOT_ONE'] = 221)] = 'B_SHOT_ONE';
        GameEventType[(GameEventType['B_SHOT_TWO'] = 222)] = 'B_SHOT_TWO';
        GameEventType[(GameEventType['B_SHOT_THREE'] = 223)] = 'B_SHOT_THREE';
        GameEventType[(GameEventType['B_MISSED_ONE'] = 231)] = 'B_MISSED_ONE';
        GameEventType[(GameEventType['B_MISSED_TWO'] = 232)] = 'B_MISSED_TWO';
        GameEventType[(GameEventType['B_MISSED_THREE'] = 233)] = 'B_MISSED_THREE';
        GameEventType[(GameEventType['B_REBOUND_A'] = 241)] = 'B_REBOUND_A';
        GameEventType[(GameEventType['B_REBOUND_D'] = 242)] = 'B_REBOUND_D';
        GameEventType[(GameEventType['B_STEAL'] = 243)] = 'B_STEAL';
        GameEventType[(GameEventType['B_LOSS'] = 244)] = 'B_LOSS';
        GameEventType[(GameEventType['V_POINT'] = 301)] = 'V_POINT';
        GameEventType[(GameEventType['V_ACE'] = 302)] = 'V_ACE';
        GameEventType[(GameEventType['V_BLOCK'] = 311)] = 'V_BLOCK';
      })(exports.GameEventType || (exports.GameEventType = {}));
      (function (GameEventExtra) {
        GameEventExtra[(GameEventExtra['OWN_GOAL'] = 1)] = 'OWN_GOAL';
        GameEventExtra[(GameEventExtra['FREE_KICK'] = 2)] = 'FREE_KICK';
        GameEventExtra[(GameEventExtra['PENALTY'] = 3)] = 'PENALTY';
      })(exports.GameEventExtra || (exports.GameEventExtra = {}));
      class GameEvent {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model._id) != undefined) {
            this._id = model._id;
          }
          if ((model === null || model === void 0 ? void 0 : model.type) != undefined) {
            this.type = model.type;
          }
          if ((model === null || model === void 0 ? void 0 : model.team) != undefined) {
            this.team = new team_model.Team(model.team);
          }
          if ((model === null || model === void 0 ? void 0 : model.game) != undefined) {
            this.game = new game_model.Game(model.game);
          }
          if ((model === null || model === void 0 ? void 0 : model.firstPlayer) != undefined) {
            this.firstPlayer = new player_model.Player(model.firstPlayer);
          }
          if ((model === null || model === void 0 ? void 0 : model.secondPlayer) != undefined) {
            this.secondPlayer = new player_model.Player(model.secondPlayer);
          }
          if ((model === null || model === void 0 ? void 0 : model.minute) != undefined) {
            this.minute = model.minute;
          }
          if ((model === null || model === void 0 ? void 0 : model.comment) != undefined) {
            this.comment = model.comment;
          }
          if ((model === null || model === void 0 ? void 0 : model.part) != undefined) {
            this.part = model.part;
          }
        }
      }
      exports.GameEvent = GameEvent;
    });

    var gameVideo_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GameVideo = exports.GameVideoType = void 0;
      var GameVideoType;
      (function (GameVideoType) {
        GameVideoType['youtube'] = 'youtube';
      })((GameVideoType = exports.GameVideoType || (exports.GameVideoType = {})));
      class GameVideo {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model._id) != undefined) {
            this._id = model._id;
          }
          if ((model === null || model === void 0 ? void 0 : model.name) != undefined) {
            this.name = model.name;
          }
          if ((model === null || model === void 0 ? void 0 : model.link) != undefined) {
            this.link = model.link;
          }
          if ((model === null || model === void 0 ? void 0 : model.type) != undefined) {
            this.type = model.type;
          }
          if (!model.type && model.link) {
            if (this.link.indexOf('youtu') !== -1) {
              this.type = GameVideoType.youtube;
            }
          }
        }
        get covers() {
          if (this.type !== GameVideoType.youtube) {
            return { lq: '', mq: '', hq: '' };
          } else {
            const videoId = (this.link.indexOf('youtu.be') !== -1 && this.link.indexOf('youtube.com') === -1 ? this.link.split('youtu.be/')[1] : this.link.split('?v=')[1]).split(
              '&',
            )[0];
            return {
              lq: `https://img.youtube.com/vi/${videoId}/default.jpg`,
              mq: `https://img.youtube.com/vi/${videoId}/mqdefault.jpg`,
              hq: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
            };
          }
        }
      }
      exports.GameVideo = GameVideo;
    });

    var gameWish_model = createCommonjsModule(function (module, exports) {
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GameWish = void 0;
      const dayjs_1 = __importDefault(dayjs_min);

      class GameWish {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.date) != undefined) {
            this.date = (d => dayjs_1.default(d))(model.date);
          }
          if ((model === null || model === void 0 ? void 0 : model.fits) != undefined) {
            this.fits = model.fits;
          }
          if ((model === null || model === void 0 ? void 0 : model.game) != undefined) {
            this.game = new game_model.Game(model.game);
          }
        }
      }
      exports.GameWish = GameWish;
    });

    var helpers = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.lcFirst = exports.ucFirst = void 0;
      function ucFirst(str) {
        return str[0].toUpperCase() + str.slice(1);
      }
      exports.ucFirst = ucFirst;
      function lcFirst(str) {
        return str[0].toLowerCase() + str.slice(1);
      }
      exports.lcFirst = lcFirst;
    });

    var gameSide_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GameSide = void 0;

      class GameSide {
        constructor(game, side) {
          var _a, _b;
          this.players = [];
          this.lineupOptimality = 100;
          this.team = new team_model.Team(game['team' + side]);
          this.score = {
            ft: game['scoreFt' + side],
            pen: game['scorePen' + side],
          };
          if (game['wishes' + side]) {
            this.wishes = {
              slots: (_a = game['wishes' + side]) === null || _a === void 0 ? void 0 : _a.map(w => new gameWish_model.GameWish(w)),
              comment: game['wishesComment' + side],
            };
          }
          this.players = (_b = game['players' + side]) === null || _b === void 0 ? void 0 : _b.map(p => new player_model.Player(p));
          if (game[helpers.lcFirst(side) + 'LineupOptimality']) {
            this.lineupOptimality = game[helpers.lcFirst(side) + 'LineupOptimality'];
          }
          if (game.stateCode === game_model.GameState.CLOSED) {
            const opponentSide = side === 'Home' ? 'Away' : 'Home';
            const opponentScore = {
              ft: game['scoreFt' + opponentSide],
              pen: game['scorePen' + opponentSide],
            };
            if (this.score.ft > opponentScore.ft || this.score.pen > opponentScore.pen) {
              this.isWinner = true;
              this.isLoser = false;
            } else if (this.score.ft < opponentScore.ft || this.score.pen < opponentScore.pen) {
              this.isWinner = false;
              this.isLoser = true;
            } else {
              this.isWinner = false;
              this.isLoser = false;
            }
          }
        }
      }
      exports.GameSide = GameSide;
    });

    var game_model = createCommonjsModule(function (module, exports) {
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Game = exports.GameState = void 0;

      const dayjs_1 = __importDefault(dayjs_min);

      var GameState;
      (function (GameState) {
        GameState[(GameState['NOT_STARTED'] = 0)] = 'NOT_STARTED';
        GameState[(GameState['WISHES'] = 1)] = 'WISHES';
        GameState[(GameState['SCHEDULED'] = 2)] = 'SCHEDULED';
        GameState[(GameState['STARTED'] = 3)] = 'STARTED';
        GameState[(GameState['CLOSED'] = 4)] = 'CLOSED';
      })((GameState = exports.GameState || (exports.GameState = {})));
      class Game extends baseModel.BaseModel {
        constructor(model) {
          super(model);
          this.currentPart = 0;
          this.staff = [];
          this.events = [];
          this.videos = [];
          this.news = [];
          this.previousDuels = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.stage) != undefined) {
            this.stage = new stage_model.Stage(model.stage);
          }
          if ((model === null || model === void 0 ? void 0 : model.stateCode) != undefined) {
            this.state = model.stateCode;
          }
          if ((model === null || model === void 0 ? void 0 : model.currentPart) != undefined) {
            this.currentPart = model.currentPart;
          }
          if ((model === null || model === void 0 ? void 0 : model.date) != undefined) {
            this.date = (d => dayjs_1.default(d))(model.date);
          }
          if ((model === null || model === void 0 ? void 0 : model.tourNumber) != undefined) {
            this.tourNumber = model.tourNumber;
          }
          if ((model === null || model === void 0 ? void 0 : model.netPosition) != undefined) {
            this.netPosition = model.netPosition;
          }
          if ((model === null || model === void 0 ? void 0 : model.techDefeat) != undefined) {
            this.techDefeat = model.techDefeat;
          }
          if ((model === null || model === void 0 ? void 0 : model.manualScore) != undefined) {
            this.manualScore = model.manualScore;
          }
          if ((model === null || model === void 0 ? void 0 : model.home) != undefined) {
            this.home = new gameSide_model.GameSide(model.home);
          }
          if ((model === null || model === void 0 ? void 0 : model.away) != undefined) {
            this.away = new gameSide_model.GameSide(model.away);
          }
          if ((model === null || model === void 0 ? void 0 : model.stadium) != undefined) {
            this.stadium = new stadium_model.Stadium(model.stadium);
          }
          if ((model === null || model === void 0 ? void 0 : model.pitch) != undefined) {
            this.pitch = new pitch_model.Pitch(model.pitch);
          }
          if ((model === null || model === void 0 ? void 0 : model.staff) != undefined) {
            this.staff = model.staff.map(__v => new gameStaff_model.GameStaff(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.events) != undefined) {
            this.events = model.events.map(__v => new gameEvent_model.GameEvent(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.photoset) != undefined) {
            this.photoset = new gamePhotoset_model.GamePhotoset(model.photoset);
          }
          if ((model === null || model === void 0 ? void 0 : model.videos) != undefined) {
            this.videos = model.videos.map(__v => new gameVideo_model.GameVideo(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.news) != undefined) {
            this.news = model.news.map(__v => new post_model.Post(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.previousDuels) != undefined) {
            this.previousDuels = model.previousDuels.map(__v => new Game(__v));
          }
          if (
            (model === null || model === void 0 ? void 0 : model.photoSetUrl) ||
            (model === null || model === void 0 ? void 0 : model.photos) ||
            (model === null || model === void 0 ? void 0 : model.photoCover)
          ) {
            this.photoset = new gamePhotoset_model.GamePhotoset({
              url: model.photoSetUrl,
              photos: model.photos,
              cover: model.photoCover,
            });
          }
          if (model) {
            this.home = new gameSide_model.GameSide(model, 'Home');
            this.away = new gameSide_model.GameSide(model, 'Away');
          }
        }
        get season() {
          var _a;
          return (_a = this.stage) === null || _a === void 0 ? void 0 : _a.season;
        }
        get champ() {
          var _a;
          return (_a = this.season) === null || _a === void 0 ? void 0 : _a.champ;
        }
        get country() {
          var _a;
          return (_a = this.champ) === null || _a === void 0 ? void 0 : _a.country;
        }
        get league() {
          return this.champ.league;
        }
        hasStarted() {
          return this.state > GameState.STARTED;
        }
        hasFinished() {
          return this.state === GameState.CLOSED;
        }
        getTeamSide(t) {
          if (t._id == this.home.team._id) {
            return this.home;
          } else if (t._id == this.away.team._id) {
            return this.away;
          } else {
            console.error('team ' + t.name + ' does not belong to game', t);
            throw new Error('failed to define team side for game');
          }
        }
        getTeamOpponentSide(t) {
          if (t._id == this.home.team._id) {
            return this.away;
          } else if (t._id == this.away.team._id) {
            return this.home;
          } else {
            console.error('team ' + t.name + ' does not belong to game', t);
            throw new Error('failed to define team opponent side for game');
          }
        }
      }
      exports.Game = Game;
    });

    var plural = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.plural = void 0;

      exports.plural = {
        [language.Language.en]: (number, forms) => {
          const n = Math.abs(number);
          return n === 1 ? forms[0] : forms[1];
        },
        [language.Language.ru]: (number, forms) => {
          let n = Math.abs(number);
          n %= 100;
          if (n >= 5 && n <= 20) {
            return forms[2];
          }
          n %= 10;
          if (n === 1) {
            return forms[0];
          }
          if (n >= 2 && n <= 4) {
            return forms[1];
          }
          return forms[2];
        },
      };
    });

    var translations = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.translations = exports.Plural = void 0;

      class Plural {
        constructor(lang, one, two, many) {
          this.lang = lang;
          this.forms = [one, two || one, many || two || one];
        }
        getForm(number) {
          return plural.plural[this.lang](number, this.forms);
        }
      }
      exports.Plural = Plural;
      exports.translations = {
        alert: {
          result_added: {
            [language.Language.en]: 'Result added',
            [language.Language.ru]: 'Добавлен результат',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          date_set: {
            [language.Language.en]: 'Date set',
            [language.Language.ru]: 'Установлена дата',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          article_published: {
            [language.Language.en]: 'New article',
            [language.Language.ru]: 'Новая статья',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          photo_added: {
            [language.Language.en]: 'Photoset added',
            [language.Language.ru]: 'Добавлен фотоотчёт',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          video_added: {
            [language.Language.en]: 'Video added',
            [language.Language.ru]: 'Добавлено видео',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          wishes_open: {
            [language.Language.en]: 'Wishes reception is open',
            [language.Language.ru]: 'Открыт приём пожеланий',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          transfer_confirmed: {
            [language.Language.en]: 'Transfer confirmed',
            [language.Language.ru]: 'Переход подтверждён',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        role: {
          operator: {
            [language.Language.en]: 'Operator',
            [language.Language.ru]: 'Оператор',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          operators: {
            [language.Language.en]: 'Operators',
            [language.Language.ru]: 'Операторы',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          photographer: {
            [language.Language.en]: 'Photographer',
            [language.Language.ru]: 'Фотограф',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          photographers: {
            [language.Language.en]: 'Photographers',
            [language.Language.ru]: 'Фотографы',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          referee: {
            [language.Language.en]: 'Referee',
            [language.Language.ru]: 'Судья',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          referees: {
            [language.Language.en]: 'Referees',
            [language.Language.ru]: 'Судьи',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          journalist: {
            [language.Language.en]: 'Journalist',
            [language.Language.ru]: 'Журналист',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          doctor: {
            [language.Language.en]: 'Doctor',
            [language.Language.ru]: 'Доктор',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          games_served: {
            [language.Language.en]: 'Games Served',
            [language.Language.ru]: 'Игр обслужено',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          avg_mark: {
            [language.Language.en]: 'Average mark',
            [language.Language.ru]: 'Средняя оценка',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        game: {
          games: {
            [language.Language.en]: 'Games',
            [language.Language.ru]: 'Игры',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          game: {
            [language.Language.en]: new Plural(language.Language.ru, 'game', 'games'),
            [language.Language.ru]: new Plural(language.Language.ru, 'матч', 'матча', 'матчей'),
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_game_teams: {
            [language.Language.en]: 'Search by teams in game',
            [language.Language.ru]: 'Поиск по командам в игре',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          date: {
            [language.Language.en]: 'Date',
            [language.Language.ru]: 'Дата',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          upcoming: {
            [language.Language.en]: 'Upcoming',
            [language.Language.ru]: 'Грядущие',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          upcoming_games: {
            [language.Language.en]: 'Upcoming games',
            [language.Language.ru]: 'Ближайшие игры',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          played: {
            [language.Language.en]: 'Results',
            [language.Language.ru]: 'Результаты',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          calendar: {
            [language.Language.en]: 'Calendar',
            [language.Language.ru]: 'Календарь',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          full_calendar: {
            [language.Language.en]: 'Full Calendar',
            [language.Language.ru]: 'Полный календарь',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_games: {
            [language.Language.en]: 'All games',
            [language.Language.ru]: 'Все игры',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          time_not_set: {
            [language.Language.en]: 'Time not set',
            [language.Language.ru]: 'Время не задано',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          td: {
            [language.Language.en]: 'TD',
            [language.Language.ru]: 'ТП',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          not_started: {
            [language.Language.en]: 'Not started',
            [language.Language.ru]: 'Игра не стартовала',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          in_progress: {
            [language.Language.en]: 'Game in progress',
            [language.Language.ru]: 'Игра идёт',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          ended: {
            [language.Language.en]: 'Game ended',
            [language.Language.ru]: 'Игра завершена',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          photo_by: {
            [language.Language.en]: 'Photo by',
            [language.Language.ru]: 'Фотограф',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          with_goals_or_assists: {
            [language.Language.en]: 'With goals or assists',
            [language.Language.ru]: 'С голами или передачами',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          with_goals: {
            [language.Language.en]: 'With goals',
            [language.Language.ru]: 'С голами',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          with_assists: {
            [language.Language.en]: 'With assists',
            [language.Language.ru]: 'С передачами',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          with_cards: {
            [language.Language.en]: 'With cards',
            [language.Language.ru]: 'С карточками',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          season_has_no_games: {
            [language.Language.en]: 'Season has no games yet',
            [language.Language.ru]: 'В сезоне пока нет добавленных игр',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          stats_preview: {
            [language.Language.en]: 'Stats preview',
            [language.Language.ru]: 'Статистическое превью',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          duels_history: {
            [language.Language.en]: 'Duels history',
            [language.Language.ru]: 'История встреч',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          events: {
            events: {
              [language.Language.en]: 'Events',
              [language.Language.ru]: 'Лента событий',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            all_events: {
              [language.Language.en]: 'All events',
              [language.Language.ru]: 'Все события',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            only_main_events: {
              [language.Language.en]: 'Only main events',
              [language.Language.ru]: 'Только основные события',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            point: {
              [language.Language.en]: 'Point',
              [language.Language.ru]: 'Очко',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            ace: {
              [language.Language.en]: 'Ace',
              [language.Language.ru]: 'Эйс',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            block: {
              [language.Language.en]: 'Block',
              [language.Language.ru]: 'Блок',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            steal: {
              [language.Language.en]: 'Steal',
              [language.Language.ru]: 'Перехват',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            loss: {
              [language.Language.en]: 'Loss',
              [language.Language.ru]: 'Потеря',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            foul: {
              [language.Language.en]: 'Foul',
              [language.Language.ru]: 'Фол',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            goal: {
              [language.Language.en]: 'Goal',
              [language.Language.ru]: 'Гол',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            corner: {
              [language.Language.en]: 'Corner kick',
              [language.Language.ru]: 'Угловой',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            danger: {
              [language.Language.en]: 'Attempt',
              [language.Language.ru]: 'Опасный момент',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            shot: {
              [language.Language.en]: 'Shot',
              [language.Language.ru]: 'Удар',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            shot_missed: {
              [language.Language.en]: 'Shot missed',
              [language.Language.ru]: 'Промах',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            game_started: {
              [language.Language.en]: 'Game started',
              [language.Language.ru]: 'Игра началась',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            game_ended: {
              [language.Language.en]: 'Game ended',
              [language.Language.ru]: 'Игра завершена',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            first_half_ended: {
              [language.Language.en]: 'First half ended',
              [language.Language.ru]: 'Первый тайм закончен',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            period_ended: {
              [language.Language.en]: 'Period ended',
              [language.Language.ru]: 'Период завершён',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            quarter_ended: {
              [language.Language.en]: 'Quarter ended',
              [language.Language.ru]: 'Четверть завершена',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            set_ended: {
              [language.Language.en]: 'Set ended',
              [language.Language.ru]: 'Сет завершён',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            unknown: {
              [language.Language.en]: 'Unknown',
              [language.Language.ru]: 'Неизвестный',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            own_goal: {
              [language.Language.en]: 'Own goal',
              [language.Language.ru]: 'Автогол',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            from_free_kick: {
              [language.Language.en]: 'From free kick',
              [language.Language.ru]: 'Со штрафного',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            from_penalty: {
              [language.Language.en]: 'From penalty',
              [language.Language.ru]: 'С пенальти',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          lineup: {
            lineups: {
              [language.Language.en]: 'Lineups',
              [language.Language.ru]: 'Составы',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            optimality: {
              [language.Language.en]: 'Lineup optimality',
              [language.Language.ru]: 'Оптимальность состава',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            lineup_not_set: {
              [language.Language.en]: 'Lineup not set',
              [language.Language.ru]: 'Состав не отмечен',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          preview: {
            stats_preview: {
              [language.Language.en]: 'Preview',
              [language.Language.ru]: 'Превью',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            season_stats: {
              [language.Language.en]: 'Season stats',
              [language.Language.ru]: 'По сезону',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            overall_stats: {
              [language.Language.en]: 'Overall stats',
              [language.Language.ru]: 'Общая статистика',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            last_5_games: {
              [language.Language.en]: 'Last 5 games',
              [language.Language.ru]: 'Последние 5 игр',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            duels: {
              [language.Language.en]: 'Duels',
              [language.Language.ru]: 'Очные встречи',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            wdl: {
              [language.Language.en]: 'W-D-L',
              [language.Language.ru]: 'В-Н-П',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            goals: {
              [language.Language.en]: 'Goals',
              [language.Language.ru]: 'Голы',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            assists: {
              [language.Language.en]: 'Assists',
              [language.Language.ru]: 'Передачи',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            goals_assists: {
              [language.Language.en]: 'Goals + Assists',
              [language.Language.ru]: 'Голы + Передачи',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            yellowCards: {
              [language.Language.en]: 'Yellow cards',
              [language.Language.ru]: 'Жёлтые карточки',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            redCards: {
              [language.Language.en]: 'Red cards',
              [language.Language.ru]: 'Красные карточки',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            points: {
              [language.Language.en]: 'Points',
              [language.Language.ru]: 'Очки',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            fouls: {
              [language.Language.en]: 'Fouls',
              [language.Language.ru]: 'Фолы',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            allFouls: {
              [language.Language.en]: 'Fouls',
              [language.Language.ru]: 'Фолы',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            technicalFouls: {
              [language.Language.en]: 'Technical fouls',
              [language.Language.ru]: 'Технические фолы',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            losses: {
              [language.Language.en]: 'Losses',
              [language.Language.ru]: 'Потери',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            steals: {
              [language.Language.en]: 'Steals',
              [language.Language.ru]: 'Перехваты',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            rebounds: {
              [language.Language.en]: 'Rebounds',
              [language.Language.ru]: 'Подборы',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            reboundsA: {
              [language.Language.en]: 'Attacking rebound',
              [language.Language.ru]: 'Подбор в нападении',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            reboundsD: {
              [language.Language.en]: 'Defencive rebound',
              [language.Language.ru]: 'Подбор в защите',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            misses: {
              [language.Language.en]: 'Misses',
              [language.Language.ru]: 'Промахи',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            blocks: {
              [language.Language.en]: 'Blocked shots',
              [language.Language.ru]: 'Блок-шоты',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            aces: {
              [language.Language.en]: 'Aces',
              [language.Language.ru]: 'Эйсы',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            win_percent: {
              [language.Language.en]: 'Win percent',
              [language.Language.ru]: 'Процент побед',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            played: {
              [language.Language.en]: 'Played',
              [language.Language.ru]: 'Игры',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            rating: {
              [language.Language.en]: 'Rating',
              [language.Language.ru]: 'Рейтинг',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            best_players: {
              [language.Language.en]: 'Best players',
              [language.Language.ru]: 'Лучшие игроки',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            players_stats: {
              [language.Language.en]: 'Players stats',
              [language.Language.ru]: 'Статистика игроков',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            no_stats_yet: {
              [language.Language.en]: 'No stats yet',
              [language.Language.ru]: 'Пока нет статистики',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          wishes: {
            send_wishes: {
              [language.Language.en]: 'Send wishes',
              [language.Language.ru]: 'Отправить пожелания',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            select_preferred_slots: {
              [language.Language.en]: 'Select preferred slots',
              [language.Language.ru]: 'Отметьте желаемые отрезки',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
        },
        media: {
          photos: {
            [language.Language.en]: 'Photos',
            [language.Language.ru]: 'Фото',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          videos: {
            [language.Language.en]: 'Videos',
            [language.Language.ru]: 'Видео',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          media: {
            [language.Language.en]: 'Media',
            [language.Language.ru]: 'Медиа',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          news: {
            [language.Language.en]: 'News',
            [language.Language.ru]: 'Новости',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          newsfeed: {
            [language.Language.en]: 'Newsfeed',
            [language.Language.ru]: 'Лента новостей',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          no_news_found_by_tag: {
            [language.Language.en]: 'No news found by selected tag',
            [language.Language.ru]: 'По выбранному тегу пока нет новостей',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_post_title: {
            [language.Language.en]: 'Search by post title',
            [language.Language.ru]: 'Поиск по заголовку',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          latest_media: {
            [language.Language.en]: 'Latest media',
            [language.Language.ru]: 'Свежие медиа',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          no_photos: {
            [language.Language.en]: 'No photo was uploaded yet',
            [language.Language.ru]: 'Пока не загружено ни одной фотографии',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          no_videos: {
            [language.Language.en]: 'No video was uploaded yet',
            [language.Language.ru]: 'Пока не загружено ни одного видео',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        navigation: {
          back: {
            [language.Language.en]: 'Back',
            [language.Language.ru]: 'Назад',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          prev: {
            [language.Language.en]: 'Prev',
            [language.Language.ru]: 'Назад',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          next: {
            [language.Language.en]: 'Next',
            [language.Language.ru]: 'Дальше',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          done: {
            [language.Language.en]: 'Done',
            [language.Language.ru]: 'Готово',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          cancel: {
            [language.Language.en]: 'Cancel',
            [language.Language.ru]: 'Отмена',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          edit: {
            [language.Language.en]: 'Edit',
            [language.Language.ru]: 'Изменить',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          server_error: {
            [language.Language.en]: 'Server Error',
            [language.Language.ru]: 'Ошибка сервера',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          more: {
            [language.Language.en]: 'plus',
            [language.Language.ru]: 'ещё',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        stadium: {
          stadium: {
            [language.Language.en]: 'Stadium',
            [language.Language.ru]: 'Стадион',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          stadiums: {
            [language.Language.en]: 'Stadiums',
            [language.Language.ru]: 'Стадионы',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_stadium_name: {
            [language.Language.en]: 'Search by stadium name',
            [language.Language.ru]: 'Поиск по названию стадиона',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_stadiums: {
            [language.Language.en]: 'All stadiums',
            [language.Language.ru]: 'Все стадионы',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          overview: {
            [language.Language.en]: 'Overview',
            [language.Language.ru]: 'Информация',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          address: {
            [language.Language.en]: 'Address',
            [language.Language.ru]: 'Адрес',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          see_stadium_location_on_map: {
            [language.Language.en]: 'See stadium location on the map',
            [language.Language.ru]: 'Посмотреть расположение стадиона на карте',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          on_map: {
            [language.Language.en]: 'Map',
            [language.Language.ru]: 'На карте',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          pitch: {
            [language.Language.en]: 'Pitch',
            [language.Language.ru]: 'Поле',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          how_to_get: {
            [language.Language.en]: 'How to get to',
            [language.Language.ru]: 'Как добраться',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          pitches: {
            [language.Language.en]: 'Pitches',
            [language.Language.ru]: 'Поля',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_pitches: {
            [language.Language.en]: 'All pitches',
            [language.Language.ru]: 'Все поля',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          surface: {
            [language.Language.en]: 'Surface',
            [language.Language.ru]: 'Покрытие',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          recommended_shoes: {
            [language.Language.en]: 'Recommended shoes',
            [language.Language.ru]: 'Рекомендуемая обувь',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_pitch_name: {
            [language.Language.en]: 'Search by pitch name',
            [language.Language.ru]: 'Поиск по названию поля',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        player: {
          search_by_player_name: {
            [language.Language.en]: "Search by player's name",
            [language.Language.ru]: 'Поиск по имени игрока',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          players: {
            [language.Language.en]: 'Players',
            [language.Language.ru]: 'Игроки',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_players: {
            [language.Language.en]: 'All players',
            [language.Language.ru]: 'Все игроки',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          player_name: {
            [language.Language.en]: 'Player name',
            [language.Language.ru]: 'Имя игрока',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          career: {
            [language.Language.en]: 'Career',
            [language.Language.ru]: 'Карьера',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          free_agent: {
            [language.Language.en]: 'Free agent',
            [language.Language.ru]: 'Свободный агент',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          birthday: {
            [language.Language.en]: 'Birth Date',
            [language.Language.ru]: 'Дата рождения',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          age: {
            [language.Language.en]: 'Age',
            [language.Language.ru]: 'Возраст',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          y_o: {
            [language.Language.en]: new Plural(language.Language.en, 'y.o'),
            [language.Language.ru]: new Plural(language.Language.ru, 'год', 'года', 'лет'),
            [language.Language.th]: new Plural(language.Language.th, ''),
            [language.Language.ch]: new Plural(language.Language.ch, ''),
          },
          cm: {
            [language.Language.en]: 'cm',
            [language.Language.ru]: 'см',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          kg: {
            [language.Language.en]: 'kg',
            [language.Language.ru]: 'кг',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          height: {
            [language.Language.en]: 'Height',
            [language.Language.ru]: 'Рост',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          weight: {
            [language.Language.en]: 'Weight',
            [language.Language.ru]: 'Вес',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          right_handed: {
            [language.Language.en]: 'Right handed',
            [language.Language.ru]: 'Правша',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          left_handed: {
            [language.Language.en]: 'Left handed',
            [language.Language.ru]: 'Левша',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          right_footed: {
            [language.Language.en]: 'Right footed',
            [language.Language.ru]: 'Правша',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          left_footed: {
            [language.Language.en]: 'Left footed',
            [language.Language.ru]: 'Левша',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          position: {
            [language.Language.en]: 'Position',
            [language.Language.ru]: 'Позиция',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          number: {
            [language.Language.en]: 'Number',
            [language.Language.ru]: 'Номер',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          also_playing_in: {
            [language.Language.en]: 'Also playing in',
            [language.Language.ru]: 'Также играет в',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          stats: {
            goals: {
              [language.Language.en]: new Plural(language.Language.en, 'goal', 'goals'),
              [language.Language.ru]: new Plural(language.Language.ru, 'гол', 'гола', 'голов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            assists: {
              [language.Language.en]: new Plural(language.Language.en, 'assist', 'assists'),
              [language.Language.ru]: new Plural(language.Language.ru, 'пас', 'паса', 'пасов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            goals_assists: {
              [language.Language.en]: new Plural(language.Language.en, 'point', 'points'),
              [language.Language.ru]: new Plural(language.Language.ru, 'очко', 'очка', 'очков'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            yellowCards: {
              [language.Language.en]: new Plural(language.Language.en, 'y.c.'),
              [language.Language.ru]: new Plural(language.Language.ru, 'ж.к.'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            redCards: {
              [language.Language.en]: new Plural(language.Language.en, 'r.c.'),
              [language.Language.ru]: new Plural(language.Language.ru, 'к.к.'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            points: {
              [language.Language.en]: new Plural(language.Language.en, 'point', 'points'),
              [language.Language.ru]: new Plural(language.Language.ru, 'очко', 'очка', 'очков'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            fouls: {
              [language.Language.en]: new Plural(language.Language.en, 'foul', 'fouls'),
              [language.Language.ru]: new Plural(language.Language.ru, 'фол', 'фола', 'фолов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            allFouls: {
              [language.Language.en]: new Plural(language.Language.en, 'foul', 'fouls'),
              [language.Language.ru]: new Plural(language.Language.ru, 'фол', 'фола', 'фолов'),
              [language.Language.th]: new Plural(language.Language.en, ''),
              [language.Language.ch]: new Plural(language.Language.en, ''),
            },
            technicalFouls: {
              [language.Language.en]: new Plural(language.Language.en, 'foul', 'fouls'),
              [language.Language.ru]: new Plural(language.Language.ru, 'фол', 'фола', 'фолов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            losses: {
              [language.Language.en]: new Plural(language.Language.en, 'loss', 'losses'),
              [language.Language.ru]: new Plural(language.Language.ru, 'потеря', 'потери', 'потерь'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            steals: {
              [language.Language.en]: new Plural(language.Language.en, 'steal', 'steals'),
              [language.Language.ru]: new Plural(language.Language.ru, 'перехват', 'перехвата', 'перехватов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            rebounds: {
              [language.Language.en]: new Plural(language.Language.en, 'rebound', 'rebounds'),
              [language.Language.ru]: new Plural(language.Language.ru, 'подбор', 'подбора', 'подборов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            reboundsA: {
              [language.Language.en]: new Plural(language.Language.en, 'rebound', 'rebounds'),
              [language.Language.ru]: new Plural(language.Language.ru, 'подбор', 'подбора', 'подборов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            reboundsD: {
              [language.Language.en]: new Plural(language.Language.en, 'rebound', 'rebounds'),
              [language.Language.ru]: new Plural(language.Language.ru, 'подбор', 'подбора', 'подборов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            misses: {
              [language.Language.en]: new Plural(language.Language.en, 'miss', 'misses'),
              [language.Language.ru]: new Plural(language.Language.ru, 'промах', 'промаха', 'промахов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            blocks: {
              [language.Language.en]: new Plural(language.Language.en, 'block', 'blocks'),
              [language.Language.ru]: new Plural(language.Language.ru, 'блок', 'блока', 'блоков'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            aces: {
              [language.Language.en]: new Plural(language.Language.en, 'ace', 'aces'),
              [language.Language.ru]: new Plural(language.Language.ru, 'эйс', 'эйса', 'эйсов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
          },
        },
        standings: {
          table: {
            [language.Language.en]: 'Table',
            [language.Language.ru]: 'Таблица',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          place: {
            [language.Language.en]: 'Place',
            [language.Language.ru]: 'Место',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          pos: {
            [language.Language.en]: 'Pos',
            [language.Language.ru]: 'Поз',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          name: {
            [language.Language.en]: 'Name',
            [language.Language.ru]: 'Название',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          gms: {
            [language.Language.en]: 'G',
            [language.Language.ru]: 'И',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          wdl: {
            [language.Language.en]: 'W-D-L',
            [language.Language.ru]: 'В-Н-П',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          wl: {
            [language.Language.en]: 'W-L',
            [language.Language.ru]: 'В-П',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          gd: {
            [language.Language.en]: 'GD',
            [language.Language.ru]: 'ЗП',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          pts: {
            [language.Language.en]: 'P',
            [language.Language.ru]: 'О',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          win_percent: {
            [language.Language.en]: 'W%',
            [language.Language.ru]: 'П%',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          form: {
            [language.Language.en]: 'Form',
            [language.Language.ru]: 'Форма',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        news: {
          tags: {
            [language.Language.en]: 'Tags',
            [language.Language.ru]: 'Тэги',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          related_posts: {
            [language.Language.en]: 'Related posts',
            [language.Language.ru]: 'Похожие новости',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        position: {
          all_positions: {
            [language.Language.en]: 'All positions',
            [language.Language.ru]: 'Все позиции',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          football: {
            goalkeeper: {
              [language.Language.en]: 'Goalkeeper',
              [language.Language.ru]: 'Вратарь',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            goalkeepers: {
              [language.Language.en]: 'Goalkeepers',
              [language.Language.ru]: 'Вратари',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            defender: {
              [language.Language.en]: 'Defender',
              [language.Language.ru]: 'Защитник',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            defenders: {
              [language.Language.en]: 'Defenders',
              [language.Language.ru]: 'Защитники',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            midfielder: {
              [language.Language.en]: 'Midfielder',
              [language.Language.ru]: 'Полузащитник',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            midfielders: {
              [language.Language.en]: 'Midfielders',
              [language.Language.ru]: 'Полузащитники',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            versatile: {
              [language.Language.en]: 'Versatile',
              [language.Language.ru]: 'Универсал',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            striker: {
              [language.Language.en]: 'Striker',
              [language.Language.ru]: 'Нападающий',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            strikers: {
              [language.Language.en]: 'Strikers',
              [language.Language.ru]: 'Нападающие',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          basketball: {
            center: {
              [language.Language.en]: 'Center',
              [language.Language.ru]: 'Центровой',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            point_guard: {
              [language.Language.en]: 'Point Guard',
              [language.Language.ru]: 'Разыгрывающий защитник',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            shooting_guard: {
              [language.Language.en]: 'Shooting Guard',
              [language.Language.ru]: 'Атакующий защитник',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            power_forward: {
              [language.Language.en]: 'Power forward',
              [language.Language.ru]: 'Тяжёлый форвард',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          hockey: {
            goalie: {
              [language.Language.en]: 'Goalie',
              [language.Language.ru]: 'Вратарь',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            defenceman: {
              [language.Language.en]: 'Defenceman',
              [language.Language.ru]: 'Защитник',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            winger: {
              [language.Language.en]: 'Winger',
              [language.Language.ru]: 'Крайний нападающий',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            centre: {
              [language.Language.en]: 'Centre',
              [language.Language.ru]: 'Центральный нападающий',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          volleyball: {
            setter: {
              [language.Language.en]: 'Setter',
              [language.Language.ru]: 'Связующий',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            libero: {
              [language.Language.en]: 'Libero',
              [language.Language.ru]: 'Либеро',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            middle_blocker: {
              [language.Language.en]: 'Middle Blocker',
              [language.Language.ru]: 'Центральный блокирующий',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            opposite_hitter: {
              [language.Language.en]: 'Opposite Hitter',
              [language.Language.ru]: 'Диагональный',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            outside_hitter: {
              [language.Language.en]: 'Outside Hitter',
              [language.Language.ru]: 'Доигровщик',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
        },
        global_search: {
          global_search: {
            [language.Language.en]: 'Search (teams, players, tournaments, games, stadiums)',
            [language.Language.ru]: 'Поиск (команды, игроки, турниры, игры, стадионы)',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          global_search_description: {
            [language.Language.en]: 'Search for teams, players, tournaments or games in all leagues and countries',
            [language.Language.ru]: 'Ищите игроков, команды, турниры и игры во всех лигах и городах',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_cities: {
            [language.Language.en]: 'All cities',
            [language.Language.ru]: 'Все города',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_leagues: {
            [language.Language.en]: 'All leagues',
            [language.Language.ru]: 'Все лиги',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        search: {
          search: {
            [language.Language.en]: 'Search',
            [language.Language.ru]: 'Поиск',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          nothing_found: {
            [language.Language.en]: 'Nothing found',
            [language.Language.ru]: 'Ничего не найдено',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        team: {
          teams: {
            [language.Language.en]: 'Teams',
            [language.Language.ru]: 'Команды',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          team: {
            [language.Language.en]: 'Team',
            [language.Language.ru]: 'Команда',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          founded: {
            [language.Language.en]: 'Founded',
            [language.Language.ru]: 'Основана',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          rating: {
            [language.Language.en]: 'Rating',
            [language.Language.ru]: 'Рейтинг',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_team_name: {
            [language.Language.en]: 'Search by team name',
            [language.Language.ru]: 'Поиск по названию команды',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_teams: {
            [language.Language.en]: 'All teams',
            [language.Language.ru]: 'Все команды',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          stats: {
            stats: {
              [language.Language.en]: 'Stats',
              [language.Language.ru]: 'Статистика',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            gms: {
              [language.Language.en]: 'P',
              [language.Language.ru]: 'И',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            played: {
              [language.Language.en]: 'P',
              [language.Language.ru]: 'И',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            goals: {
              [language.Language.en]: 'G',
              [language.Language.ru]: 'Г',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            points: {
              [language.Language.en]: 'P',
              [language.Language.ru]: 'О',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            assists: {
              [language.Language.en]: 'A',
              [language.Language.ru]: 'П',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            points_per_game: {
              [language.Language.en]: 'Ppg',
              [language.Language.ru]: 'О/и',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            assists_per_game: {
              [language.Language.en]: 'Apg',
              [language.Language.ru]: 'А/и',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            blocks_per_game: {
              [language.Language.en]: 'Bpg',
              [language.Language.ru]: 'Б/и',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            rebounds_per_game: {
              [language.Language.en]: 'Rpg',
              [language.Language.ru]: 'П/и',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          parent_team: {
            [language.Language.en]: 'Parent team',
            [language.Language.ru]: 'Основа',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          reserve_team: {
            [language.Language.en]: 'Reserve team',
            [language.Language.ru]: 'Дубль',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          roster: {
            [language.Language.en]: 'Roster',
            [language.Language.ru]: 'Заявка',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          change_roster: {
            [language.Language.en]: 'Change roster',
            [language.Language.ru]: 'Изменить заявку',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          create_new_player: {
            [language.Language.en]: 'Create new player',
            [language.Language.ru]: 'Создать нового игрока',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          edit_player_profile: {
            [language.Language.en]: 'Edit player profile',
            [language.Language.ru]: 'Изменить профиль игрока',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          request_transfer: {
            [language.Language.en]: 'Request transfer',
            [language.Language.ru]: 'Запросить трансфер',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          create_player: {
            [language.Language.en]: 'Create player',
            [language.Language.ru]: 'Создать игрока',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          remove_from_roster: {
            [language.Language.en]: 'Remove from roster',
            [language.Language.ru]: 'Удалить из заявки',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          team_has_no_players: {
            [language.Language.en]: 'Team has no players',
            [language.Language.ru]: 'У команды нет игроков',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          top_players: {
            [language.Language.en]: 'Top players',
            [language.Language.ru]: 'Лучшие игроки',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          chemistry: {
            [language.Language.en]: 'Chemistry',
            [language.Language.ru]: 'Химия',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          no_stats_yet: {
            [language.Language.en]: 'No stats yet',
            [language.Language.ru]: 'Пока нет статистики',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          avg_age: {
            [language.Language.en]: 'Avg. age',
            [language.Language.ru]: 'Ср. возраст',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        sports: {
          all_sports: {
            [language.Language.en]: 'All sports',
            [language.Language.ru]: 'Все виды спорта',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          football: {
            [language.Language.en]: 'Football',
            [language.Language.ru]: 'Футбол',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          beach_soccer: {
            [language.Language.en]: 'Beach soccer',
            [language.Language.ru]: 'Пляжный футбол',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          volleyball: {
            [language.Language.en]: 'Volleyball',
            [language.Language.ru]: 'Воллейбол',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          basketball: {
            [language.Language.en]: 'Basketball',
            [language.Language.ru]: 'Баскетбол',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          water_polo: {
            [language.Language.en]: 'Water polo',
            [language.Language.ru]: 'Водное поло',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          hockey: {
            [language.Language.en]: 'Hockey',
            [language.Language.ru]: 'Хоккей',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        champ: {
          search_by_league_or_city: {
            [language.Language.en]: 'Search by league or city',
            [language.Language.ru]: 'Поиск по лиге или городу',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_city_name: {
            [language.Language.en]: 'Search by city name',
            [language.Language.ru]: 'Поиск по названию города',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_tournament_name: {
            [language.Language.en]: 'Search by tournament name',
            [language.Language.ru]: 'Поиск по названию турнира',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          total_rating: {
            [language.Language.en]: 'Total rating',
            [language.Language.ru]: 'Глобальный рейтинг',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          champ: {
            [language.Language.en]: 'Tournament',
            [language.Language.ru]: 'Турнир',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          champ_is_finished: {
            [language.Language.en]: 'Tournament is finished',
            [language.Language.ru]: 'Турнир завершён',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          champs: {
            [language.Language.en]: 'Tournaments',
            [language.Language.ru]: 'Турниры',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_champs: {
            [language.Language.en]: 'All tournaments',
            [language.Language.ru]: 'Все турниры',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          league_champs: {
            [language.Language.en]: 'League',
            [language.Language.ru]: 'Турниры лиги',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          pinned_champs: {
            [language.Language.en]: 'Pinned',
            [language.Language.ru]: 'Закреплённые',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          no_pinned_champs: {
            [language.Language.en]: "You haven't marked any tournament yet. Press star icon to pin tournament on top of the screen",
            [language.Language.ru]: 'У вас пока нет сохранённых турниров. Нажмите на звёздочу у турнира чтобы закрепить его вверху экрана',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          season: {
            [language.Language.en]: 'Season',
            [language.Language.ru]: 'Сезон',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          seasons: {
            [language.Language.en]: 'Seasons',
            [language.Language.ru]: 'Сезоны',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          stage_has_no_games: {
            [language.Language.en]: 'Stage has no games yet',
            [language.Language.ru]: 'В стадии пока не добавлено ни одной игры',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_champ_name: {
            [language.Language.en]: 'Search by champ name',
            [language.Language.ru]: 'Поиск по названию турнира',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_stage_name: {
            [language.Language.en]: 'Search by stage name',
            [language.Language.ru]: 'Поиск по названию стадии',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_stages: {
            [language.Language.en]: 'All stages',
            [language.Language.ru]: 'Все стадии',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_countries: {
            [language.Language.en]: 'All championships',
            [language.Language.ru]: 'Все чемпионаты',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          happy_birthday: {
            [language.Language.en]: 'Happy birthday!',
            [language.Language.ru]: 'С днём рождения!',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        documents: {
          documents: {
            [language.Language.en]: 'Documents',
            [language.Language.ru]: 'Документы',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_document_title: {
            [language.Language.en]: 'Search by document title',
            [language.Language.ru]: 'Поиск по названию документа',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        contacts: {
          [language.Language.en]: 'Contacts',
          [language.Language.ru]: 'Контакты',
          [language.Language.th]: '',
          [language.Language.ch]: '',
        },
        days: {
          [language.Language.en]: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
          [language.Language.ru]: ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'],
          [language.Language.th]: '',
          [language.Language.ch]: '',
        },
        days_long: {
          [language.Language.en]: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
          [language.Language.ru]: ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота', 'Воскресенье'],
          [language.Language.th]: '',
          [language.Language.ch]: '',
        },
        months: {
          [language.Language.en]: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
          [language.Language.ru]: ['Янв', 'Фев', 'Мар', 'Апр', 'Мая', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
          [language.Language.th]: ['', '', '', '', '', '', '', '', '', '', '', ''],
          [language.Language.ch]: ['', '', '', '', '', '', '', '', '', '', '', ''],
        },
        months_full: {
          [language.Language.en]: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
          [language.Language.ru]: ['Января', 'Февраля', 'Марта', 'Апреля', 'Мая', 'Июня', 'Июля', 'Августа', 'Сентября', 'Октября', 'Ноября', 'Декабря'],
          [language.Language.th]: ['', '', '', '', '', '', '', '', '', '', '', ''],
          [language.Language.ch]: ['', '', '', '', '', '', '', '', '', '', '', ''],
        },
        round: {
          [language.Language.en]: 'round',
          [language.Language.ru]: 'тур',
          [language.Language.th]: '',
          [language.Language.ch]: '',
        },
        cup_rounds: {
          [language.Language.en]: [
            'final',
            'semifinal',
            'quarterfinal',
            '1/8 final',
            '1/16 final',
            '1/32 final',
            '1/64 final',
            '1/128 final',
            '1/3 final',
            '1/6 final',
            '1/12 final',
            'for 3rd place',
          ],
          [language.Language.ru]: [
            'финал',
            'полуфинал',
            'четвертьфинал',
            '1/8 финала',
            '1/16 финала',
            '1/32 финала',
            '1/64 финала',
            '1/128 финала',
            '1/3 финала',
            '1/6 финала',
            '1/12 финала',
            'за 3 место',
          ],
          [language.Language.th]: ['', '', '', '', '', '', '', '', '', '', '', ''],
          [language.Language.ch]: ['', '', '', '', '', '', '', '', '', '', '', ''],
        },
        transfers: {
          transfers: {
            [language.Language.en]: 'transfers',
            [language.Language.ru]: 'трансферы',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          all_transfers: {
            [language.Language.en]: 'All transfers',
            [language.Language.ru]: 'Все трансферы',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_by_player_or_team: {
            [language.Language.en]: 'Search by player or team',
            [language.Language.ru]: 'Поиск по игроку или команде',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          since: {
            [language.Language.en]: 'Since',
            [language.Language.ru]: 'С',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          till: {
            [language.Language.en]: 'Till',
            [language.Language.ru]: 'По',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          direction: {
            incoming: {
              [language.Language.en]: 'incoming',
              [language.Language.ru]: 'на вход',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            outgoing: {
              [language.Language.en]: 'outgoing',
              [language.Language.ru]: 'на выход',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            to: {
              [language.Language.en]: 'to',
              [language.Language.ru]: 'в',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            from: {
              [language.Language.en]: 'from',
              [language.Language.ru]: 'из',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          types: {
            roster_remove: {
              [language.Language.en]: 'removed from roster',
              [language.Language.ru]: 'удалён из заявки',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            create: {
              [language.Language.en]: 'created',
              [language.Language.ru]: 'создан',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            transfer: {
              [language.Language.en]: 'transfer',
              [language.Language.ru]: 'переход',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            combination: {
              [language.Language.en]: 'combination',
              [language.Language.ru]: 'совмещение',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            combine: {
              [language.Language.en]: 'combination',
              [language.Language.ru]: 'совмещение',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            stop_loan: {
              [language.Language.en]: 'combination finished',
              [language.Language.ru]: 'конец совмещения',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            free_transfer: {
              [language.Language.en]: 'Free transfer',
              [language.Language.ru]: 'переход свободного агента',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          transfer_window_closed: {
            [language.Language.en]: 'Transfer window is closed',
            [language.Language.ru]: 'Окно переходов закрыто',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          send_request: {
            [language.Language.en]: 'Send  request',
            [language.Language.ru]: 'Отправить запрос',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        load_more: {
          [language.Language.en]: 'Load more',
          [language.Language.ru]: 'Загрузить ещё',
          [language.Language.th]: '',
          [language.Language.ch]: '',
        },
        last_update: {
          [language.Language.en]: 'Updated',
          [language.Language.ru]: 'Обновлено',
          [language.Language.th]: '',
          [language.Language.ch]: '',
        },
        app_update: {
          updates_to_be_installed: {
            [language.Language.en]: 'Some internal updates have to be installed. Please wait.',
            [language.Language.ru]: 'Необходимо установить некоторые внутренние обновления. Пожалуйста, подождите немного.',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          downloading_updates: {
            [language.Language.en]: 'Downloading updates...',
            [language.Language.ru]: 'Загрузка обновлений...',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          extracting_updates: {
            [language.Language.en]: 'Extracting updates...',
            [language.Language.ru]: 'Установка обновлений...',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        league: {
          info: {
            players: {
              [language.Language.en]: new Plural(language.Language.en, 'Player', 'Players'),
              [language.Language.ru]: new Plural(language.Language.ru, 'Игрок', 'Игрока', 'Игроков'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            total_rating: {
              [language.Language.en]: 'Total rating',
              [language.Language.ru]: 'Общий рейтинг',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            teams: {
              [language.Language.en]: new Plural(language.Language.en, 'Team', 'Teams'),
              [language.Language.ru]: new Plural(language.Language.ru, 'Команда', 'Команды', 'Команд'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            stadiums: {
              [language.Language.en]: new Plural(language.Language.en, 'Stadium', 'Stadiums'),
              [language.Language.ru]: new Plural(language.Language.ru, 'Стадион', 'Стадиона', 'Стадионов'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            games: {
              [language.Language.en]: new Plural(language.Language.en, 'Game', 'Games'),
              [language.Language.ru]: new Plural(language.Language.ru, 'Игра', 'Игры', 'Игр'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
            champs: {
              [language.Language.en]: new Plural(language.Language.en, 'Champ', 'Champs'),
              [language.Language.ru]: new Plural(language.Language.ru, 'Турнир', 'Турнира', 'Турниров'),
              [language.Language.th]: new Plural(language.Language.th, ''),
              [language.Language.ch]: new Plural(language.Language.ch, ''),
            },
          },
          league: {
            [language.Language.en]: 'League',
            [language.Language.ru]: 'Лига',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          select_league: {
            [language.Language.en]: 'Select league',
            [language.Language.ru]: 'Выберите лигу',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          hall_of_fame: {
            [language.Language.en]: 'Hall of fame',
            [language.Language.ru]: 'Зал славы',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        log_in: {
          welcome_phrase: {
            please: {
              [language.Language.en]: 'Please',
              [language.Language.ru]: 'Пожалуйста',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            sign_in: {
              [language.Language.en]: 'sign in',
              [language.Language.ru]: 'войдите',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            to_personalize_feed: {
              [language.Language.en]: 'to personalize your newsfeed adn subscribe to favorite teams and players',
              [language.Language.ru]: 'чтобы настроить собственную ленту новостей и подписаться на любимых игроков и команды',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            provide_name: {
              [language.Language.en]: 'Please provide your name so we can find associated player profiles ',
              [language.Language.ru]: 'Пожалуйста укажите своё имя, чтобы мы могли найти связанные профили игроков',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            search_for_more_subscriptions: {
              [language.Language.en]: 'Search players and teams',
              [language.Language.ru]: 'Поиск игроков и команд',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            we_found_subscriptions: {
              [language.Language.en]:
                "We've found some subscriptions for you. Remove checkmark from entities that you aren't interested in. Use search to add more players and teams to follow.",
              [language.Language.ru]:
                'Мы нашли для Вас несколько подписок. Удалите галочку у тех, которые Вас не интересуют. Воспользуйтесь поиском чтобы добавить игроков и команды, за которыми хотите следить',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            no_found_subscriptions: {
              [language.Language.en]:
                'No player profiles with your name found. Go back to edit name or city or add subscriptions manually using search. You can also skip this step and add subscriptions later',
              [language.Language.ru]: 'Мы не смогли найти игроков с вашим именем. Вернитесь назад чтобы именить имя/город, или',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            subscribe_ok: {
              [language.Language.en]: 'Great! Now you are subscribed to selected items. Allow push notifications to catch all latest updates',
              [language.Language.ru]: 'Супер! Теперь вы подписаны на выбранные элементы. Разрешите пуш-уведомления чтобы быть в курсе всех обновлений',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            subscribe_nothing: {
              [language.Language.en]: 'No subscriptions created. No worries - you can add them later. Allow push notifications to receive important updates',
              [language.Language.ru]:
                'Вы пока ни на что не подписаны. Ничего страшного, вы сможете добавить подписки в любой момент. Включите пуш-уведомления, чтобы не пропустить важные обновления',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          account_search: {
            searching_for_your_player_accounts: {
              [language.Language.en]: 'Searching for your player accounts...',
              [language.Language.ru]: 'Ищем ваши аккаунты игроков...',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            no_accounts_found: {
              [language.Language.en]: 'No player records with your name found.',
              [language.Language.ru]: 'Не найдено игроков с вашим именем',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            try: {
              [language.Language.en]: 'Try to',
              [language.Language.ru]: 'Попробуйте',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            change_name_or_city: {
              [language.Language.en]: 'change name or city',
              [language.Language.ru]: 'изменить имя или город',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            or: {
              [language.Language.en]: 'or',
              [language.Language.ru]: 'или',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
            manually_search_players_teams: {
              [language.Language.en]: 'Manually search for players and teams you want to follow',
              [language.Language.ru]: 'Вручную найдите игроков и команды, за которыми хотите следить',
              [language.Language.th]: '',
              [language.Language.ch]: '',
            },
          },
          phone_number: {
            [language.Language.en]: 'Your phone number',
            [language.Language.ru]: 'Ваш номер телефона',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          incorrect_phone_format: {
            [language.Language.en]: 'Incorrect phone format',
            [language.Language.ru]: 'Некорректный формат телефона',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          no_user_with_phone_found: {
            [language.Language.en]: 'No user with such phone found',
            [language.Language.ru]: 'Пользователь с этим номером не найден',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          send_sms: {
            [language.Language.en]: 'Send SMS',
            [language.Language.ru]: 'Послать СМС',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          code_from_sms: {
            [language.Language.en]: 'Code from SMS',
            [language.Language.ru]: 'Код из СМС',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          code_should_have_6_digits: {
            [language.Language.en]: 'Code should be 6 digits long',
            [language.Language.ru]: 'Код должен быть длиной в 6 символов',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          incorrect_code: {
            [language.Language.en]: 'Incorrect code',
            [language.Language.ru]: 'Неверный код',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          or_sign_in_with: {
            [language.Language.en]: 'Or sign in with',
            [language.Language.ru]: 'Или войдите через',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          ive_read_and_accepted: {
            [language.Language.en]: "I've read and agreed with",
            [language.Language.ru]: 'Я прочитал и принял',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          read: {
            [language.Language.en]: 'Read',
            [language.Language.ru]: 'Читать',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          license_agreement: {
            [language.Language.en]: 'License agreement',
            [language.Language.ru]: 'Пользовательское соглашение',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          cookie_policy: {
            [language.Language.en]: 'Cookie policy',
            [language.Language.ru]: 'Использование cookies',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          accept_and_continue: {
            [language.Language.en]: 'Accept and continue',
            [language.Language.ru]: 'Принять и продолжить',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          log_out: {
            [language.Language.en]: 'Log out',
            [language.Language.ru]: 'Выйти',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          login: {
            [language.Language.en]: 'Login',
            [language.Language.ru]: 'Логин',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        favorites: {
          personal_newsfeed: {
            [language.Language.en]: 'Personal newsfeed',
            [language.Language.ru]: 'Лента новостей',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          news_by_tags: {
            [language.Language.en]: 'Displayed news by following tags',
            [language.Language.ru]: 'Показаны новости по тегам',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          subscribed_to: {
            [language.Language.en]: 'Subscribed to',
            [language.Language.ru]: 'Подписки',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          subscribed: {
            [language.Language.en]: 'subscribed',
            [language.Language.ru]: 'вы подписаны',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          notifications_enabled: {
            [language.Language.en]: 'Browser notifications enabled',
            [language.Language.ru]: 'Уведомления браузера включены',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          click_to_subscribe_team: {
            [language.Language.en]: 'CLick on this icon to add team to favorites',
            [language.Language.ru]: 'Кликните на эту иконку чтобы добавить команду в любимые',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          click_to_subscribe_player: {
            [language.Language.en]: 'CLick on this icon to add player to favorites',
            [language.Language.ru]: 'Кликните на эту иконку чтобы добавить игрока в любимые',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          new_subscription: {
            [language.Language.en]: 'New subscription',
            [language.Language.ru]: 'Новая подписка',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        validators: {
          field_cannot_be_empty: {
            [language.Language.en]: 'Field cannot be empty',
            [language.Language.ru]: 'Поле не может быть пустым',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          should_be_positive_number: {
            [language.Language.en]: 'Should be positive number',
            [language.Language.ru]: 'Число должно быть больше ноля',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          invalid_date_format: {
            [language.Language.en]: 'Invalid date format',
            [language.Language.ru]: 'Неверный формат даты',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          invalid_time_format: {
            [language.Language.en]: 'Invalid time format',
            [language.Language.ru]: 'Неверный формат времени',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          allowed_range: {
            [language.Language.en]: 'Allowed range',
            [language.Language.ru]: 'Разрешённый диапазон',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          phone_should_start_with_plus: {
            [language.Language.en]: 'Number should start with plus sign',
            [language.Language.ru]: 'Номер должен начинаться со знака плюс',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          invalid_phone_format: {
            [language.Language.en]: 'Invalid phone format',
            [language.Language.ru]: 'Неверный формат телефона',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          code_should_have_6_digits: {
            [language.Language.en]: 'Code should be 6 digits long',
            [language.Language.ru]: 'Код должен быть 6 символов в длину',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        explore: {
          explore: {
            [language.Language.en]: 'Explore',
            [language.Language.ru]: 'Поиск',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          recommended: {
            [language.Language.en]: 'Recommended',
            [language.Language.ru]: 'Рекомендовано',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        profile: {
          profile: {
            [language.Language.en]: 'Profile',
            [language.Language.ru]: 'Профиль',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          profile_info: {
            [language.Language.en]: 'Profile info',
            [language.Language.ru]: 'Инфо профиля',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          edit_profile: {
            [language.Language.en]: 'Edit Profile',
            [language.Language.ru]: 'Настройки профиля',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          name: {
            [language.Language.en]: 'Your name',
            [language.Language.ru]: 'Ваше имя',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          city: {
            [language.Language.en]: 'Your city',
            [language.Language.ru]: 'Ваш город',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          app_info: {
            [language.Language.en]: 'App info',
            [language.Language.ru]: 'Данные приложения',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          version: {
            [language.Language.en]: 'Version',
            [language.Language.ru]: 'Версия',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          subscriptions: {
            [language.Language.en]: 'Subscriptions',
            [language.Language.ru]: 'Подписки',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          new_subscriptions: {
            [language.Language.en]: 'New subscription',
            [language.Language.ru]: 'Новая подписка',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          manage_subscriptions: {
            [language.Language.en]: 'Manage subscriptions',
            [language.Language.ru]: 'Управление подписками',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          current_subscriptions: {
            [language.Language.en]: 'Current subscriptions',
            [language.Language.ru]: 'Текущие подписки',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          found_subscriptinos: {
            [language.Language.en]: 'Found subscriptions',
            [language.Language.ru]: 'Найденные подписки',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          no_subscriptions: {
            [language.Language.en]: 'No subscriptions added. Find favorite teams and players to receive related news',
            [language.Language.ru]: 'Подписки не добавлены. Найдите любимые команы и игроков чтобы получать новости о них',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          search_teams_or_players: {
            [language.Language.en]: 'Search teams or players by name',
            [language.Language.ru]: 'Ищите команду или игрока по имени',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          language: {
            [language.Language.en]: 'Language',
            [language.Language.ru]: 'Язык',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          unsubscribe: {
            [language.Language.en]: 'Unsubscribe',
            [language.Language.ru]: 'Отписаться',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          subscribe: {
            [language.Language.en]: 'Subscribe',
            [language.Language.ru]: 'Подписаться',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          tap_to_edit_photo: {
            [language.Language.en]: 'Tap to upload photo',
            [language.Language.ru]: 'Нажмите чтобы загрузить фото',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          pushes_enabled: {
            [language.Language.en]: 'Push notifications',
            [language.Language.ru]: 'Пуш-уведомления',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          error_registering_push: {
            [language.Language.en]: 'Token registration error',
            [language.Language.ru]: 'Ошибка регистрации токена',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          theme: {
            [language.Language.en]: 'Color theme',
            [language.Language.ru]: 'Цветовая тема',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          theme_light: {
            [language.Language.en]: 'Light',
            [language.Language.ru]: 'Светлая',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          theme_dark: {
            [language.Language.en]: 'Dark',
            [language.Language.ru]: 'Тёмная',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          theme_system: {
            [language.Language.en]: 'System',
            [language.Language.ru]: 'Системная',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
          logout: {
            [language.Language.en]: 'Log out',
            [language.Language.ru]: 'Выйти',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
        igraphics: {
          quote: {
            [language.Language.en]: 'Quote',
            [language.Language.ru]: 'Цитата',
            [language.Language.th]: '',
            [language.Language.ch]: '',
          },
        },
      };
    });

    var alert_model = createCommonjsModule(function (module, exports) {
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Alert = exports.AlertType = void 0;

      const dayjs_1 = __importDefault(dayjs_min);

      var AlertType;
      (function (AlertType) {
        AlertType[(AlertType['result'] = 0)] = 'result';
        AlertType[(AlertType['date'] = 1)] = 'date';
        AlertType[(AlertType['transfer'] = 2)] = 'transfer';
        AlertType[(AlertType['article'] = 3)] = 'article';
        AlertType[(AlertType['photo'] = 4)] = 'photo';
        AlertType[(AlertType['video'] = 5)] = 'video';
        AlertType[(AlertType['wish'] = 6)] = 'wish';
      })((AlertType = exports.AlertType || (exports.AlertType = {})));
      class Alert extends baseModel.BaseModel {
        constructor(model) {
          super(model);
          this.tags = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.type) != undefined) {
            this.type = model.type;
          }
          if ((model === null || model === void 0 ? void 0 : model.date) != undefined) {
            this.date = (d => dayjs_1.default(d))(model.date);
          }
          if ((model === null || model === void 0 ? void 0 : model.game) != undefined) {
            this.game = new game_model.Game(model.game);
          }
          if ((model === null || model === void 0 ? void 0 : model.title) != undefined) {
            this.articleTitle = model.title;
          }
          if ((model === null || model === void 0 ? void 0 : model.photoId) != undefined) {
            this.photoId = model.photoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.tags) != undefined) {
            this.tags = model.tags.map(__v => new tag_model.Tag(__v));
          }
        }
        get title() {
          if (this.type === AlertType.result) {
            return translations.translations.alert.result_added;
          } else if (this.type === AlertType.date) {
            return translations.translations.alert.date_set;
          } else if (this.type === AlertType.article) {
            return translations.translations.alert.article_published;
          } else if (this.type === AlertType.photo) {
            return translations.translations.alert.photo_added;
          } else if (this.type === AlertType.video) {
            return translations.translations.alert.video_added;
          } else if (this.type === AlertType.wish) {
            return translations.translations.alert.wishes_open;
          }
        }
      }
      exports.Alert = Alert;
    });

    var bannerVisibilityKey_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.BannerVisibilityKey = void 0;

      class BannerVisibilityKey {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.client) != undefined) {
            this.client = new appClient_model.AppClient(model.client);
          }
          if ((model === null || model === void 0 ? void 0 : model.league) != undefined) {
            this.league = new league_model.League(model.league);
          }
        }
      }
      exports.BannerVisibilityKey = BannerVisibilityKey;
    });

    var bannerDisplayStats_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.BannerDisplayStats = void 0;
      class BannerDisplayStats {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.origin) != undefined) {
            this.origin = model.origin;
          }
          if ((model === null || model === void 0 ? void 0 : model.displayed) != undefined) {
            this.displayed = model.displayed;
          }
          if ((model === null || model === void 0 ? void 0 : model.clicked) != undefined) {
            this.clicked = model.clicked;
          }
        }
      }
      exports.BannerDisplayStats = BannerDisplayStats;
    });

    var banner_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.Banner = exports.BannerSlotCode = void 0;
      (function (BannerSlotCode) {
        BannerSlotCode['mobile_game'] = 'MOBILE_GAME';
        BannerSlotCode['site_header'] = 'SITE_HEADER';
        BannerSlotCode['site_footer'] = 'SITE_FOOTER';
        BannerSlotCode['site_left_bar'] = 'SITE_LEFT_BAR';
        BannerSlotCode['site_main_page'] = 'SITE_MAIN_PAGE';
      })(exports.BannerSlotCode || (exports.BannerSlotCode = {}));
      class Banner extends sortableModel.SortableModel {
        constructor(model) {
          super(model);
          this.visibilityKeys = [];
          this.stats = [];
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.slotCode) != undefined) {
            this.slotCode = model.slotCode;
          }
          if ((model === null || model === void 0 ? void 0 : model.link) != undefined) {
            this.link = model.link;
          }
          if ((model === null || model === void 0 ? void 0 : model.description) != undefined) {
            this.description = model.description;
          }
          if ((model === null || model === void 0 ? void 0 : model.photoId) != undefined) {
            this.photoId = model.photoId;
          }
          if ((model === null || model === void 0 ? void 0 : model.visibilityKeys) != undefined) {
            this.visibilityKeys = model.visibilityKeys.map(__v => new bannerVisibilityKey_model.BannerVisibilityKey(__v));
          }
          if ((model === null || model === void 0 ? void 0 : model.stats) != undefined) {
            this.stats = model.stats.map(__v => new bannerDisplayStats_model.BannerDisplayStats(__v));
          }
        }
      }
      exports.Banner = Banner;
    });

    var globalSearchResult_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GlobalSearchResult =
        exports.isGlobalSearchResultGame =
        exports.isGlobalSearchResultChamp =
        exports.isGlobalSearchResultLeague =
        exports.isGlobalSearchResultPerson =
        exports.isGlobalSearchResultStadium =
        exports.isGlobalSearchResultPlayer =
        exports.isGlobalSearchResultTeam =
        exports.GlobalSearchResultType =
          void 0;

      var GlobalSearchResultType;
      (function (GlobalSearchResultType) {
        GlobalSearchResultType['team'] = 'team';
        GlobalSearchResultType['player'] = 'player';
        GlobalSearchResultType['tournament'] = 'tournament';
        GlobalSearchResultType['stadium'] = 'stadium';
        GlobalSearchResultType['person'] = 'person';
        GlobalSearchResultType['league'] = 'league';
        GlobalSearchResultType['game'] = 'game';
      })((GlobalSearchResultType = exports.GlobalSearchResultType || (exports.GlobalSearchResultType = {})));
      const isGlobalSearchResultTeam = r => {
        return r.type === GlobalSearchResultType.team;
      };
      exports.isGlobalSearchResultTeam = isGlobalSearchResultTeam;
      const isGlobalSearchResultPlayer = r => {
        return r.type === GlobalSearchResultType.player;
      };
      exports.isGlobalSearchResultPlayer = isGlobalSearchResultPlayer;
      const isGlobalSearchResultStadium = r => {
        return r.type === GlobalSearchResultType.stadium;
      };
      exports.isGlobalSearchResultStadium = isGlobalSearchResultStadium;
      const isGlobalSearchResultPerson = r => {
        return r.type === GlobalSearchResultType.person;
      };
      exports.isGlobalSearchResultPerson = isGlobalSearchResultPerson;
      const isGlobalSearchResultLeague = r => {
        return r.type === GlobalSearchResultType.league;
      };
      exports.isGlobalSearchResultLeague = isGlobalSearchResultLeague;
      const isGlobalSearchResultChamp = r => {
        return r.type === GlobalSearchResultType.tournament;
      };
      exports.isGlobalSearchResultChamp = isGlobalSearchResultChamp;
      const isGlobalSearchResultGame = r => {
        return r.type === GlobalSearchResultType.game;
      };
      exports.isGlobalSearchResultGame = isGlobalSearchResultGame;
      class GlobalSearchResult {
        constructor(type, item) {
          this.type = type;
          if (this.type == GlobalSearchResultType.game) {
            this.item = new game_model.Game(item);
          } else if (this.type == GlobalSearchResultType.league) {
            this.item = new league_model.League(item);
          } else if (this.type == GlobalSearchResultType.person) {
            this.item = new user_model.User(item);
          } else if (this.type == GlobalSearchResultType.player) {
            this.item = new player_model.Player(item);
          } else if (this.type == GlobalSearchResultType.stadium) {
            this.item = new stadium_model.Stadium(item);
          } else if (this.type == GlobalSearchResultType.team) {
            this.item = new team_model.Team(item);
          } else if (this.type == GlobalSearchResultType.tournament) {
            this.item = new champ_model.Champ(item);
          }
        }
      }
      exports.GlobalSearchResult = GlobalSearchResult;
    });

    var licenseAgreement_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.LicenseAgreement = exports.LicenseAgreementToken = void 0;
      class LicenseAgreementToken {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.type) != undefined) {
            this.type = model.type;
          }
          if ((model === null || model === void 0 ? void 0 : model.text) != undefined) {
            this.text = model.text;
          }
        }
      }
      exports.LicenseAgreementToken = LicenseAgreementToken;
      class LicenseAgreement {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.language) != undefined) {
            this.language = model.language;
          }
          if ((model === null || model === void 0 ? void 0 : model.tokens) != undefined) {
            this.tokens = model.tokens.map(__v => new LicenseAgreementToken(__v));
          }
        }
      }
      exports.LicenseAgreement = LicenseAgreement;
    });

    var cookiePolicy_model = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.CookiePolicy = void 0;

      class CookiePolicy {
        constructor(model) {
          this.isFtbModel = true;
          if ((model === null || model === void 0 ? void 0 : model.language) != undefined) {
            this.language = model.language;
          }
          if ((model === null || model === void 0 ? void 0 : model.tokens) != undefined) {
            this.tokens = model.tokens.map(__v => new licenseAgreement_model.LicenseAgreementToken(__v));
          }
        }
      }
      exports.CookiePolicy = CookiePolicy;
    });

    var models = createCommonjsModule(function (module, exports) {
      var __createBinding =
        (commonjsGlobal && commonjsGlobal.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (commonjsGlobal && commonjsGlobal.__exportStar) ||
        function (m, exports) {
          for (var p in m) if (p !== 'default' && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      __exportStar(language, exports);
      __exportStar(collection, exports);
      __exportStar(sports, exports);
      __exportStar(cupRound, exports);
      __exportStar(alert_model, exports);
      __exportStar(appClient_model, exports);
      __exportStar(banner_model, exports);
      __exportStar(bannerDisplayStats_model, exports);
      __exportStar(bannerVisibilityKey_model, exports);
      __exportStar(blacklistRecord_model, exports);
      __exportStar(champ_model, exports);
      __exportStar(champContact_model, exports);
      __exportStar(city_model, exports);
      __exportStar(country_model, exports);
      __exportStar(disqualification_model, exports);
      __exportStar(document_model, exports);
      __exportStar(game_model, exports);
      __exportStar(gameEvent_model, exports);
      __exportStar(gamePhoto_model, exports);
      __exportStar(gamePhotoset_model, exports);
      __exportStar(gameSide_model, exports);
      __exportStar(gameStaff_model, exports);
      __exportStar(gameVideo_model, exports);
      __exportStar(gameWish_model, exports);
      __exportStar(globalSearchResult_model, exports);
      __exportStar(ipData_model, exports);
      __exportStar(league_model, exports);
      __exportStar(licenseAgreement_model, exports);
      __exportStar(cookiePolicy_model, exports);
      __exportStar(pitch_model, exports);
      __exportStar(player_model, exports);
      __exportStar(playerCareer_model, exports);
      __exportStar(playerGame_model, exports);
      __exportStar(post_model, exports);
      __exportStar(role_model, exports);
      __exportStar(season_model, exports);
      __exportStar(seasonPlayerStats_model, exports);
      __exportStar(stadium_model, exports);
      __exportStar(stage_model, exports);
      __exportStar(stageEvent_model, exports);
      __exportStar(tableRow_model, exports);
      __exportStar(tag_model, exports);
      __exportStar(team_model, exports);
      __exportStar(teamStats_model, exports);
      __exportStar(teamPlayerStats_model, exports);
      __exportStar(teamTopPlayers_model, exports);
      __exportStar(transferRequest_model, exports);
      __exportStar(user_model, exports);
      __exportStar(userDevice_model, exports);
      __exportStar(userSubsciption_model, exports);
      __exportStar(userRecommendation_model, exports);
    });

    var browser$1 = createCommonjsModule(function (module, exports) {
      // ref: https://github.com/tc39/proposal-global
      var getGlobal = function () {
        // the only reliable means to get the global object is
        // `Function('return this')()`
        // However, this causes CSP violations in Chrome apps.
        if (typeof self !== 'undefined') {
          return self;
        }
        if (typeof window !== 'undefined') {
          return window;
        }
        if (typeof global !== 'undefined') {
          return global;
        }
        throw new Error('unable to locate global object');
      };

      var global = getGlobal();

      module.exports = exports = global.fetch;

      // Needed for TypeScript and Webpack.
      if (global.fetch) {
        exports.default = global.fetch.bind(global);
      }

      exports.Headers = global.Headers;
      exports.Request = global.Request;
      exports.Response = global.Response;
    });

    const appendToMap = (map, propName, value) => {
      const items = map.get(propName);
      if (!items) {
        map.set(propName, [value]);
      } else if (!items.includes(value)) {
        items.push(value);
      }
    };
    const debounce = (fn, ms) => {
      let timeoutId;
      return (...args) => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
          timeoutId = 0;
          fn(...args);
        }, ms);
      };
    };

    /**
     * Check if a possible element isConnected.
     * The property might not be there, so we check for it.
     *
     * We want it to return true if isConnected is not a property,
     * otherwise we would remove these elements and would not update.
     *
     * Better leak in Edge than to be useless.
     */
    const isConnected = maybeElement => !('isConnected' in maybeElement) || maybeElement.isConnected;
    const cleanupElements = debounce(map => {
      for (let key of map.keys()) {
        map.set(key, map.get(key).filter(isConnected));
      }
    }, 2000);
    const stencilSubscription = ({ on }) => {
      const elmsToUpdate = new Map();
      if (typeof getRenderingRef === 'function') {
        // If we are not in a stencil project, we do nothing.
        // This function is not really exported by @stencil/core.
        on('dispose', () => {
          elmsToUpdate.clear();
        });
        on('get', propName => {
          const elm = getRenderingRef();
          if (elm) {
            appendToMap(elmsToUpdate, propName, elm);
          }
        });
        on('set', propName => {
          const elements = elmsToUpdate.get(propName);
          if (elements) {
            elmsToUpdate.set(propName, elements.filter(forceUpdate$1));
          }
          cleanupElements(elmsToUpdate);
        });
        on('reset', () => {
          elmsToUpdate.forEach(elms => elms.forEach(forceUpdate$1));
          cleanupElements(elmsToUpdate);
        });
      }
    };

    const createObservableMap = (defaultState, shouldUpdate = (a, b) => a !== b) => {
      let states = new Map(Object.entries(defaultState !== null && defaultState !== void 0 ? defaultState : {}));
      const handlers = {
        dispose: [],
        get: [],
        set: [],
        reset: [],
      };
      const reset = () => {
        states = new Map(Object.entries(defaultState !== null && defaultState !== void 0 ? defaultState : {}));
        handlers.reset.forEach(cb => cb());
      };
      const dispose = () => {
        // Call first dispose as resetting the state would
        // cause less updates ;)
        handlers.dispose.forEach(cb => cb());
        reset();
      };
      const get = propName => {
        handlers.get.forEach(cb => cb(propName));
        return states.get(propName);
      };
      const set = (propName, value) => {
        const oldValue = states.get(propName);
        if (shouldUpdate(value, oldValue, propName)) {
          states.set(propName, value);
          handlers.set.forEach(cb => cb(propName, value, oldValue));
        }
      };
      const state =
        typeof Proxy === 'undefined'
          ? {}
          : new Proxy(defaultState, {
              get(_, propName) {
                return get(propName);
              },
              ownKeys(_) {
                return Array.from(states.keys());
              },
              getOwnPropertyDescriptor() {
                return {
                  enumerable: true,
                  configurable: true,
                };
              },
              has(_, propName) {
                return states.has(propName);
              },
              set(_, propName, value) {
                set(propName, value);
                return true;
              },
            });
      const on = (eventName, callback) => {
        handlers[eventName].push(callback);
        return () => {
          removeFromArray(handlers[eventName], callback);
        };
      };
      const onChange = (propName, cb) => {
        const unSet = on('set', (key, newValue) => {
          if (key === propName) {
            cb(newValue);
          }
        });
        const unReset = on('reset', () => cb(defaultState[propName]));
        return () => {
          unSet();
          unReset();
        };
      };
      const use = (...subscriptions) =>
        subscriptions.forEach(subscription => {
          if (subscription.set) {
            on('set', subscription.set);
          }
          if (subscription.get) {
            on('get', subscription.get);
          }
          if (subscription.reset) {
            on('reset', subscription.reset);
          }
        });
      const forceUpdate = key => {
        const oldValue = states.get(key);
        handlers.set.forEach(cb => cb(key, oldValue, oldValue));
      };
      return {
        state,
        get,
        set,
        on,
        onChange,
        use,
        dispose,
        reset,
        forceUpdate,
      };
    };
    const removeFromArray = (array, item) => {
      const index = array.indexOf(item);
      if (index >= 0) {
        array[index] = array[array.length - 1];
        array.length--;
      }
    };

    const createStore = (defaultState, shouldUpdate) => {
      const map = createObservableMap(defaultState, shouldUpdate);
      stencilSubscription(map);
      return map;
    };

    var dist$1 = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      createObservableMap: createObservableMap,
      createStore: createStore,
    });

    var store_1 = /*@__PURE__*/ getAugmentedNamespace(dist$1);

    var user_store = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.onUserStateChange = exports.userState = void 0;

      const store = store_1.createStore(new user_model.User({ language: language.Language.default }));
      exports.userState = store.state;
      exports.onUserStateChange = store.onChange;
    });

    var env_store = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.onEnvStateChange = exports.envState = void 0;

      const store = store_1.createStore({
        envMode: 'production',
        appKey: 'AFL_RU',
        version: '0.0.0',
        releasedDate: '01.01.2021',
        coreVersion: '5',
        graphqlHost: '',
        apiHost: '',
        statsHost: '',
        imgHost: '',
        localHost: '',
        ipApiKey: '',
        appMode: 'plain',
        appFlowUpdateAvailable: false,
        platform: 'web',
        systemAppTheme: 'light',
        os: 'unknown',
        hostsScheme: {
          test: {
            DEFAULT: {
              api: 'http://localhost:3001/api',
              stats: 'http://localhost:3002/stats',
              img: 'http://localhost:3001/api',
              graphql: 'http://localhost:3004/graphql',
            },
          },
          dev: {
            DEFAULT: {
              api: 'http://localhost:3001/api',
              stats: 'http://localhost:3002/stats',
              img: 'http://localhost:3001/api',
              graphql: 'http://localhost:3004/graphql',
            },
          },
          prod: {
            AFL_ARM: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            AFL_BY: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            AFL_KZ: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            AFL_RU: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            AFL_TH: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            AFL_UA: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            AFL_UZ: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            AFL_CR: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            AFL_PL: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            AFL_PETR: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            BS_MSK: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
            F_LEAGUE: {
              graphql: 'https://footballista.ru/graphql',
              api: 'https://footballista.ru/api',
              stats: 'https://footballista.ru/stats',
              img: 'https://footballista.ru/img',
            },
          },
        },
      });
      exports.envState = store.state;
      exports.onEnvStateChange = store.onChange;
      exports.onEnvStateChange('envMode', mode => {
        if (mode === 'test' || mode === 'dev') {
          assignHosts(mode, 'DEFAULT');
        }
      });
      user_store.onUserStateChange('league', league => {
        if (exports.envState.envMode === 'production' && exports.envState.hostsScheme[league.appClient.key]) {
          assignHosts('production', league.appClient.key);
        }
      });
      function assignHosts(envMode, key) {
        exports.envState.graphqlHost = exports.envState.hostsScheme[envMode][key].graphql;
        exports.envState.apiHost = exports.envState.hostsScheme[envMode][key].api;
        exports.envState.statsHost = exports.envState.hostsScheme[envMode][key].stats;
        exports.envState.imgHost = exports.envState.hostsScheme[envMode][key].img;
      }
    });

    var http_client = createCommonjsModule(function (module, exports) {
      var __createBinding =
        (commonjsGlobal && commonjsGlobal.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (commonjsGlobal && commonjsGlobal.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, 'default', { enumerable: true, value: v });
            }
          : function (o, v) {
              o['default'] = v;
            });
      var __importStar =
        (commonjsGlobal && commonjsGlobal.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.HttpClient = void 0;
      const node_fetch_1 = __importStar(browser$1);

      class HttpClient {
        constructor() {}
        load(urlOrOptions, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const options = typeof urlOrOptions == 'string' ? { method: 'GET', url: urlOrOptions, host: '' } : urlOrOptions;
            if (!options.host) options.host = '';
            options.url = options.host + options.url;
            if (!options.headers) options.headers = new node_fetch_1.Headers();
            options.headers.append('AppKey', env_store.envState.appKey);
            options.headers.append('AppVersion', env_store.envState.coreVersion);
            options.headers.append('ClientLanguage', user_store.userState.language);
            if (!options.headers.has('Content-Type')) {
              options.headers.append('Content-Type', 'application/json');
            }
            if (user_store.userState.token) {
              options.headers.append('Authorization', 'Bearer ' + user_store.userState.token);
            }
            const call = typeof window === 'undefined' ? node_fetch_1.default : fetch;
            try {
              const response = yield call(options.url, {
                method: options.method.toUpperCase(),
                mode: 'cors',
                cache: 'no-cache',
                credentials: 'omit',
                headers: options.headers,
                redirect: 'error',
                body: JSON.stringify(options.body),
                signal: abortSignal,
              });
              if (!response.ok) throw response;
              const contentType = response.headers.get('content-type');
              if (contentType && contentType.includes('json')) {
                return yield response.json();
              } else {
                return response.blob();
              }
            } catch (e) {
              console.error(e);
              throw e;
            }
          });
        }
      }
      exports.HttpClient = HttpClient;
    });

    var graphql_client = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GraphqlClient = void 0;

      class GraphqlClient {
        load(query, key, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const body = { query: '{ ' + query + ' }' };
            const headers = new browser$1.Headers();
            headers.append('Content-Type', 'application/json');
            const url = (key || '') + '?query=query {' + query + ' }';
            return (yield new http_client.HttpClient().load(
              {
                method: 'POST',
                host: env_store.envState.graphqlHost,
                url,
                headers,
                body,
              },
              abortSignal,
            )).data;
          });
        }
      }
      exports.GraphqlClient = GraphqlClient;
    });

    var team_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.TeamTiles = exports.TeamService = void 0;

      class TeamService {
        loadBaseTeamInfo(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
      }`,
              'team-base-info',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamInfo(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.stats}
        ${exports.TeamTiles.roster}
        ${exports.TeamTiles.seasons()}
        ${exports.TeamTiles.games(0, 15)}
        ${exports.TeamTiles.news(0, 16)}
        ${exports.TeamTiles.photoGames(0, 16)}
        ${exports.TeamTiles.videoGames(0, 16)}
        ${exports.TeamTiles.transfers(0, 10)}
        ${exports.TeamTiles.topPlayers(0, 5)}
      }`,
              'team-info',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamRoster(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.roster}
      }`,
              'team-roster',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamMedia(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.news()}
        ${exports.TeamTiles.photoGames()}
        ${exports.TeamTiles.videoGames()}
      }
    `,
              'team-media',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamNews(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.news()}
      }
    `,
              'team-news',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamPhotos(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.photoGames()}
      }
    `,
              'team-photos',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamVideos(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.videoGames()}
      }
    `,
              'team-videos',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamGames(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.games()}
      }
    `,
              'team-games',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamSeasons(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.seasons()}
      }
    `,
              'team-seasons',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamTransfers(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.transfers()}
      }
    `,
              'team-transfers',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamTopPlayers(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.topPlayers()}
      }
    `,
              'team-top-players',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
        loadTeamPlayersStats(teamId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Team(_id: ${teamId}) {
        ${exports.TeamTiles.info}
        ${exports.TeamTiles.fullPlayersStats}
      }
    `,
              'team-players-stats',
              abortSignal,
            );
            return new team_model.Team(response['Team']);
          });
        }
      }
      exports.TeamService = TeamService;
      exports.TeamTiles = {
        info: `
    _id
    name
    logo
    logoId
    hasPhoto
    rating
    parentTeam { _id, name, logo, logoId }
    reserveTeam { _id, name, logo, logoId }
    league { _id, name, sports }
  `,
        stats: `
    stats { games, won, draw, lost, scored, conceded, winPercent }
  `,
        roster: `
    players {
        _id
        firstName
        middleName
        lastName
        birthdayDate
        photoId
        position
        number
        teams {
          _id
          logo
          logoId
          name
        }
      }
  `,
        fullPlayersStats: `fullPlayersStats {
       player { _id, firstName, lastName, photoId }
       played
       won
       draw
       lost
       goals
       assists
       yellowCards
       redCards
       teamScored
       teamConceded
       chemistry {
          player { _id, firstName, lastName, photoId }
          value
       }
    }`,
        seasons: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `seasons(${params}) {
      total, items {
        _id
        name
        inProgress
        sortIdx
        champ {
          _id
          name
          sortIdx
          country {
            _id
            name
            flag
            sortIdx
          }
        }
        stages {
          _id
          name
          format
          sortIdx
          teamsInStage {
            _id
            position
            team {
              _id
            }
          }
        }
      }
    }`;
        },
        news: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `news(${params}) {
      total, items {
        _id
        title
        photoId
      }
    }`;
        },
        photoGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `gamesWithPhotos(${params}) {
      total, items {
        ${game_service.GameTiles.info}
        photoCover
      }
    }`;
        },
        videoGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `gamesWithVideos(${params}) {
      total, items {
        ${game_service.GameTiles.info}
        videos { name, link }
      }
    }`;
        },
        games: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `games(${params}) {
      total, items {
        ${game_service.GameTiles.info}
        stage { _id, name, season { _id, name, champ { _id, name  country { _id, name } } } }
      }
    }`;
        },
        transfers: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `transfers(${params}) {
      total, items {
        _id
        type
        player { _id, firstName, lastName, photoId }
        fromTeam { _id, name, shortName, logo, logoId }
        toTeam { _id, name, shortName, logo, logoId }
        adminConfirmedTimestamp
      }
    }`;
        },
        topPlayers: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `topPlayers(${params}) {
      games { value, player { _id, firstName, lastName, photoId } }
      goals { value, player { _id, firstName, lastName, photoId } }
      assists { value, player { _id, firstName, lastName, photoId } }
      goals_assists { value, player { _id, firstName, lastName, photoId } }
      connection { value, firstPlayer { _id, firstName, lastName, photoId },  secondPlayer { _id, firstName, lastName, photoId } }
    }`;
        },
      };
    });

    var game_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GameTiles = exports.GameService = void 0;

      class GameService {
        constructor() {}
        loadFullGameInfo(gameId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Game(_id: ${gameId}) {
        ${exports.GameTiles.info}
        ${exports.GameTiles.lineup}
        ${exports.GameTiles.events}
        ${exports.GameTiles.media_preview}
        ${exports.GameTiles.staff}
      }`,
              'game-info',
              abortSignal,
            );
            return new game_model.Game(response['Game']);
          });
        }
        loadGamePreview(gameId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Game(_id: ${gameId}) {
        ${exports.GameTiles.info}
        ${exports.GameTiles.preview()}
      }`,
              'game-preview',
              abortSignal,
            );
            return new game_model.Game(response['Game']);
          });
        }
        loadGameMedia(gameId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Game(_id: ${gameId}) {
        ${exports.GameTiles.info}
        ${exports.GameTiles.media}
      }`,
              'game-media',
              abortSignal,
            );
            return new game_model.Game(response['Game']);
          });
        }
        loadGamePhotos(gameId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Game(_id: ${gameId}) {
        ${exports.GameTiles.info}
        ${exports.GameTiles.photos}
      }`,
              'game-photos',
              abortSignal,
            );
            return new game_model.Game(response['Game']);
          });
        }
        loadGameVideos(gameId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Game(_id: ${gameId}) {
        ${exports.GameTiles.info}
        ${exports.GameTiles.videos}
      }`,
              'game-videos',
              abortSignal,
            );
            return new game_model.Game(response['Game']);
          });
        }
      }
      exports.GameService = GameService;
      exports.GameTiles = {
        info: `
    _id
    stateCode
    scoreFtHome
    scoreFtAway
    scorePenHome
    scorePenAway
    techDefeat
    date
    photoCover
    tourNumber
    stage {
      _id, name, format, season {
        _id, name, champ {
          _id, name, country {
            _id, name, flag, league {
              _id, name, sports
            }
          }
        }
      }
    }
    stadium { _id, name }
    pitch { _id, name }
    teamHome { _id, shortName, name, logo, logoId }
    teamAway { _id, shortName, name, logo, logoId }
  `,
        staff: `staff { _id, role, user { _id, name, photoId } }`,
        media_preview: `
    videos { _id, link, name, type, thumbnail }
    photos(limit:18) {
      total
      items {
        thumb
        middle
      }
    }`,
        media: `
    photos { total, items { thumb, middle, full, hd } }
    videos { link, name }
  `,
        photos: `
    photos { total, items { thumb, middle, full, hd } }
  `,
        videos: `
    videos { link, name }
  `,
        lineup: `
    homeLineupOptimality
    awayLineupOptimality
    teamHome { _id, shortName, name, logo, logoId, players { _id, photoId, firstName, middleName, lastName, number, position } }
    teamAway { _id, shortName, name, logo, logoId, players { _id, photoId, firstName, middleName, lastName, number, position } }
    playersHome { _id, firstName, lastName, photoId, number, position }
    playersAway { _id, firstName, lastName, photoId, number, position }
  `,
        events: `events {
          _id
          type
          minute
          comment
          part
          extra
          team { _id }
          firstPlayer { _id, firstName, lastName, number }
          secondPlayer { _id, firstName, lastName, number }
  }`,
        preview: () => `
    teamHome {
      _id
      rating
      ${team_service.TeamTiles.games(0, 15)}
      ${team_service.TeamTiles.stats}
    }
    teamAway {
      _id
      rating
      ${team_service.TeamTiles.games(0, 15)}
      ${team_service.TeamTiles.stats}
    }
    stage {
      table { _id,  shortName, name, logo, logoId, label, position, games, w, d, l, winPercent, scored, conceded, winPercent, points, form }
    }
    previousDuels {
      _id
      stateCode
      teamHome { _id, name, shortName, logo, logoId }
      teamAway { _id, name, shortName, logo, logoId}
      date
      tourNumber
      stadium { _id, name }
      stage { _id, name, format, season { _id, name, champ { _id, name } } }
      scoreFtHome
      scoreFtAway
      scorePenHome
      scorePenAway
    }
  `,
      };
    });

    var globalSearch_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.GlobalSearchService = void 0;

      class GlobalSearchService {
        constructor() {}
        search(query, leagueId, cityId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const cityStr = cityId ? '&cityId=' + cityId : '';
            const leagueStr = leagueId ? '&leagueId=' + leagueId : '';
            const response = yield new http_client.HttpClient().load(env_store.envState.apiHost + `/search?query=${query}${cityStr}${leagueStr}`, abortSignal);
            return response.map(row => new globalSearchResult_model.GlobalSearchResult(row.type, row.item));
          });
        }
      }
      exports.GlobalSearchService = GlobalSearchService;
    });

    var ip_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.IpService = void 0;

      const node_fetch_1 = __importDefault(browser$1);
      class IpService {
        constructor() {}
        getIpData(abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const apiKey = env_store.envState.ipApiKey;
            if (!apiKey) throw new Error('Cannot retrieve ip data - "ipApiKey" not set in environment');
            const call = typeof window === 'undefined' ? node_fetch_1.default : fetch;
            try {
              const response = yield call(`https://api.ipapi.com/api/check?access_key=${apiKey}&format=1`, {
                method: 'GET',
                mode: 'cors',
                cache: 'no-cache',
                credentials: 'omit',
                redirect: 'error',
                signal: abortSignal,
              });
              if (!response.ok) throw response;
              const parsedResponse = yield response.json();
              return new ipData_model.IpData(parsedResponse);
            } catch (e) {
              console.error(e);
              throw e;
            }
          });
        }
      }
      exports.IpService = IpService;
    });

    var league_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.LeagueTiles = exports.LeagueService = void 0;

      class LeagueService {
        loadLeagues(abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League_list {
            _id
            name
            sortIdx
            sports
            city { _id, name, flag, sortIdx }
            client { _id, key, name }
      }`,
              'leagues-list',
              abortSignal,
            );
            return response['League_list'].map(l => new league_model.League(l));
          });
        }
        /**
         * @param leagueId
         * @param previewMode - load only "first page" items for each collection property
         */
        loadLeagueInfo(leagueId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        ${exports.LeagueTiles.overview}
        ${exports.LeagueTiles.teams(20)}
        ${exports.LeagueTiles.news(0, 16)}
        ${exports.LeagueTiles.photoGames(0, 20)}
        ${exports.LeagueTiles.videoGames(0, 20)}
        ${exports.LeagueTiles.documents(20)}
        ${exports.LeagueTiles.stadiums(20)}
        ${exports.LeagueTiles.champs}
        ${exports.LeagueTiles.contacts}
        ${exports.LeagueTiles.partners}
      }`,
              'league-info',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        loadLeagueTeams(leagueId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        sports
        ${exports.LeagueTiles.teams()}
      }`,
              'league-teams',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        loadLeagueStadiums(leagueId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        ${exports.LeagueTiles.stadiums()}
      }`,
              'league-stadiums',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        loadLeagueNews(leagueId, offset, limit, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        ${exports.LeagueTiles.news(offset, limit)}
      }`,
              'league-news',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        loadLeaguePhotoGames(leagueId, offset, limit, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        ${exports.LeagueTiles.photoGames(offset, limit)}
      }`,
              'league-photo-games',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        loadLeagueVideoGames(leagueId, offset, limit, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        ${exports.LeagueTiles.videoGames(offset, limit)}
      }`,
              'league-video-games',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        loadLeagueDocuments(leagueId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        ${exports.LeagueTiles.documents()}
      }`,
              'league-documents',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        loadLeagueChamps(leagueId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        ${exports.LeagueTiles.champs}
      }`,
              'league-champs',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        loadLeagueBirthdays(leagueId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        ${exports.LeagueTiles.birthdays}
      }`,
              'league-birthdays',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        searchLeagueNews(leagueId, query, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        ${exports.LeagueTiles.searchNews(query)}
      }`,
              'league-news-search',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        searchLeaguePhotoGames(leagueId, query, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        ${exports.LeagueTiles.searchGamesWithPhotos(query)}
      }`,
              'league-photo-search',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
        searchLeagueVideoGames(leagueId, query, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `League(_id: ${leagueId}) {
        _id
        name
        ${exports.LeagueTiles.searchGamesWithVideos(query)}
      }`,
              'league-video-search',
              abortSignal,
            );
            return new league_model.League(response['League']);
          });
        }
      }
      exports.LeagueService = LeagueService;
      exports.LeagueTiles = {
        overview: `
    _id
    name
    logoId
    linkVk
    linkFb
    linkWeb
    linkIg
    linkTelegram
    linkYoutube
    city { _id, name, flag, sortIdx }
    client { _id, key, name }
    stats {
      champs
      teams
      rating
      players
      stadiums
      games
    }
  `,
        news: (offset = 0, limit = 10) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `news(${params}) {
      total, items {
        _id
        title
        photoId
      }
    }`;
        },
        photoGames: (offset = 0, limit = 10) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `gamesWithPhotos(${params}) {
      total, items {
        ${game_service.GameTiles.info}
        photoCover
      }
    }`;
        },
        videoGames: (offset = 0, limit = 10) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `gamesWithVideos(${params}) {
      total, items {
        ${game_service.GameTiles.info}
        videos { name, link }
      }
    }`;
        },
        searchNews: query => `
    news(query: "${encodeURI(query)}") {
      total, items {
        _id
        title
        photoId
      }
    }
  `,
        searchGamesWithPhotos: query => `
    gamesWithPhotos(query: "${encodeURI(query)}") {
      total, items {
        ${game_service.GameTiles.info}
        photoCover
      }
    }
  `,
        searchGamesWithVideos: query => `
   gamesWithVideos(query: "${encodeURI(query)}") {
      total, items {
        ${game_service.GameTiles.info}
        videos { name, link }
      }
    }
  `,
        documents: limit => `documents${limit ? '(limit: ' + limit + ')' : ''} {
    total, items {
      _id, name, extension, sortIdx
    }
  }`,
        stadiums: limit => `stadiums${limit ? '(limit: ' + limit + ')' : ''} {
      total, items {
        _id, name, address, photoId
      }
    }`,
        teams: limit => `teams${limit ? '(limit: ' + limit + ')' : ''} {
      total, items {
        _id, name, shortName, logo, logoId, rating
      }
    }`,
        birthdays: `
    birthdays {
      _id
      firstName
      middleName
      lastName
      birthdayDate
      teams {
        _id name shortName logo logoId
      }
   }
  `,
        contacts: `
    contacts {
     _id
     description
     sortIdx
     user { _id, name, phone, vk, fb, photoId }
   }
  `,
        partners: `
    partners {
     _id
     sortIdx
     photoId
     name
     link
     description
   }
  `,
        champs: `champs {
      _id
        name
        sortIdx
        country {
          _id
          name
          flag
          sortIdx
        }
        seasons {
          _id
          name
          sortIdx
        }
    }`,
      };
    });

    var licenseAgreement_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.LicenseAgreementService = void 0;

      class LicenseAgreementService {
        loadLicenseAgreement(appKey, language, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` LicenseAgreement(appKey: "${appKey}", language: "${language}") {
      language,
      tokens {
        type
        text
      }
    }`,
              'license-agreement',
              abortSignal,
            );
            return new licenseAgreement_model.LicenseAgreement(response['LicenseAgreement']);
          });
        }
        loadCookiesPolicy(appKey, language, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` CookiePolicy(appKey: "${appKey}", language: "${language}") {
      language,
      tokens {
        type
        text
      }
    }`,
              'cookie-policy',
              abortSignal,
            );
            return new cookiePolicy_model.CookiePolicy(response['CookiePolicy']);
          });
        }
      }
      exports.LicenseAgreementService = LicenseAgreementService;
    });

    var news_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.NewsTiles = exports.NewsService = void 0;

      class NewsService {
        loadNews(tags, offset, limit, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            let params = `offset: ${offset}`;
            if (limit) params += `, limit: ${limit}`;
            tags = tags.map(t => {
              var _a;
              const obj = {};
              for (const key in t) {
                obj[key] = ((_a = t[key]) === null || _a === void 0 ? void 0 : _a._id) ? { _id: t[key]._id } : (obj[key] = t[key]);
              }
              return obj;
            });
            const response = yield new graphql_client.GraphqlClient().load(
              `Post_list(tags: "${JSON.stringify(tags).replace(/"/g, '\\"')}", ${params}) {
        total, items {
         _id
          date
          type
          title
          body
          photoId
          tags {
            _id
            key
            city { _id, name, flag }
            league { _id, name, sports }
            champ { _id, name }
            team { _id, name, logo, logoId }
            stadium { _id, name }
            game { _id }
            player { _id, firstName, lastName, photoId, globalProfile { _id } }
          }
          game {
            _id
            scoreFtHome
            scoreFtAway
            scorePenHome
            scorePenAway
            date
            techDefeat
            photoCover
            stateCode
            tourNumber
            teamHome {
              _id
              name
              shortName
              logo
              logoId
            }
            teamAway {
              _id
              name
              shortName
              logo
              logoId
            }
            stadium {
              _id
              name
            }
            pitch {
              _id
              name
            }
            videos { _id, link, name, type, thumbnail }
            stage {
              _id, name, format, season {
                _id, name, champ {
                  _id, name, country {
                    _id, name, flag, league {
                      _id, name, sports
                    }
                  }
                }
              }
            }
          }
        }
      }`,
              'post-list',
              abortSignal,
            );
            const collection$1 = response['Post_list'];
            collection$1.items = collection$1.items.map(a => new alert_model.Alert(a));
            return new collection.Collection(collection$1);
          });
        }
        loadPostInfo(postId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Post(_id: ${postId}) {
        ${exports.NewsTiles.info}
      }`,
              'post-info',
              abortSignal,
            );
            return new post_model.Post(response['Post']);
          });
        }
        loadRelatedPosts(postId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Post(_id: ${postId}) {
        ${exports.NewsTiles.relatedPosts}
      }`,
              'post-info',
              abortSignal,
            );
            return new post_model.Post(response['Post']);
          });
        }
      }
      exports.NewsService = NewsService;
      exports.NewsTiles = {
        info: `
    _id
    title
    photoId
    body
    date
    type
    tags {
      _id
      key
      city { _id, name }
      league { _id, name }
      champ { _id, name }
      team { _id, name }
      stadium { _id, name }
      game { _id }
      player { _id, firstName, lastName }
    }
  `,
        relatedPosts: `
   _id
   relatedPosts {
   _id
    title
    photoId
    date
    type
   }
  `,
      };
    });

    var person_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.PersonTiles = exports.PersonService = void 0;

      class PersonService {
        loadPersonInfo(userId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `User(_id: ${userId}) {
        ${exports.PersonTiles.info}
        ${exports.PersonTiles.games(0, 10)}
      }`,
              'person-info',
              abortSignal,
            );
            return new user_model.User(response['User']);
          });
        }
        loadPersonGames(userId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` User(_id: ${userId}) {
        ${exports.PersonTiles.info}
        ${exports.PersonTiles.games()}
      }
    `,
              'person-games',
              abortSignal,
            );
            return new user_model.User(response['User']);
          });
        }
      }
      exports.PersonService = PersonService;
      exports.PersonTiles = {
        info: `
    _id
    name
    photoId
    roles { _id, level, league { _id, name } }
  `,
        games: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `games(${params}) {
      total, items {
        ${game_service.GameTiles.info}
        staff { _id, mark, role,  user { _id } }
      }
    }`;
        },
      };
    });

    var player_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.PlayerTiles = exports.PlayerService = void 0;

      class PlayerService {
        loadPlayerInfo(playerId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `
      Player(_id: ${playerId}) {
        ${exports.PlayerTiles.info}
        ${exports.PlayerTiles.games(0, 15)}
        ${exports.PlayerTiles.news(0, 16)}
        ${exports.PlayerTiles.photoGames(0, 16)}
        ${exports.PlayerTiles.videoGames(0, 16)}
        ${exports.PlayerTiles.transfers(0, 10)}
      }
    `,
              'player-info',
              abortSignal,
            );
            return new player_model.Player(response['Player']);
          });
        }
        loadPlayerBasicInfo(playerId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `
      Player(_id: ${playerId}) {
        ${exports.PlayerTiles.info}
        ${exports.PlayerTiles.globalProfile}
      }
    `,
              'player-base-info',
              abortSignal,
            );
            return new player_model.Player(response['Player']);
          });
        }
        loadPlayerCareer(playerId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `
      Player(_id: ${playerId}) {
        ${exports.PlayerTiles.info}
        ${exports.PlayerTiles.career}
      }
    `,
              'player-career',
              abortSignal,
            );
            return new player_model.Player(response['Player']);
          });
        }
        loadPlayerMedia(playerId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Player(_id: ${playerId}) {
        ${exports.PlayerTiles.info}
        ${exports.PlayerTiles.news()}
        ${exports.PlayerTiles.photoGames()}
        ${exports.PlayerTiles.videoGames()}
      }
    `,
              'player-media',
              abortSignal,
            );
            return new player_model.Player(response['Player']);
          });
        }
        loadPlayerNews(playerId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Player(_id: ${playerId}) {
        ${exports.PlayerTiles.info}
        ${exports.PlayerTiles.news()}
      }
    `,
              'player-news',
              abortSignal,
            );
            return new player_model.Player(response['Player']);
          });
        }
        loadPlayerPhotos(playerId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Player(_id: ${playerId}) {
        ${exports.PlayerTiles.info}
        ${exports.PlayerTiles.photoGames()}
      }
    `,
              'player-photos',
              abortSignal,
            );
            return new player_model.Player(response['Player']);
          });
        }
        loadPlayerVideos(playerId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Player(_id: ${playerId}) {
        ${exports.PlayerTiles.info}
        ${exports.PlayerTiles.videoGames()}
      }
    `,
              'player-videos',
              abortSignal,
            );
            return new player_model.Player(response['Player']);
          });
        }
        loadPlayerGames(playerId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Player(_id: ${playerId}) {
        ${exports.PlayerTiles.info}
        ${exports.PlayerTiles.games()}
      }
    `,
              'player-games',
              abortSignal,
            );
            return new player_model.Player(response['Player']);
          });
        }
        loadPlayerTransfers(playerId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Player(_id: ${playerId}) {
        ${exports.PlayerTiles.info}
        ${exports.PlayerTiles.transfers()}
      }
    `,
              'player-transfers',
              abortSignal,
            );
            return new player_model.Player(response['Player']);
          });
        }
      }
      exports.PlayerService = PlayerService;
      exports.PlayerTiles = {
        info: `
    _id
    firstName
    middleName
    lastName
    photoId
    position
    leg
    league { _id, name, sports }
    teams { _id, name, logo, logoId, league { _id, name, sports } }
    birthdayDate
    height
    weight
    globalProfile { _id, players { _id, firstName, lastName, league { _id, name, sports } } }
  `,
        career: `career {
      played
      goals
      assists
      winPercent
      yellowCards
      redCards
      points
      seasons {
        from
        till
        teams {_id, name, logo, logoId }
        season {
          _id
          name
          champ {
            _id
            name
            country {
              _id
              name
              flag
            }
          }
        }
        stats { played, goals, assists, points }
      }
      teams {
        from
        till
        team { _id, name, logo, logoId }
        stats { played, goals, assists, points }
      }
    }
  `,
        globalProfile: ` globalProfile {
    _id
    players {
      _id
      firstName
      lastName
      league { _id, name, sports }
      teams { _id, name, logo, logoId, league { _id, name, sports } }
    }
  }
  `,
        news: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `news(${params}) {
      total, items {
        _id
        title
        photoId
      }
    }`;
        },
        photoGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `gamesWithPhotos(${params}) {
      total, items {
        ${game_service.GameTiles.info}
        photoCover
      }
    }`;
        },
        videoGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `gamesWithVideos(${params}) {
      total, items {
        ${game_service.GameTiles.info}
        videos { name, link }
      }
    }`;
        },
        games: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `games(${params}) {
      total, items {
        game {
          ${game_service.GameTiles.info}
          stage { _id, name, season { _id, name, champ { _id, name  country { _id, name } } } }
        }
        stats { teamId, goals, assists, yellow, red }
      }
    }`;
        },
        transfers: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `transfers(${params}) {
      total, items {
        _id
        type
        fromTeam { _id, name, shortName, logo, logoId }
        toTeam { _id, name, shortName, logo, logoId }
        adminConfirmedTimestamp
      }
    }`;
        },
      };
    });

    var profile_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.ProfileService = void 0;

      /**
       * loading private profile data (requires authentication token in httpService user model)
       */
      class ProfileService {
        loadProfileInfo(abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Profile {
        _id
        name
        photoId
        language
        notificationsAllowed,
        licenseAccepted,
        roles {
          _id
          level
          team {
            _id
            name
            shortName
            logo
            logoId
          }
        }
        league { _id, name, sports, city { _id, name, flag }, client { _id, key, name  } }
        subscriptions {
          _id,
          team {
            _id, name, logo, logoId, league { _id, name, sports }
          }
          player {
            _id, firstName, lastName,  photoId, league { _id, name, sports }, globalProfile { _id }
          }
        }
    }`,
              'user-profile',
              abortSignal,
            );
            return new user_model.User(response['Profile']);
          });
        }
        loadRecommendations(abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Profile {
      _id
      recommendations {
          team {
            _id, name, logo, logoId, league { _id, name, sports }
          }
          player {
            _id, firstName, lastName,  photoId, league { _id, name, sports }
          }
          stadium {
            _id, name, photoId, league { _id, name, sports }
          }
      }
    }`,
              'user-recommendations',
              abortSignal,
            );
            return new user_model.User(response['Profile']);
          });
        }
        loadProfileAlerts(limit = 10, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.queryProfileAlerts(null, limit, abortSignal);
          });
        }
        loadMoreProfileAlerts(user, limit = 10, abortSignal) {
          var _a;
          return __awaiter(this, void 0, void 0, function* () {
            const fromId = ((_a = user.alerts) === null || _a === void 0 ? void 0 : _a.items.length) ? user.alerts.items[user.alerts.items.length - 1]._id : null;
            const loadedUser = yield this.queryProfileAlerts(fromId, limit, abortSignal);
            return Object.assign(loadedUser, {
              alerts: new collection.Collection({
                total: user.alerts.total,
                items: [...user.alerts.items, ...loadedUser.alerts.items],
              }),
            });
          });
        }
        queryProfileAlerts(fromId, limit, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Profile {
      alerts(limit: ${limit}, fromId: ${fromId}) {
        total,
        items {
          _id
          date
          type
          title
          body
          game {
            _id
            scoreFtHome
            scoreFtAway
            scorePenHome
            scorePenAway
            date
            techDefeat
            photoCover
            teamHome {
              _id
              name
              shortName
              logo
              logoId
            }
            teamAway {
              _id
              name
              shortName
              logo
              logoId
            }
            stadium {
              _id
              name
            }
            pitch {
              _id
              name
            }
            videos { _id, link, name, type, thumbnail }
          }
        }
      }
    }`,
              'user-alerts',
              abortSignal,
            );
            return new user_model.User(response['Profile']);
          });
        }
      }
      exports.ProfileService = ProfileService;
    });

    var season_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.SeasonTiles = exports.SeasonService = void 0;

      class SeasonService {
        loadSeasonInfo(seasonId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Season(_id: ${seasonId}) {
        ${exports.SeasonTiles.info}
        ${exports.SeasonTiles.standings}
        ${exports.SeasonTiles.birthdays}
        ${exports.SeasonTiles.calendar(0, 15)}
        ${exports.SeasonTiles.upcomingGames(0, 15)}
        ${exports.SeasonTiles.playedGames(0, 15)}
        ${exports.SeasonTiles.playersStats(15)}
        ${exports.SeasonTiles.news(0, 16)}
        ${exports.SeasonTiles.photoGames(0, 16)}
        ${exports.SeasonTiles.videoGames(0, 16)}
      }
    `,
              'season-info',
              abortSignal,
            );
            return new season_model.Season(response['Season']);
          });
        }
        loadSeasonStandings(seasonId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Season(_id: ${seasonId}) {
        ${exports.SeasonTiles.info}
        ${exports.SeasonTiles.standings}
      }
    `,
              'season-standings',
              abortSignal,
            );
            return new season_model.Season(response['Season']);
          });
        }
        loadSeasonPlayersStats(seasonId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Season(_id: ${seasonId}) {
        ${exports.SeasonTiles.info}
        ${exports.SeasonTiles.playersStats()}
      }
    `,
              'season-players-stats',
              abortSignal,
            );
            return new season_model.Season(response['Season']);
          });
        }
        loadSeasonMedia(seasonId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Season(_id: ${seasonId}) {
        ${exports.SeasonTiles.info}
        ${exports.SeasonTiles.news()}
        ${exports.SeasonTiles.photoGames()}
        ${exports.SeasonTiles.videoGames()}
      }
    `,
              'season-media',
              abortSignal,
            );
            return new season_model.Season(response['Season']);
          });
        }
        loadSeasonNews(seasonId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Season(_id: ${seasonId}) {
        ${exports.SeasonTiles.info}
        ${exports.SeasonTiles.news()}
      }
    `,
              'season-news',
              abortSignal,
            );
            return new season_model.Season(response['Season']);
          });
        }
        loadSeasonPhotos(seasonId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Season(_id: ${seasonId}) {
        ${exports.SeasonTiles.info}
        ${exports.SeasonTiles.photoGames()}
      }
    `,
              'season-photos',
              abortSignal,
            );
            return new season_model.Season(response['Season']);
          });
        }
        loadSeasonVideos(seasonId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Season(_id: ${seasonId}) {
        ${exports.SeasonTiles.info}
        ${exports.SeasonTiles.videoGames()}
      }
    `,
              'season-videos',
              abortSignal,
            );
            return new season_model.Season(response['Season']);
          });
        }
        loadSeasonCalendar(seasonId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Season(_id: ${seasonId}) {
        ${exports.SeasonTiles.info}
        ${exports.SeasonTiles.calendar()}
      }
    `,
              'season-calendar',
              abortSignal,
            );
            return new season_model.Season(response['Season']);
          });
        }
      }
      exports.SeasonService = SeasonService;
      exports.SeasonTiles = {
        info: `
    _id
    name
    inProgress
    stages {
      _id
      name
      format
      sortIdx
    }
    champ {
      _id
      name
      contacts {
        _id
         description
         sortIdx
         user { _id, name, phone, vk, fb, photoId }
     }
      seasons {
        _id
        name
        sortIdx
      }
      country {
        _id
        name
        flag
        league {
          _id
          name
          sports
        }
      }
    }
  `,
        standings: `
    stages {
        _id
        name
        format
        sortIdx
        table {
          _id
          shortName
          name
          logo
          logoId
          label
          position
          games
          w
          d
          l
          winPercent
          scored
          conceded
          winPercent
          points
          form
        }
        teamsInStage {
          _id
          team {
            _id
          }
        }
        cupNet {
          _id
          netPosition
          stateCode
          date
          tourNumber
          scoreFtHome
          scoreFtAway
          scorePenHome
          scorePenAway
          teamHome { _id, name, shortName, logo, logoId }
          teamAway { _id, name, shortName, logo, logoId }
        }
      }
  `,
        playersStats: firstScreenLimit => {
          const firstScreenLimitStr = firstScreenLimit ? `(firstScreenLimit: ${firstScreenLimit})` : '';
          return `playersStats${firstScreenLimitStr} {
      _id
      firstName
      lastName
      photoId
      played
      goals
      assists
      yellowCards
      redCards
      teams  { _id, name, logo, logoId }
    }
  `;
        },
        news: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `news(${params}) {
      total, items {
        _id
        title
        photoId
      }
    }`;
        },
        photoGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `gamesWithPhotos(${params}) {
      total, items {
        ${game_service.GameTiles.info}
        photoCover
      }
    }`;
        },
        videoGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `gamesWithVideos(${params}) {
      total, items {
        ${game_service.GameTiles.info}
        videos { name, link }
      }
    }`;
        },
        birthdays: `
    birthdays {
      _id
      firstName
      middleName
      lastName
      birthdayDate
      teams {
        _id name shortName logo logoId
      }
   }
  `,
        upcomingGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `upcomingGames(${params}) {
      total, items {
        ${game_service.GameTiles.info}
      }
    }`;
        },
        playedGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `playedGames(${params}) {
      total, items {
        ${game_service.GameTiles.info}
      }
    }`;
        },
        calendar: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `calendar(${params}) {
      total, items {
        ${game_service.GameTiles.info}
      }
    }`;
        },
      };
    });

    var stadium_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.StadiumTiles = exports.StadiumService = void 0;

      class StadiumService {
        loadStadiumInfo(userId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              `Stadium(_id: ${userId}) {
        ${exports.StadiumTiles.info}
        ${exports.StadiumTiles.upcomingGames(0, 15)}
        ${exports.StadiumTiles.playedGames(0, 15)}
        ${exports.StadiumTiles.allGames(0, 15)}
      }`,
              'stadium-info',
              abortSignal,
            );
            return new stadium_model.Stadium(response['Stadium']);
          });
        }
        loadStadiumGames(userId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Stadium(_id: ${userId}) {
        ${exports.StadiumTiles.info}
        ${exports.StadiumTiles.upcomingGames()}
        ${exports.StadiumTiles.playedGames()}
      }
    `,
              'stadium-games',
              abortSignal,
            );
            return new stadium_model.Stadium(response['Stadium']);
          });
        }
        loadAllStadiumGames(userId, abortSignal) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new graphql_client.GraphqlClient().load(
              ` Stadium(_id: ${userId}) {
        ${exports.StadiumTiles.info}
        ${exports.StadiumTiles.allGames()}
        }
    `,
              'stadium-all-games',
              abortSignal,
            );
            return new stadium_model.Stadium(response['Stadium']);
          });
        }
      }
      exports.StadiumService = StadiumService;
      exports.StadiumTiles = {
        info: `
      _id
      name
      photoId
      address
      description
      lat
      long
      pitches {
        _id
        name
        description
        sortIdx
        hasPhoto
        photoId
      }
  `,
        allGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `games(${params}) {
      total, items {
        ${game_service.GameTiles.info}
      }
    }`;
        },
        upcomingGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `upcomingGames(${params}) {
      total, items {
        ${game_service.GameTiles.info}
      }
    }`;
        },
        playedGames: (offset = 0, limit) => {
          let params = `offset: ${offset}`;
          if (limit) params += `, limit: ${limit}`;
          return `playedGames(${params}) {
      total, items {
        ${game_service.GameTiles.info}
      }
    }`;
        },
      };
    });

    var user_service = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.UserService = void 0;

      class UserService {
        authFirebase(token) {
          return __awaiter(this, void 0, void 0, function* () {
            const response = yield new http_client.HttpClient().load({
              method: 'POST',
              url: '/profile/auth_firebase',
              host: env_store.envState.apiHost,
              body: { token },
            });
            return { token: response.token, user: new user_model.User(response.user) };
          });
        }
        setSubsciptions(subscriptions) {
          return __awaiter(this, void 0, void 0, function* () {
            yield new http_client.HttpClient().load({
              method: 'POST',
              url: '/profile/set_subscriptions',
              host: env_store.envState.apiHost,
              body: { subscriptions },
            });
            return true;
          });
        }
        editProfile(user, photo) {
          return __awaiter(this, void 0, void 0, function* () {
            yield new http_client.HttpClient().load({
              method: 'POST',
              url: '/profile/edit',
              host: env_store.envState.apiHost,
              body: Object.assign(user, { photo: photo }),
            });
            return true;
          });
        }
        addDevice(token) {
          return __awaiter(this, void 0, void 0, function* () {
            yield new http_client.HttpClient().load({
              method: 'POST',
              url: '/profile/add_device',
              host: env_store.envState.apiHost,
              body: { token },
            });
            return true;
          });
        }
        assumeSubscriptions() {
          return __awaiter(this, void 0, void 0, function* () {
            const subscriptions = yield new http_client.HttpClient().load({
              method: 'GET',
              url: '/profile/assume_subscriptions',
              host: env_store.envState.apiHost,
            });
            return subscriptions;
          });
        }
      }
      exports.UserService = UserService;
    });

    var routing_store = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.routingState = void 0;

      const defaultRoutes = {
        home: '/',
        league: '/leagues/:leagueId/:leagueName',
        team: '/teams/:teamId/:teamName',
        game: '/games/:gameId/:gameTitle',
        season: '/seasons/:seasonId/:tournamentName',
        player: '/players/:playerId/:playerName',
        person: '/users/:personId/:personName',
        stadium: '/stadium/:stadiumId/:stadiumName',
        post: '/news/:postId/:postTitle',
      };
      exports.routingState = store_1.createStore({ routes: defaultRoutes }).state;
    });

    var buildRoute_1 = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.createEntityRoute = exports.buildRoute = void 0;

      function buildRoute(route, params) {
        if (params) {
          for (const key in params) {
            route = route.replace(':' + key, encodeURI(params[key] + ''));
          }
        }
        return route;
      }
      exports.buildRoute = buildRoute;
      function createEntityRoute(entity, section) {
        const prepareParams = (prefix, entity) => {
          const prepareKeyName = key => {
            if (key == '_id') key = 'id';
            return prefix + helpers.ucFirst(key);
          };
          const params = {};
          for (const key in entity) {
            if (typeof entity[key] == 'number' || typeof entity[key] == 'string') {
              params[prepareKeyName(key)] = entity[key];
            }
          }
          if (section) params['section'] = section;
          return params;
        };
        if (entity instanceof team_model.Team) {
          return buildRoute(routing_store.routingState.routes.team, prepareParams('team', entity));
        } else if (entity instanceof stadium_model.Stadium) {
          return buildRoute(routing_store.routingState.routes.stadium, prepareParams('stadium', entity));
        } else if (entity instanceof game_model.Game) {
          return buildRoute(
            routing_store.routingState.routes.game,
            prepareParams('game', {
              _id: entity._id,
              title: entity.home.team.name + '-' + entity.away.team.name,
            }),
          );
        } else if (entity instanceof player_model.Player) {
          entity['name'] = entity.firstName + ' ' + entity.lastName;
          return buildRoute(routing_store.routingState.routes.player, prepareParams('player', entity));
        } else if (entity instanceof user_model.User) {
          return buildRoute(routing_store.routingState.routes.person, prepareParams('person', entity));
        } else if (entity instanceof post_model.Post) {
          return buildRoute(routing_store.routingState.routes.post, prepareParams('post', entity));
        } else if (entity instanceof models.League) {
          return buildRoute(routing_store.routingState.routes.league, prepareParams('league', entity));
        } else if (entity instanceof season_model.Season) {
          return buildRoute(routing_store.routingState.routes.season, {
            seasonId: entity._id,
            tournamentName: entity.champ.name,
          });
        } else {
          console.log('Failed to created route for passed entity', entity);
          throw new Error('Failed to created route for passed entity');
        }
      }
      exports.createEntityRoute = createEntityRoute;
    });

    var relativeDate_1 = createCommonjsModule(function (module, exports) {
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.relativeDate = void 0;
      const dayjs_1 = __importDefault(dayjs_min);

      const days = {
        en: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        ru: ['Вс', 'Пн', 'Вт', 'Ср', 'Чт', 'Пт', 'Сб', 'Вс'],
      };
      const months = {
        en: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        ru: ['Янв', 'Фев', 'Мар', 'Апр', 'Май', 'Июн', 'Июл', 'Авг', 'Сен', 'Окт', 'Ноя', 'Дек'],
      };
      const sec = {
        en: ['second', 'seconds'],
        ru: ['секунду', 'секунды', 'секунд'],
      };
      const min = {
        en: ['minute', 'minutes'],
        ru: ['минуту', 'минуты', 'минут'],
      };
      const hour = {
        en: ['hour', 'hours'],
        ru: ['час', 'часа', 'часов'],
      };
      const ago = { en: 'ago', ru: 'назад' };
      function relativeDate(date, locale = language.Language.default, showTime = true) {
        const now = dayjs_1.default();
        if (now.diff(date) < 0) {
          if (date.year() !== now.year()) {
            return date.format('DD ') + months[locale][date.month()] + ' (' + days[locale][date.day()] + ') ' + date.format('HH:mm');
          } else {
            return date.format('DD ') + months[locale][date.month()] + date.format(' YYYY') + (showTime ? date.format(' HH:mm') : '');
          }
        } else {
          if (now.diff(date, 's') < 60) {
            const d = now.diff(date, 's');
            return d + ' ' + plural.plural[locale](d, sec[locale]) + ' ' + ago[locale];
          } else if (now.diff(date, 'm') < 60) {
            const d = now.diff(date, 'm');
            return d + ' ' + plural.plural[locale](d, min[locale]) + ' ' + ago[locale];
          } else if (now.diff(date, 'h') < 24) {
            const d = now.diff(date, 'h');
            return d + ' ' + plural.plural[locale](d, hour[locale]) + ' ' + ago[locale];
          } else if (now.year() === date.year()) {
            return date.format('DD ') + months[locale][date.month()] + ' (' + days[locale][date.day()] + ') ' + (showTime ? date.format('HH:mm') : '');
          } else {
            return date.format('DD ') + months[locale][date.month()] + date.format(' YYYY') + (showTime ? date.format(' HH:mm') : '');
          }
        }
      }
      exports.relativeDate = relativeDate;
    });

    var filter_1 = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.filter = void 0;
      function filter(items, query, fields) {
        // заменяем в строке string все элементы из find на replace
        let multireplaceString = (string, find, replace) => {
          for (let i = 0; i < find.length; i++) {
            let regExp = new RegExp(find[i], 'g');
            string = string.replace(regExp, replace[i]);
          }
          return string;
        };
        //удаляем всякие спецсимволы
        let simplifyString = string => {
          string = string + '';
          return multireplaceString(string.toLowerCase(), 'ёáàâãäåèéêëìíîïñòóôõöùúûüýÿ', 'еaaaaaaeeeeiiiinooooouuuuyy').replace(/\s\s+/g, ' ');
        };
        if (!query) return items; // фильтр пустой, значит все подходят
        let queries = simplifyString(query).split(' ');
        let checkWholeItem = function (item) {
          for (let q of queries) {
            if (!checkPart(q, item)) {
              return false;
            } //каждая из частей запроса должна входить хотя бы в одну из частей элемента
          }
          return true;
        };
        let checkPart = function (value, item) {
          let parts = [];
          if (fields) {
            for (let field of fields) {
              let part = item;
              for (let f of field.split('.')) {
                if (!part[f]) {
                  part = '';
                  break;
                } else {
                  part = part[f];
                }
              }
              parts.push(part);
            }
          } else {
            //фильтруем массив простых элементов
            parts.push(item);
          }
          for (let p of parts) {
            if (simplifyString(p).indexOf(value) !== -1) {
              return true;
            }
          }
          return false;
        };
        let result = [];
        for (let item of items) {
          if (checkWholeItem(item)) {
            result.push(item);
          }
        }
        return result;
      }
      exports.filter = filter;
    });

    /*! Capacitor: https://capacitorjs.com/ - MIT License */

    var ExceptionCode;
    (function (ExceptionCode) {
      /**
       * API is not implemented.
       *
       * This usually means the API can't be used because it is not implemented for
       * the current platform.
       */
      ExceptionCode['Unimplemented'] = 'UNIMPLEMENTED';
      /**
       * API is not available.
       *
       * This means the API can't be used right now because:
       *   - it is currently missing a prerequisite, such as network connectivity
       *   - it requires a particular platform or browser version
       */
      ExceptionCode['Unavailable'] = 'UNAVAILABLE';
    })(ExceptionCode || (ExceptionCode = {}));
    class CapacitorException extends Error {
      constructor(message, code) {
        super(message);
        this.message = message;
        this.code = code;
      }
    }
    const getPlatformId = win => {
      var _a, _b;
      if (win === null || win === void 0 ? void 0 : win.androidBridge) {
        return 'android';
      } else if (
        (_b = (_a = win === null || win === void 0 ? void 0 : win.webkit) === null || _a === void 0 ? void 0 : _a.messageHandlers) === null || _b === void 0 ? void 0 : _b.bridge
      ) {
        return 'ios';
      } else {
        return 'web';
      }
    };

    const createCapacitor = win => {
      var _a, _b, _c, _d, _e;
      const capCustomPlatform = win.CapacitorCustomPlatform || null;
      const cap = win.Capacitor || {};
      const Plugins = (cap.Plugins = cap.Plugins || {});
      /**
       * @deprecated Use `capCustomPlatform` instead, default functions like registerPlugin will function with the new object.
       */
      const capPlatforms = win.CapacitorPlatforms;
      const defaultGetPlatform = () => {
        return capCustomPlatform !== null ? capCustomPlatform.name : getPlatformId(win);
      };
      const getPlatform =
        ((_a = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _a === void 0 ? void 0 : _a.getPlatform) || defaultGetPlatform;
      const defaultIsNativePlatform = () => getPlatform() !== 'web';
      const isNativePlatform =
        ((_b = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _b === void 0 ? void 0 : _b.isNativePlatform) ||
        defaultIsNativePlatform;
      const defaultIsPluginAvailable = pluginName => {
        const plugin = registeredPlugins.get(pluginName);
        if (plugin === null || plugin === void 0 ? void 0 : plugin.platforms.has(getPlatform())) {
          // JS implementation available for the current platform.
          return true;
        }
        if (getPluginHeader(pluginName)) {
          // Native implementation available.
          return true;
        }
        return false;
      };
      const isPluginAvailable =
        ((_c = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _c === void 0 ? void 0 : _c.isPluginAvailable) ||
        defaultIsPluginAvailable;
      const defaultGetPluginHeader = pluginName => {
        var _a;
        return (_a = cap.PluginHeaders) === null || _a === void 0 ? void 0 : _a.find(h => h.name === pluginName);
      };
      const getPluginHeader =
        ((_d = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _d === void 0 ? void 0 : _d.getPluginHeader) ||
        defaultGetPluginHeader;
      const handleError = err => win.console.error(err);
      const pluginMethodNoop = (_target, prop, pluginName) => {
        return Promise.reject(`${pluginName} does not have an implementation of "${prop}".`);
      };
      const registeredPlugins = new Map();
      const defaultRegisterPlugin = (pluginName, jsImplementations = {}) => {
        const registeredPlugin = registeredPlugins.get(pluginName);
        if (registeredPlugin) {
          console.warn(`Capacitor plugin "${pluginName}" already registered. Cannot register plugins twice.`);
          return registeredPlugin.proxy;
        }
        const platform = getPlatform();
        const pluginHeader = getPluginHeader(pluginName);
        let jsImplementation;
        const loadPluginImplementation = async () => {
          if (!jsImplementation && platform in jsImplementations) {
            jsImplementation =
              typeof jsImplementations[platform] === 'function' ? (jsImplementation = await jsImplementations[platform]()) : (jsImplementation = jsImplementations[platform]);
          } else if (capCustomPlatform !== null && !jsImplementation && 'web' in jsImplementations) {
            jsImplementation =
              typeof jsImplementations['web'] === 'function' ? (jsImplementation = await jsImplementations['web']()) : (jsImplementation = jsImplementations['web']);
          }
          return jsImplementation;
        };
        const createPluginMethod = (impl, prop) => {
          var _a, _b;
          if (pluginHeader) {
            const methodHeader = pluginHeader === null || pluginHeader === void 0 ? void 0 : pluginHeader.methods.find(m => prop === m.name);
            if (methodHeader) {
              if (methodHeader.rtype === 'promise') {
                return options => cap.nativePromise(pluginName, prop.toString(), options);
              } else {
                return (options, callback) => cap.nativeCallback(pluginName, prop.toString(), options, callback);
              }
            } else if (impl) {
              return (_a = impl[prop]) === null || _a === void 0 ? void 0 : _a.bind(impl);
            }
          } else if (impl) {
            return (_b = impl[prop]) === null || _b === void 0 ? void 0 : _b.bind(impl);
          } else {
            throw new CapacitorException(`"${pluginName}" plugin is not implemented on ${platform}`, ExceptionCode.Unimplemented);
          }
        };
        const createPluginMethodWrapper = prop => {
          let remove;
          const wrapper = (...args) => {
            const p = loadPluginImplementation().then(impl => {
              const fn = createPluginMethod(impl, prop);
              if (fn) {
                const p = fn(...args);
                remove = p === null || p === void 0 ? void 0 : p.remove;
                return p;
              } else {
                throw new CapacitorException(`"${pluginName}.${prop}()" is not implemented on ${platform}`, ExceptionCode.Unimplemented);
              }
            });
            if (prop === 'addListener') {
              p.remove = async () => remove();
            }
            return p;
          };
          // Some flair ✨
          wrapper.toString = () => `${prop.toString()}() { [capacitor code] }`;
          Object.defineProperty(wrapper, 'name', {
            value: prop,
            writable: false,
            configurable: false,
          });
          return wrapper;
        };
        const addListener = createPluginMethodWrapper('addListener');
        const removeListener = createPluginMethodWrapper('removeListener');
        const addListenerNative = (eventName, callback) => {
          const call = addListener({ eventName }, callback);
          const remove = async () => {
            const callbackId = await call;
            removeListener(
              {
                eventName,
                callbackId,
              },
              callback,
            );
          };
          const p = new Promise(resolve => call.then(() => resolve({ remove })));
          p.remove = async () => {
            console.warn(`Using addListener() without 'await' is deprecated.`);
            await remove();
          };
          return p;
        };
        const proxy = new Proxy(
          {},
          {
            get(_, prop) {
              switch (prop) {
                // https://github.com/facebook/react/issues/20030
                case '$$typeof':
                  return undefined;
                case 'toJSON':
                  return () => ({});
                case 'addListener':
                  return pluginHeader ? addListenerNative : addListener;
                case 'removeListener':
                  return removeListener;
                default:
                  return createPluginMethodWrapper(prop);
              }
            },
          },
        );
        Plugins[pluginName] = proxy;
        registeredPlugins.set(pluginName, {
          name: pluginName,
          proxy,
          platforms: new Set([...Object.keys(jsImplementations), ...(pluginHeader ? [platform] : [])]),
        });
        return proxy;
      };
      const registerPlugin =
        ((_e = capPlatforms === null || capPlatforms === void 0 ? void 0 : capPlatforms.currentPlatform) === null || _e === void 0 ? void 0 : _e.registerPlugin) ||
        defaultRegisterPlugin;
      // Add in convertFileSrc for web, it will already be available in native context
      if (!cap.convertFileSrc) {
        cap.convertFileSrc = filePath => filePath;
      }
      cap.getPlatform = getPlatform;
      cap.handleError = handleError;
      cap.isNativePlatform = isNativePlatform;
      cap.isPluginAvailable = isPluginAvailable;
      cap.pluginMethodNoop = pluginMethodNoop;
      cap.registerPlugin = registerPlugin;
      cap.Exception = CapacitorException;
      cap.DEBUG = !!cap.DEBUG;
      cap.isLoggingEnabled = !!cap.isLoggingEnabled;
      // Deprecated props
      cap.platform = cap.getPlatform();
      cap.isNative = cap.isNativePlatform();
      return cap;
    };
    const initCapacitorGlobal = win => (win.Capacitor = createCapacitor(win));

    const Capacitor = /*#__PURE__*/ initCapacitorGlobal(
      typeof globalThis !== 'undefined' ? globalThis : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : {},
    );
    const registerPlugin = Capacitor.registerPlugin;

    /**
     * Base class web plugins should extend.
     */
    class WebPlugin {
      constructor(config) {
        this.listeners = {};
        this.windowListeners = {};
        if (config) {
          // TODO: add link to upgrade guide
          console.warn(`Capacitor WebPlugin "${config.name}" config object was deprecated in v3 and will be removed in v4.`);
          this.config = config;
        }
      }
      addListener(eventName, listenerFunc) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
          this.listeners[eventName] = [];
        }
        this.listeners[eventName].push(listenerFunc);
        // If we haven't added a window listener for this event and it requires one,
        // go ahead and add it
        const windowListener = this.windowListeners[eventName];
        if (windowListener && !windowListener.registered) {
          this.addWindowListener(windowListener);
        }
        const remove = async () => this.removeListener(eventName, listenerFunc);
        const p = Promise.resolve({ remove });
        Object.defineProperty(p, 'remove', {
          value: async () => {
            console.warn(`Using addListener() without 'await' is deprecated.`);
            await remove();
          },
        });
        return p;
      }
      async removeAllListeners() {
        this.listeners = {};
        for (const listener in this.windowListeners) {
          this.removeWindowListener(this.windowListeners[listener]);
        }
        this.windowListeners = {};
      }
      notifyListeners(eventName, data) {
        const listeners = this.listeners[eventName];
        if (listeners) {
          listeners.forEach(listener => listener(data));
        }
      }
      hasListeners(eventName) {
        return !!this.listeners[eventName].length;
      }
      registerWindowListener(windowEventName, pluginEventName) {
        this.windowListeners[pluginEventName] = {
          registered: false,
          windowEventName,
          pluginEventName,
          handler: event => {
            this.notifyListeners(pluginEventName, event);
          },
        };
      }
      unimplemented(msg = 'not implemented') {
        return new Capacitor.Exception(msg, ExceptionCode.Unimplemented);
      }
      unavailable(msg = 'not available') {
        return new Capacitor.Exception(msg, ExceptionCode.Unavailable);
      }
      async removeListener(eventName, listenerFunc) {
        const listeners = this.listeners[eventName];
        if (!listeners) {
          return;
        }
        const index = listeners.indexOf(listenerFunc);
        this.listeners[eventName].splice(index, 1);
        // If there are no more listeners for this type of event,
        // remove the window listener
        if (!this.listeners[eventName].length) {
          this.removeWindowListener(this.windowListeners[eventName]);
        }
      }
      addWindowListener(handle) {
        window.addEventListener(handle.windowEventName, handle.handler);
        handle.registered = true;
      }
      removeWindowListener(handle) {
        if (!handle) {
          return;
        }
        window.removeEventListener(handle.windowEventName, handle.handler);
        handle.registered = false;
      }
    }

    const Storage = registerPlugin('Storage', {
      web: () =>
        Promise.resolve()
          .then(function () {
            return web$1;
          })
          .then(m => new m.StorageWeb()),
    });

    var esm$1 = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      Storage: Storage,
    });

    var zipModel_1 = createCommonjsModule(function (module, exports) {
      var __createBinding =
        (commonjsGlobal && commonjsGlobal.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (commonjsGlobal && commonjsGlobal.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, 'default', { enumerable: true, value: v });
            }
          : function (o, v) {
              o['default'] = v;
            });
      var __importStar =
        (commonjsGlobal && commonjsGlobal.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.unzipModel = exports.zipModel = void 0;

      const models$1 = __importStar(models);
      function zipModel(model) {
        return __awaiter(this, void 0, void 0, function* () {
          let result;
          if (Array.isArray(model)) {
            result = yield Promise.all(
              model.map(p =>
                __awaiter(this, void 0, void 0, function* () {
                  return yield zipModel(p);
                }),
              ),
            );
          } else if (typeof model == 'object' && model !== null) {
            const properties = {};
            for (const key in model) {
              properties[key] = yield zipModel(model[key]);
            }
            if (model.isFtbModel) {
              result = { zippedModel: model.constructor.name, properties };
            } else {
              result = properties;
            }
          } else {
            result = model;
          }
          return JSON.stringify(result);
        });
      }
      exports.zipModel = zipModel;
      function unzipModel(zipped) {
        return __awaiter(this, void 0, void 0, function* () {
          const parsed = JSON.parse(zipped);
          if (typeof parsed != 'object' || parsed == null) {
            return parsed;
          } else if (Array.isArray(parsed)) {
            return yield Promise.all(
              parsed.map(p =>
                __awaiter(this, void 0, void 0, function* () {
                  return yield unzipModel(p);
                }),
              ),
            );
          } else {
            let properties = {};
            let originProperties = parsed.zippedModel ? parsed.properties : parsed;
            if (parsed.zippedModel) {
              properties = new models$1[parsed.zippedModel]();
              // we cannot use dynamic import in rollup :(
              // const imports = await import(`../models/${class2Dash(parsed.zippedModel)}.model`);
              // properties = new imports[parsed.zippedModel]();
            }
            const parseProp = prop =>
              __awaiter(this, void 0, void 0, function* () {
                try {
                  prop = JSON.parse(prop);
                } finally {
                  if (Array.isArray(prop)) {
                    return yield Promise.all(
                      prop.map(p =>
                        __awaiter(this, void 0, void 0, function* () {
                          return yield parseProp(p);
                        }),
                      ),
                    );
                  } else if (typeof prop == 'object' && prop !== null) {
                    return yield unzipModel(JSON.stringify(prop));
                  } else {
                    return prop;
                  }
                }
              });
            for (const key in originProperties) {
              if (key !== 'zipped') {
                properties[key] = yield parseProp(originProperties[key]);
              }
            }
            return properties;
          }
        });
      }
      exports.unzipModel = unzipModel;
    });

    var storage_1 = /*@__PURE__*/ getAugmentedNamespace(esm$1);

    var storage = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.removeFromStorage = exports.getFromStorage = exports.setToStorage = void 0;

      function setToStorage(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
          yield storage_1.Storage.set({
            key: key,
            value: yield zipModel_1.zipModel(value),
          });
        });
      }
      exports.setToStorage = setToStorage;
      function getFromStorage(key) {
        return __awaiter(this, void 0, void 0, function* () {
          const { value } = yield storage_1.Storage.get({ key: key });
          return value ? zipModel_1.unzipModel(value) : null;
        });
      }
      exports.getFromStorage = getFromStorage;
      function removeFromStorage(key) {
        return __awaiter(this, void 0, void 0, function* () {
          yield storage_1.Storage.remove({
            key: key,
          });
        });
      }
      exports.removeFromStorage = removeFromStorage;
    });

    var validators = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.validateConfirmCode =
        exports.validatePhone =
        exports.validateTime =
        exports.validateDate =
        exports.validateRange =
        exports.validateZeroOrMore =
        exports.validatePositiveNumber =
        exports.validateNotEmpty =
          void 0;

      const dayjs_1 = __importDefault(dayjs_min);
      const validateNotEmpty = value =>
        __awaiter(void 0, void 0, void 0, function* () {
          return [null, undefined, ''].includes(value) ? translations.translations.validators.field_cannot_be_empty : null;
        });
      exports.validateNotEmpty = validateNotEmpty;
      const validatePositiveNumber = value =>
        __awaiter(void 0, void 0, void 0, function* () {
          if (!value) return null;
          return parseInt(value) > 0 ? null : translations.translations.validators.should_be_positive_number;
        });
      exports.validatePositiveNumber = validatePositiveNumber;
      const validateZeroOrMore = value =>
        __awaiter(void 0, void 0, void 0, function* () {
          if (!value) return null;
          return parseInt(value) >= 0 ? null : translations.translations.validators.should_be_positive_number;
        });
      exports.validateZeroOrMore = validateZeroOrMore;
      const validateRange = (value, rangeFrom, rangeTo) =>
        __awaiter(void 0, void 0, void 0, function* () {
          if (!value) return null;
          return parseInt(value) < rangeTo && parseInt(value) > rangeFrom ? null : translations.translations.validators.allowed_range;
        });
      exports.validateRange = validateRange;
      const validateDate = value =>
        __awaiter(void 0, void 0, void 0, function* () {
          if (!value) return null;
          let date = dayjs_1.default(value, 'DD.MM.YYYY');
          if (date.isValid()) return null;
          date = dayjs_1.default(value, 'YYYY-MM-DD');
          if (date.isValid()) return null;
          return translations.translations.validators.invalid_date_format;
        });
      exports.validateDate = validateDate;
      const validateTime = value =>
        __awaiter(void 0, void 0, void 0, function* () {
          if (!value) return null;
          const [hours, minutes] = value.split(':');
          if (parseInt(hours) < 0 || parseInt(hours) > 23 || parseInt(minutes) < 0 || parseInt(minutes) > 59) {
            return translations.translations.validators.invalid_time_format;
          } else {
            return null;
          }
        });
      exports.validateTime = validateTime;
      const validatePhone = value =>
        __awaiter(void 0, void 0, void 0, function* () {
          if (!value) return null;
          if (value.charAt(0) !== '+') return translations.translations.validators.phone_should_start_with_plus;
          if (new RegExp('^\\+[0-9]{9,15}$').test(value)) {
            return null;
          } else {
            return translations.translations.validators.invalid_phone_format;
          }
        });
      exports.validatePhone = validatePhone;
      const validateConfirmCode = value =>
        __awaiter(void 0, void 0, void 0, function* () {
          if (!value) return null;
          if (value.length != 6) {
            return translations.translations.validators.code_should_have_6_digits;
          } else {
            return null;
          }
        });
      exports.validateConfirmCode = validateConfirmCode;
    });

    var playersPositions = createCommonjsModule(function (module, exports) {
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.positionOrder = exports.getPlayerPosition = exports.positionCategories = exports.positions = void 0;
      exports.positions = {
        'football': ['GK', 'CB', 'LB', 'RB', 'CM', 'LM', 'RM', 'ST'],
        'beach-soccer': ['GK', 'DF', 'UN', 'ST'],
        'basketball': ['PG', 'SG', 'C', 'SF', 'PF'],
        'volleyball': ['Lib', 'Def', 'Set', 'Hit'],
      };
      exports.positionCategories = {
        goalkeepers: ['GK'],
        defenders: ['SW', 'CB', 'RB', 'LB', 'RWB', 'LWB', 'DF'],
        midfielders: ['DM', 'CM', 'AM', 'RDM', 'LM', 'RM', 'LDM', 'RCM', 'LCM', 'RAM', 'LAM', 'UN'],
        strikers: ['CF', 'RF', 'LF', 'ST'],
      };
      const getPlayerPosition = index => {
        if (['GK'].includes(index)) {
          return 'goalkeeper';
        } else if (['SW', 'CB', 'RB', 'LB', 'RWB', 'LWB', 'DF'].includes(index)) {
          return 'defender';
        } else if (['DM', 'CM', 'AM', 'RDM', 'LM', 'RM', 'LDM', 'RCM', 'LCM', 'RAM', 'LAM'].includes(index)) {
          return 'midfielder';
        } else if (['UN'].includes(index)) {
          return 'versatile';
        } else if (['CF', 'RF', 'LF', 'ST'].includes(index)) {
          return 'striker';
        }
      };
      exports.getPlayerPosition = getPlayerPosition;
      exports.positionOrder = ['goalkeepers', 'defenders', 'midfielders', 'strikers'];
    });

    /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function (d, b) {
      extendStatics =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (d, b) {
            d.__proto__ = b;
          }) ||
        function (d, b) {
          for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
      return extendStatics(d, b);
    };

    function __extends(d, b) {
      if (typeof b !== 'function' && b !== null) throw new TypeError('Class extends value ' + String(b) + ' is not a constructor or null');
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : ((__.prototype = b.prototype), new __());
    }

    var __assign = function () {
      __assign =
        Object.assign ||
        function __assign(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
          }
          return t;
        };
      return __assign.apply(this, arguments);
    };

    function __awaiter$1(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P
          ? value
          : new P(function (resolve) {
              resolve(value);
            });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator['throw'](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    function __generator(thisArg, body) {
      var _ = {
          label: 0,
          sent: function () {
            if (t[0] & 1) throw t[1];
            return t[1];
          },
          trys: [],
          ops: [],
        },
        f,
        y,
        t,
        g;
      return (
        (g = { next: verb(0), throw: verb(1), return: verb(2) }),
        typeof Symbol === 'function' &&
          (g[Symbol.iterator] = function () {
            return this;
          }),
        g
      );
      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError('Generator is already executing.');
        while (_)
          try {
            if (((f = 1), y && (t = op[0] & 2 ? y['return'] : op[0] ? y['throw'] || ((t = y['return']) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)) return t;
            if (((y = 0), t)) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!((t = _.trys), (t = t.length > 0 && t[t.length - 1])) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2]) _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    }

    function __values$1(o) {
      var s = typeof Symbol === 'function' && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === 'number')
        return {
          next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          },
        };
      throw new TypeError(s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
    }

    function __read(o, n) {
      var m = typeof Symbol === 'function' && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
        r,
        ar = [],
        e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error: error };
      } finally {
        try {
          if (r && !r.done && (m = i['return'])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    }

    function __spreadArray(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || from);
    }

    /**
     * @license
     * Copyright 2017 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Do a deep-copy of basic JavaScript Objects or Arrays.
     */
    function deepCopy(value) {
      return deepExtend(undefined, value);
    }
    /**
     * Copy properties from source to target (recursively allows extension
     * of Objects and Arrays).  Scalar values in the target are over-written.
     * If target is undefined, an object of the appropriate type will be created
     * (and returned).
     *
     * We recursively copy all child properties of plain Objects in the source- so
     * that namespace- like dictionaries are merged.
     *
     * Note that the target can be a function, in which case the properties in
     * the source Object are copied onto it as static properties of the Function.
     *
     * Note: we don't merge __proto__ to prevent prototype pollution
     */
    function deepExtend(target, source) {
      if (!(source instanceof Object)) {
        return source;
      }
      switch (source.constructor) {
        case Date:
          // Treat Dates like scalars; if the target date object had any child
          // properties - they will be lost!
          var dateValue = source;
          return new Date(dateValue.getTime());
        case Object:
          if (target === undefined) {
            target = {};
          }
          break;
        case Array:
          // Always copy the array source and overwrite the target.
          target = [];
          break;
        default:
          // Not a plain Object - treat it as a scalar.
          return source;
      }
      for (var prop in source) {
        // use isValidKey to guard against prototype pollution. See https://snyk.io/vuln/SNYK-JS-LODASH-450202
        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
          continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
      }
      return target;
    }
    function isValidKey(key) {
      return key !== '__proto__';
    }

    /**
     * @license
     * Copyright 2017 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var Deferred = /** @class */ (function () {
      function Deferred() {
        var _this = this;
        this.reject = function () {};
        this.resolve = function () {};
        this.promise = new Promise(function (resolve, reject) {
          _this.resolve = resolve;
          _this.reject = reject;
        });
      }
      /**
       * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
       * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
       * and returns a node-style callback which will resolve or reject the Deferred's promise.
       */
      Deferred.prototype.wrapCallback = function (callback) {
        var _this = this;
        return function (error, value) {
          if (error) {
            _this.reject(error);
          } else {
            _this.resolve(value);
          }
          if (typeof callback === 'function') {
            // Attaching noop handler just in case developer wasn't expecting
            // promises
            _this.promise.catch(function () {});
            // Some of our callbacks don't expect a value and our own tests
            // assert that the parameter length is 1
            if (callback.length === 1) {
              callback(error);
            } else {
              callback(error, value);
            }
          }
        };
      };
      return Deferred;
    })();
    /**
     * Detect Node.js.
     *
     * @return true if Node.js environment is detected.
     */
    // Node detection logic from: https://github.com/iliakan/detect-node/
    function isNode$1() {
      try {
        return Object.prototype.toString.call(global.process) === '[object process]';
      } catch (e) {
        return false;
      }
    }
    /**
     * Detect Browser Environment
     */
    function isBrowser() {
      return typeof self === 'object' && self.self === self;
    }

    /**
     * @license
     * Copyright 2017 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var ERROR_NAME = 'FirebaseError';
    // Based on code from:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types
    var FirebaseError = /** @class */ (function (_super) {
      __extends(FirebaseError, _super);
      function FirebaseError(code, message, customData) {
        var _this = _super.call(this, message) || this;
        _this.code = code;
        _this.customData = customData;
        _this.name = ERROR_NAME;
        // Fix For ES5
        // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, FirebaseError.prototype);
        // Maintains proper stack trace for where our error was thrown.
        // Only available on V8.
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_this, ErrorFactory.prototype.create);
        }
        return _this;
      }
      return FirebaseError;
    })(Error);
    var ErrorFactory = /** @class */ (function () {
      function ErrorFactory(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
      }
      ErrorFactory.prototype.create = function (code) {
        var data = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          data[_i - 1] = arguments[_i];
        }
        var customData = data[0] || {};
        var fullCode = this.service + '/' + code;
        var template = this.errors[code];
        var message = template ? replaceTemplate(template, customData) : 'Error';
        // Service Name: Error message (service/code).
        var fullMessage = this.serviceName + ': ' + message + ' (' + fullCode + ').';
        var error = new FirebaseError(fullCode, fullMessage, customData);
        return error;
      };
      return ErrorFactory;
    })();
    function replaceTemplate(template, data) {
      return template.replace(PATTERN, function (_, key) {
        var value = data[key];
        return value != null ? String(value) : '<' + key + '?>';
      });
    }
    var PATTERN = /\{\$([^}]+)}/g;

    /**
     * @license
     * Copyright 2017 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function contains(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }

    /**
     * Helper to make a Subscribe function (just like Promise helps make a
     * Thenable).
     *
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    function createSubscribe(executor, onNoObservers) {
      var proxy = new ObserverProxy(executor, onNoObservers);
      return proxy.subscribe.bind(proxy);
    }
    /**
     * Implement fan-out for any number of Observers attached via a subscribe
     * function.
     */
    var ObserverProxy = /** @class */ (function () {
      /**
       * @param executor Function which can make calls to a single Observer
       *     as a proxy.
       * @param onNoObservers Callback when count of Observers goes to zero.
       */
      function ObserverProxy(executor, onNoObservers) {
        var _this = this;
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        // Micro-task scheduling by calling task.then().
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        // Call the executor asynchronously so subscribers that are called
        // synchronously after the creation of the subscribe function
        // can still receive the very first value generated in the executor.
        this.task
          .then(function () {
            executor(_this);
          })
          .catch(function (e) {
            _this.error(e);
          });
      }
      ObserverProxy.prototype.next = function (value) {
        this.forEachObserver(function (observer) {
          observer.next(value);
        });
      };
      ObserverProxy.prototype.error = function (error) {
        this.forEachObserver(function (observer) {
          observer.error(error);
        });
        this.close(error);
      };
      ObserverProxy.prototype.complete = function () {
        this.forEachObserver(function (observer) {
          observer.complete();
        });
        this.close();
      };
      /**
       * Subscribe function that can be used to add an Observer to the fan-out list.
       *
       * - We require that no event is sent to a subscriber sychronously to their
       *   call to subscribe().
       */
      ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {
        var _this = this;
        var observer;
        if (nextOrObserver === undefined && error === undefined && complete === undefined) {
          throw new Error('Missing Observer.');
        }
        // Assemble an Observer object when passed as callback functions.
        if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {
          observer = nextOrObserver;
        } else {
          observer = {
            next: nextOrObserver,
            error: error,
            complete: complete,
          };
        }
        if (observer.next === undefined) {
          observer.next = noop$1;
        }
        if (observer.error === undefined) {
          observer.error = noop$1;
        }
        if (observer.complete === undefined) {
          observer.complete = noop$1;
        }
        var unsub = this.unsubscribeOne.bind(this, this.observers.length);
        // Attempt to subscribe to a terminated Observable - we
        // just respond to the Observer with the final error or complete
        // event.
        if (this.finalized) {
          // eslint-disable-next-line @typescript-eslint/no-floating-promises
          this.task.then(function () {
            try {
              if (_this.finalError) {
                observer.error(_this.finalError);
              } else {
                observer.complete();
              }
            } catch (e) {
              // nothing
            }
            return;
          });
        }
        this.observers.push(observer);
        return unsub;
      };
      // Unsubscribe is synchronous - we guarantee that no events are sent to
      // any unsubscribed Observer.
      ObserverProxy.prototype.unsubscribeOne = function (i) {
        if (this.observers === undefined || this.observers[i] === undefined) {
          return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== undefined) {
          this.onNoObservers(this);
        }
      };
      ObserverProxy.prototype.forEachObserver = function (fn) {
        if (this.finalized) {
          // Already closed by previous event....just eat the additional values.
          return;
        }
        // Since sendOne calls asynchronously - there is no chance that
        // this.observers will become undefined.
        for (var i = 0; i < this.observers.length; i++) {
          this.sendOne(i, fn);
        }
      };
      // Call the Observer via one of it's callback function. We are careful to
      // confirm that the observe has not been unsubscribed since this asynchronous
      // function had been queued.
      ObserverProxy.prototype.sendOne = function (i, fn) {
        var _this = this;
        // Execute the callback asynchronously
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.task.then(function () {
          if (_this.observers !== undefined && _this.observers[i] !== undefined) {
            try {
              fn(_this.observers[i]);
            } catch (e) {
              // Ignore exceptions raised in Observers or missing methods of an
              // Observer.
              // Log error to console. b/31404806
              if (typeof console !== 'undefined' && console.error) {
                console.error(e);
              }
            }
          }
        });
      };
      ObserverProxy.prototype.close = function (err) {
        var _this = this;
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        if (err !== undefined) {
          this.finalError = err;
        }
        // Proxy is no longer needed - garbage collect references
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        this.task.then(function () {
          _this.observers = undefined;
          _this.onNoObservers = undefined;
        });
      };
      return ObserverProxy;
    })();
    /**
     * Return true if the object passed in implements any of the named methods.
     */
    function implementsAnyMethods(obj, methods) {
      if (typeof obj !== 'object' || obj === null) {
        return false;
      }
      for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in obj && typeof obj[method] === 'function') {
          return true;
        }
      }
      return false;
    }
    function noop$1() {
      // do nothing
    }

    /**
     * Component for service name T, e.g. `auth`, `auth-internal`
     */
    var Component = /** @class */ (function () {
      /**
       *
       * @param name The public service name, e.g. app, auth, firestore, database
       * @param instanceFactory Service factory responsible for creating the public interface
       * @param type whether the service provided by the component is public or private
       */
      function Component(name, instanceFactory, type) {
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type;
        this.multipleInstances = false;
        /**
         * Properties to be added to the service namespace
         */
        this.serviceProps = {};
        this.instantiationMode = 'LAZY' /* LAZY */;
        this.onInstanceCreated = null;
      }
      Component.prototype.setInstantiationMode = function (mode) {
        this.instantiationMode = mode;
        return this;
      };
      Component.prototype.setMultipleInstances = function (multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
      };
      Component.prototype.setServiceProps = function (props) {
        this.serviceProps = props;
        return this;
      };
      Component.prototype.setInstanceCreatedCallback = function (callback) {
        this.onInstanceCreated = callback;
        return this;
      };
      return Component;
    })();

    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var DEFAULT_ENTRY_NAME$1 = '[DEFAULT]';

    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Provider for instance for service name T, e.g. 'auth', 'auth-internal'
     * NameServiceMapping[T] is an alias for the type of the instance
     */
    var Provider = /** @class */ (function () {
      function Provider(name, container) {
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = new Map();
        this.instancesDeferred = new Map();
        this.instancesOptions = new Map();
        this.onInitCallbacks = new Map();
      }
      /**
       * @param identifier A provider can provide mulitple instances of a service
       * if this.component.multipleInstances is true.
       */
      Provider.prototype.get = function (identifier) {
        // if multipleInstances is not supported, use the default name
        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
          var deferred = new Deferred();
          this.instancesDeferred.set(normalizedIdentifier, deferred);
          if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
            // initialize the service if it can be auto-initialized
            try {
              var instance = this.getOrInitializeService({
                instanceIdentifier: normalizedIdentifier,
              });
              if (instance) {
                deferred.resolve(instance);
              }
            } catch (e) {
              // when the instance factory throws an exception during get(), it should not cause
              // a fatal error. We just return the unresolved promise in this case.
            }
          }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
      };
      Provider.prototype.getImmediate = function (options) {
        var _a;
        // if multipleInstances is not supported, use the default name
        var normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        var optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
          try {
            return this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier,
            });
          } catch (e) {
            if (optional) {
              return null;
            } else {
              throw e;
            }
          }
        } else {
          // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw
          if (optional) {
            return null;
          } else {
            throw Error('Service ' + this.name + ' is not available');
          }
        }
      };
      Provider.prototype.getComponent = function () {
        return this.component;
      };
      Provider.prototype.setComponent = function (component) {
        var e_1, _a;
        if (component.name !== this.name) {
          throw Error('Mismatching Component ' + component.name + ' for Provider ' + this.name + '.');
        }
        if (this.component) {
          throw Error('Component for ' + this.name + ' has already been provided');
        }
        this.component = component;
        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)
        if (!this.shouldAutoInitialize()) {
          return;
        }
        // if the service is eager, initialize the default instance
        if (isComponentEager(component)) {
          try {
            this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME$1 });
          } catch (e) {
            // when the instance factory for an eager Component throws an exception during the eager
            // initialization, it should not cause a fatal error.
            // TODO: Investigate if we need to make it configurable, because some component may want to cause
            // a fatal error in this case?
          }
        }
        try {
          // Create service instances for the pending promises and resolve them
          // NOTE: if this.multipleInstances is false, only the default instance will be created
          // and all promises with resolve with it regardless of the identifier.
          for (var _b = __values$1(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2),
              instanceIdentifier = _d[0],
              instanceDeferred = _d[1];
            var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            try {
              // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.
              var instance = this.getOrInitializeService({
                instanceIdentifier: normalizedIdentifier,
              });
              instanceDeferred.resolve(instance);
            } catch (e) {
              // when the instance factory throws an exception, it should not cause
              // a fatal error. We just leave the promise unresolved.
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      };
      Provider.prototype.clearInstance = function (identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME$1;
        }
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
      };
      // app.delete() will call this method on every provider to delete the services
      // TODO: should we mark the provider as deleted?
      Provider.prototype.delete = function () {
        return __awaiter$1(this, void 0, void 0, function () {
          var services;
          return __generator(this, function (_a) {
            switch (_a.label) {
              case 0:
                services = Array.from(this.instances.values());
                return [
                  4 /*yield*/,
                  Promise.all(
                    __spreadArray(
                      __spreadArray(
                        [],
                        __read(
                          services
                            .filter(function (service) {
                              return 'INTERNAL' in service;
                            }) // legacy services
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            .map(function (service) {
                              return service.INTERNAL.delete();
                            }),
                        ),
                      ),
                      __read(
                        services
                          .filter(function (service) {
                            return '_delete' in service;
                          }) // modularized services
                          // eslint-disable-next-line @typescript-eslint/no-explicit-any
                          .map(function (service) {
                            return service._delete();
                          }),
                      ),
                    ),
                  ),
                ];
              case 1:
                _a.sent();
                return [2 /*return*/];
            }
          });
        });
      };
      Provider.prototype.isComponentSet = function () {
        return this.component != null;
      };
      Provider.prototype.isInitialized = function (identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME$1;
        }
        return this.instances.has(identifier);
      };
      Provider.prototype.getOptions = function (identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME$1;
        }
        return this.instancesOptions.get(identifier) || {};
      };
      Provider.prototype.initialize = function (opts) {
        var e_2, _a;
        if (opts === void 0) {
          opts = {};
        }
        var _b = opts.options,
          options = _b === void 0 ? {} : _b;
        var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) {
          throw Error(this.name + '(' + normalizedIdentifier + ') has already been initialized');
        }
        if (!this.isComponentSet()) {
          throw Error('Component ' + this.name + ' has not been registered yet');
        }
        var instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier,
          options: options,
        });
        try {
          // resolve any pending promise waiting for the service instance
          for (var _c = __values$1(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
            var _e = __read(_d.value, 2),
              instanceIdentifier = _e[0],
              instanceDeferred = _e[1];
            var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
            if (normalizedIdentifier === normalizedDeferredIdentifier) {
              instanceDeferred.resolve(instance);
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        return instance;
      };
      /**
       *
       * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
       * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
       *
       * @param identifier An optional instance identifier
       * @returns a function to unregister the callback
       */
      Provider.prototype.onInit = function (callback, identifier) {
        var _a;
        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        var existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) {
          callback(existingInstance, normalizedIdentifier);
        }
        return function () {
          existingCallbacks.delete(callback);
        };
      };
      /**
       * Invoke onInit callbacks synchronously
       * @param instance the service instance`
       */
      Provider.prototype.invokeOnInitCallbacks = function (instance, identifier) {
        var e_3, _a;
        var callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) {
          return;
        }
        try {
          for (var callbacks_1 = __values$1(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
            var callback = callbacks_1_1.value;
            try {
              callback(instance, identifier);
            } catch (_b) {
              // ignore errors in the onInit callback
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
          } finally {
            if (e_3) throw e_3.error;
          }
        }
      };
      Provider.prototype.getOrInitializeService = function (_a) {
        var instanceIdentifier = _a.instanceIdentifier,
          _b = _a.options,
          options = _b === void 0 ? {} : _b;
        var instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
          instance = this.component.instanceFactory(this.container, {
            instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
            options: options,
          });
          this.instances.set(instanceIdentifier, instance);
          this.instancesOptions.set(instanceIdentifier, options);
          /**
           * Invoke onInit listeners.
           * Note this.component.onInstanceCreated is different, which is used by the component creator,
           * while onInit listeners are registered by consumers of the provider.
           */
          this.invokeOnInitCallbacks(instance, instanceIdentifier);
          /**
           * Order is important
           * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which
           * makes `isInitialized()` return true.
           */
          if (this.component.onInstanceCreated) {
            try {
              this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
            } catch (_c) {
              // ignore errors in the onInstanceCreatedCallback
            }
          }
        }
        return instance || null;
      };
      Provider.prototype.normalizeInstanceIdentifier = function (identifier) {
        if (identifier === void 0) {
          identifier = DEFAULT_ENTRY_NAME$1;
        }
        if (this.component) {
          return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME$1;
        } else {
          return identifier; // assume multiple instances are supported before the component is provided.
        }
      };
      Provider.prototype.shouldAutoInitialize = function () {
        return !!this.component && this.component.instantiationMode !== 'EXPLICIT' /* EXPLICIT */;
      };
      return Provider;
    })();
    // undefined should be passed to the service factory for the default instance
    function normalizeIdentifierForFactory(identifier) {
      return identifier === DEFAULT_ENTRY_NAME$1 ? undefined : identifier;
    }
    function isComponentEager(component) {
      return component.instantiationMode === 'EAGER' /* EAGER */;
    }

    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`
     */
    var ComponentContainer = /** @class */ (function () {
      function ComponentContainer(name) {
        this.name = name;
        this.providers = new Map();
      }
      /**
       *
       * @param component Component being added
       * @param overwrite When a component with the same name has already been registered,
       * if overwrite is true: overwrite the existing component with the new component and create a new
       * provider with the new component. It can be useful in tests where you want to use different mocks
       * for different tests.
       * if overwrite is false: throw an exception
       */
      ComponentContainer.prototype.addComponent = function (component) {
        var provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
          throw new Error('Component ' + component.name + ' has already been registered with ' + this.name);
        }
        provider.setComponent(component);
      };
      ComponentContainer.prototype.addOrOverwriteComponent = function (component) {
        var provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
          // delete the existing provider from the container, so we can register the new component
          this.providers.delete(component.name);
        }
        this.addComponent(component);
      };
      /**
       * getProvider provides a type safe interface where it can only be called with a field name
       * present in NameServiceMapping interface.
       *
       * Firebase SDKs providing services should extend NameServiceMapping interface to register
       * themselves.
       */
      ComponentContainer.prototype.getProvider = function (name) {
        if (this.providers.has(name)) {
          return this.providers.get(name);
        }
        // create a Provider for a service that hasn't registered with Firebase
        var provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
      };
      ComponentContainer.prototype.getProviders = function () {
        return Array.from(this.providers.values());
      };
      return ComponentContainer;
    })();

    /*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

    function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
      return r;
    }

    /**
     * @license
     * Copyright 2017 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var _a$2;
    /**
     * A container for all of the Logger instances
     */
    var instances = [];
    /**
     * The JS SDK supports 5 log levels and also allows a user the ability to
     * silence the logs altogether.
     *
     * The order is a follows:
     * DEBUG < VERBOSE < INFO < WARN < ERROR
     *
     * All of the log types above the current log level will be captured (i.e. if
     * you set the log level to `INFO`, errors will still be logged, but `DEBUG` and
     * `VERBOSE` logs will not)
     */
    var LogLevel;
    (function (LogLevel) {
      LogLevel[(LogLevel['DEBUG'] = 0)] = 'DEBUG';
      LogLevel[(LogLevel['VERBOSE'] = 1)] = 'VERBOSE';
      LogLevel[(LogLevel['INFO'] = 2)] = 'INFO';
      LogLevel[(LogLevel['WARN'] = 3)] = 'WARN';
      LogLevel[(LogLevel['ERROR'] = 4)] = 'ERROR';
      LogLevel[(LogLevel['SILENT'] = 5)] = 'SILENT';
    })(LogLevel || (LogLevel = {}));
    var levelStringToEnum = {
      debug: LogLevel.DEBUG,
      verbose: LogLevel.VERBOSE,
      info: LogLevel.INFO,
      warn: LogLevel.WARN,
      error: LogLevel.ERROR,
      silent: LogLevel.SILENT,
    };
    /**
     * The default log level
     */
    var defaultLogLevel = LogLevel.INFO;
    /**
     * By default, `console.debug` is not displayed in the developer console (in
     * chrome). To avoid forcing users to have to opt-in to these logs twice
     * (i.e. once for firebase, and once in the console), we are sending `DEBUG`
     * logs to the `console.log` function.
     */
    var ConsoleMethod =
      ((_a$2 = {}),
      (_a$2[LogLevel.DEBUG] = 'log'),
      (_a$2[LogLevel.VERBOSE] = 'log'),
      (_a$2[LogLevel.INFO] = 'info'),
      (_a$2[LogLevel.WARN] = 'warn'),
      (_a$2[LogLevel.ERROR] = 'error'),
      _a$2);
    /**
     * The default log handler will forward DEBUG, VERBOSE, INFO, WARN, and ERROR
     * messages on to their corresponding console counterparts (if the log method
     * is supported by the current log level)
     */
    var defaultLogHandler = function (instance, logType) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      if (logType < instance.logLevel) {
        return;
      }
      var now = new Date().toISOString();
      var method = ConsoleMethod[logType];
      if (method) {
        console[method].apply(console, __spreadArrays(['[' + now + ']  ' + instance.name + ':'], args));
      } else {
        throw new Error('Attempted to log a message with an invalid logType (value: ' + logType + ')');
      }
    };
    var Logger = /** @class */ (function () {
      /**
       * Gives you an instance of a Logger to capture messages according to
       * Firebase's logging scheme.
       *
       * @param name The name that the logs will be associated with
       */
      function Logger(name) {
        this.name = name;
        /**
         * The log level of the given Logger instance.
         */
        this._logLevel = defaultLogLevel;
        /**
         * The main (internal) log handler for the Logger instance.
         * Can be set to a new function in internal package code but not by user.
         */
        this._logHandler = defaultLogHandler;
        /**
         * The optional, additional, user-defined log handler for the Logger instance.
         */
        this._userLogHandler = null;
        /**
         * Capture the current instance for later use
         */
        instances.push(this);
      }
      Object.defineProperty(Logger.prototype, 'logLevel', {
        get: function () {
          return this._logLevel;
        },
        set: function (val) {
          if (!(val in LogLevel)) {
            throw new TypeError('Invalid value "' + val + '" assigned to `logLevel`');
          }
          this._logLevel = val;
        },
        enumerable: false,
        configurable: true,
      });
      // Workaround for setter/getter having to be the same type.
      Logger.prototype.setLogLevel = function (val) {
        this._logLevel = typeof val === 'string' ? levelStringToEnum[val] : val;
      };
      Object.defineProperty(Logger.prototype, 'logHandler', {
        get: function () {
          return this._logHandler;
        },
        set: function (val) {
          if (typeof val !== 'function') {
            throw new TypeError('Value assigned to `logHandler` must be a function');
          }
          this._logHandler = val;
        },
        enumerable: false,
        configurable: true,
      });
      Object.defineProperty(Logger.prototype, 'userLogHandler', {
        get: function () {
          return this._userLogHandler;
        },
        set: function (val) {
          this._userLogHandler = val;
        },
        enumerable: false,
        configurable: true,
      });
      /**
       * The functions below are all based on the `console` interface
       */
      Logger.prototype.debug = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.DEBUG], args));
        this._logHandler.apply(this, __spreadArrays([this, LogLevel.DEBUG], args));
      };
      Logger.prototype.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.VERBOSE], args));
        this._logHandler.apply(this, __spreadArrays([this, LogLevel.VERBOSE], args));
      };
      Logger.prototype.info = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.INFO], args));
        this._logHandler.apply(this, __spreadArrays([this, LogLevel.INFO], args));
      };
      Logger.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.WARN], args));
        this._logHandler.apply(this, __spreadArrays([this, LogLevel.WARN], args));
      };
      Logger.prototype.error = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        this._userLogHandler && this._userLogHandler.apply(this, __spreadArrays([this, LogLevel.ERROR], args));
        this._logHandler.apply(this, __spreadArrays([this, LogLevel.ERROR], args));
      };
      return Logger;
    })();
    function setLogLevel(level) {
      instances.forEach(function (inst) {
        inst.setLogLevel(level);
      });
    }
    function setUserLogHandler(logCallback, options) {
      var _loop_1 = function (instance) {
        var customLogLevel = null;
        if (options && options.level) {
          customLogLevel = levelStringToEnum[options.level];
        }
        if (logCallback === null) {
          instance.userLogHandler = null;
        } else {
          instance.userLogHandler = function (instance, level) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
              args[_i - 2] = arguments[_i];
            }
            var message = args
              .map(function (arg) {
                if (arg == null) {
                  return null;
                } else if (typeof arg === 'string') {
                  return arg;
                } else if (typeof arg === 'number' || typeof arg === 'boolean') {
                  return arg.toString();
                } else if (arg instanceof Error) {
                  return arg.message;
                } else {
                  try {
                    return JSON.stringify(arg);
                  } catch (ignored) {
                    return null;
                  }
                }
              })
              .filter(function (arg) {
                return arg;
              })
              .join(' ');
            if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance.logLevel)) {
              logCallback({
                level: LogLevel[level].toLowerCase(),
                message: message,
                args: args,
                type: instance.name,
              });
            }
          };
        }
      };
      for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
        var instance = instances_1[_i];
        _loop_1(instance);
      }
    }

    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var _a$1;
    var ERRORS =
      ((_a$1 = {}),
      (_a$1['no-app' /* NO_APP */] = "No Firebase App '{$appName}' has been created - " + 'call Firebase App.initializeApp()'),
      (_a$1['bad-app-name' /* BAD_APP_NAME */] = "Illegal App name: '{$appName}"),
      (_a$1['duplicate-app' /* DUPLICATE_APP */] = "Firebase App named '{$appName}' already exists"),
      (_a$1['app-deleted' /* APP_DELETED */] = "Firebase App named '{$appName}' already deleted"),
      (_a$1['invalid-app-argument' /* INVALID_APP_ARGUMENT */] = 'firebase.{$appName}() takes either no argument or a ' + 'Firebase App instance.'),
      (_a$1['invalid-log-argument' /* INVALID_LOG_ARGUMENT */] = 'First argument to `onLog` must be null or a function.'),
      _a$1);
    var ERROR_FACTORY = new ErrorFactory('app', 'Firebase', ERRORS);

    var name$c = '@firebase/app';
    var version$1 = '0.6.30';

    var name$b = '@firebase/analytics';

    var name$a = '@firebase/app-check';

    var name$9 = '@firebase/auth';

    var name$8 = '@firebase/database';

    var name$7 = '@firebase/functions';

    var name$6 = '@firebase/installations';

    var name$5 = '@firebase/messaging';

    var name$4 = '@firebase/performance';

    var name$3 = '@firebase/remote-config';

    var name$2 = '@firebase/storage';

    var name$1 = '@firebase/firestore';

    var name$d = 'firebase-wrapper';

    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var _a;
    var DEFAULT_ENTRY_NAME = '[DEFAULT]';
    var PLATFORM_LOG_STRING =
      ((_a = {}),
      (_a[name$c] = 'fire-core'),
      (_a[name$b] = 'fire-analytics'),
      (_a[name$a] = 'fire-app-check'),
      (_a[name$9] = 'fire-auth'),
      (_a[name$8] = 'fire-rtdb'),
      (_a[name$7] = 'fire-fn'),
      (_a[name$6] = 'fire-iid'),
      (_a[name$5] = 'fire-fcm'),
      (_a[name$4] = 'fire-perf'),
      (_a[name$3] = 'fire-rc'),
      (_a[name$2] = 'fire-gcs'),
      (_a[name$1] = 'fire-fst'),
      (_a['fire-js'] = 'fire-js'),
      (_a[name$d] = 'fire-js-all'),
      _a);

    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var logger = new Logger('@firebase/app');

    /**
     * @license
     * Copyright 2017 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Global context object for a collection of services using
     * a shared authentication state.
     */
    var FirebaseAppImpl = /** @class */ (function () {
      function FirebaseAppImpl(options, config, firebase_) {
        var _this = this;
        this.firebase_ = firebase_;
        this.isDeleted_ = false;
        this.name_ = config.name;
        this.automaticDataCollectionEnabled_ = config.automaticDataCollectionEnabled || false;
        this.options_ = deepCopy(options);
        this.container = new ComponentContainer(config.name);
        // add itself to container
        this._addComponent(
          new Component(
            'app',
            function () {
              return _this;
            },
            'PUBLIC' /* PUBLIC */,
          ),
        );
        // populate ComponentContainer with existing components
        this.firebase_.INTERNAL.components.forEach(function (component) {
          return _this._addComponent(component);
        });
      }
      Object.defineProperty(FirebaseAppImpl.prototype, 'automaticDataCollectionEnabled', {
        get: function () {
          this.checkDestroyed_();
          return this.automaticDataCollectionEnabled_;
        },
        set: function (val) {
          this.checkDestroyed_();
          this.automaticDataCollectionEnabled_ = val;
        },
        enumerable: false,
        configurable: true,
      });
      Object.defineProperty(FirebaseAppImpl.prototype, 'name', {
        get: function () {
          this.checkDestroyed_();
          return this.name_;
        },
        enumerable: false,
        configurable: true,
      });
      Object.defineProperty(FirebaseAppImpl.prototype, 'options', {
        get: function () {
          this.checkDestroyed_();
          return this.options_;
        },
        enumerable: false,
        configurable: true,
      });
      FirebaseAppImpl.prototype.delete = function () {
        var _this = this;
        return new Promise(function (resolve) {
          _this.checkDestroyed_();
          resolve();
        })
          .then(function () {
            _this.firebase_.INTERNAL.removeApp(_this.name_);
            return Promise.all(
              _this.container.getProviders().map(function (provider) {
                return provider.delete();
              }),
            );
          })
          .then(function () {
            _this.isDeleted_ = true;
          });
      };
      /**
       * Return a service instance associated with this app (creating it
       * on demand), identified by the passed instanceIdentifier.
       *
       * NOTE: Currently storage and functions are the only ones that are leveraging this
       * functionality. They invoke it by calling:
       *
       * ```javascript
       * firebase.app().storage('STORAGE BUCKET ID')
       * ```
       *
       * The service name is passed to this already
       * @internal
       */
      FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {
        var _a;
        if (instanceIdentifier === void 0) {
          instanceIdentifier = DEFAULT_ENTRY_NAME;
        }
        this.checkDestroyed_();
        // Initialize instance if InstatiationMode is `EXPLICIT`.
        var provider = this.container.getProvider(name);
        if (!provider.isInitialized() && ((_a = provider.getComponent()) === null || _a === void 0 ? void 0 : _a.instantiationMode) === 'EXPLICIT' /* EXPLICIT */) {
          provider.initialize();
        }
        // getImmediate will always succeed because _getService is only called for registered components.
        return provider.getImmediate({
          identifier: instanceIdentifier,
        });
      };
      /**
       * Remove a service instance from the cache, so we will create a new instance for this service
       * when people try to get this service again.
       *
       * NOTE: currently only firestore is using this functionality to support firestore shutdown.
       *
       * @param name The service name
       * @param instanceIdentifier instance identifier in case multiple instances are allowed
       * @internal
       */
      FirebaseAppImpl.prototype._removeServiceInstance = function (name, instanceIdentifier) {
        if (instanceIdentifier === void 0) {
          instanceIdentifier = DEFAULT_ENTRY_NAME;
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        this.container.getProvider(name).clearInstance(instanceIdentifier);
      };
      /**
       * @param component the component being added to this app's container
       */
      FirebaseAppImpl.prototype._addComponent = function (component) {
        try {
          this.container.addComponent(component);
        } catch (e) {
          logger.debug('Component ' + component.name + ' failed to register with FirebaseApp ' + this.name, e);
        }
      };
      FirebaseAppImpl.prototype._addOrOverwriteComponent = function (component) {
        this.container.addOrOverwriteComponent(component);
      };
      FirebaseAppImpl.prototype.toJSON = function () {
        return {
          name: this.name,
          automaticDataCollectionEnabled: this.automaticDataCollectionEnabled,
          options: this.options,
        };
      };
      /**
       * This function will throw an Error if the App has already been deleted -
       * use before performing API actions on the App.
       */
      FirebaseAppImpl.prototype.checkDestroyed_ = function () {
        if (this.isDeleted_) {
          throw ERROR_FACTORY.create('app-deleted' /* APP_DELETED */, { appName: this.name_ });
        }
      };
      return FirebaseAppImpl;
    })();
    // Prevent dead-code elimination of these methods w/o invalid property
    // copying.
    (FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) || FirebaseAppImpl.prototype.delete || console.log('dc');

    var version$2 = '8.10.0';

    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Because auth can't share code with other components, we attach the utility functions
     * in an internal namespace to share code.
     * This function return a firebase namespace object without
     * any utility functions, so it can be shared between the regular firebaseNamespace and
     * the lite version.
     */
    function createFirebaseNamespaceCore(firebaseAppImpl) {
      var apps = {};
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      var components = new Map();
      // A namespace is a plain JavaScript Object.
      var namespace = {
        // Hack to prevent Babel from modifying the object returned
        // as the firebase namespace.
        // @ts-ignore
        __esModule: true,
        initializeApp: initializeApp,
        // @ts-ignore
        app: app,
        registerVersion: registerVersion,
        setLogLevel: setLogLevel,
        onLog: onLog,
        // @ts-ignore
        apps: null,
        SDK_VERSION: version$2,
        INTERNAL: {
          registerComponent: registerComponent,
          removeApp: removeApp,
          components: components,
          useAsService: useAsService,
        },
      };
      // Inject a circular default export to allow Babel users who were previously
      // using:
      //
      //   import firebase from 'firebase';
      //   which becomes: var firebase = require('firebase').default;
      //
      // instead of
      //
      //   import * as firebase from 'firebase';
      //   which becomes: var firebase = require('firebase');
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      namespace['default'] = namespace;
      // firebase.apps is a read-only getter.
      Object.defineProperty(namespace, 'apps', {
        get: getApps,
      });
      /**
       * Called by App.delete() - but before any services associated with the App
       * are deleted.
       */
      function removeApp(name) {
        delete apps[name];
      }
      /**
       * Get the App object for a given name (or DEFAULT).
       */
      function app(name) {
        name = name || DEFAULT_ENTRY_NAME;
        if (!contains(apps, name)) {
          throw ERROR_FACTORY.create('no-app' /* NO_APP */, { appName: name });
        }
        return apps[name];
      }
      // @ts-ignore
      app['App'] = firebaseAppImpl;
      function initializeApp(options, rawConfig) {
        if (rawConfig === void 0) {
          rawConfig = {};
        }
        if (typeof rawConfig !== 'object' || rawConfig === null) {
          var name_1 = rawConfig;
          rawConfig = { name: name_1 };
        }
        var config = rawConfig;
        if (config.name === undefined) {
          config.name = DEFAULT_ENTRY_NAME;
        }
        var name = config.name;
        if (typeof name !== 'string' || !name) {
          throw ERROR_FACTORY.create('bad-app-name' /* BAD_APP_NAME */, {
            appName: String(name),
          });
        }
        if (contains(apps, name)) {
          throw ERROR_FACTORY.create('duplicate-app' /* DUPLICATE_APP */, { appName: name });
        }
        var app = new firebaseAppImpl(options, config, namespace);
        apps[name] = app;
        return app;
      }
      /*
       * Return an array of all the non-deleted FirebaseApps.
       */
      function getApps() {
        // Make a copy so caller cannot mutate the apps list.
        return Object.keys(apps).map(function (name) {
          return apps[name];
        });
      }
      function registerComponent(component) {
        var componentName = component.name;
        if (components.has(componentName)) {
          logger.debug('There were multiple attempts to register component ' + componentName + '.');
          return component.type === 'PUBLIC' /* PUBLIC */
            ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
              namespace[componentName]
            : null;
        }
        components.set(componentName, component);
        // create service namespace for public components
        if (component.type === 'PUBLIC' /* PUBLIC */) {
          // The Service namespace is an accessor function ...
          var serviceNamespace = function (appArg) {
            if (appArg === void 0) {
              appArg = app();
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            if (typeof appArg[componentName] !== 'function') {
              // Invalid argument.
              // This happens in the following case: firebase.storage('gs:/')
              throw ERROR_FACTORY.create('invalid-app-argument' /* INVALID_APP_ARGUMENT */, {
                appName: componentName,
              });
            }
            // Forward service instance lookup to the FirebaseApp.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return appArg[componentName]();
          };
          // ... and a container for service-level properties.
          if (component.serviceProps !== undefined) {
            deepExtend(serviceNamespace, component.serviceProps);
          }
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          namespace[componentName] = serviceNamespace;
          // Patch the FirebaseAppImpl prototype
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          firebaseAppImpl.prototype[componentName] =
            // TODO: The eslint disable can be removed and the 'ignoreRestArgs'
            // option added to the no-explicit-any rule when ESlint releases it.
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            function () {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              var serviceFxn = this._getService.bind(this, componentName);
              return serviceFxn.apply(this, component.multipleInstances ? args : []);
            };
        }
        // add the component to existing app instances
        for (var _i = 0, _a = Object.keys(apps); _i < _a.length; _i++) {
          var appName = _a[_i];
          apps[appName]._addComponent(component);
        }
        return component.type === 'PUBLIC' /* PUBLIC */
          ? // eslint-disable-next-line @typescript-eslint/no-explicit-any
            namespace[componentName]
          : null;
      }
      function registerVersion(libraryKeyOrName, version, variant) {
        var _a;
        // TODO: We can use this check to whitelist strings when/if we set up
        // a good whitelist system.
        var library = (_a = PLATFORM_LOG_STRING[libraryKeyOrName]) !== null && _a !== void 0 ? _a : libraryKeyOrName;
        if (variant) {
          library += '-' + variant;
        }
        var libraryMismatch = library.match(/\s|\//);
        var versionMismatch = version.match(/\s|\//);
        if (libraryMismatch || versionMismatch) {
          var warning = ['Unable to register library "' + library + '" with version "' + version + '":'];
          if (libraryMismatch) {
            warning.push('library name "' + library + '" contains illegal characters (whitespace or "/")');
          }
          if (libraryMismatch && versionMismatch) {
            warning.push('and');
          }
          if (versionMismatch) {
            warning.push('version name "' + version + '" contains illegal characters (whitespace or "/")');
          }
          logger.warn(warning.join(' '));
          return;
        }
        registerComponent(
          new Component(
            library + '-version',
            function () {
              return { library: library, version: version };
            },
            'VERSION' /* VERSION */,
          ),
        );
      }
      function onLog(logCallback, options) {
        if (logCallback !== null && typeof logCallback !== 'function') {
          throw ERROR_FACTORY.create('invalid-log-argument' /* INVALID_LOG_ARGUMENT */);
        }
        setUserLogHandler(logCallback, options);
      }
      // Map the requested service to a registered service name
      // (used to map auth to serverAuth service when needed).
      function useAsService(app, name) {
        if (name === 'serverAuth') {
          return null;
        }
        var useService = name;
        return useService;
      }
      return namespace;
    }

    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Return a firebase namespace object.
     *
     * In production, this will be called exactly once and the result
     * assigned to the 'firebase' global.  It may be called multiple times
     * in unit tests.
     */
    function createFirebaseNamespace() {
      var namespace = createFirebaseNamespaceCore(FirebaseAppImpl);
      namespace.INTERNAL = __assign(__assign({}, namespace.INTERNAL), {
        createFirebaseNamespace: createFirebaseNamespace,
        extendNamespace: extendNamespace,
        createSubscribe: createSubscribe,
        ErrorFactory: ErrorFactory,
        deepExtend: deepExtend,
      });
      /**
       * Patch the top-level firebase namespace with additional properties.
       *
       * firebase.INTERNAL.extendNamespace()
       */
      function extendNamespace(props) {
        deepExtend(namespace, props);
      }
      return namespace;
    }
    var firebase$1 = createFirebaseNamespace();

    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var PlatformLoggerService = /** @class */ (function () {
      function PlatformLoggerService(container) {
        this.container = container;
      }
      // In initial implementation, this will be called by installations on
      // auth token refresh, and installations will send this string.
      PlatformLoggerService.prototype.getPlatformInfoString = function () {
        var providers = this.container.getProviders();
        // Loop through providers and get library/version pairs from any that are
        // version components.
        return providers
          .map(function (provider) {
            if (isVersionServiceProvider(provider)) {
              var service = provider.getImmediate();
              return service.library + '/' + service.version;
            } else {
              return null;
            }
          })
          .filter(function (logString) {
            return logString;
          })
          .join(' ');
      };
      return PlatformLoggerService;
    })();
    /**
     *
     * @param provider check if this provider provides a VersionService
     *
     * NOTE: Using Provider<'app-version'> is a hack to indicate that the provider
     * provides VersionService. The provider is not necessarily a 'app-version'
     * provider.
     */
    function isVersionServiceProvider(provider) {
      var component = provider.getComponent();
      return (component === null || component === void 0 ? void 0 : component.type) === 'VERSION' /* VERSION */;
    }

    /**
     * @license
     * Copyright 2019 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    function registerCoreComponents(firebase, variant) {
      firebase.INTERNAL.registerComponent(
        new Component(
          'platform-logger',
          function (container) {
            return new PlatformLoggerService(container);
          },
          'PRIVATE' /* PRIVATE */,
        ),
      );
      // Register `app` package.
      firebase.registerVersion(name$c, version$1, variant);
      // Register platform SDK identifier (no version).
      firebase.registerVersion('fire-js', '');
    }

    /**
     * @license
     * Copyright 2017 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    // Firebase Lite detection test
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (isBrowser() && self.firebase !== undefined) {
      logger.warn('\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  ');
      // eslint-disable-next-line
      var sdkVersion = self.firebase.SDK_VERSION;
      if (sdkVersion && sdkVersion.indexOf('LITE') >= 0) {
        logger.warn(
          '\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    ',
        );
      }
    }
    var initializeApp = firebase$1.initializeApp;
    // TODO: This disable can be removed and the 'ignoreRestArgs' option added to
    // the no-explicit-any rule when ESlint releases it.
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    firebase$1.initializeApp = function () {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      // Environment check before initializing app
      // Do the check in initializeApp, so people have a chance to disable it by setting logLevel
      // in @firebase/logger
      if (isNode$1()) {
        logger.warn(
          '\n      Warning: This is a browser-targeted Firebase bundle but it appears it is being\n      run in a Node environment.  If running in a Node environment, make sure you\n      are using the bundle specified by the "main" field in package.json.\n      \n      If you are using Webpack, you can specify "main" as the first item in\n      "resolve.mainFields":\n      https://webpack.js.org/configuration/resolve/#resolvemainfields\n      \n      If using Rollup, use the @rollup/plugin-node-resolve plugin and specify "main"\n      as the first item in "mainFields", e.g. [\'main\', \'module\'].\n      https://github.com/rollup/@rollup/plugin-node-resolve\n      ',
        );
      }
      return initializeApp.apply(undefined, args);
    };
    var firebase = firebase$1;
    registerCoreComponents(firebase);

    (function () {
      /*

 Copyright The Closure Library Authors.
 SPDX-License-Identifier: Apache-2.0
*/
      var k,
        aa =
          'function' == typeof Object.defineProperties
            ? Object.defineProperty
            : function (a, b, c) {
                a != Array.prototype && a != Object.prototype && (a[b] = c.value);
              };
      function ba(a) {
        a = ['object' == typeof window && window, 'object' == typeof self && self, 'object' == typeof global && global, a];
        for (var b = 0; b < a.length; ++b) {
          var c = a[b];
          if (c && c.Math == Math) return c;
        }
        return globalThis;
      }
      var ca = ba(this);
      function da(a, b) {
        if (b) {
          var c = ca;
          a = a.split('.');
          for (var d = 0; d < a.length - 1; d++) {
            var e = a[d];
            e in c || (c[e] = {});
            c = c[e];
          }
          a = a[a.length - 1];
          d = c[a];
          b = b(d);
          b != d && null != b && aa(c, a, { configurable: !0, writable: !0, value: b });
        }
      }
      function ea(a) {
        var b = 0;
        return function () {
          return b < a.length ? { done: !1, value: a[b++] } : { done: !0 };
        };
      }
      function fa(a) {
        var b = 'undefined' != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
        return b ? b.call(a) : { next: ea(a) };
      }
      da('Promise', function (a) {
        function b(g) {
          this.b = 0;
          this.c = void 0;
          this.a = [];
          var h = this.f();
          try {
            g(h.resolve, h.reject);
          } catch (m) {
            h.reject(m);
          }
        }
        function c() {
          this.a = null;
        }
        function d(g) {
          return g instanceof b
            ? g
            : new b(function (h) {
                h(g);
              });
        }
        if (a) return a;
        c.prototype.b = function (g) {
          if (null == this.a) {
            this.a = [];
            var h = this;
            this.c(function () {
              h.g();
            });
          }
          this.a.push(g);
        };
        var e = ca.setTimeout;
        c.prototype.c = function (g) {
          e(g, 0);
        };
        c.prototype.g = function () {
          for (; this.a && this.a.length; ) {
            var g = this.a;
            this.a = [];
            for (var h = 0; h < g.length; ++h) {
              var m = g[h];
              g[h] = null;
              try {
                m();
              } catch (p) {
                this.f(p);
              }
            }
          }
          this.a = null;
        };
        c.prototype.f = function (g) {
          this.c(function () {
            throw g;
          });
        };
        b.prototype.f = function () {
          function g(p) {
            return function (v) {
              m || ((m = !0), p.call(h, v));
            };
          }
          var h = this,
            m = !1;
          return { resolve: g(this.m), reject: g(this.g) };
        };
        b.prototype.m = function (g) {
          if (g === this) this.g(new TypeError('A Promise cannot resolve to itself'));
          else if (g instanceof b) this.s(g);
          else {
            a: switch (typeof g) {
              case 'object':
                var h = null != g;
                break a;
              case 'function':
                h = !0;
                break a;
              default:
                h = !1;
            }
            h ? this.v(g) : this.h(g);
          }
        };
        b.prototype.v = function (g) {
          var h = void 0;
          try {
            h = g.then;
          } catch (m) {
            this.g(m);
            return;
          }
          'function' == typeof h ? this.u(h, g) : this.h(g);
        };
        b.prototype.g = function (g) {
          this.i(2, g);
        };
        b.prototype.h = function (g) {
          this.i(1, g);
        };
        b.prototype.i = function (g, h) {
          if (0 != this.b) throw Error('Cannot settle(' + g + ', ' + h + '): Promise already settled in state' + this.b);
          this.b = g;
          this.c = h;
          this.l();
        };
        b.prototype.l = function () {
          if (null != this.a) {
            for (var g = 0; g < this.a.length; ++g) f.b(this.a[g]);
            this.a = null;
          }
        };
        var f = new c();
        b.prototype.s = function (g) {
          var h = this.f();
          g.Ra(h.resolve, h.reject);
        };
        b.prototype.u = function (g, h) {
          var m = this.f();
          try {
            g.call(h, m.resolve, m.reject);
          } catch (p) {
            m.reject(p);
          }
        };
        b.prototype.then = function (g, h) {
          function m(A, Q) {
            return 'function' == typeof A
              ? function (ya) {
                  try {
                    p(A(ya));
                  } catch (Ad) {
                    v(Ad);
                  }
                }
              : Q;
          }
          var p,
            v,
            B = new b(function (A, Q) {
              p = A;
              v = Q;
            });
          this.Ra(m(g, p), m(h, v));
          return B;
        };
        b.prototype.catch = function (g) {
          return this.then(void 0, g);
        };
        b.prototype.Ra = function (g, h) {
          function m() {
            switch (p.b) {
              case 1:
                g(p.c);
                break;
              case 2:
                h(p.c);
                break;
              default:
                throw Error('Unexpected state: ' + p.b);
            }
          }
          var p = this;
          null == this.a ? f.b(m) : this.a.push(m);
        };
        b.resolve = d;
        b.reject = function (g) {
          return new b(function (h, m) {
            m(g);
          });
        };
        b.race = function (g) {
          return new b(function (h, m) {
            for (var p = fa(g), v = p.next(); !v.done; v = p.next()) d(v.value).Ra(h, m);
          });
        };
        b.all = function (g) {
          var h = fa(g),
            m = h.next();
          return m.done
            ? d([])
            : new b(function (p, v) {
                function B(ya) {
                  return function (Ad) {
                    A[ya] = Ad;
                    Q--;
                    0 == Q && p(A);
                  };
                }
                var A = [],
                  Q = 0;
                do A.push(void 0), Q++, d(m.value).Ra(B(A.length - 1), v), (m = h.next());
                while (!m.done);
              });
        };
        return b;
      });
      var ha = ha || {},
        l = this || self,
        ia = /^[\w+/_-]+[=]{0,2}$/,
        ja = null;
      function ka(a) {
        return (a = a.querySelector && a.querySelector('script[nonce]')) && (a = a.nonce || a.getAttribute('nonce')) && ia.test(a) ? a : '';
      }
      function la() {}
      function ma(a) {
        var b = typeof a;
        return 'object' != b ? b : a ? (Array.isArray(a) ? 'array' : b) : 'null';
      }
      function na(a) {
        var b = ma(a);
        return 'array' == b || ('object' == b && 'number' == typeof a.length);
      }
      function oa(a) {
        return 'function' == ma(a);
      }
      function n(a) {
        var b = typeof a;
        return ('object' == b && null != a) || 'function' == b;
      }
      function pa(a) {
        return (Object.prototype.hasOwnProperty.call(a, qa) && a[qa]) || (a[qa] = ++ra);
      }
      var qa = 'closure_uid_' + ((1e9 * Math.random()) >>> 0),
        ra = 0;
      function sa(a, b, c) {
        return a.call.apply(a.bind, arguments);
      }
      function ta(a, b, c) {
        if (!a) throw Error();
        if (2 < arguments.length) {
          var d = Array.prototype.slice.call(arguments, 2);
          return function () {
            var e = Array.prototype.slice.call(arguments);
            Array.prototype.unshift.apply(e, d);
            return a.apply(b, e);
          };
        }
        return function () {
          return a.apply(b, arguments);
        };
      }
      function q(a, b, c) {
        Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf('native code') ? (q = sa) : (q = ta);
        return q.apply(null, arguments);
      }
      function ua(a, b) {
        var c = Array.prototype.slice.call(arguments, 1);
        return function () {
          var d = c.slice();
          d.push.apply(d, arguments);
          return a.apply(this, d);
        };
      }
      function r(a, b) {
        function c() {}
        c.prototype = b.prototype;
        a.bb = b.prototype;
        a.prototype = new c();
        a.prototype.constructor = a;
      }
      function wa(a) {
        return a;
      }
      function t(a, b, c) {
        this.code = xa + a;
        this.message = b || za[a] || '';
        this.a = c || null;
      }
      r(t, Error);
      t.prototype.w = function () {
        var a = { code: this.code, message: this.message };
        this.a && (a.serverResponse = this.a);
        return a;
      };
      t.prototype.toJSON = function () {
        return this.w();
      };
      function Aa(a) {
        var b = a && a.code;
        return b ? new t(b.substring(xa.length), a.message, a.serverResponse) : null;
      }
      var xa = 'auth/',
        za = {
          'admin-restricted-operation': 'This operation is restricted to administrators only.',
          'argument-error': '',
          'app-not-authorized':
            "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.",
          'app-not-installed': 'The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.',
          'captcha-check-failed':
            'The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.',
          'code-expired': 'The SMS code has expired. Please re-send the verification code to try again.',
          'cordova-not-ready': 'Cordova framework is not ready.',
          'cors-unsupported': 'This browser is not supported.',
          'credential-already-in-use': 'This credential is already associated with a different user account.',
          'custom-token-mismatch': 'The custom token corresponds to a different audience.',
          'requires-recent-login': 'This operation is sensitive and requires recent authentication. Log in again before retrying this request.',
          'dynamic-link-not-activated': 'Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.',
          'email-change-needs-verification': 'Multi-factor users must always have a verified email.',
          'email-already-in-use': 'The email address is already in use by another account.',
          'expired-action-code': 'The action code has expired. ',
          'cancelled-popup-request': 'This operation has been cancelled due to another conflicting popup being opened.',
          'internal-error': 'An internal error has occurred.',
          'invalid-app-credential': 'The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.',
          'invalid-app-id': 'The mobile app identifier is not registed for the current project.',
          'invalid-user-token':
            "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.",
          'invalid-auth-event': 'An internal error has occurred.',
          'invalid-verification-code':
            'The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.',
          'invalid-continue-uri': 'The continue URL provided in the request is invalid.',
          'invalid-cordova-configuration':
            'The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.',
          'invalid-custom-token': 'The custom token format is incorrect. Please check the documentation.',
          'invalid-dynamic-link-domain': 'The provided dynamic link domain is not configured or authorized for the current project.',
          'invalid-email': 'The email address is badly formatted.',
          'invalid-api-key': 'Your API key is invalid, please check you have copied it correctly.',
          'invalid-cert-hash': 'The SHA-1 certificate hash provided is invalid.',
          'invalid-credential': 'The supplied auth credential is malformed or has expired.',
          'invalid-message-payload':
            'The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.',
          'invalid-multi-factor-session': 'The request does not contain a valid proof of first factor successful sign-in.',
          'invalid-oauth-provider': 'EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.',
          'invalid-oauth-client-id': 'The OAuth client ID provided is either invalid or does not match the specified API key.',
          'unauthorized-domain': 'This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.',
          'invalid-action-code': 'The action code is invalid. This can happen if the code is malformed, expired, or has already been used.',
          'wrong-password': 'The password is invalid or the user does not have a password.',
          'invalid-persistence-type': 'The specified persistence type is invalid. It can only be local, session or none.',
          'invalid-phone-number':
            'The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].',
          'invalid-provider-id': 'The specified provider ID is invalid.',
          'invalid-recipient-email': 'The email corresponding to this action failed to send as the provided recipient email address is invalid.',
          'invalid-sender':
            'The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.',
          'invalid-verification-id': 'The verification ID used to create the phone auth credential is invalid.',
          'invalid-tenant-id': "The Auth instance's tenant ID is invalid.",
          'multi-factor-info-not-found': 'The user does not have a second factor matching the identifier provided.',
          'multi-factor-auth-required': 'Proof of ownership of a second factor is required to complete sign-in.',
          'missing-android-pkg-name': 'An Android Package Name must be provided if the Android App is required to be installed.',
          'auth-domain-config-required': 'Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.',
          'missing-app-credential': 'The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.',
          'missing-verification-code': 'The phone auth credential was created with an empty SMS verification code.',
          'missing-continue-uri': 'A continue URL must be provided in the request.',
          'missing-iframe-start': 'An internal error has occurred.',
          'missing-ios-bundle-id': 'An iOS Bundle ID must be provided if an App Store ID is provided.',
          'missing-multi-factor-info': 'No second factor identifier is provided.',
          'missing-multi-factor-session': 'The request is missing proof of first factor successful sign-in.',
          'missing-or-invalid-nonce':
            'The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.',
          'missing-phone-number': 'To send verification codes, provide a phone number for the recipient.',
          'missing-verification-id': 'The phone auth credential was created with an empty verification ID.',
          'app-deleted': 'This instance of FirebaseApp has been deleted.',
          'account-exists-with-different-credential':
            'An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.',
          'network-request-failed': 'A network error (such as timeout, interrupted connection or unreachable host) has occurred.',
          'no-auth-event': 'An internal error has occurred.',
          'no-such-provider': 'User was not linked to an account with the given provider.',
          'null-user': 'A null user object was provided as the argument for an operation which requires a non-null user object.',
          'operation-not-allowed':
            'The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.',
          'operation-not-supported-in-this-environment':
            'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',
          'popup-blocked': 'Unable to establish a connection with the popup. It may have been blocked by the browser.',
          'popup-closed-by-user': 'The popup has been closed by the user before finalizing the operation.',
          'provider-already-linked': 'User can only be linked to one identity for the given provider.',
          'quota-exceeded': "The project's quota for this operation has been exceeded.",
          'redirect-cancelled-by-user': 'The redirect operation has been cancelled by the user before finalizing.',
          'redirect-operation-pending': 'A redirect sign-in operation is already pending.',
          'rejected-credential': 'The request contains malformed or mismatching credentials.',
          'second-factor-already-in-use': 'The second factor is already enrolled on this account.',
          'maximum-second-factor-count-exceeded': 'The maximum allowed number of second factors on a user has been exceeded.',
          'tenant-id-mismatch': "The provided tenant ID does not match the Auth instance's tenant ID",
          'timeout': 'The operation has timed out.',
          'user-token-expired': "The user's credential is no longer valid. The user must sign in again.",
          'too-many-requests': 'We have blocked all requests from this device due to unusual activity. Try again later.',
          'unauthorized-continue-uri': 'The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.',
          'unsupported-first-factor': 'Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.',
          'unsupported-persistence-type': 'The current environment does not support the specified persistence type.',
          'unsupported-tenant-operation': 'This operation is not supported in a multi-tenant context.',
          'unverified-email': 'The operation requires a verified email.',
          'user-cancelled': 'The user did not grant your application the permissions it requested.',
          'user-not-found': 'There is no user record corresponding to this identifier. The user may have been deleted.',
          'user-disabled': 'The user account has been disabled by an administrator.',
          'user-mismatch': 'The supplied credentials do not correspond to the previously signed in user.',
          'user-signed-out': '',
          'weak-password': 'The password must be 6 characters long or more.',
          'web-storage-unsupported': 'This browser is not supported or 3rd party cookies and data may be disabled.',
        };
      var Ba = {
        ld: {
          Ua: 'https://staging-identitytoolkit.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/',
          $a: 'https://staging-securetoken.sandbox.googleapis.com/v1/token',
          Xa: 'https://staging-identitytoolkit.sandbox.googleapis.com/v2/',
          id: 'b',
        },
        sd: {
          Ua: 'https://www.googleapis.com/identitytoolkit/v3/relyingparty/',
          $a: 'https://securetoken.googleapis.com/v1/token',
          Xa: 'https://identitytoolkit.googleapis.com/v2/',
          id: 'p',
        },
        ud: {
          Ua: 'https://staging-www.sandbox.googleapis.com/identitytoolkit/v3/relyingparty/',
          $a: 'https://staging-securetoken.sandbox.googleapis.com/v1/token',
          Xa: 'https://staging-identitytoolkit.sandbox.googleapis.com/v2/',
          id: 's',
        },
        vd: {
          Ua: 'https://www-googleapis-test.sandbox.google.com/identitytoolkit/v3/relyingparty/',
          $a: 'https://test-securetoken.sandbox.googleapis.com/v1/token',
          Xa: 'https://test-identitytoolkit.sandbox.googleapis.com/v2/',
          id: 't',
        },
      };
      function Ca(a) {
        for (var b in Ba) if (Ba[b].id === a) return (a = Ba[b]), { firebaseEndpoint: a.Ua, secureTokenEndpoint: a.$a, identityPlatformEndpoint: a.Xa };
        return null;
      }
      var Da;
      Da = Ca('__EID__') ? '__EID__' : void 0;
      function Ea(a) {
        if (!a) return !1;
        try {
          return !!a.$goog_Thenable;
        } catch (b) {
          return !1;
        }
      }
      function u(a) {
        if (Error.captureStackTrace) Error.captureStackTrace(this, u);
        else {
          var b = Error().stack;
          b && (this.stack = b);
        }
        a && (this.message = String(a));
      }
      r(u, Error);
      u.prototype.name = 'CustomError';
      function Fa(a, b) {
        a = a.split('%s');
        for (var c = '', d = a.length - 1, e = 0; e < d; e++) c += a[e] + (e < b.length ? b[e] : '%s');
        u.call(this, c + a[d]);
      }
      r(Fa, u);
      Fa.prototype.name = 'AssertionError';
      function Ga(a, b) {
        throw new Fa('Failure' + (a ? ': ' + a : ''), Array.prototype.slice.call(arguments, 1));
      }
      function Ha(a, b) {
        this.c = a;
        this.f = b;
        this.b = 0;
        this.a = null;
      }
      Ha.prototype.get = function () {
        if (0 < this.b) {
          this.b--;
          var a = this.a;
          this.a = a.next;
          a.next = null;
        } else a = this.c();
        return a;
      };
      function Ia(a, b) {
        a.f(b);
        100 > a.b && (a.b++, (b.next = a.a), (a.a = b));
      }
      function Ja() {
        this.b = this.a = null;
      }
      var La = new Ha(
        function () {
          return new Ka();
        },
        function (a) {
          a.reset();
        },
      );
      Ja.prototype.add = function (a, b) {
        var c = La.get();
        c.set(a, b);
        this.b ? (this.b.next = c) : (this.a = c);
        this.b = c;
      };
      function Ma() {
        var a = Na,
          b = null;
        a.a && ((b = a.a), (a.a = a.a.next), a.a || (a.b = null), (b.next = null));
        return b;
      }
      function Ka() {
        this.next = this.b = this.a = null;
      }
      Ka.prototype.set = function (a, b) {
        this.a = a;
        this.b = b;
        this.next = null;
      };
      Ka.prototype.reset = function () {
        this.next = this.b = this.a = null;
      };
      var Oa = Array.prototype.indexOf
          ? function (a, b) {
              return Array.prototype.indexOf.call(a, b, void 0);
            }
          : function (a, b) {
              if ('string' === typeof a) return 'string' !== typeof b || 1 != b.length ? -1 : a.indexOf(b, 0);
              for (var c = 0; c < a.length; c++) if (c in a && a[c] === b) return c;
              return -1;
            },
        w = Array.prototype.forEach
          ? function (a, b, c) {
              Array.prototype.forEach.call(a, b, c);
            }
          : function (a, b, c) {
              for (var d = a.length, e = 'string' === typeof a ? a.split('') : a, f = 0; f < d; f++) f in e && b.call(c, e[f], f, a);
            };
      function Pa(a, b) {
        for (var c = 'string' === typeof a ? a.split('') : a, d = a.length - 1; 0 <= d; --d) d in c && b.call(void 0, c[d], d, a);
      }
      var Qa = Array.prototype.filter
          ? function (a, b) {
              return Array.prototype.filter.call(a, b, void 0);
            }
          : function (a, b) {
              for (var c = a.length, d = [], e = 0, f = 'string' === typeof a ? a.split('') : a, g = 0; g < c; g++)
                if (g in f) {
                  var h = f[g];
                  b.call(void 0, h, g, a) && (d[e++] = h);
                }
              return d;
            },
        Ra = Array.prototype.map
          ? function (a, b) {
              return Array.prototype.map.call(a, b, void 0);
            }
          : function (a, b) {
              for (var c = a.length, d = Array(c), e = 'string' === typeof a ? a.split('') : a, f = 0; f < c; f++) f in e && (d[f] = b.call(void 0, e[f], f, a));
              return d;
            },
        Sa = Array.prototype.some
          ? function (a, b) {
              return Array.prototype.some.call(a, b, void 0);
            }
          : function (a, b) {
              for (var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0; e < c; e++) if (e in d && b.call(void 0, d[e], e, a)) return !0;
              return !1;
            };
      function Ta(a) {
        a: {
          var b = Ua;
          for (var c = a.length, d = 'string' === typeof a ? a.split('') : a, e = 0; e < c; e++)
            if (e in d && b.call(void 0, d[e], e, a)) {
              b = e;
              break a;
            }
          b = -1;
        }
        return 0 > b ? null : 'string' === typeof a ? a.charAt(b) : a[b];
      }
      function Va(a, b) {
        return 0 <= Oa(a, b);
      }
      function Wa(a, b) {
        b = Oa(a, b);
        var c;
        (c = 0 <= b) && Array.prototype.splice.call(a, b, 1);
        return c;
      }
      function Xa(a, b) {
        var c = 0;
        Pa(a, function (d, e) {
          b.call(void 0, d, e, a) && 1 == Array.prototype.splice.call(a, e, 1).length && c++;
        });
      }
      function Ya(a) {
        return Array.prototype.concat.apply([], arguments);
      }
      function Za(a) {
        var b = a.length;
        if (0 < b) {
          for (var c = Array(b), d = 0; d < b; d++) c[d] = a[d];
          return c;
        }
        return [];
      }
      var $a = String.prototype.trim
          ? function (a) {
              return a.trim();
            }
          : function (a) {
              return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
            },
        ab = /&/g,
        bb = /</g,
        cb = />/g,
        db = /"/g,
        eb = /'/g,
        fb = /\x00/g,
        gb = /[\x00&<>"']/;
      function x(a, b) {
        return -1 != a.indexOf(b);
      }
      function hb(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      var ib;
      a: {
        var jb = l.navigator;
        if (jb) {
          var kb = jb.userAgent;
          if (kb) {
            ib = kb;
            break a;
          }
        }
        ib = '';
      }
      function y(a) {
        return x(ib, a);
      }
      function lb(a, b) {
        for (var c in a) b.call(void 0, a[c], c, a);
      }
      function mb(a) {
        for (var b in a) return !1;
        return !0;
      }
      function nb(a) {
        var b = {},
          c;
        for (c in a) b[c] = a[c];
        return b;
      }
      var ob = 'constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf'.split(' ');
      function z(a, b) {
        for (var c, d, e = 1; e < arguments.length; e++) {
          d = arguments[e];
          for (c in d) a[c] = d[c];
          for (var f = 0; f < ob.length; f++) (c = ob[f]), Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
        }
      }
      function pb(a, b) {
        a: {
          try {
            var c = a && a.ownerDocument,
              d = c && (c.defaultView || c.parentWindow);
            d = d || l;
            if (d.Element && d.Location) {
              var e = d;
              break a;
            }
          } catch (g) {}
          e = null;
        }
        if (e && 'undefined' != typeof e[b] && (!a || (!(a instanceof e[b]) && (a instanceof e.Location || a instanceof e.Element)))) {
          if (n(a))
            try {
              var f = a.constructor.displayName || a.constructor.name || Object.prototype.toString.call(a);
            } catch (g) {
              f = '<object could not be stringified>';
            }
          else f = void 0 === a ? 'undefined' : null === a ? 'null' : typeof a;
          Ga('Argument is not a %s (or a non-Element, non-Location mock); got: %s', b, f);
        }
      }
      function qb(a, b) {
        this.a = (a === rb && b) || '';
        this.b = sb;
      }
      qb.prototype.ta = !0;
      qb.prototype.sa = function () {
        return this.a;
      };
      qb.prototype.toString = function () {
        return 'Const{' + this.a + '}';
      };
      function tb(a) {
        if (a instanceof qb && a.constructor === qb && a.b === sb) return a.a;
        Ga("expected object of type Const, got '" + a + "'");
        return 'type_error:Const';
      }
      var sb = {},
        rb = {};
      var ub;
      function vb() {
        if (void 0 === ub) {
          var a = null,
            b = l.trustedTypes;
          if (b && b.createPolicy) {
            try {
              a = b.createPolicy('goog#html', { createHTML: wa, createScript: wa, createScriptURL: wa });
            } catch (c) {
              l.console && l.console.error(c.message);
            }
            ub = a;
          } else ub = a;
        }
        return ub;
      }
      function wb(a, b) {
        this.a = b === xb ? a : '';
      }
      wb.prototype.ta = !0;
      wb.prototype.sa = function () {
        return this.a.toString();
      };
      wb.prototype.toString = function () {
        return 'TrustedResourceUrl{' + this.a + '}';
      };
      function yb(a) {
        if (a instanceof wb && a.constructor === wb) return a.a;
        Ga("expected object of type TrustedResourceUrl, got '" + a + "' of type " + ma(a));
        return 'type_error:TrustedResourceUrl';
      }
      function zb(a, b) {
        var c = tb(a);
        if (!Ab.test(c)) throw Error('Invalid TrustedResourceUrl format: ' + c);
        a = c.replace(Bb, function (d, e) {
          if (!Object.prototype.hasOwnProperty.call(b, e))
            throw Error('Found marker, "' + e + '", in format string, "' + c + '", but no valid label mapping found in args: ' + JSON.stringify(b));
          d = b[e];
          return d instanceof qb ? tb(d) : encodeURIComponent(String(d));
        });
        return Cb(a);
      }
      var Bb = /%{(\w+)}/g,
        Ab = /^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i,
        xb = {};
      function Cb(a) {
        var b = vb();
        a = b ? b.createScriptURL(a) : a;
        return new wb(a, xb);
      }
      function C(a, b) {
        this.a = b === Db ? a : '';
      }
      C.prototype.ta = !0;
      C.prototype.sa = function () {
        return this.a.toString();
      };
      C.prototype.toString = function () {
        return 'SafeUrl{' + this.a + '}';
      };
      function Eb(a) {
        if (a instanceof C && a.constructor === C) return a.a;
        Ga("expected object of type SafeUrl, got '" + a + "' of type " + ma(a));
        return 'type_error:SafeUrl';
      }
      var Fb =
          /^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)|font\/\w+|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime|x-matroska))(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i,
        Gb = /^data:(.*);base64,[a-z0-9+\/]+=*$/i,
        Hb = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
      function Ib(a) {
        if (a instanceof C) return a;
        a = 'object' == typeof a && a.ta ? a.sa() : String(a);
        if (Hb.test(a)) a = new C(a, Db);
        else {
          a = String(a);
          a = a.replace(/(%0A|%0D)/g, '');
          var b = a.match(Gb);
          a = b && Fb.test(b[1]) ? new C(a, Db) : null;
        }
        return a;
      }
      function Jb(a) {
        if (a instanceof C) return a;
        a = 'object' == typeof a && a.ta ? a.sa() : String(a);
        Hb.test(a) || (a = 'about:invalid#zClosurez');
        return new C(a, Db);
      }
      var Db = {},
        Kb = new C('about:invalid#zClosurez', Db);
      function Lb(a, b, c) {
        this.a = c === Mb ? a : '';
      }
      Lb.prototype.ta = !0;
      Lb.prototype.sa = function () {
        return this.a.toString();
      };
      Lb.prototype.toString = function () {
        return 'SafeHtml{' + this.a + '}';
      };
      function Nb(a) {
        if (a instanceof Lb && a.constructor === Lb) return a.a;
        Ga("expected object of type SafeHtml, got '" + a + "' of type " + ma(a));
        return 'type_error:SafeHtml';
      }
      var Mb = {};
      function Ob(a, b) {
        pb(a, 'HTMLScriptElement');
        a.src = yb(b);
        (b = a.ownerDocument && a.ownerDocument.defaultView) && b != l ? (b = ka(b.document)) : (null === ja && (ja = ka(l.document)), (b = ja));
        b && a.setAttribute('nonce', b);
      }
      function Pb(a, b, c, d) {
        a = a instanceof C ? a : Jb(a);
        b = b || l;
        c = c instanceof qb ? tb(c) : c || '';
        return b.open(Eb(a), c, d, void 0);
      }
      function Qb(a, b) {
        for (var c = a.split('%s'), d = '', e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length; ) d += c.shift() + e.shift();
        return d + c.join('%s');
      }
      function Rb(a) {
        gb.test(a) &&
          (-1 != a.indexOf('&') && (a = a.replace(ab, '&amp;')),
          -1 != a.indexOf('<') && (a = a.replace(bb, '&lt;')),
          -1 != a.indexOf('>') && (a = a.replace(cb, '&gt;')),
          -1 != a.indexOf('"') && (a = a.replace(db, '&quot;')),
          -1 != a.indexOf("'") && (a = a.replace(eb, '&#39;')),
          -1 != a.indexOf('\x00') && (a = a.replace(fb, '&#0;')));
        return a;
      }
      function Sb(a) {
        Sb[' '](a);
        return a;
      }
      Sb[' '] = la;
      function Tb(a, b) {
        var c = Ub;
        return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : (c[a] = b(a));
      }
      var Vb = y('Opera'),
        Wb = y('Trident') || y('MSIE'),
        Xb = y('Edge'),
        Yb = Xb || Wb,
        Zb = y('Gecko') && !(x(ib.toLowerCase(), 'webkit') && !y('Edge')) && !(y('Trident') || y('MSIE')) && !y('Edge'),
        $b = x(ib.toLowerCase(), 'webkit') && !y('Edge');
      function ac() {
        var a = l.document;
        return a ? a.documentMode : void 0;
      }
      var bc;
      a: {
        var cc = '',
          dc = (function () {
            var a = ib;
            if (Zb) return /rv:([^\);]+)(\)|;)/.exec(a);
            if (Xb) return /Edge\/([\d\.]+)/.exec(a);
            if (Wb) return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
            if ($b) return /WebKit\/(\S+)/.exec(a);
            if (Vb) return /(?:Version)[ \/]?(\S+)/.exec(a);
          })();
        dc && (cc = dc ? dc[1] : '');
        if (Wb) {
          var ec = ac();
          if (null != ec && ec > parseFloat(cc)) {
            bc = String(ec);
            break a;
          }
        }
        bc = cc;
      }
      var Ub = {};
      function fc(a) {
        return Tb(a, function () {
          for (var b = 0, c = $a(String(bc)).split('.'), d = $a(String(a)).split('.'), e = Math.max(c.length, d.length), f = 0; 0 == b && f < e; f++) {
            var g = c[f] || '',
              h = d[f] || '';
            do {
              g = /(\d*)(\D*)(.*)/.exec(g) || ['', '', '', ''];
              h = /(\d*)(\D*)(.*)/.exec(h) || ['', '', '', ''];
              if (0 == g[0].length && 0 == h[0].length) break;
              b = hb(0 == g[1].length ? 0 : parseInt(g[1], 10), 0 == h[1].length ? 0 : parseInt(h[1], 10)) || hb(0 == g[2].length, 0 == h[2].length) || hb(g[2], h[2]);
              g = g[3];
              h = h[3];
            } while (0 == b);
          }
          return 0 <= b;
        });
      }
      var gc;
      if (l.document && Wb) {
        var hc = ac();
        gc = hc ? hc : parseInt(bc, 10) || void 0;
      } else gc = void 0;
      var ic = gc;
      try {
        new self.OffscreenCanvas(0, 0).getContext('2d');
      } catch (a) {}
      var jc = !Wb || 9 <= Number(ic);
      function kc(a) {
        var b = document;
        return 'string' === typeof a ? b.getElementById(a) : a;
      }
      function lc(a, b) {
        lb(b, function (c, d) {
          c && 'object' == typeof c && c.ta && (c = c.sa());
          'style' == d
            ? (a.style.cssText = c)
            : 'class' == d
            ? (a.className = c)
            : 'for' == d
            ? (a.htmlFor = c)
            : mc.hasOwnProperty(d)
            ? a.setAttribute(mc[d], c)
            : 0 == d.lastIndexOf('aria-', 0) || 0 == d.lastIndexOf('data-', 0)
            ? a.setAttribute(d, c)
            : (a[d] = c);
        });
      }
      var mc = {
        cellpadding: 'cellPadding',
        cellspacing: 'cellSpacing',
        colspan: 'colSpan',
        frameborder: 'frameBorder',
        height: 'height',
        maxlength: 'maxLength',
        nonce: 'nonce',
        role: 'role',
        rowspan: 'rowSpan',
        type: 'type',
        usemap: 'useMap',
        valign: 'vAlign',
        width: 'width',
      };
      function nc(a, b, c) {
        var d = arguments,
          e = document,
          f = String(d[0]),
          g = d[1];
        if (!jc && g && (g.name || g.type)) {
          f = ['<', f];
          g.name && f.push(' name="', Rb(g.name), '"');
          if (g.type) {
            f.push(' type="', Rb(g.type), '"');
            var h = {};
            z(h, g);
            delete h.type;
            g = h;
          }
          f.push('>');
          f = f.join('');
        }
        f = oc(e, f);
        g && ('string' === typeof g ? (f.className = g) : Array.isArray(g) ? (f.className = g.join(' ')) : lc(f, g));
        2 < d.length && pc(e, f, d);
        return f;
      }
      function pc(a, b, c) {
        function d(h) {
          h && b.appendChild('string' === typeof h ? a.createTextNode(h) : h);
        }
        for (var e = 2; e < c.length; e++) {
          var f = c[e];
          if (!na(f) || (n(f) && 0 < f.nodeType)) d(f);
          else {
            a: {
              if (f && 'number' == typeof f.length) {
                if (n(f)) {
                  var g = 'function' == typeof f.item || 'string' == typeof f.item;
                  break a;
                }
                if (oa(f)) {
                  g = 'function' == typeof f.item;
                  break a;
                }
              }
              g = !1;
            }
            w(g ? Za(f) : f, d);
          }
        }
      }
      function oc(a, b) {
        b = String(b);
        'application/xhtml+xml' === a.contentType && (b = b.toLowerCase());
        return a.createElement(b);
      }
      function qc(a) {
        l.setTimeout(function () {
          throw a;
        }, 0);
      }
      var rc;
      function sc() {
        var a = l.MessageChannel;
        'undefined' === typeof a &&
          'undefined' !== typeof window &&
          window.postMessage &&
          window.addEventListener &&
          !y('Presto') &&
          (a = function () {
            var e = oc(document, 'IFRAME');
            e.style.display = 'none';
            document.documentElement.appendChild(e);
            var f = e.contentWindow;
            e = f.document;
            e.open();
            e.close();
            var g = 'callImmediate' + Math.random(),
              h = 'file:' == f.location.protocol ? '*' : f.location.protocol + '//' + f.location.host;
            e = q(function (m) {
              if (('*' == h || m.origin == h) && m.data == g) this.port1.onmessage();
            }, this);
            f.addEventListener('message', e, !1);
            this.port1 = {};
            this.port2 = {
              postMessage: function () {
                f.postMessage(g, h);
              },
            };
          });
        if ('undefined' !== typeof a && !y('Trident') && !y('MSIE')) {
          var b = new a(),
            c = {},
            d = c;
          b.port1.onmessage = function () {
            if (void 0 !== c.next) {
              c = c.next;
              var e = c.Hb;
              c.Hb = null;
              e();
            }
          };
          return function (e) {
            d.next = { Hb: e };
            d = d.next;
            b.port2.postMessage(0);
          };
        }
        return function (e) {
          l.setTimeout(e, 0);
        };
      }
      function tc(a, b) {
        uc || vc();
        wc || (uc(), (wc = !0));
        Na.add(a, b);
      }
      var uc;
      function vc() {
        if (l.Promise && l.Promise.resolve) {
          var a = l.Promise.resolve(void 0);
          uc = function () {
            a.then(xc);
          };
        } else
          uc = function () {
            var b = xc;
            !oa(l.setImmediate) || (l.Window && l.Window.prototype && !y('Edge') && l.Window.prototype.setImmediate == l.setImmediate)
              ? (rc || (rc = sc()), rc(b))
              : l.setImmediate(b);
          };
      }
      var wc = !1,
        Na = new Ja();
      function xc() {
        for (var a; (a = Ma()); ) {
          try {
            a.a.call(a.b);
          } catch (b) {
            qc(b);
          }
          Ia(La, a);
        }
        wc = !1;
      }
      function D(a, b) {
        this.a = yc;
        this.i = void 0;
        this.f = this.b = this.c = null;
        this.g = this.h = !1;
        if (a != la)
          try {
            var c = this;
            a.call(
              b,
              function (d) {
                zc(c, Ac, d);
              },
              function (d) {
                if (!(d instanceof Bc))
                  try {
                    if (d instanceof Error) throw d;
                    throw Error('Promise rejected.');
                  } catch (e) {}
                zc(c, Cc, d);
              },
            );
          } catch (d) {
            zc(this, Cc, d);
          }
      }
      var yc = 0,
        Ac = 2,
        Cc = 3;
      function Dc() {
        this.next = this.f = this.b = this.g = this.a = null;
        this.c = !1;
      }
      Dc.prototype.reset = function () {
        this.f = this.b = this.g = this.a = null;
        this.c = !1;
      };
      var Ec = new Ha(
        function () {
          return new Dc();
        },
        function (a) {
          a.reset();
        },
      );
      function Fc(a, b, c) {
        var d = Ec.get();
        d.g = a;
        d.b = b;
        d.f = c;
        return d;
      }
      function E(a) {
        if (a instanceof D) return a;
        var b = new D(la);
        zc(b, Ac, a);
        return b;
      }
      function F(a) {
        return new D(function (b, c) {
          c(a);
        });
      }
      function Gc(a, b, c) {
        Hc(a, b, c, null) || tc(ua(b, a));
      }
      function Ic(a) {
        return new D(function (b, c) {
          var d = a.length,
            e = [];
          if (d)
            for (
              var f = function (p, v) {
                  d--;
                  e[p] = v;
                  0 == d && b(e);
                },
                g = function (p) {
                  c(p);
                },
                h = 0,
                m;
              h < a.length;
              h++
            )
              (m = a[h]), Gc(m, ua(f, h), g);
          else b(e);
        });
      }
      function Jc(a) {
        return new D(function (b) {
          var c = a.length,
            d = [];
          if (c)
            for (
              var e = function (h, m, p) {
                  c--;
                  d[h] = m ? { Qb: !0, value: p } : { Qb: !1, reason: p };
                  0 == c && b(d);
                },
                f = 0,
                g;
              f < a.length;
              f++
            )
              (g = a[f]), Gc(g, ua(e, f, !0), ua(e, f, !1));
          else b(d);
        });
      }
      D.prototype.then = function (a, b, c) {
        return Kc(this, oa(a) ? a : null, oa(b) ? b : null, c);
      };
      D.prototype.$goog_Thenable = !0;
      k = D.prototype;
      k.oa = function (a, b) {
        a = Fc(a, a, b);
        a.c = !0;
        Lc(this, a);
        return this;
      };
      k.o = function (a, b) {
        return Kc(this, null, a, b);
      };
      k.cancel = function (a) {
        if (this.a == yc) {
          var b = new Bc(a);
          tc(function () {
            Mc(this, b);
          }, this);
        }
      };
      function Mc(a, b) {
        if (a.a == yc)
          if (a.c) {
            var c = a.c;
            if (c.b) {
              for (var d = 0, e = null, f = null, g = c.b; g && (g.c || (d++, g.a == a && (e = g), !(e && 1 < d))); g = g.next) e || (f = g);
              e && (c.a == yc && 1 == d ? Mc(c, b) : (f ? ((d = f), d.next == c.f && (c.f = d), (d.next = d.next.next)) : Nc(c), Oc(c, e, Cc, b)));
            }
            a.c = null;
          } else zc(a, Cc, b);
      }
      function Lc(a, b) {
        a.b || (a.a != Ac && a.a != Cc) || Pc(a);
        a.f ? (a.f.next = b) : (a.b = b);
        a.f = b;
      }
      function Kc(a, b, c, d) {
        var e = Fc(null, null, null);
        e.a = new D(function (f, g) {
          e.g = b
            ? function (h) {
                try {
                  var m = b.call(d, h);
                  f(m);
                } catch (p) {
                  g(p);
                }
              }
            : f;
          e.b = c
            ? function (h) {
                try {
                  var m = c.call(d, h);
                  void 0 === m && h instanceof Bc ? g(h) : f(m);
                } catch (p) {
                  g(p);
                }
              }
            : g;
        });
        e.a.c = a;
        Lc(a, e);
        return e.a;
      }
      k.$c = function (a) {
        this.a = yc;
        zc(this, Ac, a);
      };
      k.ad = function (a) {
        this.a = yc;
        zc(this, Cc, a);
      };
      function zc(a, b, c) {
        a.a == yc &&
          (a === c && ((b = Cc), (c = new TypeError('Promise cannot resolve to itself'))),
          (a.a = 1),
          Hc(c, a.$c, a.ad, a) || ((a.i = c), (a.a = b), (a.c = null), Pc(a), b != Cc || c instanceof Bc || Qc(a, c)));
      }
      function Hc(a, b, c, d) {
        if (a instanceof D) return Lc(a, Fc(b || la, c || null, d)), !0;
        if (Ea(a)) return a.then(b, c, d), !0;
        if (n(a))
          try {
            var e = a.then;
            if (oa(e)) return Rc(a, e, b, c, d), !0;
          } catch (f) {
            return c.call(d, f), !0;
          }
        return !1;
      }
      function Rc(a, b, c, d, e) {
        function f(m) {
          h || ((h = !0), d.call(e, m));
        }
        function g(m) {
          h || ((h = !0), c.call(e, m));
        }
        var h = !1;
        try {
          b.call(a, g, f);
        } catch (m) {
          f(m);
        }
      }
      function Pc(a) {
        a.h || ((a.h = !0), tc(a.gc, a));
      }
      function Nc(a) {
        var b = null;
        a.b && ((b = a.b), (a.b = b.next), (b.next = null));
        a.b || (a.f = null);
        return b;
      }
      k.gc = function () {
        for (var a; (a = Nc(this)); ) Oc(this, a, this.a, this.i);
        this.h = !1;
      };
      function Oc(a, b, c, d) {
        if (c == Cc && b.b && !b.c) for (; a && a.g; a = a.c) a.g = !1;
        if (b.a) (b.a.c = null), Sc(b, c, d);
        else
          try {
            b.c ? b.g.call(b.f) : Sc(b, c, d);
          } catch (e) {
            Tc.call(null, e);
          }
        Ia(Ec, b);
      }
      function Sc(a, b, c) {
        b == Ac ? a.g.call(a.f, c) : a.b && a.b.call(a.f, c);
      }
      function Qc(a, b) {
        a.g = !0;
        tc(function () {
          a.g && Tc.call(null, b);
        });
      }
      var Tc = qc;
      function Bc(a) {
        u.call(this, a);
      }
      r(Bc, u);
      Bc.prototype.name = 'cancel';
      function Uc() {
        this.ya = this.ya;
        this.pa = this.pa;
      }
      var Vc = 0;
      Uc.prototype.ya = !1;
      function Xc(a) {
        if (!a.ya && ((a.ya = !0), a.Da(), 0 != Vc)) {
          pa(a);
        }
      }
      Uc.prototype.Da = function () {
        if (this.pa) for (; this.pa.length; ) this.pa.shift()();
      };
      var Yc =
        Object.freeze ||
        function (a) {
          return a;
        };
      var Zc = !Wb || 9 <= Number(ic),
        $c = Wb && !fc('9'),
        ad = (function () {
          if (!l.addEventListener || !Object.defineProperty) return !1;
          var a = !1,
            b = Object.defineProperty({}, 'passive', {
              get: function () {
                a = !0;
              },
            });
          try {
            l.addEventListener('test', la, b), l.removeEventListener('test', la, b);
          } catch (c) {}
          return a;
        })();
      function G(a, b) {
        this.type = a;
        this.b = this.target = b;
        this.defaultPrevented = !1;
      }
      G.prototype.preventDefault = function () {
        this.defaultPrevented = !0;
      };
      function bd(a, b) {
        G.call(this, a ? a.type : '');
        this.relatedTarget = this.b = this.target = null;
        this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
        this.key = '';
        this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1;
        this.pointerId = 0;
        this.pointerType = '';
        this.a = null;
        if (a) {
          var c = (this.type = a.type),
            d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
          this.target = a.target || a.srcElement;
          this.b = b;
          if ((b = a.relatedTarget)) {
            if (Zb) {
              a: {
                try {
                  Sb(b.nodeName);
                  var e = !0;
                  break a;
                } catch (f) {}
                e = !1;
              }
              e || (b = null);
            }
          } else 'mouseover' == c ? (b = a.fromElement) : 'mouseout' == c && (b = a.toElement);
          this.relatedTarget = b;
          d
            ? ((this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX),
              (this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY),
              (this.screenX = d.screenX || 0),
              (this.screenY = d.screenY || 0))
            : ((this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX),
              (this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY),
              (this.screenX = a.screenX || 0),
              (this.screenY = a.screenY || 0));
          this.button = a.button;
          this.key = a.key || '';
          this.ctrlKey = a.ctrlKey;
          this.altKey = a.altKey;
          this.shiftKey = a.shiftKey;
          this.metaKey = a.metaKey;
          this.pointerId = a.pointerId || 0;
          this.pointerType = 'string' === typeof a.pointerType ? a.pointerType : cd[a.pointerType] || '';
          this.a = a;
          a.defaultPrevented && this.preventDefault();
        }
      }
      r(bd, G);
      var cd = Yc({ 2: 'touch', 3: 'pen', 4: 'mouse' });
      bd.prototype.preventDefault = function () {
        bd.bb.preventDefault.call(this);
        var a = this.a;
        if (a.preventDefault) a.preventDefault();
        else if (((a.returnValue = !1), $c))
          try {
            if (a.ctrlKey || (112 <= a.keyCode && 123 >= a.keyCode)) a.keyCode = -1;
          } catch (b) {}
      };
      bd.prototype.g = function () {
        return this.a;
      };
      var dd = 'closure_listenable_' + ((1e6 * Math.random()) | 0),
        ed = 0;
      function fd(a, b, c, d, e) {
        this.listener = a;
        this.proxy = null;
        this.src = b;
        this.type = c;
        this.capture = !!d;
        this.Wa = e;
        this.key = ++ed;
        this.wa = this.Qa = !1;
      }
      function gd(a) {
        a.wa = !0;
        a.listener = null;
        a.proxy = null;
        a.src = null;
        a.Wa = null;
      }
      function hd(a) {
        this.src = a;
        this.a = {};
        this.b = 0;
      }
      hd.prototype.add = function (a, b, c, d, e) {
        var f = a.toString();
        a = this.a[f];
        a || ((a = this.a[f] = []), this.b++);
        var g = id(a, b, d, e);
        -1 < g ? ((b = a[g]), c || (b.Qa = !1)) : ((b = new fd(b, this.src, f, !!d, e)), (b.Qa = c), a.push(b));
        return b;
      };
      function jd(a, b) {
        var c = b.type;
        c in a.a && Wa(a.a[c], b) && (gd(b), 0 == a.a[c].length && (delete a.a[c], a.b--));
      }
      function id(a, b, c, d) {
        for (var e = 0; e < a.length; ++e) {
          var f = a[e];
          if (!f.wa && f.listener == b && f.capture == !!c && f.Wa == d) return e;
        }
        return -1;
      }
      var kd = 'closure_lm_' + ((1e6 * Math.random()) | 0),
        ld = {};
      function nd(a, b, c, d, e) {
        if (d && d.once) od(a, b, c, d, e);
        else if (Array.isArray(b)) for (var f = 0; f < b.length; f++) nd(a, b[f], c, d, e);
        else (c = pd(c)), a && a[dd] ? qd(a, b, c, n(d) ? !!d.capture : !!d, e) : rd(a, b, c, !1, d, e);
      }
      function rd(a, b, c, d, e, f) {
        if (!b) throw Error('Invalid event type');
        var g = n(e) ? !!e.capture : !!e,
          h = sd(a);
        h || (a[kd] = h = new hd(a));
        c = h.add(b, c, d, g, f);
        if (!c.proxy) {
          d = td();
          c.proxy = d;
          d.src = a;
          d.listener = c;
          if (a.addEventListener) ad || (e = g), void 0 === e && (e = !1), a.addEventListener(b.toString(), d, e);
          else if (a.attachEvent) a.attachEvent(ud(b.toString()), d);
          else if (a.addListener && a.removeListener) a.addListener(d);
          else throw Error('addEventListener and attachEvent are unavailable.');
        }
      }
      function td() {
        var a = vd,
          b = Zc
            ? function (c) {
                return a.call(b.src, b.listener, c);
              }
            : function (c) {
                c = a.call(b.src, b.listener, c);
                if (!c) return c;
              };
        return b;
      }
      function od(a, b, c, d, e) {
        if (Array.isArray(b)) for (var f = 0; f < b.length; f++) od(a, b[f], c, d, e);
        else (c = pd(c)), a && a[dd] ? wd(a, b, c, n(d) ? !!d.capture : !!d, e) : rd(a, b, c, !0, d, e);
      }
      function xd(a, b, c, d, e) {
        if (Array.isArray(b)) for (var f = 0; f < b.length; f++) xd(a, b[f], c, d, e);
        else
          ((d = n(d) ? !!d.capture : !!d), (c = pd(c)), a && a[dd])
            ? ((a = a.v),
              (b = String(b).toString()),
              b in a.a && ((f = a.a[b]), (c = id(f, c, d, e)), -1 < c && (gd(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.a[b], a.b--))))
            : a && (a = sd(a)) && ((b = a.a[b.toString()]), (a = -1), b && (a = id(b, c, d, e)), (c = -1 < a ? b[a] : null) && yd(c));
      }
      function yd(a) {
        if ('number' !== typeof a && a && !a.wa) {
          var b = a.src;
          if (b && b[dd]) jd(b.v, a);
          else {
            var c = a.type,
              d = a.proxy;
            b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(ud(c), d) : b.addListener && b.removeListener && b.removeListener(d);
            (c = sd(b)) ? (jd(c, a), 0 == c.b && ((c.src = null), (b[kd] = null))) : gd(a);
          }
        }
      }
      function ud(a) {
        return a in ld ? ld[a] : (ld[a] = 'on' + a);
      }
      function zd(a, b, c, d) {
        var e = !0;
        if ((a = sd(a)))
          if ((b = a.a[b.toString()]))
            for (b = b.concat(), a = 0; a < b.length; a++) {
              var f = b[a];
              f && f.capture == c && !f.wa && ((f = Bd(f, d)), (e = e && !1 !== f));
            }
        return e;
      }
      function Bd(a, b) {
        var c = a.listener,
          d = a.Wa || a.src;
        a.Qa && yd(a);
        return c.call(d, b);
      }
      function vd(a, b) {
        if (a.wa) return !0;
        if (!Zc) {
          if (!b)
            a: {
              b = ['window', 'event'];
              for (var c = l, d = 0; d < b.length; d++)
                if (((c = c[b[d]]), null == c)) {
                  b = null;
                  break a;
                }
              b = c;
            }
          d = b;
          b = new bd(d, this);
          c = !0;
          if (!(0 > d.keyCode || void 0 != d.returnValue)) {
            a: {
              var e = !1;
              if (0 == d.keyCode)
                try {
                  d.keyCode = -1;
                  break a;
                } catch (g) {
                  e = !0;
                }
              if (e || void 0 == d.returnValue) d.returnValue = !0;
            }
            d = [];
            for (e = b.b; e; e = e.parentNode) d.push(e);
            a = a.type;
            for (e = d.length - 1; 0 <= e; e--) {
              b.b = d[e];
              var f = zd(d[e], a, !0, b);
              c = c && f;
            }
            for (e = 0; e < d.length; e++) (b.b = d[e]), (f = zd(d[e], a, !1, b)), (c = c && f);
          }
          return c;
        }
        return Bd(a, new bd(b, this));
      }
      function sd(a) {
        a = a[kd];
        return a instanceof hd ? a : null;
      }
      var Cd = '__closure_events_fn_' + ((1e9 * Math.random()) >>> 0);
      function pd(a) {
        if (oa(a)) return a;
        a[Cd] ||
          (a[Cd] = function (b) {
            return a.handleEvent(b);
          });
        return a[Cd];
      }
      function H() {
        Uc.call(this);
        this.v = new hd(this);
        this.bc = this;
        this.hb = null;
      }
      r(H, Uc);
      H.prototype[dd] = !0;
      H.prototype.addEventListener = function (a, b, c, d) {
        nd(this, a, b, c, d);
      };
      H.prototype.removeEventListener = function (a, b, c, d) {
        xd(this, a, b, c, d);
      };
      H.prototype.dispatchEvent = function (a) {
        var b,
          c = this.hb;
        if (c) for (b = []; c; c = c.hb) b.push(c);
        c = this.bc;
        var d = a.type || a;
        if ('string' === typeof a) a = new G(a, c);
        else if (a instanceof G) a.target = a.target || c;
        else {
          var e = a;
          a = new G(d, c);
          z(a, e);
        }
        e = !0;
        if (b)
          for (var f = b.length - 1; 0 <= f; f--) {
            var g = (a.b = b[f]);
            e = Dd(g, d, !0, a) && e;
          }
        g = a.b = c;
        e = Dd(g, d, !0, a) && e;
        e = Dd(g, d, !1, a) && e;
        if (b) for (f = 0; f < b.length; f++) (g = a.b = b[f]), (e = Dd(g, d, !1, a) && e);
        return e;
      };
      H.prototype.Da = function () {
        H.bb.Da.call(this);
        if (this.v) {
          var a = this.v,
            c;
          for (c in a.a) {
            for (var d = a.a[c], e = 0; e < d.length; e++) gd(d[e]);
            delete a.a[c];
            a.b--;
          }
        }
        this.hb = null;
      };
      function qd(a, b, c, d, e) {
        a.v.add(String(b), c, !1, d, e);
      }
      function wd(a, b, c, d, e) {
        a.v.add(String(b), c, !0, d, e);
      }
      function Dd(a, b, c, d) {
        b = a.v.a[String(b)];
        if (!b) return !0;
        b = b.concat();
        for (var e = !0, f = 0; f < b.length; ++f) {
          var g = b[f];
          if (g && !g.wa && g.capture == c) {
            var h = g.listener,
              m = g.Wa || g.src;
            g.Qa && jd(a.v, g);
            e = !1 !== h.call(m, d) && e;
          }
        }
        return e && !d.defaultPrevented;
      }
      function Ed(a, b, c) {
        if (oa(a)) c && (a = q(a, c));
        else if (a && 'function' == typeof a.handleEvent) a = q(a.handleEvent, a);
        else throw Error('Invalid listener argument');
        return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
      }
      function Fd(a) {
        var b = null;
        return new D(function (c, d) {
          b = Ed(function () {
            c(void 0);
          }, a);
          -1 == b && d(Error('Failed to schedule timer.'));
        }).o(function (c) {
          l.clearTimeout(b);
          throw c;
        });
      }
      function Gd(a) {
        if (a.X && 'function' == typeof a.X) return a.X();
        if ('string' === typeof a) return a.split('');
        if (na(a)) {
          for (var b = [], c = a.length, d = 0; d < c; d++) b.push(a[d]);
          return b;
        }
        b = [];
        c = 0;
        for (d in a) b[c++] = a[d];
        return b;
      }
      function Hd(a) {
        if (a.Y && 'function' == typeof a.Y) return a.Y();
        if (!a.X || 'function' != typeof a.X) {
          if (na(a) || 'string' === typeof a) {
            var b = [];
            a = a.length;
            for (var c = 0; c < a; c++) b.push(c);
            return b;
          }
          b = [];
          c = 0;
          for (var d in a) b[c++] = d;
          return b;
        }
      }
      function Id(a, b) {
        if (a.forEach && 'function' == typeof a.forEach) a.forEach(b, void 0);
        else if (na(a) || 'string' === typeof a) w(a, b, void 0);
        else for (var c = Hd(a), d = Gd(a), e = d.length, f = 0; f < e; f++) b.call(void 0, d[f], c && c[f], a);
      }
      function Jd(a, b) {
        this.b = {};
        this.a = [];
        this.c = 0;
        var c = arguments.length;
        if (1 < c) {
          if (c % 2) throw Error('Uneven number of arguments');
          for (var d = 0; d < c; d += 2) this.set(arguments[d], arguments[d + 1]);
        } else if (a)
          if (a instanceof Jd) for (c = a.Y(), d = 0; d < c.length; d++) this.set(c[d], a.get(c[d]));
          else for (d in a) this.set(d, a[d]);
      }
      k = Jd.prototype;
      k.X = function () {
        Kd(this);
        for (var a = [], b = 0; b < this.a.length; b++) a.push(this.b[this.a[b]]);
        return a;
      };
      k.Y = function () {
        Kd(this);
        return this.a.concat();
      };
      k.clear = function () {
        this.b = {};
        this.c = this.a.length = 0;
      };
      function Kd(a) {
        if (a.c != a.a.length) {
          for (var b = 0, c = 0; b < a.a.length; ) {
            var d = a.a[b];
            Ld(a.b, d) && (a.a[c++] = d);
            b++;
          }
          a.a.length = c;
        }
        if (a.c != a.a.length) {
          var e = {};
          for (c = b = 0; b < a.a.length; ) (d = a.a[b]), Ld(e, d) || ((a.a[c++] = d), (e[d] = 1)), b++;
          a.a.length = c;
        }
      }
      k.get = function (a, b) {
        return Ld(this.b, a) ? this.b[a] : b;
      };
      k.set = function (a, b) {
        Ld(this.b, a) || (this.c++, this.a.push(a));
        this.b[a] = b;
      };
      k.forEach = function (a, b) {
        for (var c = this.Y(), d = 0; d < c.length; d++) {
          var e = c[d],
            f = this.get(e);
          a.call(b, f, e, this);
        }
      };
      function Ld(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      var Md = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
      function Nd(a, b) {
        if (a) {
          a = a.split('&');
          for (var c = 0; c < a.length; c++) {
            var d = a[c].indexOf('='),
              e = null;
            if (0 <= d) {
              var f = a[c].substring(0, d);
              e = a[c].substring(d + 1);
            } else f = a[c];
            b(f, e ? decodeURIComponent(e.replace(/\+/g, ' ')) : '');
          }
        }
      }
      function Od(a, b) {
        this.a = this.l = this.c = '';
        this.g = null;
        this.h = this.f = '';
        this.i = !1;
        var c;
        a instanceof Od
          ? ((this.i = void 0 !== b ? b : a.i), Pd(this, a.c), (this.l = a.l), (this.a = a.a), Qd(this, a.g), (this.f = a.f), Rd(this, Sd(a.b)), (this.h = a.h))
          : a && (c = String(a).match(Md))
          ? ((this.i = !!b),
            Pd(this, c[1] || '', !0),
            (this.l = Td(c[2] || '')),
            (this.a = Td(c[3] || '', !0)),
            Qd(this, c[4]),
            (this.f = Td(c[5] || '', !0)),
            Rd(this, c[6] || '', !0),
            (this.h = Td(c[7] || '')))
          : ((this.i = !!b), (this.b = new Ud(null, this.i)));
      }
      Od.prototype.toString = function () {
        var a = [],
          b = this.c;
        b && a.push(Vd(b, Wd, !0), ':');
        var c = this.a;
        if (c || 'file' == b)
          a.push('//'),
            (b = this.l) && a.push(Vd(b, Wd, !0), '@'),
            a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, '%$1')),
            (c = this.g),
            null != c && a.push(':', String(c));
        if ((c = this.f)) this.a && '/' != c.charAt(0) && a.push('/'), a.push(Vd(c, '/' == c.charAt(0) ? Xd : Yd, !0));
        (c = this.b.toString()) && a.push('?', c);
        (c = this.h) && a.push('#', Vd(c, Zd));
        return a.join('');
      };
      Od.prototype.resolve = function (a) {
        var b = new Od(this),
          c = !!a.c;
        c ? Pd(b, a.c) : (c = !!a.l);
        c ? (b.l = a.l) : (c = !!a.a);
        c ? (b.a = a.a) : (c = null != a.g);
        var d = a.f;
        if (c) Qd(b, a.g);
        else if ((c = !!a.f)) {
          if ('/' != d.charAt(0))
            if (this.a && !this.f) d = '/' + d;
            else {
              var e = b.f.lastIndexOf('/');
              -1 != e && (d = b.f.substr(0, e + 1) + d);
            }
          e = d;
          if ('..' == e || '.' == e) d = '';
          else if (x(e, './') || x(e, '/.')) {
            d = 0 == e.lastIndexOf('/', 0);
            e = e.split('/');
            for (var f = [], g = 0; g < e.length; ) {
              var h = e[g++];
              '.' == h
                ? d && g == e.length && f.push('')
                : '..' == h
                ? ((1 < f.length || (1 == f.length && '' != f[0])) && f.pop(), d && g == e.length && f.push(''))
                : (f.push(h), (d = !0));
            }
            d = f.join('/');
          } else d = e;
        }
        c ? (b.f = d) : (c = '' !== a.b.toString());
        c ? Rd(b, Sd(a.b)) : (c = !!a.h);
        c && (b.h = a.h);
        return b;
      };
      function Pd(a, b, c) {
        a.c = c ? Td(b, !0) : b;
        a.c && (a.c = a.c.replace(/:$/, ''));
      }
      function Qd(a, b) {
        if (b) {
          b = Number(b);
          if (isNaN(b) || 0 > b) throw Error('Bad port number ' + b);
          a.g = b;
        } else a.g = null;
      }
      function Rd(a, b, c) {
        b instanceof Ud ? ((a.b = b), $d(a.b, a.i)) : (c || (b = Vd(b, ae)), (a.b = new Ud(b, a.i)));
      }
      function I(a, b, c) {
        a.b.set(b, c);
      }
      function be(a, b) {
        return a.b.get(b);
      }
      function J(a) {
        return a instanceof Od ? new Od(a) : new Od(a, void 0);
      }
      function ce(a, b, c, d) {
        var e = new Od(null, void 0);
        a && Pd(e, a);
        b && (e.a = b);
        c && Qd(e, c);
        d && (e.f = d);
        return e;
      }
      function Td(a, b) {
        return a ? (b ? decodeURI(a.replace(/%25/g, '%2525')) : decodeURIComponent(a)) : '';
      }
      function Vd(a, b, c) {
        return 'string' === typeof a ? ((a = encodeURI(a).replace(b, de)), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, '%$1')), a) : null;
      }
      function de(a) {
        a = a.charCodeAt(0);
        return '%' + ((a >> 4) & 15).toString(16) + (a & 15).toString(16);
      }
      var Wd = /[#\/\?@]/g,
        Yd = /[#\?:]/g,
        Xd = /[#\?]/g,
        ae = /[#\?@]/g,
        Zd = /#/g;
      function Ud(a, b) {
        this.b = this.a = null;
        this.c = a || null;
        this.f = !!b;
      }
      function ee(a) {
        a.a ||
          ((a.a = new Jd()),
          (a.b = 0),
          a.c &&
            Nd(a.c, function (b, c) {
              a.add(decodeURIComponent(b.replace(/\+/g, ' ')), c);
            }));
      }
      function fe(a) {
        var b = Hd(a);
        if ('undefined' == typeof b) throw Error('Keys are undefined');
        var c = new Ud(null, void 0);
        a = Gd(a);
        for (var d = 0; d < b.length; d++) {
          var e = b[d],
            f = a[d];
          Array.isArray(f) ? ge(c, e, f) : c.add(e, f);
        }
        return c;
      }
      k = Ud.prototype;
      k.add = function (a, b) {
        ee(this);
        this.c = null;
        a = he(this, a);
        var c = this.a.get(a);
        c || this.a.set(a, (c = []));
        c.push(b);
        this.b += 1;
        return this;
      };
      function ie(a, b) {
        ee(a);
        b = he(a, b);
        Ld(a.a.b, b) && ((a.c = null), (a.b -= a.a.get(b).length), (a = a.a), Ld(a.b, b) && (delete a.b[b], a.c--, a.a.length > 2 * a.c && Kd(a)));
      }
      k.clear = function () {
        this.a = this.c = null;
        this.b = 0;
      };
      function je(a, b) {
        ee(a);
        b = he(a, b);
        return Ld(a.a.b, b);
      }
      k.forEach = function (a, b) {
        ee(this);
        this.a.forEach(function (c, d) {
          w(
            c,
            function (e) {
              a.call(b, e, d, this);
            },
            this,
          );
        }, this);
      };
      k.Y = function () {
        ee(this);
        for (var a = this.a.X(), b = this.a.Y(), c = [], d = 0; d < b.length; d++) for (var e = a[d], f = 0; f < e.length; f++) c.push(b[d]);
        return c;
      };
      k.X = function (a) {
        ee(this);
        var b = [];
        if ('string' === typeof a) je(this, a) && (b = Ya(b, this.a.get(he(this, a))));
        else {
          a = this.a.X();
          for (var c = 0; c < a.length; c++) b = Ya(b, a[c]);
        }
        return b;
      };
      k.set = function (a, b) {
        ee(this);
        this.c = null;
        a = he(this, a);
        je(this, a) && (this.b -= this.a.get(a).length);
        this.a.set(a, [b]);
        this.b += 1;
        return this;
      };
      k.get = function (a, b) {
        if (!a) return b;
        a = this.X(a);
        return 0 < a.length ? String(a[0]) : b;
      };
      function ge(a, b, c) {
        ie(a, b);
        0 < c.length && ((a.c = null), a.a.set(he(a, b), Za(c)), (a.b += c.length));
      }
      k.toString = function () {
        if (this.c) return this.c;
        if (!this.a) return '';
        for (var a = [], b = this.a.Y(), c = 0; c < b.length; c++) {
          var d = b[c],
            e = encodeURIComponent(String(d));
          d = this.X(d);
          for (var f = 0; f < d.length; f++) {
            var g = e;
            '' !== d[f] && (g += '=' + encodeURIComponent(String(d[f])));
            a.push(g);
          }
        }
        return (this.c = a.join('&'));
      };
      function Sd(a) {
        var b = new Ud();
        b.c = a.c;
        a.a && ((b.a = new Jd(a.a)), (b.b = a.b));
        return b;
      }
      function he(a, b) {
        b = String(b);
        a.f && (b = b.toLowerCase());
        return b;
      }
      function $d(a, b) {
        b &&
          !a.f &&
          (ee(a),
          (a.c = null),
          a.a.forEach(function (c, d) {
            var e = d.toLowerCase();
            d != e && (ie(this, d), ge(this, e, c));
          }, a));
        a.f = b;
      }
      function ke(a) {
        var b = [];
        le(new me(), a, b);
        return b.join('');
      }
      function me() {}
      function le(a, b, c) {
        if (null == b) c.push('null');
        else {
          if ('object' == typeof b) {
            if (Array.isArray(b)) {
              var d = b;
              b = d.length;
              c.push('[');
              for (var e = '', f = 0; f < b; f++) c.push(e), le(a, d[f], c), (e = ',');
              c.push(']');
              return;
            }
            if (b instanceof String || b instanceof Number || b instanceof Boolean) b = b.valueOf();
            else {
              c.push('{');
              e = '';
              for (d in b) Object.prototype.hasOwnProperty.call(b, d) && ((f = b[d]), 'function' != typeof f && (c.push(e), ne(d, c), c.push(':'), le(a, f, c), (e = ',')));
              c.push('}');
              return;
            }
          }
          switch (typeof b) {
            case 'string':
              ne(b, c);
              break;
            case 'number':
              c.push(isFinite(b) && !isNaN(b) ? String(b) : 'null');
              break;
            case 'boolean':
              c.push(String(b));
              break;
            case 'function':
              c.push('null');
              break;
            default:
              throw Error('Unknown type: ' + typeof b);
          }
        }
      }
      var oe = { '"': '\\"', '\\': '\\\\', '/': '\\/', '\b': '\\b', '\f': '\\f', '\n': '\\n', '\r': '\\r', '\t': '\\t', '\x0B': '\\u000b' },
        pe = /\uffff/.test('\uffff') ? /[\\"\x00-\x1f\x7f-\uffff]/g : /[\\"\x00-\x1f\x7f-\xff]/g;
      function ne(a, b) {
        b.push(
          '"',
          a.replace(pe, function (c) {
            var d = oe[c];
            d || ((d = '\\u' + (c.charCodeAt(0) | 65536).toString(16).substr(1)), (oe[c] = d));
            return d;
          }),
          '"',
        );
      }
      function qe() {
        var a = K();
        return (Wb && !!ic && 11 == ic) || /Edge\/\d+/.test(a);
      }
      function re() {
        return (l.window && l.window.location.href) || (self && self.location && self.location.href) || '';
      }
      function se(a, b) {
        b = b || l.window;
        var c = 'about:blank';
        a && (c = Eb(Ib(a) || Kb));
        b.location.href = c;
      }
      function te(a, b) {
        var c = [],
          d;
        for (d in a)
          d in b
            ? typeof a[d] != typeof b[d]
              ? c.push(d)
              : 'object' == typeof a[d] && null != a[d] && null != b[d]
              ? 0 < te(a[d], b[d]).length && c.push(d)
              : a[d] !== b[d] && c.push(d)
            : c.push(d);
        for (d in b) d in a || c.push(d);
        return c;
      }
      function ue() {
        var a = K();
        a = ve(a) != we ? null : (a = a.match(/\sChrome\/(\d+)/i)) && 2 == a.length ? parseInt(a[1], 10) : null;
        return a && 30 > a ? !1 : !Wb || !ic || 9 < ic;
      }
      function xe(a) {
        a = (a || K()).toLowerCase();
        return a.match(/android/) || a.match(/webos/) || a.match(/iphone|ipad|ipod/) || a.match(/blackberry/) || a.match(/windows phone/) || a.match(/iemobile/) ? !0 : !1;
      }
      function ye(a) {
        a = a || l.window;
        try {
          a.close();
        } catch (b) {}
      }
      function ze(a, b, c) {
        var d = Math.floor(1e9 * Math.random()).toString();
        b = b || 500;
        c = c || 600;
        var e = (window.screen.availHeight - c) / 2,
          f = (window.screen.availWidth - b) / 2;
        b = { width: b, height: c, top: 0 < e ? e : 0, left: 0 < f ? f : 0, location: !0, resizable: !0, statusbar: !0, toolbar: !1 };
        c = K().toLowerCase();
        d && ((b.target = d), x(c, 'crios/') && (b.target = '_blank'));
        ve(K()) == Ae && ((a = a || 'http://localhost'), (b.scrollbars = !0));
        c = a || '';
        (a = b) || (a = {});
        d = window;
        b = c instanceof C ? c : Ib('undefined' != typeof c.href ? c.href : String(c)) || Kb;
        c = a.target || c.target;
        e = [];
        for (g in a)
          switch (g) {
            case 'width':
            case 'height':
            case 'top':
            case 'left':
              e.push(g + '=' + a[g]);
              break;
            case 'target':
            case 'noopener':
            case 'noreferrer':
              break;
            default:
              e.push(g + '=' + (a[g] ? 1 : 0));
          }
        var g = e.join(',');
        if (((y('iPhone') && !y('iPod') && !y('iPad')) || y('iPad') || y('iPod')) && d.navigator && d.navigator.standalone && c && '_self' != c)
          (g = oc(document, 'A')),
            pb(g, 'HTMLAnchorElement'),
            (b = b instanceof C ? b : Jb(b)),
            (g.href = Eb(b)),
            g.setAttribute('target', c),
            a.noreferrer && g.setAttribute('rel', 'noreferrer'),
            (a = document.createEvent('MouseEvent')),
            a.initMouseEvent('click', !0, !0, d, 1),
            g.dispatchEvent(a),
            (g = {});
        else if (a.noreferrer) {
          if (
            ((g = Pb('', d, c, g)),
            (a = Eb(b)),
            g &&
              (Yb && x(a, ';') && (a = "'" + a.replace(/'/g, '%27') + "'"),
              (g.opener = null),
              (a = '<meta name="referrer" content="no-referrer"><meta http-equiv="refresh" content="0; url=' + Rb(a) + '">'),
              (a = (d = vb()) ? d.createHTML(a) : a),
              (a = new Lb(a, null, Mb)),
              (d = g.document)))
          )
            d.write(Nb(a)), d.close();
        } else (g = Pb(b, d, c, g)) && a.noopener && (g.opener = null);
        if (g)
          try {
            g.focus();
          } catch (h) {}
        return g;
      }
      function Be(a) {
        return new D(function (b) {
          function c() {
            Fd(2e3).then(function () {
              if (!a || a.closed) b();
              else return c();
            });
          }
          return c();
        });
      }
      var Ce = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,
        De = /^[^@]+@[^@]+$/;
      function Ee() {
        var a = null;
        return new D(function (b) {
          'complete' == l.document.readyState
            ? b()
            : ((a = function () {
                b();
              }),
              od(window, 'load', a));
        }).o(function (b) {
          xd(window, 'load', a);
          throw b;
        });
      }
      function Fe() {
        return Ge(void 0)
          ? Ee().then(function () {
              return new D(function (a, b) {
                var c = l.document,
                  d = setTimeout(function () {
                    b(Error('Cordova framework is not ready.'));
                  }, 1e3);
                c.addEventListener(
                  'deviceready',
                  function () {
                    clearTimeout(d);
                    a();
                  },
                  !1,
                );
              });
            })
          : F(Error('Cordova must run in an Android or iOS file scheme.'));
      }
      function Ge(a) {
        a = a || K();
        return !(('file:' !== He() && 'ionic:' !== He()) || !a.toLowerCase().match(/iphone|ipad|ipod|android/));
      }
      function Ie() {
        var a = l.window;
        try {
          return !(!a || a == a.top);
        } catch (b) {
          return !1;
        }
      }
      function Je() {
        return 'undefined' !== typeof l.WorkerGlobalScope && 'function' === typeof l.importScripts;
      }
      function Ke() {
        return firebase.INTERNAL.hasOwnProperty('reactNative') ? 'ReactNative' : firebase.INTERNAL.hasOwnProperty('node') ? 'Node' : Je() ? 'Worker' : 'Browser';
      }
      function Le() {
        var a = Ke();
        return 'ReactNative' === a || 'Node' === a;
      }
      function Me() {
        for (var a = 50, b = []; 0 < a; ) b.push('1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.charAt(Math.floor(62 * Math.random()))), a--;
        return b.join('');
      }
      var Ae = 'Firefox',
        we = 'Chrome';
      function ve(a) {
        var b = a.toLowerCase();
        if (x(b, 'opera/') || x(b, 'opr/') || x(b, 'opios/')) return 'Opera';
        if (x(b, 'iemobile')) return 'IEMobile';
        if (x(b, 'msie') || x(b, 'trident/')) return 'IE';
        if (x(b, 'edge/')) return 'Edge';
        if (x(b, 'firefox/')) return Ae;
        if (x(b, 'silk/')) return 'Silk';
        if (x(b, 'blackberry')) return 'Blackberry';
        if (x(b, 'webos')) return 'Webos';
        if (!x(b, 'safari/') || x(b, 'chrome/') || x(b, 'crios/') || x(b, 'android'))
          if ((!x(b, 'chrome/') && !x(b, 'crios/')) || x(b, 'edge/')) {
            if (x(b, 'android')) return 'Android';
            if ((a = a.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/)) && 2 == a.length) return a[1];
          } else return we;
        else return 'Safari';
        return 'Other';
      }
      var Ne = { md: 'FirebaseCore-web', od: 'FirebaseUI-web' };
      function Oe(a, b) {
        b = b || [];
        var c = [],
          d = {},
          e;
        for (e in Ne) d[Ne[e]] = !0;
        for (e = 0; e < b.length; e++) 'undefined' !== typeof d[b[e]] && (delete d[b[e]], c.push(b[e]));
        c.sort();
        b = c;
        b.length || (b = ['FirebaseCore-web']);
        c = Ke();
        'Browser' === c ? ((d = K()), (c = ve(d))) : 'Worker' === c && ((d = K()), (c = ve(d) + '-' + c));
        return c + '/JsCore/' + a + '/' + b.join(',');
      }
      function K() {
        return (l.navigator && l.navigator.userAgent) || '';
      }
      function L(a, b) {
        a = a.split('.');
        b = b || l;
        for (var c = 0; c < a.length && 'object' == typeof b && null != b; c++) b = b[a[c]];
        c != a.length && (b = void 0);
        return b;
      }
      function Pe() {
        try {
          var a = l.localStorage,
            b = Qe();
          if (a) return a.setItem(b, '1'), a.removeItem(b), qe() ? !!l.indexedDB : !0;
        } catch (c) {
          return Je() && !!l.indexedDB;
        }
        return !1;
      }
      function Re() {
        return (Se() || 'chrome-extension:' === He() || Ge()) && !Le() && Pe() && !Je();
      }
      function Se() {
        return 'http:' === He() || 'https:' === He();
      }
      function He() {
        return (l.location && l.location.protocol) || null;
      }
      function Te(a) {
        a = a || K();
        return xe(a) || ve(a) == Ae ? !1 : !0;
      }
      function Ue(a) {
        return 'undefined' === typeof a ? null : ke(a);
      }
      function Ve(a) {
        var b = {},
          c;
        for (c in a) a.hasOwnProperty(c) && null !== a[c] && void 0 !== a[c] && (b[c] = a[c]);
        return b;
      }
      function We(a) {
        if (null !== a) return JSON.parse(a);
      }
      function Qe(a) {
        return a ? a : Math.floor(1e9 * Math.random()).toString();
      }
      function Xe(a) {
        a = a || K();
        return 'Safari' == ve(a) || a.toLowerCase().match(/iphone|ipad|ipod/) ? !1 : !0;
      }
      function Ye() {
        var a = l.___jsl;
        if (a && a.H)
          for (var b in a.H)
            if (((a.H[b].r = a.H[b].r || []), (a.H[b].L = a.H[b].L || []), (a.H[b].r = a.H[b].L.concat()), a.CP)) for (var c = 0; c < a.CP.length; c++) a.CP[c] = null;
      }
      function Ze(a, b) {
        if (a > b) throw Error('Short delay should be less than long delay!');
        this.a = a;
        this.c = b;
        a = K();
        b = Ke();
        this.b = xe(a) || 'ReactNative' === b;
      }
      Ze.prototype.get = function () {
        var a = l.navigator;
        return (a && 'boolean' === typeof a.onLine && (Se() || 'chrome-extension:' === He() || 'undefined' !== typeof a.connection) ? a.onLine : 1)
          ? this.b
            ? this.c
            : this.a
          : Math.min(5e3, this.a);
      };
      function $e() {
        var a = l.document;
        return a && 'undefined' !== typeof a.visibilityState ? 'visible' == a.visibilityState : !0;
      }
      function af() {
        var a = l.document,
          b = null;
        return $e() || !a
          ? E()
          : new D(function (c) {
              b = function () {
                $e() && (a.removeEventListener('visibilitychange', b, !1), c());
              };
              a.addEventListener('visibilitychange', b, !1);
            }).o(function (c) {
              a.removeEventListener('visibilitychange', b, !1);
              throw c;
            });
      }
      function bf(a) {
        try {
          var b = new Date(parseInt(a, 10));
          if (!isNaN(b.getTime()) && !/[^0-9]/.test(a)) return b.toUTCString();
        } catch (c) {}
        return null;
      }
      function cf() {
        return !(!L('fireauth.oauthhelper', l) && !L('fireauth.iframe', l));
      }
      function df() {
        var a = l.navigator;
        return (a && a.serviceWorker && a.serviceWorker.controller) || null;
      }
      function ef() {
        var a = l.navigator;
        return a && a.serviceWorker
          ? E()
              .then(function () {
                return a.serviceWorker.ready;
              })
              .then(function (b) {
                return b.active || null;
              })
              .o(function () {
                return null;
              })
          : E(null);
      }
      var ff = {};
      function gf(a) {
        ff[a] || ((ff[a] = !0), 'undefined' !== typeof console && 'function' === typeof console.warn && console.warn(a));
      }
      var hf;
      try {
        var jf = {};
        Object.defineProperty(jf, 'abcd', { configurable: !0, enumerable: !0, value: 1 });
        Object.defineProperty(jf, 'abcd', { configurable: !0, enumerable: !0, value: 2 });
        hf = 2 == jf.abcd;
      } catch (a) {
        hf = !1;
      }
      function M(a, b, c) {
        hf ? Object.defineProperty(a, b, { configurable: !0, enumerable: !0, value: c }) : (a[b] = c);
      }
      function N(a, b) {
        if (b) for (var c in b) b.hasOwnProperty(c) && M(a, c, b[c]);
      }
      function kf(a) {
        var b = {};
        N(b, a);
        return b;
      }
      function lf(a) {
        var b = {},
          c;
        for (c in a) a.hasOwnProperty(c) && (b[c] = a[c]);
        return b;
      }
      function mf(a, b) {
        if (!b || !b.length) return !0;
        if (!a) return !1;
        for (var c = 0; c < b.length; c++) {
          var d = a[b[c]];
          if (void 0 === d || null === d || '' === d) return !1;
        }
        return !0;
      }
      function nf(a) {
        var b = a;
        if ('object' == typeof a && null != a) {
          b = 'length' in a ? [] : {};
          for (var c in a) M(b, c, nf(a[c]));
        }
        return b;
      }
      function of(a) {
        var b = a && (a[pf] ? 'phone' : null);
        if (b && a && a[qf]) {
          M(this, 'uid', a[qf]);
          M(this, 'displayName', a[rf] || null);
          var c = null;
          a[sf] && (c = new Date(a[sf]).toUTCString());
          M(this, 'enrollmentTime', c);
          M(this, 'factorId', b);
        } else throw new t('internal-error', 'Internal assert: invalid MultiFactorInfo object');
      }
      of.prototype.w = function () {
        return { uid: this.uid, displayName: this.displayName, factorId: this.factorId, enrollmentTime: this.enrollmentTime };
      };
      function tf(a) {
        try {
          var b = new uf(a);
        } catch (c) {
          b = null;
        }
        return b;
      }
      var rf = 'displayName',
        sf = 'enrolledAt',
        qf = 'mfaEnrollmentId',
        pf = 'phoneInfo';
      function uf(a) {
        of.call(this, a);
        M(this, 'phoneNumber', a[pf]);
      }
      r(uf, of);
      uf.prototype.w = function () {
        var a = uf.bb.w.call(this);
        a.phoneNumber = this.phoneNumber;
        return a;
      };
      function vf(a) {
        var b = {},
          c = a[wf],
          d = a[xf],
          e = a[yf];
        a = tf(a[zf]);
        if (!e || (e != Af && e != Bf && !c) || (e == Bf && !d) || (e == Cf && !a)) throw Error('Invalid checkActionCode response!');
        e == Bf ? ((b[Df] = c || null), (b[Ef] = c || null), (b[Ff] = d)) : ((b[Df] = d || null), (b[Ef] = d || null), (b[Ff] = c || null));
        b[Gf] = a || null;
        M(this, Hf, e);
        M(this, If, nf(b));
      }
      var Cf = 'REVERT_SECOND_FACTOR_ADDITION',
        Af = 'EMAIL_SIGNIN',
        Bf = 'VERIFY_AND_CHANGE_EMAIL',
        wf = 'email',
        zf = 'mfaInfo',
        xf = 'newEmail',
        yf = 'requestType',
        Ff = 'email',
        Df = 'fromEmail',
        Gf = 'multiFactorInfo',
        Ef = 'previousEmail',
        If = 'data',
        Hf = 'operation';
      function Jf(a) {
        a = J(a);
        var b = be(a, Kf) || null,
          c = be(a, Lf) || null,
          d = be(a, Mf) || null;
        d = d ? Nf[d] || null : null;
        if (!b || !c || !d) throw new t('argument-error', Kf + ', ' + Lf + 'and ' + Mf + ' are required in a valid action code URL.');
        N(this, { apiKey: b, operation: d, code: c, continueUrl: be(a, Of) || null, languageCode: be(a, Pf) || null, tenantId: be(a, Qf) || null });
      }
      var Kf = 'apiKey',
        Lf = 'oobCode',
        Of = 'continueUrl',
        Pf = 'languageCode',
        Mf = 'mode',
        Qf = 'tenantId',
        Nf = { recoverEmail: 'RECOVER_EMAIL', resetPassword: 'PASSWORD_RESET', revertSecondFactorAddition: Cf, signIn: Af, verifyAndChangeEmail: Bf, verifyEmail: 'VERIFY_EMAIL' };
      function Rf(a) {
        try {
          return new Jf(a);
        } catch (b) {
          return null;
        }
      }
      function Sf(a) {
        var b = a[Tf];
        if ('undefined' === typeof b) throw new t('missing-continue-uri');
        if ('string' !== typeof b || ('string' === typeof b && !b.length)) throw new t('invalid-continue-uri');
        this.h = b;
        this.b = this.a = null;
        this.g = !1;
        var c = a[Uf];
        if (c && 'object' === typeof c) {
          b = c[Vf];
          var d = c[Wf];
          c = c[Xf];
          if ('string' === typeof b && b.length) {
            this.a = b;
            if ('undefined' !== typeof d && 'boolean' !== typeof d) throw new t('argument-error', Wf + ' property must be a boolean when specified.');
            this.g = !!d;
            if ('undefined' !== typeof c && ('string' !== typeof c || ('string' === typeof c && !c.length)))
              throw new t('argument-error', Xf + ' property must be a non empty string when specified.');
            this.b = c || null;
          } else {
            if ('undefined' !== typeof b) throw new t('argument-error', Vf + ' property must be a non empty string when specified.');
            if ('undefined' !== typeof d || 'undefined' !== typeof c) throw new t('missing-android-pkg-name');
          }
        } else if ('undefined' !== typeof c) throw new t('argument-error', Uf + ' property must be a non null object when specified.');
        this.f = null;
        if ((b = a[Yf]) && 'object' === typeof b)
          if (((b = b[Zf]), 'string' === typeof b && b.length)) this.f = b;
          else {
            if ('undefined' !== typeof b) throw new t('argument-error', Zf + ' property must be a non empty string when specified.');
          }
        else if ('undefined' !== typeof b) throw new t('argument-error', Yf + ' property must be a non null object when specified.');
        b = a[$f];
        if ('undefined' !== typeof b && 'boolean' !== typeof b) throw new t('argument-error', $f + ' property must be a boolean when specified.');
        this.c = !!b;
        a = a[ag];
        if ('undefined' !== typeof a && ('string' !== typeof a || ('string' === typeof a && !a.length)))
          throw new t('argument-error', ag + ' property must be a non empty string when specified.');
        this.i = a || null;
      }
      var Uf = 'android',
        ag = 'dynamicLinkDomain',
        $f = 'handleCodeInApp',
        Yf = 'iOS',
        Tf = 'url',
        Wf = 'installApp',
        Xf = 'minimumVersion',
        Vf = 'packageName',
        Zf = 'bundleId';
      function bg(a) {
        var b = {};
        b.continueUrl = a.h;
        b.canHandleCodeInApp = a.c;
        if ((b.androidPackageName = a.a)) (b.androidMinimumVersion = a.b), (b.androidInstallApp = a.g);
        b.iOSBundleId = a.f;
        b.dynamicLinkDomain = a.i;
        for (var c in b) null === b[c] && delete b[c];
        return b;
      }
      function cg(a) {
        return Ra(a, function (b) {
          b = b.toString(16);
          return 1 < b.length ? b : '0' + b;
        }).join('');
      }
      var dg = null;
      function eg(a) {
        var b = [];
        fg(a, function (c) {
          b.push(c);
        });
        return b;
      }
      function fg(a, b) {
        function c(m) {
          for (; d < a.length; ) {
            var p = a.charAt(d++),
              v = dg[p];
            if (null != v) return v;
            if (!/^[\s\xa0]*$/.test(p)) throw Error('Unknown base64 encoding at char: ' + p);
          }
          return m;
        }
        gg();
        for (var d = 0; ; ) {
          var e = c(-1),
            f = c(0),
            g = c(64),
            h = c(64);
          if (64 === h && -1 === e) break;
          b((e << 2) | (f >> 4));
          64 != g && (b(((f << 4) & 240) | (g >> 2)), 64 != h && b(((g << 6) & 192) | h));
        }
      }
      function gg() {
        if (!dg) {
          dg = {};
          for (var a = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.split(''), b = ['+/=', '+/', '-_=', '-_.', '-_'], c = 0; 5 > c; c++)
            for (var d = a.concat(b[c].split('')), e = 0; e < d.length; e++) {
              var f = d[e];
              void 0 === dg[f] && (dg[f] = e);
            }
        }
      }
      function hg(a) {
        var b = ig(a);
        if (!(b && b.sub && b.iss && b.aud && b.exp)) throw Error('Invalid JWT');
        this.h = a;
        this.a = b.exp;
        this.i = b.sub;
        a = Date.now() / 1e3;
        this.g = b.iat || (a > this.a ? this.a : a);
        this.b = b.provider_id || (b.firebase && b.firebase.sign_in_provider) || null;
        this.f = (b.firebase && b.firebase.tenant) || null;
        this.c = !!b.is_anonymous || 'anonymous' == this.b;
      }
      hg.prototype.T = function () {
        return this.f;
      };
      hg.prototype.l = function () {
        return this.c;
      };
      hg.prototype.toString = function () {
        return this.h;
      };
      function jg(a) {
        try {
          return new hg(a);
        } catch (b) {
          return null;
        }
      }
      function ig(a) {
        if (!a) return null;
        a = a.split('.');
        if (3 != a.length) return null;
        a = a[1];
        for (var b = (4 - (a.length % 4)) % 4, c = 0; c < b; c++) a += '.';
        try {
          var d = eg(a);
          a = [];
          for (c = b = 0; b < d.length; ) {
            var e = d[b++];
            if (128 > e) a[c++] = String.fromCharCode(e);
            else if (191 < e && 224 > e) {
              var f = d[b++];
              a[c++] = String.fromCharCode(((e & 31) << 6) | (f & 63));
            } else if (239 < e && 365 > e) {
              f = d[b++];
              var g = d[b++],
                h = d[b++],
                m = (((e & 7) << 18) | ((f & 63) << 12) | ((g & 63) << 6) | (h & 63)) - 65536;
              a[c++] = String.fromCharCode(55296 + (m >> 10));
              a[c++] = String.fromCharCode(56320 + (m & 1023));
            } else (f = d[b++]), (g = d[b++]), (a[c++] = String.fromCharCode(((e & 15) << 12) | ((f & 63) << 6) | (g & 63)));
          }
          return JSON.parse(a.join(''));
        } catch (p) {}
        return null;
      }
      var kg = 'oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_timestamp oauth_token oauth_version'.split(' '),
        lg = ['client_id', 'response_type', 'scope', 'redirect_uri', 'state'],
        mg = {
          nd: { Ja: 'locale', va: 700, ua: 600, fa: 'facebook.com', Ya: lg },
          pd: { Ja: null, va: 500, ua: 750, fa: 'github.com', Ya: lg },
          qd: { Ja: 'hl', va: 515, ua: 680, fa: 'google.com', Ya: lg },
          wd: { Ja: 'lang', va: 485, ua: 705, fa: 'twitter.com', Ya: kg },
          kd: { Ja: 'locale', va: 640, ua: 600, fa: 'apple.com', Ya: [] },
        };
      function ng(a) {
        for (var b in mg) if (mg[b].fa == a) return mg[b];
        return null;
      }
      function og(a) {
        var b = {};
        b['facebook.com'] = pg;
        b['google.com'] = qg;
        b['github.com'] = rg;
        b['twitter.com'] = sg;
        var c = a && a[tg];
        try {
          if (c) return b[c] ? new b[c](a) : new ug(a);
          if ('undefined' !== typeof a[vg]) return new wg(a);
        } catch (d) {}
        return null;
      }
      var vg = 'idToken',
        tg = 'providerId';
      function wg(a) {
        var b = a[tg];
        if (!b && a[vg]) {
          var c = jg(a[vg]);
          c && c.b && (b = c.b);
        }
        if (!b) throw Error('Invalid additional user info!');
        if ('anonymous' == b || 'custom' == b) b = null;
        c = !1;
        'undefined' !== typeof a.isNewUser ? (c = !!a.isNewUser) : 'identitytoolkit#SignupNewUserResponse' === a.kind && (c = !0);
        M(this, 'providerId', b);
        M(this, 'isNewUser', c);
      }
      function ug(a) {
        wg.call(this, a);
        a = We(a.rawUserInfo || '{}');
        M(this, 'profile', nf(a || {}));
      }
      r(ug, wg);
      function pg(a) {
        ug.call(this, a);
        if ('facebook.com' != this.providerId) throw Error('Invalid provider ID!');
      }
      r(pg, ug);
      function rg(a) {
        ug.call(this, a);
        if ('github.com' != this.providerId) throw Error('Invalid provider ID!');
        M(this, 'username', (this.profile && this.profile.login) || null);
      }
      r(rg, ug);
      function qg(a) {
        ug.call(this, a);
        if ('google.com' != this.providerId) throw Error('Invalid provider ID!');
      }
      r(qg, ug);
      function sg(a) {
        ug.call(this, a);
        if ('twitter.com' != this.providerId) throw Error('Invalid provider ID!');
        M(this, 'username', a.screenName || null);
      }
      r(sg, ug);
      function xg(a) {
        var b = J(a),
          c = be(b, 'link'),
          d = be(J(c), 'link');
        b = be(b, 'deep_link_id');
        return be(J(b), 'link') || b || d || c || a;
      }
      function yg(a, b) {
        if (!a && !b) throw new t('internal-error', 'Internal assert: no raw session string available');
        if (a && b) throw new t('internal-error', 'Internal assert: unable to determine the session type');
        this.a = a || null;
        this.b = b || null;
        this.type = this.a ? zg : Ag;
      }
      var zg = 'enroll',
        Ag = 'signin';
      yg.prototype.Ha = function () {
        return this.a ? E(this.a) : E(this.b);
      };
      yg.prototype.w = function () {
        return this.type == zg ? { multiFactorSession: { idToken: this.a } } : { multiFactorSession: { pendingCredential: this.b } };
      };
      function Bg() {}
      Bg.prototype.ka = function () {};
      Bg.prototype.b = function () {};
      Bg.prototype.c = function () {};
      Bg.prototype.w = function () {};
      function Cg(a, b) {
        return a
          .then(function (c) {
            if (c[Dg]) {
              var d = jg(c[Dg]);
              if (!d || b != d.i) throw new t('user-mismatch');
              return c;
            }
            throw new t('user-mismatch');
          })
          .o(function (c) {
            throw c && c.code && c.code == xa + 'user-not-found' ? new t('user-mismatch') : c;
          });
      }
      function Eg(a, b) {
        if (b) this.a = b;
        else throw new t('internal-error', 'failed to construct a credential');
        M(this, 'providerId', a);
        M(this, 'signInMethod', a);
      }
      Eg.prototype.ka = function (a) {
        return Fg(a, Gg(this));
      };
      Eg.prototype.b = function (a, b) {
        var c = Gg(this);
        c.idToken = b;
        return Hg(a, c);
      };
      Eg.prototype.c = function (a, b) {
        return Cg(Ig(a, Gg(this)), b);
      };
      function Gg(a) {
        return { pendingToken: a.a, requestUri: 'http://localhost' };
      }
      Eg.prototype.w = function () {
        return { providerId: this.providerId, signInMethod: this.signInMethod, pendingToken: this.a };
      };
      function Jg(a) {
        if (a && a.providerId && a.signInMethod && 0 == a.providerId.indexOf('saml.') && a.pendingToken)
          try {
            return new Eg(a.providerId, a.pendingToken);
          } catch (b) {}
        return null;
      }
      function Kg(a, b, c) {
        this.a = null;
        if (b.idToken || b.accessToken)
          b.idToken && M(this, 'idToken', b.idToken),
            b.accessToken && M(this, 'accessToken', b.accessToken),
            b.nonce && !b.pendingToken && M(this, 'nonce', b.nonce),
            b.pendingToken && (this.a = b.pendingToken);
        else if (b.oauthToken && b.oauthTokenSecret) M(this, 'accessToken', b.oauthToken), M(this, 'secret', b.oauthTokenSecret);
        else throw new t('internal-error', 'failed to construct a credential');
        M(this, 'providerId', a);
        M(this, 'signInMethod', c);
      }
      Kg.prototype.ka = function (a) {
        return Fg(a, Lg(this));
      };
      Kg.prototype.b = function (a, b) {
        var c = Lg(this);
        c.idToken = b;
        return Hg(a, c);
      };
      Kg.prototype.c = function (a, b) {
        var c = Lg(this);
        return Cg(Ig(a, c), b);
      };
      function Lg(a) {
        var b = {};
        a.idToken && (b.id_token = a.idToken);
        a.accessToken && (b.access_token = a.accessToken);
        a.secret && (b.oauth_token_secret = a.secret);
        b.providerId = a.providerId;
        a.nonce && !a.a && (b.nonce = a.nonce);
        b = { postBody: fe(b).toString(), requestUri: 'http://localhost' };
        a.a && (delete b.postBody, (b.pendingToken = a.a));
        return b;
      }
      Kg.prototype.w = function () {
        var a = { providerId: this.providerId, signInMethod: this.signInMethod };
        this.idToken && (a.oauthIdToken = this.idToken);
        this.accessToken && (a.oauthAccessToken = this.accessToken);
        this.secret && (a.oauthTokenSecret = this.secret);
        this.nonce && (a.nonce = this.nonce);
        this.a && (a.pendingToken = this.a);
        return a;
      };
      function Mg(a) {
        if (a && a.providerId && a.signInMethod) {
          var b = {
            idToken: a.oauthIdToken,
            accessToken: a.oauthTokenSecret ? null : a.oauthAccessToken,
            oauthTokenSecret: a.oauthTokenSecret,
            oauthToken: a.oauthTokenSecret && a.oauthAccessToken,
            nonce: a.nonce,
            pendingToken: a.pendingToken,
          };
          try {
            return new Kg(a.providerId, b, a.signInMethod);
          } catch (c) {}
        }
        return null;
      }
      function Ng(a, b) {
        this.Qc = b || [];
        N(this, { providerId: a, isOAuthProvider: !0 });
        this.Jb = {};
        this.qb = (ng(a) || {}).Ja || null;
        this.pb = null;
      }
      Ng.prototype.Ka = function (a) {
        this.Jb = nb(a);
        return this;
      };
      function Og(a) {
        if ('string' !== typeof a || 0 != a.indexOf('saml.')) throw new t('argument-error', 'SAML provider IDs must be prefixed with "saml."');
        Ng.call(this, a, []);
      }
      r(Og, Ng);
      function Pg(a) {
        Ng.call(this, a, lg);
        this.a = [];
      }
      r(Pg, Ng);
      Pg.prototype.Ca = function (a) {
        Va(this.a, a) || this.a.push(a);
        return this;
      };
      Pg.prototype.Rb = function () {
        return Za(this.a);
      };
      Pg.prototype.credential = function (a, b) {
        var c;
        n(a) ? (c = { idToken: a.idToken || null, accessToken: a.accessToken || null, nonce: a.rawNonce || null }) : (c = { idToken: a || null, accessToken: b || null });
        if (!c.idToken && !c.accessToken) throw new t('argument-error', 'credential failed: must provide the ID token and/or the access token.');
        return new Kg(this.providerId, c, this.providerId);
      };
      function Qg() {
        Pg.call(this, 'facebook.com');
      }
      r(Qg, Pg);
      M(Qg, 'PROVIDER_ID', 'facebook.com');
      M(Qg, 'FACEBOOK_SIGN_IN_METHOD', 'facebook.com');
      function Rg(a) {
        if (!a) throw new t('argument-error', 'credential failed: expected 1 argument (the OAuth access token).');
        var b = a;
        n(a) && (b = a.accessToken);
        return new Qg().credential({ accessToken: b });
      }
      function Sg() {
        Pg.call(this, 'github.com');
      }
      r(Sg, Pg);
      M(Sg, 'PROVIDER_ID', 'github.com');
      M(Sg, 'GITHUB_SIGN_IN_METHOD', 'github.com');
      function Tg(a) {
        if (!a) throw new t('argument-error', 'credential failed: expected 1 argument (the OAuth access token).');
        var b = a;
        n(a) && (b = a.accessToken);
        return new Sg().credential({ accessToken: b });
      }
      function Ug() {
        Pg.call(this, 'google.com');
        this.Ca('profile');
      }
      r(Ug, Pg);
      M(Ug, 'PROVIDER_ID', 'google.com');
      M(Ug, 'GOOGLE_SIGN_IN_METHOD', 'google.com');
      function Vg(a, b) {
        var c = a;
        n(a) && ((c = a.idToken), (b = a.accessToken));
        return new Ug().credential({ idToken: c, accessToken: b });
      }
      function Wg() {
        Ng.call(this, 'twitter.com', kg);
      }
      r(Wg, Ng);
      M(Wg, 'PROVIDER_ID', 'twitter.com');
      M(Wg, 'TWITTER_SIGN_IN_METHOD', 'twitter.com');
      function Xg(a, b) {
        var c = a;
        n(c) || (c = { oauthToken: a, oauthTokenSecret: b });
        if (!c.oauthToken || !c.oauthTokenSecret) throw new t('argument-error', 'credential failed: expected 2 arguments (the OAuth access token and secret).');
        return new Kg('twitter.com', c, 'twitter.com');
      }
      function Yg(a, b, c) {
        this.a = a;
        this.f = b;
        M(this, 'providerId', 'password');
        M(this, 'signInMethod', c === Zg.EMAIL_LINK_SIGN_IN_METHOD ? Zg.EMAIL_LINK_SIGN_IN_METHOD : Zg.EMAIL_PASSWORD_SIGN_IN_METHOD);
      }
      Yg.prototype.ka = function (a) {
        return this.signInMethod == Zg.EMAIL_LINK_SIGN_IN_METHOD ? O(a, $g, { email: this.a, oobCode: this.f }) : O(a, ah, { email: this.a, password: this.f });
      };
      Yg.prototype.b = function (a, b) {
        return this.signInMethod == Zg.EMAIL_LINK_SIGN_IN_METHOD
          ? O(a, bh, { idToken: b, email: this.a, oobCode: this.f })
          : O(a, ch, { idToken: b, email: this.a, password: this.f });
      };
      Yg.prototype.c = function (a, b) {
        return Cg(this.ka(a), b);
      };
      Yg.prototype.w = function () {
        return { email: this.a, password: this.f, signInMethod: this.signInMethod };
      };
      function dh(a) {
        return a && a.email && a.password ? new Yg(a.email, a.password, a.signInMethod) : null;
      }
      function Zg() {
        N(this, { providerId: 'password', isOAuthProvider: !1 });
      }
      function eh(a, b) {
        b = fh(b);
        if (!b) throw new t('argument-error', 'Invalid email link!');
        return new Yg(a, b.code, Zg.EMAIL_LINK_SIGN_IN_METHOD);
      }
      function fh(a) {
        a = xg(a);
        return (a = Rf(a)) && a.operation === Af ? a : null;
      }
      N(Zg, { PROVIDER_ID: 'password' });
      N(Zg, { EMAIL_LINK_SIGN_IN_METHOD: 'emailLink' });
      N(Zg, { EMAIL_PASSWORD_SIGN_IN_METHOD: 'password' });
      function gh(a) {
        if (!((a.fb && a.eb) || (a.La && a.ea))) throw new t('internal-error');
        this.a = a;
        M(this, 'providerId', 'phone');
        this.fa = 'phone';
        M(this, 'signInMethod', 'phone');
      }
      gh.prototype.ka = function (a) {
        return a.gb(hh(this));
      };
      gh.prototype.b = function (a, b) {
        var c = hh(this);
        c.idToken = b;
        return O(a, ih, c);
      };
      gh.prototype.c = function (a, b) {
        var c = hh(this);
        c.operation = 'REAUTH';
        a = O(a, jh, c);
        return Cg(a, b);
      };
      gh.prototype.w = function () {
        var a = { providerId: 'phone' };
        this.a.fb && (a.verificationId = this.a.fb);
        this.a.eb && (a.verificationCode = this.a.eb);
        this.a.La && (a.temporaryProof = this.a.La);
        this.a.ea && (a.phoneNumber = this.a.ea);
        return a;
      };
      function kh(a) {
        if (a && 'phone' === a.providerId && ((a.verificationId && a.verificationCode) || (a.temporaryProof && a.phoneNumber))) {
          var b = {};
          w(['verificationId', 'verificationCode', 'temporaryProof', 'phoneNumber'], function (c) {
            a[c] && (b[c] = a[c]);
          });
          return new gh(b);
        }
        return null;
      }
      function hh(a) {
        return a.a.La && a.a.ea ? { temporaryProof: a.a.La, phoneNumber: a.a.ea } : { sessionInfo: a.a.fb, code: a.a.eb };
      }
      function lh(a) {
        try {
          this.a = a || firebase.auth();
        } catch (b) {
          throw new t(
            'argument-error',
            'Either an instance of firebase.auth.Auth must be passed as an argument to the firebase.auth.PhoneAuthProvider constructor, or the default firebase App instance must be initialized via firebase.initializeApp().',
          );
        }
        N(this, { providerId: 'phone', isOAuthProvider: !1 });
      }
      lh.prototype.gb = function (a, b) {
        var c = this.a.a;
        return E(b.verify()).then(function (d) {
          if ('string' !== typeof d)
            throw new t('argument-error', 'An implementation of firebase.auth.ApplicationVerifier.prototype.verify() must return a firebase.Promise that resolves with a string.');
          switch (b.type) {
            case 'recaptcha':
              var e = n(a) ? a.session : null,
                f = n(a) ? a.phoneNumber : a,
                g;
              e && e.type == zg
                ? (g = e.Ha().then(function (h) {
                    return mh(c, { idToken: h, phoneEnrollmentInfo: { phoneNumber: f, recaptchaToken: d } });
                  }))
                : e && e.type == Ag
                ? (g = e.Ha().then(function (h) {
                    return nh(c, {
                      mfaPendingCredential: h,
                      mfaEnrollmentId: (a.multiFactorHint && a.multiFactorHint.uid) || a.multiFactorUid,
                      phoneSignInInfo: { recaptchaToken: d },
                    });
                  }))
                : (g = oh(c, { phoneNumber: f, recaptchaToken: d }));
              return g.then(
                function (h) {
                  'function' === typeof b.reset && b.reset();
                  return h;
                },
                function (h) {
                  'function' === typeof b.reset && b.reset();
                  throw h;
                },
              );
            default:
              throw new t('argument-error', 'Only firebase.auth.ApplicationVerifiers with type="recaptcha" are currently supported.');
          }
        });
      };
      function ph(a, b) {
        if (!a) throw new t('missing-verification-id');
        if (!b) throw new t('missing-verification-code');
        return new gh({ fb: a, eb: b });
      }
      N(lh, { PROVIDER_ID: 'phone' });
      N(lh, { PHONE_SIGN_IN_METHOD: 'phone' });
      function qh(a) {
        if (a.temporaryProof && a.phoneNumber) return new gh({ La: a.temporaryProof, ea: a.phoneNumber });
        var b = a && a.providerId;
        if (!b || 'password' === b) return null;
        var c = a && a.oauthAccessToken,
          d = a && a.oauthTokenSecret,
          e = a && a.nonce,
          f = a && a.oauthIdToken,
          g = a && a.pendingToken;
        try {
          switch (b) {
            case 'google.com':
              return Vg(f, c);
            case 'facebook.com':
              return Rg(c);
            case 'github.com':
              return Tg(c);
            case 'twitter.com':
              return Xg(c, d);
            default:
              return c || d || f || g
                ? g
                  ? 0 == b.indexOf('saml.')
                    ? new Eg(b, g)
                    : new Kg(b, { pendingToken: g, idToken: a.oauthIdToken, accessToken: a.oauthAccessToken }, b)
                  : new Pg(b).credential({ idToken: f, accessToken: c, rawNonce: e })
                : null;
          }
        } catch (h) {
          return null;
        }
      }
      function rh(a) {
        if (!a.isOAuthProvider) throw new t('invalid-oauth-provider');
      }
      function sh(a, b, c, d, e, f, g) {
        this.c = a;
        this.b = b || null;
        this.g = c || null;
        this.f = d || null;
        this.i = f || null;
        this.h = g || null;
        this.a = e || null;
        if (this.g || this.a) {
          if (this.g && this.a) throw new t('invalid-auth-event');
          if (this.g && !this.f) throw new t('invalid-auth-event');
        } else throw new t('invalid-auth-event');
      }
      sh.prototype.getUid = function () {
        var a = [];
        a.push(this.c);
        this.b && a.push(this.b);
        this.f && a.push(this.f);
        this.h && a.push(this.h);
        return a.join('-');
      };
      sh.prototype.T = function () {
        return this.h;
      };
      sh.prototype.w = function () {
        return { type: this.c, eventId: this.b, urlResponse: this.g, sessionId: this.f, postBody: this.i, tenantId: this.h, error: this.a && this.a.w() };
      };
      function th(a) {
        a = a || {};
        return a.type ? new sh(a.type, a.eventId, a.urlResponse, a.sessionId, a.error && Aa(a.error), a.postBody, a.tenantId) : null;
      }
      function uh() {
        this.b = null;
        this.a = [];
      }
      var vh = null;
      function wh(a) {
        var b = vh;
        b.a.push(a);
        b.b ||
          ((b.b = function (c) {
            for (var d = 0; d < b.a.length; d++) b.a[d](c);
          }),
          (a = L('universalLinks.subscribe', l)),
          'function' === typeof a && a(null, b.b));
      }
      function xh(a) {
        var b = 'unauthorized-domain',
          c = void 0,
          d = J(a);
        a = d.a;
        d = d.c;
        'chrome-extension' == d
          ? (c = Qb(
              'This chrome extension ID (chrome-extension://%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.',
              a,
            ))
          : 'http' == d || 'https' == d
          ? (c = Qb(
              'This domain (%s) is not authorized to run this operation. Add it to the OAuth redirect domains list in the Firebase console -> Auth section -> Sign in method tab.',
              a,
            ))
          : (b = 'operation-not-supported-in-this-environment');
        t.call(this, b, c);
      }
      r(xh, t);
      function yh(a, b, c) {
        t.call(this, a, c);
        a = b || {};
        a.Kb && M(this, 'email', a.Kb);
        a.ea && M(this, 'phoneNumber', a.ea);
        a.credential && M(this, 'credential', a.credential);
        a.$b && M(this, 'tenantId', a.$b);
      }
      r(yh, t);
      yh.prototype.w = function () {
        var a = { code: this.code, message: this.message };
        this.email && (a.email = this.email);
        this.phoneNumber && (a.phoneNumber = this.phoneNumber);
        this.tenantId && (a.tenantId = this.tenantId);
        var b = this.credential && this.credential.w();
        b && z(a, b);
        return a;
      };
      yh.prototype.toJSON = function () {
        return this.w();
      };
      function zh(a) {
        if (a.code) {
          var b = a.code || '';
          0 == b.indexOf(xa) && (b = b.substring(xa.length));
          var c = { credential: qh(a), $b: a.tenantId };
          if (a.email) c.Kb = a.email;
          else if (a.phoneNumber) c.ea = a.phoneNumber;
          else if (!c.credential) return new t(b, a.message || void 0);
          return new yh(b, c, a.message);
        }
        return null;
      }
      function Ah() {}
      Ah.prototype.c = null;
      function Bh(a) {
        return a.c || (a.c = a.b());
      }
      var Ch;
      function Dh() {}
      r(Dh, Ah);
      Dh.prototype.a = function () {
        var a = Eh(this);
        return a ? new ActiveXObject(a) : new XMLHttpRequest();
      };
      Dh.prototype.b = function () {
        var a = {};
        Eh(this) && ((a[0] = !0), (a[1] = !0));
        return a;
      };
      function Eh(a) {
        if (!a.f && 'undefined' == typeof XMLHttpRequest && 'undefined' != typeof ActiveXObject) {
          for (var b = ['MSXML2.XMLHTTP.6.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP', 'Microsoft.XMLHTTP'], c = 0; c < b.length; c++) {
            var d = b[c];
            try {
              return new ActiveXObject(d), (a.f = d);
            } catch (e) {}
          }
          throw Error('Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed');
        }
        return a.f;
      }
      Ch = new Dh();
      function Fh() {}
      r(Fh, Ah);
      Fh.prototype.a = function () {
        var a = new XMLHttpRequest();
        if ('withCredentials' in a) return a;
        if ('undefined' != typeof XDomainRequest) return new Gh();
        throw Error('Unsupported browser');
      };
      Fh.prototype.b = function () {
        return {};
      };
      function Gh() {
        this.a = new XDomainRequest();
        this.readyState = 0;
        this.onreadystatechange = null;
        this.responseType = this.responseText = this.response = '';
        this.status = -1;
        this.statusText = '';
        this.a.onload = q(this.qc, this);
        this.a.onerror = q(this.Tb, this);
        this.a.onprogress = q(this.rc, this);
        this.a.ontimeout = q(this.vc, this);
      }
      k = Gh.prototype;
      k.open = function (a, b, c) {
        if (null != c && !c) throw Error('Only async requests are supported.');
        this.a.open(a, b);
      };
      k.send = function (a) {
        if (a)
          if ('string' == typeof a) this.a.send(a);
          else throw Error('Only string data is supported');
        else this.a.send();
      };
      k.abort = function () {
        this.a.abort();
      };
      k.setRequestHeader = function () {};
      k.getResponseHeader = function (a) {
        return 'content-type' == a.toLowerCase() ? this.a.contentType : '';
      };
      k.qc = function () {
        this.status = 200;
        this.response = this.responseText = this.a.responseText;
        Hh(this, 4);
      };
      k.Tb = function () {
        this.status = 500;
        this.response = this.responseText = '';
        Hh(this, 4);
      };
      k.vc = function () {
        this.Tb();
      };
      k.rc = function () {
        this.status = 200;
        Hh(this, 1);
      };
      function Hh(a, b) {
        a.readyState = b;
        if (a.onreadystatechange) a.onreadystatechange();
      }
      k.getAllResponseHeaders = function () {
        return 'content-type: ' + this.a.contentType;
      };
      function Ih(a, b, c) {
        this.reset(a, b, c, void 0, void 0);
      }
      Ih.prototype.a = null;
      Ih.prototype.reset = function (a, b, c, d, e) {
        delete this.a;
      };
      function Kh(a) {
        this.f = a;
        this.b = this.c = this.a = null;
      }
      function Lh(a, b) {
        this.name = a;
        this.value = b;
      }
      Lh.prototype.toString = function () {
        return this.name;
      };
      var Mh = new Lh('SEVERE', 1e3),
        Nh = new Lh('WARNING', 900),
        Oh = new Lh('CONFIG', 700),
        Ph = new Lh('FINE', 500);
      function Qh(a) {
        if (a.c) return a.c;
        if (a.a) return Qh(a.a);
        Ga('Root logger has no level set.');
        return null;
      }
      Kh.prototype.log = function (a, b, c) {
        if (a.value >= Qh(this).value) for (oa(b) && (b = b()), a = new Ih(a, String(b), this.f), c && (a.a = c), c = this; c; ) c = c.a;
      };
      var Rh = {},
        Sh = null;
      function Th(a) {
        Sh || ((Sh = new Kh('')), (Rh[''] = Sh), (Sh.c = Oh));
        var b;
        if (!(b = Rh[a])) {
          b = new Kh(a);
          var c = a.lastIndexOf('.'),
            d = a.substr(c + 1);
          c = Th(a.substr(0, c));
          c.b || (c.b = {});
          c.b[d] = b;
          b.a = c;
          Rh[a] = b;
        }
        return b;
      }
      function Uh(a, b) {
        a && a.log(Ph, b, void 0);
      }
      function Vh(a) {
        this.f = a;
      }
      r(Vh, Ah);
      Vh.prototype.a = function () {
        return new Wh(this.f);
      };
      Vh.prototype.b = (function (a) {
        return function () {
          return a;
        };
      })({});
      function Wh(a) {
        H.call(this);
        this.u = a;
        this.h = void 0;
        this.readyState = Xh;
        this.status = 0;
        this.responseType = this.responseText = this.response = this.statusText = '';
        this.onreadystatechange = null;
        this.l = new Headers();
        this.b = null;
        this.s = 'GET';
        this.f = '';
        this.a = !1;
        this.i = Th('goog.net.FetchXmlHttp');
        this.m = this.c = this.g = null;
      }
      r(Wh, H);
      var Xh = 0;
      k = Wh.prototype;
      k.open = function (a, b) {
        if (this.readyState != Xh) throw (this.abort(), Error('Error reopening a connection'));
        this.s = a;
        this.f = b;
        this.readyState = 1;
        Yh(this);
      };
      k.send = function (a) {
        if (1 != this.readyState) throw (this.abort(), Error('need to call open() first. '));
        this.a = !0;
        var b = { headers: this.l, method: this.s, credentials: this.h, cache: void 0 };
        a && (b.body = a);
        this.u.fetch(new Request(this.f, b)).then(this.uc.bind(this), this.Va.bind(this));
      };
      k.abort = function () {
        this.response = this.responseText = '';
        this.l = new Headers();
        this.status = 0;
        this.c && this.c.cancel('Request was aborted.');
        1 <= this.readyState && this.a && 4 != this.readyState && ((this.a = !1), Zh(this));
        this.readyState = Xh;
      };
      k.uc = function (a) {
        this.a &&
          ((this.g = a),
          this.b || ((this.status = this.g.status), (this.statusText = this.g.statusText), (this.b = a.headers), (this.readyState = 2), Yh(this)),
          this.a &&
            ((this.readyState = 3),
            Yh(this),
            this.a &&
              ('arraybuffer' === this.responseType
                ? a.arrayBuffer().then(this.sc.bind(this), this.Va.bind(this))
                : 'undefined' !== typeof l.ReadableStream && 'body' in a
                ? ((this.response = this.responseText = ''), (this.c = a.body.getReader()), (this.m = new TextDecoder()), $h(this))
                : a.text().then(this.tc.bind(this), this.Va.bind(this)))));
      };
      function $h(a) {
        a.c.read().then(a.pc.bind(a)).catch(a.Va.bind(a));
      }
      k.pc = function (a) {
        if (this.a) {
          var b = this.m.decode(a.value ? a.value : new Uint8Array(0), { stream: !a.done });
          b && (this.response = this.responseText += b);
          a.done ? Zh(this) : Yh(this);
          3 == this.readyState && $h(this);
        }
      };
      k.tc = function (a) {
        this.a && ((this.response = this.responseText = a), Zh(this));
      };
      k.sc = function (a) {
        this.a && ((this.response = a), Zh(this));
      };
      k.Va = function (a) {
        var b = this.i;
        b && b.log(Nh, 'Failed to fetch url ' + this.f, a instanceof Error ? a : Error(a));
        this.a && Zh(this);
      };
      function Zh(a) {
        a.readyState = 4;
        a.g = null;
        a.c = null;
        a.m = null;
        Yh(a);
      }
      k.setRequestHeader = function (a, b) {
        this.l.append(a, b);
      };
      k.getResponseHeader = function (a) {
        return this.b
          ? this.b.get(a.toLowerCase()) || ''
          : ((a = this.i) && a.log(Nh, 'Attempting to get response header but no headers have been received for url: ' + this.f, void 0), '');
      };
      k.getAllResponseHeaders = function () {
        if (!this.b) {
          var a = this.i;
          a && a.log(Nh, 'Attempting to get all response headers but no headers have been received for url: ' + this.f, void 0);
          return '';
        }
        a = [];
        for (var b = this.b.entries(), c = b.next(); !c.done; ) (c = c.value), a.push(c[0] + ': ' + c[1]), (c = b.next());
        return a.join('\r\n');
      };
      function Yh(a) {
        a.onreadystatechange && a.onreadystatechange.call(a);
      }
      Object.defineProperty(Wh.prototype, 'withCredentials', {
        get: function () {
          return 'include' === this.h;
        },
        set: function (a) {
          this.h = a ? 'include' : 'same-origin';
        },
      });
      function ai(a) {
        H.call(this);
        this.headers = new Jd();
        this.D = a || null;
        this.c = !1;
        this.C = this.a = null;
        this.h = this.P = this.l = '';
        this.f = this.N = this.i = this.J = !1;
        this.g = 0;
        this.s = null;
        this.m = bi;
        this.u = this.S = !1;
      }
      r(ai, H);
      var bi = '';
      ai.prototype.b = Th('goog.net.XhrIo');
      var ci = /^https?$/i,
        di = ['POST', 'PUT'];
      function ei(a, b, c, d, e) {
        if (a.a) throw Error('[goog.net.XhrIo] Object is active with another request=' + a.l + '; newUri=' + b);
        c = c ? c.toUpperCase() : 'GET';
        a.l = b;
        a.h = '';
        a.P = c;
        a.J = !1;
        a.c = !0;
        a.a = a.D ? a.D.a() : Ch.a();
        a.C = a.D ? Bh(a.D) : Bh(Ch);
        a.a.onreadystatechange = q(a.Wb, a);
        try {
          Uh(a.b, fi(a, 'Opening Xhr')), (a.N = !0), a.a.open(c, String(b), !0), (a.N = !1);
        } catch (g) {
          Uh(a.b, fi(a, 'Error opening Xhr: ' + g.message));
          gi(a, g);
          return;
        }
        b = d || '';
        var f = new Jd(a.headers);
        e &&
          Id(e, function (g, h) {
            f.set(h, g);
          });
        e = Ta(f.Y());
        d = l.FormData && b instanceof l.FormData;
        !Va(di, c) || e || d || f.set('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8');
        f.forEach(function (g, h) {
          this.a.setRequestHeader(h, g);
        }, a);
        a.m && (a.a.responseType = a.m);
        'withCredentials' in a.a && a.a.withCredentials !== a.S && (a.a.withCredentials = a.S);
        try {
          hi(a),
            0 < a.g &&
              ((a.u = ii(a.a)),
              Uh(a.b, fi(a, 'Will abort after ' + a.g + 'ms if incomplete, xhr2 ' + a.u)),
              a.u ? ((a.a.timeout = a.g), (a.a.ontimeout = q(a.Ma, a))) : (a.s = Ed(a.Ma, a.g, a))),
            Uh(a.b, fi(a, 'Sending request')),
            (a.i = !0),
            a.a.send(b),
            (a.i = !1);
        } catch (g) {
          Uh(a.b, fi(a, 'Send error: ' + g.message)), gi(a, g);
        }
      }
      function ii(a) {
        return Wb && fc(9) && 'number' === typeof a.timeout && void 0 !== a.ontimeout;
      }
      function Ua(a) {
        return 'content-type' == a.toLowerCase();
      }
      k = ai.prototype;
      k.Ma = function () {
        'undefined' != typeof ha && this.a && ((this.h = 'Timed out after ' + this.g + 'ms, aborting'), Uh(this.b, fi(this, this.h)), this.dispatchEvent('timeout'), this.abort(8));
      };
      function gi(a, b) {
        a.c = !1;
        a.a && ((a.f = !0), a.a.abort(), (a.f = !1));
        a.h = b;
        ji(a);
        ki(a);
      }
      function ji(a) {
        a.J || ((a.J = !0), a.dispatchEvent('complete'), a.dispatchEvent('error'));
      }
      k.abort = function () {
        this.a &&
          this.c &&
          (Uh(this.b, fi(this, 'Aborting')), (this.c = !1), (this.f = !0), this.a.abort(), (this.f = !1), this.dispatchEvent('complete'), this.dispatchEvent('abort'), ki(this));
      };
      k.Da = function () {
        this.a && (this.c && ((this.c = !1), (this.f = !0), this.a.abort(), (this.f = !1)), ki(this, !0));
        ai.bb.Da.call(this);
      };
      k.Wb = function () {
        this.ya || (this.N || this.i || this.f ? li(this) : this.Jc());
      };
      k.Jc = function () {
        li(this);
      };
      function li(a) {
        if (a.c && 'undefined' != typeof ha)
          if (a.C[1] && 4 == mi(a) && 2 == ni(a)) Uh(a.b, fi(a, 'Local request error detected and ignored'));
          else if (a.i && 4 == mi(a)) Ed(a.Wb, 0, a);
          else if ((a.dispatchEvent('readystatechange'), 4 == mi(a))) {
            Uh(a.b, fi(a, 'Request complete'));
            a.c = !1;
            try {
              var b = ni(a);
              a: switch (b) {
                case 200:
                case 201:
                case 202:
                case 204:
                case 206:
                case 304:
                case 1223:
                  var c = !0;
                  break a;
                default:
                  c = !1;
              }
              var d;
              if (!(d = c)) {
                var e;
                if ((e = 0 === b)) {
                  var f = String(a.l).match(Md)[1] || null;
                  if (!f && l.self && l.self.location) {
                    var g = l.self.location.protocol;
                    f = g.substr(0, g.length - 1);
                  }
                  e = !ci.test(f ? f.toLowerCase() : '');
                }
                d = e;
              }
              if (d) a.dispatchEvent('complete'), a.dispatchEvent('success');
              else {
                try {
                  var h = 2 < mi(a) ? a.a.statusText : '';
                } catch (m) {
                  Uh(a.b, 'Can not get status: ' + m.message), (h = '');
                }
                a.h = h + ' [' + ni(a) + ']';
                ji(a);
              }
            } finally {
              ki(a);
            }
          }
      }
      function ki(a, b) {
        if (a.a) {
          hi(a);
          var c = a.a,
            d = a.C[0] ? la : null;
          a.a = null;
          a.C = null;
          b || a.dispatchEvent('ready');
          try {
            c.onreadystatechange = d;
          } catch (e) {
            (a = a.b) && a.log(Mh, 'Problem encountered resetting onreadystatechange: ' + e.message, void 0);
          }
        }
      }
      function hi(a) {
        a.a && a.u && (a.a.ontimeout = null);
        a.s && (l.clearTimeout(a.s), (a.s = null));
      }
      function mi(a) {
        return a.a ? a.a.readyState : 0;
      }
      function ni(a) {
        try {
          return 2 < mi(a) ? a.a.status : -1;
        } catch (b) {
          return -1;
        }
      }
      function oi(a) {
        try {
          return a.a ? a.a.responseText : '';
        } catch (b) {
          return Uh(a.b, 'Can not get responseText: ' + b.message), '';
        }
      }
      k.getResponse = function () {
        try {
          if (!this.a) return null;
          if ('response' in this.a) return this.a.response;
          switch (this.m) {
            case bi:
            case 'text':
              return this.a.responseText;
            case 'arraybuffer':
              if ('mozResponseArrayBuffer' in this.a) return this.a.mozResponseArrayBuffer;
          }
          var a = this.b;
          a && a.log(Mh, 'Response type ' + this.m + ' is not supported on this browser', void 0);
          return null;
        } catch (b) {
          return Uh(this.b, 'Can not get response: ' + b.message), null;
        }
      };
      function fi(a, b) {
        return b + ' [' + a.P + ' ' + a.l + ' ' + ni(a) + ']';
      }
      function pi(a) {
        var b = qi;
        this.g = [];
        this.u = b;
        this.s = a || null;
        this.f = this.a = !1;
        this.c = void 0;
        this.v = this.C = this.i = !1;
        this.h = 0;
        this.b = null;
        this.l = 0;
      }
      pi.prototype.cancel = function (a) {
        if (this.a) this.c instanceof pi && this.c.cancel();
        else {
          if (this.b) {
            var b = this.b;
            delete this.b;
            a ? b.cancel(a) : (b.l--, 0 >= b.l && b.cancel());
          }
          this.u ? this.u.call(this.s, this) : (this.v = !0);
          this.a || ((a = new ri(this)), si(this), ti(this, !1, a));
        }
      };
      pi.prototype.m = function (a, b) {
        this.i = !1;
        ti(this, a, b);
      };
      function ti(a, b, c) {
        a.a = !0;
        a.c = c;
        a.f = !b;
        ui(a);
      }
      function si(a) {
        if (a.a) {
          if (!a.v) throw new vi(a);
          a.v = !1;
        }
      }
      function wi(a, b) {
        xi(a, null, b, void 0);
      }
      function xi(a, b, c, d) {
        a.g.push([b, c, d]);
        a.a && ui(a);
      }
      pi.prototype.then = function (a, b, c) {
        var d,
          e,
          f = new D(function (g, h) {
            d = g;
            e = h;
          });
        xi(this, d, function (g) {
          g instanceof ri ? f.cancel() : e(g);
        });
        return f.then(a, b, c);
      };
      pi.prototype.$goog_Thenable = !0;
      function yi(a) {
        return Sa(a.g, function (b) {
          return oa(b[1]);
        });
      }
      function ui(a) {
        if (a.h && a.a && yi(a)) {
          var b = a.h,
            c = zi[b];
          c && (l.clearTimeout(c.a), delete zi[b]);
          a.h = 0;
        }
        a.b && (a.b.l--, delete a.b);
        b = a.c;
        for (var d = (c = !1); a.g.length && !a.i; ) {
          var e = a.g.shift(),
            f = e[0],
            g = e[1];
          e = e[2];
          if ((f = a.f ? g : f))
            try {
              var h = f.call(e || a.s, b);
              void 0 !== h && ((a.f = a.f && (h == b || h instanceof Error)), (a.c = b = h));
              if (Ea(b) || ('function' === typeof l.Promise && b instanceof l.Promise)) (d = !0), (a.i = !0);
            } catch (m) {
              (b = m), (a.f = !0), yi(a) || (c = !0);
            }
        }
        a.c = b;
        d && ((h = q(a.m, a, !0)), (d = q(a.m, a, !1)), b instanceof pi ? (xi(b, h, d), (b.C = !0)) : b.then(h, d));
        c && ((b = new Ai(b)), (zi[b.a] = b), (a.h = b.a));
      }
      function vi() {
        u.call(this);
      }
      r(vi, u);
      vi.prototype.message = 'Deferred has already fired';
      vi.prototype.name = 'AlreadyCalledError';
      function ri() {
        u.call(this);
      }
      r(ri, u);
      ri.prototype.message = 'Deferred was canceled';
      ri.prototype.name = 'CanceledError';
      function Ai(a) {
        this.a = l.setTimeout(q(this.c, this), 0);
        this.b = a;
      }
      Ai.prototype.c = function () {
        delete zi[this.a];
        throw this.b;
      };
      var zi = {};
      function Bi(a) {
        var c = document,
          d = yb(a).toString(),
          e = oc(document, 'SCRIPT'),
          f = { Xb: e, Ma: void 0 },
          g = new pi(f),
          h = null,
          m = 5e3;
        (h = window.setTimeout(function () {
          Ci(e, !0);
          var p = new Di(Ei, 'Timeout reached for loading script ' + d);
          si(g);
          ti(g, !1, p);
        }, m)),
          (f.Ma = h);
        e.onload = e.onreadystatechange = function () {
          (e.readyState && 'loaded' != e.readyState && 'complete' != e.readyState) || (Ci(e, !1, h), si(g), ti(g, !0, null));
        };
        e.onerror = function () {
          Ci(e, !0, h);
          var p = new Di(Fi, 'Error while loading script ' + d);
          si(g);
          ti(g, !1, p);
        };
        f = {};
        z(f, { type: 'text/javascript', charset: 'UTF-8' });
        lc(e, f);
        Ob(e, a);
        Gi(c).appendChild(e);
        return g;
      }
      function Gi(a) {
        var b;
        return (b = (a || document).getElementsByTagName('HEAD')) && 0 != b.length ? b[0] : a.documentElement;
      }
      function qi() {
        if (this && this.Xb) {
          var a = this.Xb;
          a && 'SCRIPT' == a.tagName && Ci(a, !0, this.Ma);
        }
      }
      function Ci(a, b, c) {
        null != c && l.clearTimeout(c);
        a.onload = la;
        a.onerror = la;
        a.onreadystatechange = la;
        b &&
          window.setTimeout(function () {
            a && a.parentNode && a.parentNode.removeChild(a);
          }, 0);
      }
      var Fi = 0,
        Ei = 1;
      function Di(a, b) {
        var c = 'Jsloader error (code #' + a + ')';
        b && (c += ': ' + b);
        u.call(this, c);
        this.code = a;
      }
      r(Di, u);
      function Hi(a) {
        this.f = a;
      }
      r(Hi, Ah);
      Hi.prototype.a = function () {
        return new this.f();
      };
      Hi.prototype.b = function () {
        return {};
      };
      function Ii(a, b, c) {
        this.c = a;
        a = b || {};
        this.l = a.secureTokenEndpoint || 'https://securetoken.googleapis.com/v1/token';
        this.m = a.secureTokenTimeout || Ji;
        this.g = nb(a.secureTokenHeaders || Ki);
        this.h = a.firebaseEndpoint || 'https://www.googleapis.com/identitytoolkit/v3/relyingparty/';
        this.i = a.identityPlatformEndpoint || 'https://identitytoolkit.googleapis.com/v2/';
        this.v = a.firebaseTimeout || Li;
        this.a = nb(a.firebaseHeaders || Mi);
        c && ((this.a['X-Client-Version'] = c), (this.g['X-Client-Version'] = c));
        c = 'Node' == Ke();
        c = l.XMLHttpRequest || (c && firebase.INTERNAL.node && firebase.INTERNAL.node.XMLHttpRequest);
        if (!c && !Je()) throw new t('internal-error', 'The XMLHttpRequest compatibility library was not found.');
        this.f = void 0;
        Je() ? (this.f = new Vh(self)) : Le() ? (this.f = new Hi(c)) : (this.f = new Fh());
        this.b = null;
      }
      var Ni,
        Dg = 'idToken',
        Ji = new Ze(3e4, 6e4),
        Ki = { 'Content-Type': 'application/x-www-form-urlencoded' },
        Li = new Ze(3e4, 6e4),
        Mi = { 'Content-Type': 'application/json' };
      function Oi(a, b) {
        b ? (a.a['X-Firebase-Locale'] = b) : delete a.a['X-Firebase-Locale'];
      }
      function Pi(a, b) {
        b &&
          ((a.l = Qi('https://securetoken.googleapis.com/v1/token', b)),
          (a.h = Qi('https://www.googleapis.com/identitytoolkit/v3/relyingparty/', b)),
          (a.i = Qi('https://identitytoolkit.googleapis.com/v2/', b)));
      }
      function Qi(a, b) {
        a = J(a);
        b = J(b.url);
        a.f = a.a + a.f;
        Pd(a, b.c);
        a.a = b.a;
        Qd(a, b.g);
        return a.toString();
      }
      function Ri(a, b) {
        b ? ((a.a['X-Client-Version'] = b), (a.g['X-Client-Version'] = b)) : (delete a.a['X-Client-Version'], delete a.g['X-Client-Version']);
      }
      Ii.prototype.T = function () {
        return this.b;
      };
      function Si(a, b, c, d, e, f, g) {
        ue() || Je()
          ? (a = q(a.u, a))
          : (Ni ||
              (Ni = new D(function (h, m) {
                Ti(h, m);
              })),
            (a = q(a.s, a)));
        a(b, c, d, e, f, g);
      }
      Ii.prototype.u = function (a, b, c, d, e, f) {
        if (Je() && ('undefined' === typeof l.fetch || 'undefined' === typeof l.Headers || 'undefined' === typeof l.Request))
          throw new t(
            'operation-not-supported-in-this-environment',
            'fetch, Headers and Request native APIs or equivalent Polyfills must be available to support HTTP requests from a Worker environment.',
          );
        var g = new ai(this.f);
        if (f) {
          g.g = Math.max(0, f);
          var h = setTimeout(function () {
            g.dispatchEvent('timeout');
          }, f);
        }
        qd(g, 'complete', function () {
          h && clearTimeout(h);
          var m = null;
          try {
            m = JSON.parse(oi(this)) || null;
          } catch (p) {
            m = null;
          }
          b && b(m);
        });
        wd(g, 'ready', function () {
          h && clearTimeout(h);
          Xc(this);
        });
        wd(g, 'timeout', function () {
          h && clearTimeout(h);
          Xc(this);
          b && b(null);
        });
        ei(g, a, c, d, e);
      };
      var Ui = new qb(rb, 'https://apis.google.com/js/client.js?onload=%{onload}'),
        Vi = '__fcb' + Math.floor(1e6 * Math.random()).toString();
      function Ti(a, b) {
        if (((window.gapi || {}).client || {}).request) a();
        else {
          l[Vi] = function () {
            ((window.gapi || {}).client || {}).request ? a() : b(Error('CORS_UNSUPPORTED'));
          };
          var c = zb(Ui, { onload: Vi });
          wi(Bi(c), function () {
            b(Error('CORS_UNSUPPORTED'));
          });
        }
      }
      Ii.prototype.s = function (a, b, c, d, e) {
        var f = this;
        Ni.then(function () {
          window.gapi.client.setApiKey(f.c);
          var g = window.gapi.auth.getToken();
          window.gapi.auth.setToken(null);
          window.gapi.client.request({
            path: a,
            method: c,
            body: d,
            headers: e,
            authType: 'none',
            callback: function (h) {
              window.gapi.auth.setToken(g);
              b && b(h);
            },
          });
        }).o(function (g) {
          b && b({ error: { message: (g && g.message) || 'CORS_UNSUPPORTED' } });
        });
      };
      function Wi(a, b) {
        return new D(function (c, d) {
          ('refresh_token' == b.grant_type && b.refresh_token) || ('authorization_code' == b.grant_type && b.code)
            ? Si(
                a,
                a.l + '?key=' + encodeURIComponent(a.c),
                function (e) {
                  e ? (e.error ? d(Xi(e)) : e.access_token && e.refresh_token ? c(e) : d(new t('internal-error'))) : d(new t('network-request-failed'));
                },
                'POST',
                fe(b).toString(),
                a.g,
                a.m.get(),
              )
            : d(new t('internal-error'));
        });
      }
      function Yi(a, b, c, d, e, f, g) {
        var h = J(b + c);
        I(h, 'key', a.c);
        g && I(h, 'cb', Date.now().toString());
        var m = 'GET' == d;
        if (m) for (var p in e) e.hasOwnProperty(p) && I(h, p, e[p]);
        return new D(function (v, B) {
          Si(
            a,
            h.toString(),
            function (A) {
              A ? (A.error ? B(Xi(A, f || {})) : v(A)) : B(new t('network-request-failed'));
            },
            d,
            m ? void 0 : ke(Ve(e)),
            a.a,
            a.v.get(),
          );
        });
      }
      function Zi(a) {
        a = a.email;
        if ('string' !== typeof a || !De.test(a)) throw new t('invalid-email');
      }
      function $i(a) {
        'email' in a && Zi(a);
      }
      function aj(a, b) {
        return O(a, bj, { identifier: b, continueUri: Se() ? re() : 'http://localhost' }).then(function (c) {
          return c.signinMethods || [];
        });
      }
      function cj(a) {
        return O(a, dj, {}).then(function (b) {
          return b.authorizedDomains || [];
        });
      }
      function P(a) {
        if (!a[Dg]) {
          if (a.mfaPendingCredential) throw new t('multi-factor-auth-required', null, nb(a));
          throw new t('internal-error');
        }
      }
      function ej(a) {
        if (a.phoneNumber || a.temporaryProof) {
          if (!a.phoneNumber || !a.temporaryProof) throw new t('internal-error');
        } else {
          if (!a.sessionInfo) throw new t('missing-verification-id');
          if (!a.code) throw new t('missing-verification-code');
        }
      }
      Ii.prototype.Ab = function () {
        return O(this, fj, {});
      };
      Ii.prototype.Cb = function (a, b) {
        return O(this, gj, { idToken: a, email: b });
      };
      Ii.prototype.Db = function (a, b) {
        return O(this, ch, { idToken: a, password: b });
      };
      var hj = { displayName: 'DISPLAY_NAME', photoUrl: 'PHOTO_URL' };
      k = Ii.prototype;
      k.Eb = function (a, b) {
        var c = { idToken: a },
          d = [];
        lb(hj, function (e, f) {
          var g = b[f];
          null === g ? d.push(e) : f in b && (c[f] = g);
        });
        d.length && (c.deleteAttribute = d);
        return O(this, gj, c);
      };
      k.wb = function (a, b) {
        a = { requestType: 'PASSWORD_RESET', email: a };
        z(a, b);
        return O(this, ij, a);
      };
      k.xb = function (a, b) {
        a = { requestType: 'EMAIL_SIGNIN', email: a };
        z(a, b);
        return O(this, jj, a);
      };
      k.vb = function (a, b) {
        a = { requestType: 'VERIFY_EMAIL', idToken: a };
        z(a, b);
        return O(this, kj, a);
      };
      k.Fb = function (a, b, c) {
        a = { requestType: 'VERIFY_AND_CHANGE_EMAIL', idToken: a, newEmail: b };
        z(a, c);
        return O(this, lj, a);
      };
      function oh(a, b) {
        return O(a, mj, b);
      }
      k.gb = function (a) {
        return O(this, nj, a);
      };
      function mh(a, b) {
        return O(a, oj, b).then(function (c) {
          return c.phoneSessionInfo.sessionInfo;
        });
      }
      function pj(a) {
        if (!a.phoneVerificationInfo) throw new t('internal-error');
        if (!a.phoneVerificationInfo.sessionInfo) throw new t('missing-verification-id');
        if (!a.phoneVerificationInfo.code) throw new t('missing-verification-code');
      }
      function nh(a, b) {
        return O(a, qj, b).then(function (c) {
          return c.phoneResponseInfo.sessionInfo;
        });
      }
      function rj(a, b, c) {
        return O(a, sj, { idToken: b, deleteProvider: c });
      }
      function tj(a) {
        if (!a.requestUri || (!a.sessionId && !a.postBody && !a.pendingToken)) throw new t('internal-error');
      }
      function uj(a, b) {
        b.oauthIdToken &&
          b.providerId &&
          0 == b.providerId.indexOf('oidc.') &&
          !b.pendingToken &&
          (a.sessionId ? (b.nonce = a.sessionId) : a.postBody && ((a = new Ud(a.postBody)), je(a, 'nonce') && (b.nonce = a.get('nonce'))));
        return b;
      }
      function vj(a) {
        var b = null;
        a.needConfirmation
          ? ((a.code = 'account-exists-with-different-credential'), (b = zh(a)))
          : 'FEDERATED_USER_ID_ALREADY_LINKED' == a.errorMessage
          ? ((a.code = 'credential-already-in-use'), (b = zh(a)))
          : 'EMAIL_EXISTS' == a.errorMessage
          ? ((a.code = 'email-already-in-use'), (b = zh(a)))
          : a.errorMessage && (b = wj(a.errorMessage));
        if (b) throw b;
        P(a);
      }
      function Fg(a, b) {
        b.returnIdpCredential = !0;
        return O(a, xj, b);
      }
      function Hg(a, b) {
        b.returnIdpCredential = !0;
        return O(a, yj, b);
      }
      function Ig(a, b) {
        b.returnIdpCredential = !0;
        b.autoCreate = !1;
        return O(a, zj, b);
      }
      function Aj(a) {
        if (!a.oobCode) throw new t('invalid-action-code');
      }
      k.ob = function (a, b) {
        return O(this, Bj, { oobCode: a, newPassword: b });
      };
      k.Sa = function (a) {
        return O(this, Cj, { oobCode: a });
      };
      k.kb = function (a) {
        return O(this, Dj, { oobCode: a });
      };
      var Dj = { endpoint: 'setAccountInfo', A: Aj, Z: 'email', B: !0 },
        Cj = {
          endpoint: 'resetPassword',
          A: Aj,
          G: function (a) {
            var b = a.requestType;
            if (!b || (!a.email && 'EMAIL_SIGNIN' != b && 'VERIFY_AND_CHANGE_EMAIL' != b)) throw new t('internal-error');
          },
          B: !0,
        },
        Ej = {
          endpoint: 'signupNewUser',
          A: function (a) {
            Zi(a);
            if (!a.password) throw new t('weak-password');
          },
          G: P,
          V: !0,
          B: !0,
        },
        bj = { endpoint: 'createAuthUri', B: !0 },
        Fj = { endpoint: 'deleteAccount', O: ['idToken'] },
        sj = {
          endpoint: 'setAccountInfo',
          O: ['idToken', 'deleteProvider'],
          A: function (a) {
            if (!Array.isArray(a.deleteProvider)) throw new t('internal-error');
          },
        },
        $g = { endpoint: 'emailLinkSignin', O: ['email', 'oobCode'], A: Zi, G: P, V: !0, B: !0 },
        bh = { endpoint: 'emailLinkSignin', O: ['idToken', 'email', 'oobCode'], A: Zi, G: P, V: !0 },
        Gj = { endpoint: 'accounts/mfaEnrollment:finalize', O: ['idToken', 'phoneVerificationInfo'], A: pj, G: P, B: !0, Na: !0 },
        Hj = { endpoint: 'accounts/mfaSignIn:finalize', O: ['mfaPendingCredential', 'phoneVerificationInfo'], A: pj, G: P, B: !0, Na: !0 },
        Ij = { endpoint: 'getAccountInfo' },
        jj = {
          endpoint: 'getOobConfirmationCode',
          O: ['requestType'],
          A: function (a) {
            if ('EMAIL_SIGNIN' != a.requestType) throw new t('internal-error');
            Zi(a);
          },
          Z: 'email',
          B: !0,
        },
        kj = {
          endpoint: 'getOobConfirmationCode',
          O: ['idToken', 'requestType'],
          A: function (a) {
            if ('VERIFY_EMAIL' != a.requestType) throw new t('internal-error');
          },
          Z: 'email',
          B: !0,
        },
        lj = {
          endpoint: 'getOobConfirmationCode',
          O: ['idToken', 'newEmail', 'requestType'],
          A: function (a) {
            if ('VERIFY_AND_CHANGE_EMAIL' != a.requestType) throw new t('internal-error');
          },
          Z: 'email',
          B: !0,
        },
        ij = {
          endpoint: 'getOobConfirmationCode',
          O: ['requestType'],
          A: function (a) {
            if ('PASSWORD_RESET' != a.requestType) throw new t('internal-error');
            Zi(a);
          },
          Z: 'email',
          B: !0,
        },
        dj = { mb: !0, endpoint: 'getProjectConfig', Vb: 'GET' },
        Jj = {
          mb: !0,
          endpoint: 'getRecaptchaParam',
          Vb: 'GET',
          G: function (a) {
            if (!a.recaptchaSiteKey) throw new t('internal-error');
          },
        },
        Bj = { endpoint: 'resetPassword', A: Aj, Z: 'email', B: !0 },
        mj = { endpoint: 'sendVerificationCode', O: ['phoneNumber', 'recaptchaToken'], Z: 'sessionInfo', B: !0 },
        gj = { endpoint: 'setAccountInfo', O: ['idToken'], A: $i, V: !0 },
        ch = {
          endpoint: 'setAccountInfo',
          O: ['idToken'],
          A: function (a) {
            $i(a);
            if (!a.password) throw new t('weak-password');
          },
          G: P,
          V: !0,
        },
        fj = { endpoint: 'signupNewUser', G: P, V: !0, B: !0 },
        oj = {
          endpoint: 'accounts/mfaEnrollment:start',
          O: ['idToken', 'phoneEnrollmentInfo'],
          A: function (a) {
            if (!a.phoneEnrollmentInfo) throw new t('internal-error');
            if (!a.phoneEnrollmentInfo.phoneNumber) throw new t('missing-phone-number');
            if (!a.phoneEnrollmentInfo.recaptchaToken) throw new t('missing-app-credential');
          },
          G: function (a) {
            if (!a.phoneSessionInfo || !a.phoneSessionInfo.sessionInfo) throw new t('internal-error');
          },
          B: !0,
          Na: !0,
        },
        qj = {
          endpoint: 'accounts/mfaSignIn:start',
          O: ['mfaPendingCredential', 'mfaEnrollmentId', 'phoneSignInInfo'],
          A: function (a) {
            if (!a.phoneSignInInfo || !a.phoneSignInInfo.recaptchaToken) throw new t('missing-app-credential');
          },
          G: function (a) {
            if (!a.phoneResponseInfo || !a.phoneResponseInfo.sessionInfo) throw new t('internal-error');
          },
          B: !0,
          Na: !0,
        },
        xj = { endpoint: 'verifyAssertion', A: tj, Za: uj, G: vj, V: !0, B: !0 },
        zj = {
          endpoint: 'verifyAssertion',
          A: tj,
          Za: uj,
          G: function (a) {
            if (a.errorMessage && 'USER_NOT_FOUND' == a.errorMessage) throw new t('user-not-found');
            if (a.errorMessage) throw wj(a.errorMessage);
            P(a);
          },
          V: !0,
          B: !0,
        },
        yj = {
          endpoint: 'verifyAssertion',
          A: function (a) {
            tj(a);
            if (!a.idToken) throw new t('internal-error');
          },
          Za: uj,
          G: vj,
          V: !0,
        },
        Kj = {
          endpoint: 'verifyCustomToken',
          A: function (a) {
            if (!a.token) throw new t('invalid-custom-token');
          },
          G: P,
          V: !0,
          B: !0,
        },
        ah = {
          endpoint: 'verifyPassword',
          A: function (a) {
            Zi(a);
            if (!a.password) throw new t('wrong-password');
          },
          G: P,
          V: !0,
          B: !0,
        },
        nj = { endpoint: 'verifyPhoneNumber', A: ej, G: P, B: !0 },
        ih = {
          endpoint: 'verifyPhoneNumber',
          A: function (a) {
            if (!a.idToken) throw new t('internal-error');
            ej(a);
          },
          G: function (a) {
            if (a.temporaryProof) throw ((a.code = 'credential-already-in-use'), zh(a));
            P(a);
          },
        },
        jh = { Ib: { USER_NOT_FOUND: 'user-not-found' }, endpoint: 'verifyPhoneNumber', A: ej, G: P, B: !0 },
        Lj = {
          endpoint: 'accounts/mfaEnrollment:withdraw',
          O: ['idToken', 'mfaEnrollmentId'],
          G: function (a) {
            if (!!a[Dg] ^ !!a.refreshToken) throw new t('internal-error');
          },
          B: !0,
          Na: !0,
        };
      function O(a, b, c) {
        if (!mf(c, b.O)) return F(new t('internal-error'));
        var d = !!b.Na,
          e = b.Vb || 'POST',
          f;
        return E(c)
          .then(b.A)
          .then(function () {
            b.V && (c.returnSecureToken = !0);
            b.B && a.b && 'undefined' === typeof c.tenantId && (c.tenantId = a.b);
            return d ? Yi(a, a.i, b.endpoint, e, c, b.Ib, b.mb || !1) : Yi(a, a.h, b.endpoint, e, c, b.Ib, b.mb || !1);
          })
          .then(function (g) {
            f = g;
            return b.Za ? b.Za(c, f) : f;
          })
          .then(b.G)
          .then(function () {
            if (!b.Z) return f;
            if (!(b.Z in f)) throw new t('internal-error');
            return f[b.Z];
          });
      }
      function wj(a) {
        return Xi({ error: { errors: [{ message: a }], code: 400, message: a } });
      }
      function Xi(a, b) {
        var c = ((a.error && a.error.errors && a.error.errors[0]) || {}).reason || '';
        var d = { keyInvalid: 'invalid-api-key', ipRefererBlocked: 'app-not-authorized' };
        if ((c = d[c] ? new t(d[c]) : null)) return c;
        c = (a.error && a.error.message) || '';
        d = {
          INVALID_CUSTOM_TOKEN: 'invalid-custom-token',
          CREDENTIAL_MISMATCH: 'custom-token-mismatch',
          MISSING_CUSTOM_TOKEN: 'internal-error',
          INVALID_IDENTIFIER: 'invalid-email',
          MISSING_CONTINUE_URI: 'internal-error',
          INVALID_EMAIL: 'invalid-email',
          INVALID_PASSWORD: 'wrong-password',
          USER_DISABLED: 'user-disabled',
          MISSING_PASSWORD: 'internal-error',
          EMAIL_EXISTS: 'email-already-in-use',
          PASSWORD_LOGIN_DISABLED: 'operation-not-allowed',
          INVALID_IDP_RESPONSE: 'invalid-credential',
          INVALID_PENDING_TOKEN: 'invalid-credential',
          FEDERATED_USER_ID_ALREADY_LINKED: 'credential-already-in-use',
          MISSING_OR_INVALID_NONCE: 'missing-or-invalid-nonce',
          INVALID_MESSAGE_PAYLOAD: 'invalid-message-payload',
          INVALID_RECIPIENT_EMAIL: 'invalid-recipient-email',
          INVALID_SENDER: 'invalid-sender',
          EMAIL_NOT_FOUND: 'user-not-found',
          RESET_PASSWORD_EXCEED_LIMIT: 'too-many-requests',
          EXPIRED_OOB_CODE: 'expired-action-code',
          INVALID_OOB_CODE: 'invalid-action-code',
          MISSING_OOB_CODE: 'internal-error',
          INVALID_PROVIDER_ID: 'invalid-provider-id',
          CREDENTIAL_TOO_OLD_LOGIN_AGAIN: 'requires-recent-login',
          INVALID_ID_TOKEN: 'invalid-user-token',
          TOKEN_EXPIRED: 'user-token-expired',
          USER_NOT_FOUND: 'user-token-expired',
          CORS_UNSUPPORTED: 'cors-unsupported',
          DYNAMIC_LINK_NOT_ACTIVATED: 'dynamic-link-not-activated',
          INVALID_APP_ID: 'invalid-app-id',
          TOO_MANY_ATTEMPTS_TRY_LATER: 'too-many-requests',
          WEAK_PASSWORD: 'weak-password',
          OPERATION_NOT_ALLOWED: 'operation-not-allowed',
          USER_CANCELLED: 'user-cancelled',
          CAPTCHA_CHECK_FAILED: 'captcha-check-failed',
          INVALID_APP_CREDENTIAL: 'invalid-app-credential',
          INVALID_CODE: 'invalid-verification-code',
          INVALID_PHONE_NUMBER: 'invalid-phone-number',
          INVALID_SESSION_INFO: 'invalid-verification-id',
          INVALID_TEMPORARY_PROOF: 'invalid-credential',
          MISSING_APP_CREDENTIAL: 'missing-app-credential',
          MISSING_CODE: 'missing-verification-code',
          MISSING_PHONE_NUMBER: 'missing-phone-number',
          MISSING_SESSION_INFO: 'missing-verification-id',
          QUOTA_EXCEEDED: 'quota-exceeded',
          SESSION_EXPIRED: 'code-expired',
          REJECTED_CREDENTIAL: 'rejected-credential',
          INVALID_CONTINUE_URI: 'invalid-continue-uri',
          MISSING_ANDROID_PACKAGE_NAME: 'missing-android-pkg-name',
          MISSING_IOS_BUNDLE_ID: 'missing-ios-bundle-id',
          UNAUTHORIZED_DOMAIN: 'unauthorized-continue-uri',
          INVALID_DYNAMIC_LINK_DOMAIN: 'invalid-dynamic-link-domain',
          INVALID_OAUTH_CLIENT_ID: 'invalid-oauth-client-id',
          INVALID_CERT_HASH: 'invalid-cert-hash',
          UNSUPPORTED_TENANT_OPERATION: 'unsupported-tenant-operation',
          INVALID_TENANT_ID: 'invalid-tenant-id',
          TENANT_ID_MISMATCH: 'tenant-id-mismatch',
          ADMIN_ONLY_OPERATION: 'admin-restricted-operation',
          INVALID_MFA_PENDING_CREDENTIAL: 'invalid-multi-factor-session',
          MFA_ENROLLMENT_NOT_FOUND: 'multi-factor-info-not-found',
          MISSING_MFA_PENDING_CREDENTIAL: 'missing-multi-factor-session',
          MISSING_MFA_ENROLLMENT_ID: 'missing-multi-factor-info',
          EMAIL_CHANGE_NEEDS_VERIFICATION: 'email-change-needs-verification',
          SECOND_FACTOR_EXISTS: 'second-factor-already-in-use',
          SECOND_FACTOR_LIMIT_EXCEEDED: 'maximum-second-factor-count-exceeded',
          UNSUPPORTED_FIRST_FACTOR: 'unsupported-first-factor',
          UNVERIFIED_EMAIL: 'unverified-email',
        };
        z(d, b || {});
        b = (b = c.match(/^[^\s]+\s*:\s*([\s\S]*)$/)) && 1 < b.length ? b[1] : void 0;
        for (var e in d) if (0 === c.indexOf(e)) return new t(d[e], b);
        !b && a && (b = Ue(a));
        return new t('internal-error', b);
      }
      function Mj(a) {
        this.b = a;
        this.a = null;
        this.sb = Nj(this);
      }
      function Nj(a) {
        return Oj().then(function () {
          return new D(function (b, c) {
            L('gapi.iframes.getContext')().open(
              {
                where: document.body,
                url: a.b,
                messageHandlersFilter: L('gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER'),
                attributes: { style: { position: 'absolute', top: '-100px', width: '1px', height: '1px' } },
                dontclear: !0,
              },
              function (d) {
                function e() {
                  clearTimeout(f);
                  b();
                }
                a.a = d;
                a.a.restyle({ setHideOnLeave: !1 });
                var f = setTimeout(function () {
                  c(Error('Network Error'));
                }, Pj.get());
                d.ping(e).then(e, function () {
                  c(Error('Network Error'));
                });
              },
            );
          });
        });
      }
      function Qj(a, b) {
        return a.sb.then(function () {
          return new D(function (c) {
            a.a.send(b.type, b, c, L('gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER'));
          });
        });
      }
      function Rj(a, b) {
        a.sb.then(function () {
          a.a.register('authEvent', b, L('gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER'));
        });
      }
      var Sj = new qb(rb, 'https://apis.google.com/js/api.js?onload=%{onload}'),
        Tj = new Ze(3e4, 6e4),
        Pj = new Ze(5e3, 15e3),
        Uj = null;
      function Oj() {
        return Uj
          ? Uj
          : (Uj = new D(function (a, b) {
              function c() {
                Ye();
                L('gapi.load')('gapi.iframes', {
                  callback: a,
                  ontimeout: function () {
                    Ye();
                    b(Error('Network Error'));
                  },
                  timeout: Tj.get(),
                });
              }
              if (L('gapi.iframes.Iframe')) a();
              else if (L('gapi.load')) c();
              else {
                var d = '__iframefcb' + Math.floor(1e6 * Math.random()).toString();
                l[d] = function () {
                  L('gapi.load') ? c() : b(Error('Network Error'));
                };
                d = zb(Sj, { onload: d });
                E(Bi(d)).o(function () {
                  b(Error('Network Error'));
                });
              }
            }).o(function (a) {
              Uj = null;
              throw a;
            }));
      }
      function Vj(a, b, c, d) {
        this.l = a;
        this.h = b;
        this.i = c;
        this.g = d;
        this.f = null;
        this.g ? ((a = J(this.g.url)), (a = ce(a.c, a.a, a.g, '/emulator/auth/iframe'))) : (a = ce('https', this.l, null, '/__/auth/iframe'));
        this.a = a;
        I(this.a, 'apiKey', this.h);
        I(this.a, 'appName', this.i);
        this.b = null;
        this.c = [];
      }
      Vj.prototype.toString = function () {
        this.f ? I(this.a, 'v', this.f) : ie(this.a.b, 'v');
        this.b ? I(this.a, 'eid', this.b) : ie(this.a.b, 'eid');
        this.c.length ? I(this.a, 'fw', this.c.join(',')) : ie(this.a.b, 'fw');
        return this.a.toString();
      };
      function Wj(a, b, c, d, e, f) {
        this.u = a;
        this.s = b;
        this.c = c;
        this.m = d;
        this.v = f;
        this.i = this.g = this.l = null;
        this.a = e;
        this.h = this.f = null;
      }
      Wj.prototype.zb = function (a) {
        this.h = a;
        return this;
      };
      Wj.prototype.toString = function () {
        if (this.v) {
          var a = J(this.v.url);
          a = ce(a.c, a.a, a.g, '/emulator/auth/handler');
        } else a = ce('https', this.u, null, '/__/auth/handler');
        I(a, 'apiKey', this.s);
        I(a, 'appName', this.c);
        I(a, 'authType', this.m);
        if (this.a.isOAuthProvider) {
          var b = this.a;
          try {
            var c = firebase.app(this.c).auth().la();
          } catch (h) {
            c = null;
          }
          b.pb = c;
          I(a, 'providerId', this.a.providerId);
          c = this.a;
          b = Ve(c.Jb);
          for (var d in b) b[d] = b[d].toString();
          d = c.Qc;
          b = nb(b);
          for (var e = 0; e < d.length; e++) {
            var f = d[e];
            f in b && delete b[f];
          }
          c.qb && c.pb && !b[c.qb] && (b[c.qb] = c.pb);
          mb(b) || I(a, 'customParameters', Ue(b));
        }
        'function' === typeof this.a.Rb && ((c = this.a.Rb()), c.length && I(a, 'scopes', c.join(',')));
        this.l ? I(a, 'redirectUrl', this.l) : ie(a.b, 'redirectUrl');
        this.g ? I(a, 'eventId', this.g) : ie(a.b, 'eventId');
        this.i ? I(a, 'v', this.i) : ie(a.b, 'v');
        if (this.b) for (var g in this.b) this.b.hasOwnProperty(g) && !be(a, g) && I(a, g, this.b[g]);
        this.h ? I(a, 'tid', this.h) : ie(a.b, 'tid');
        this.f ? I(a, 'eid', this.f) : ie(a.b, 'eid');
        g = Xj(this.c);
        g.length && I(a, 'fw', g.join(','));
        return a.toString();
      };
      function Xj(a) {
        try {
          return firebase.app(a).auth().Ga();
        } catch (b) {
          return [];
        }
      }
      function Yj(a, b, c, d, e, f) {
        this.s = a;
        this.g = b;
        this.b = c;
        this.f = f;
        this.c = d || null;
        this.i = e || null;
        this.l = this.u = this.C = null;
        this.h = [];
        this.m = this.a = null;
      }
      function Zj(a) {
        var b = re();
        return cj(a).then(function (c) {
          a: {
            var d = J(b),
              e = d.c;
            d = d.a;
            for (var f = 0; f < c.length; f++) {
              var g = c[f];
              var h = d;
              var m = e;
              0 == g.indexOf('chrome-extension://')
                ? (h = J(g).a == h && 'chrome-extension' == m)
                : 'http' != m && 'https' != m
                ? (h = !1)
                : Ce.test(g)
                ? (h = h == g)
                : ((g = g.split('.').join('\\.')), (h = new RegExp('^(.+\\.' + g + '|' + g + ')$', 'i').test(h)));
              if (h) {
                c = !0;
                break a;
              }
            }
            c = !1;
          }
          if (!c) throw new xh(re());
        });
      }
      function ak(a) {
        if (a.m) return a.m;
        a.m = Ee().then(function () {
          if (!a.u) {
            var b = a.c,
              c = a.i,
              d = Xj(a.b),
              e = new Vj(a.s, a.g, a.b, a.f);
            e.f = b;
            e.b = c;
            e.c = Za(d || []);
            a.u = e.toString();
          }
          a.v = new Mj(a.u);
          bk(a);
        });
        return a.m;
      }
      k = Yj.prototype;
      k.Pb = function (a, b, c) {
        var d = new t('popup-closed-by-user'),
          e = new t('web-storage-unsupported'),
          f = this,
          g = !1;
        return this.ma()
          .then(function () {
            ck(f).then(function (h) {
              h || (a && ye(a), b(e), (g = !0));
            });
          })
          .o(function () {})
          .then(function () {
            if (!g) return Be(a);
          })
          .then(function () {
            if (!g)
              return Fd(c).then(function () {
                b(d);
              });
          });
      };
      k.Yb = function () {
        var a = K();
        return !Te(a) && !Xe(a);
      };
      k.Ub = function () {
        return !1;
      };
      k.Nb = function (a, b, c, d, e, f, g, h) {
        if (!a) return F(new t('popup-blocked'));
        if (g && !Te())
          return (
            this.ma().o(function (p) {
              ye(a);
              e(p);
            }),
            d(),
            E()
          );
        this.a || (this.a = Zj(dk(this)));
        var m = this;
        return this.a
          .then(function () {
            var p = m.ma().o(function (v) {
              ye(a);
              e(v);
              throw v;
            });
            d();
            return p;
          })
          .then(function () {
            rh(c);
            if (!g) {
              var p = ek(m.s, m.g, m.b, b, c, null, f, m.c, void 0, m.i, h, m.f);
              se(p, a);
            }
          })
          .o(function (p) {
            'auth/network-request-failed' == p.code && (m.a = null);
            throw p;
          });
      };
      function dk(a) {
        a.l || ((a.C = a.c ? Oe(a.c, Xj(a.b)) : null), (a.l = new Ii(a.g, Ca(a.i), a.C)), a.f && Pi(a.l, a.f));
        return a.l;
      }
      k.Ob = function (a, b, c, d) {
        this.a || (this.a = Zj(dk(this)));
        var e = this;
        return this.a
          .then(function () {
            rh(b);
            var f = ek(e.s, e.g, e.b, a, b, re(), c, e.c, void 0, e.i, d, e.f);
            se(f);
          })
          .o(function (f) {
            'auth/network-request-failed' == f.code && (e.a = null);
            throw f;
          });
      };
      k.ma = function () {
        var a = this;
        return ak(this)
          .then(function () {
            return a.v.sb;
          })
          .o(function () {
            a.a = null;
            throw new t('network-request-failed');
          });
      };
      k.ac = function () {
        return !0;
      };
      function ek(a, b, c, d, e, f, g, h, m, p, v, B) {
        a = new Wj(a, b, c, d, e, B);
        a.l = f;
        a.g = g;
        a.i = h;
        a.b = nb(m || null);
        a.f = p;
        return a.zb(v).toString();
      }
      function bk(a) {
        if (!a.v) throw Error('IfcHandler must be initialized!');
        Rj(a.v, function (b) {
          var c = {};
          if (b && b.authEvent) {
            var d = !1;
            b = th(b.authEvent);
            for (c = 0; c < a.h.length; c++) d = a.h[c](b) || d;
            c = {};
            c.status = d ? 'ACK' : 'ERROR';
            return E(c);
          }
          c.status = 'ERROR';
          return E(c);
        });
      }
      function ck(a) {
        var b = { type: 'webStorageSupport' };
        return ak(a)
          .then(function () {
            return Qj(a.v, b);
          })
          .then(function (c) {
            if (c && c.length && 'undefined' !== typeof c[0].webStorageSupport) return c[0].webStorageSupport;
            throw Error();
          });
      }
      k.Ea = function (a) {
        this.h.push(a);
      };
      k.Ta = function (a) {
        Xa(this.h, function (b) {
          return b == a;
        });
      };
      function fk(a) {
        this.a = a || (firebase.INTERNAL.reactNative && firebase.INTERNAL.reactNative.AsyncStorage);
        if (!this.a) throw new t('internal-error', 'The React Native compatibility library was not found.');
        this.type = 'asyncStorage';
      }
      k = fk.prototype;
      k.get = function (a) {
        return E(this.a.getItem(a)).then(function (b) {
          return b && We(b);
        });
      };
      k.set = function (a, b) {
        return E(this.a.setItem(a, Ue(b)));
      };
      k.U = function (a) {
        return E(this.a.removeItem(a));
      };
      k.ca = function () {};
      k.ia = function () {};
      function gk(a) {
        this.b = a;
        this.a = {};
        this.f = q(this.c, this);
      }
      var hk = [];
      function ik() {
        var a = Je() ? self : null;
        w(hk, function (c) {
          c.b == a && (b = c);
        });
        if (!b) {
          var b = new gk(a);
          hk.push(b);
        }
        return b;
      }
      gk.prototype.c = function (a) {
        var b = a.data.eventType,
          c = a.data.eventId,
          d = this.a[b];
        if (d && 0 < d.length) {
          a.ports[0].postMessage({ status: 'ack', eventId: c, eventType: b, response: null });
          var e = [];
          w(d, function (f) {
            e.push(
              E().then(function () {
                return f(a.origin, a.data.data);
              }),
            );
          });
          Jc(e).then(function (f) {
            var g = [];
            w(f, function (h) {
              g.push({ fulfilled: h.Qb, value: h.value, reason: h.reason ? h.reason.message : void 0 });
            });
            w(g, function (h) {
              for (var m in h) 'undefined' === typeof h[m] && delete h[m];
            });
            a.ports[0].postMessage({ status: 'done', eventId: c, eventType: b, response: g });
          });
        }
      };
      function jk(a, b, c) {
        mb(a.a) && a.b.addEventListener('message', a.f);
        'undefined' === typeof a.a[b] && (a.a[b] = []);
        a.a[b].push(c);
      }
      function kk(a) {
        this.a = a;
      }
      kk.prototype.postMessage = function (a, b) {
        this.a.postMessage(a, b);
      };
      function lk(a) {
        this.c = a;
        this.b = !1;
        this.a = [];
      }
      function mk(a, b, c, d) {
        var e,
          f = c || {},
          g,
          h,
          m,
          p = null;
        if (a.b) return F(Error('connection_unavailable'));
        var v = d ? 800 : 50,
          B = 'undefined' !== typeof MessageChannel ? new MessageChannel() : null;
        return new D(function (A, Q) {
          B
            ? ((e = Math.floor(Math.random() * Math.pow(10, 20)).toString()),
              B.port1.start(),
              (h = setTimeout(function () {
                Q(Error('unsupported_event'));
              }, v)),
              (g = function (ya) {
                ya.data.eventId === e &&
                  ('ack' === ya.data.status
                    ? (clearTimeout(h),
                      (m = setTimeout(function () {
                        Q(Error('timeout'));
                      }, 3e3)))
                    : 'done' === ya.data.status
                    ? (clearTimeout(m), 'undefined' !== typeof ya.data.response ? A(ya.data.response) : Q(Error('unknown_error')))
                    : (clearTimeout(h), clearTimeout(m), Q(Error('invalid_response'))));
              }),
              (p = { messageChannel: B, onMessage: g }),
              a.a.push(p),
              B.port1.addEventListener('message', g),
              a.c.postMessage({ eventType: b, eventId: e, data: f }, [B.port2]))
            : Q(Error('connection_unavailable'));
        })
          .then(function (A) {
            nk(a, p);
            return A;
          })
          .o(function (A) {
            nk(a, p);
            throw A;
          });
      }
      function nk(a, b) {
        if (b) {
          var c = b.messageChannel,
            d = b.onMessage;
          c && (c.port1.removeEventListener('message', d), c.port1.close());
          Xa(a.a, function (e) {
            return e == b;
          });
        }
      }
      lk.prototype.close = function () {
        for (; 0 < this.a.length; ) nk(this, this.a[0]);
        this.b = !0;
      };
      function ok() {
        if (!pk()) throw new t('web-storage-unsupported');
        this.c = {};
        this.a = [];
        this.b = 0;
        this.m = l.indexedDB;
        this.type = 'indexedDB';
        this.g = this.v = this.f = this.l = null;
        this.s = !1;
        this.h = null;
        var a = this;
        Je() && self
          ? ((this.v = ik()),
            jk(this.v, 'keyChanged', function (b, c) {
              return qk(a).then(function (d) {
                0 < d.length &&
                  w(a.a, function (e) {
                    e(d);
                  });
                return { keyProcessed: Va(d, c.key) };
              });
            }),
            jk(this.v, 'ping', function () {
              return E(['keyChanged']);
            }))
          : ef().then(function (b) {
              if ((a.h = b))
                (a.g = new lk(new kk(b))),
                  mk(a.g, 'ping', null, !0)
                    .then(function (c) {
                      c[0].fulfilled && Va(c[0].value, 'keyChanged') && (a.s = !0);
                    })
                    .o(function () {});
            });
      }
      var rk;
      function sk(a) {
        return new D(function (b, c) {
          var d = a.m.deleteDatabase('firebaseLocalStorageDb');
          d.onsuccess = function () {
            b();
          };
          d.onerror = function (e) {
            c(Error(e.target.error));
          };
        });
      }
      function tk(a) {
        return new D(function (b, c) {
          var d = a.m.open('firebaseLocalStorageDb', 1);
          d.onerror = function (e) {
            try {
              e.preventDefault();
            } catch (f) {}
            c(Error(e.target.error));
          };
          d.onupgradeneeded = function (e) {
            e = e.target.result;
            try {
              e.createObjectStore('firebaseLocalStorage', { keyPath: 'fbase_key' });
            } catch (f) {
              c(f);
            }
          };
          d.onsuccess = function (e) {
            e = e.target.result;
            e.objectStoreNames.contains('firebaseLocalStorage')
              ? b(e)
              : sk(a)
                  .then(function () {
                    return tk(a);
                  })
                  .then(function (f) {
                    b(f);
                  })
                  .o(function (f) {
                    c(f);
                  });
          };
        });
      }
      function uk(a) {
        a.i || (a.i = tk(a));
        return a.i;
      }
      function vk(a, b) {
        function c(e, f) {
          uk(a)
            .then(b)
            .then(e)
            .o(function (g) {
              if (3 < ++d) f(g);
              else
                return uk(a)
                  .then(function (h) {
                    h.close();
                    a.i = void 0;
                    return c(e, f);
                  })
                  .o(function (h) {
                    f(h);
                  });
            });
        }
        var d = 0;
        return new D(c);
      }
      function pk() {
        try {
          return !!l.indexedDB;
        } catch (a) {
          return !1;
        }
      }
      function wk(a) {
        return a.objectStore('firebaseLocalStorage');
      }
      function xk(a, b) {
        return a.transaction(['firebaseLocalStorage'], b ? 'readwrite' : 'readonly');
      }
      function yk(a) {
        return new D(function (b, c) {
          a.onsuccess = function (d) {
            d && d.target ? b(d.target.result) : b();
          };
          a.onerror = function (d) {
            c(d.target.error);
          };
        });
      }
      k = ok.prototype;
      k.set = function (a, b) {
        var c = this,
          d = !1;
        return vk(this, function (e) {
          e = wk(xk(e, !0));
          return yk(e.get(a));
        })
          .then(function (e) {
            return vk(c, function (f) {
              f = wk(xk(f, !0));
              if (e) return (e.value = b), yk(f.put(e));
              c.b++;
              d = !0;
              var g = {};
              g.fbase_key = a;
              g.value = b;
              return yk(f.add(g));
            });
          })
          .then(function () {
            c.c[a] = b;
            return zk(c, a);
          })
          .oa(function () {
            d && c.b--;
          });
      };
      function zk(a, b) {
        return a.g && a.h && df() === a.h
          ? mk(a.g, 'keyChanged', { key: b }, a.s)
              .then(function () {})
              .o(function () {})
          : E();
      }
      k.get = function (a) {
        return vk(this, function (b) {
          return yk(wk(xk(b, !1)).get(a));
        }).then(function (b) {
          return b && b.value;
        });
      };
      k.U = function (a) {
        var b = this,
          c = !1;
        return vk(this, function (d) {
          c = !0;
          b.b++;
          return yk(wk(xk(d, !0))['delete'](a));
        })
          .then(function () {
            delete b.c[a];
            return zk(b, a);
          })
          .oa(function () {
            c && b.b--;
          });
      };
      function qk(a) {
        return uk(a)
          .then(function (b) {
            var c = wk(xk(b, !1));
            return c.getAll
              ? yk(c.getAll())
              : new D(function (d, e) {
                  var f = [],
                    g = c.openCursor();
                  g.onsuccess = function (h) {
                    (h = h.target.result) ? (f.push(h.value), h['continue']()) : d(f);
                  };
                  g.onerror = function (h) {
                    e(h.target.error);
                  };
                });
          })
          .then(function (b) {
            var c = {},
              d = [];
            if (0 == a.b) {
              for (d = 0; d < b.length; d++) c[b[d].fbase_key] = b[d].value;
              d = te(a.c, c);
              a.c = c;
            }
            return d;
          });
      }
      k.ca = function (a) {
        0 == this.a.length && Ak(this);
        this.a.push(a);
      };
      k.ia = function (a) {
        Xa(this.a, function (b) {
          return b == a;
        });
        0 == this.a.length && Bk(this);
      };
      function Ak(a) {
        function b() {
          a.f = setTimeout(function () {
            a.l = qk(a)
              .then(function (c) {
                0 < c.length &&
                  w(a.a, function (d) {
                    d(c);
                  });
              })
              .then(function () {
                b();
              })
              .o(function (c) {
                'STOP_EVENT' != c.message && b();
              });
          }, 800);
        }
        Bk(a);
        b();
      }
      function Bk(a) {
        a.l && a.l.cancel('STOP_EVENT');
        a.f && (clearTimeout(a.f), (a.f = null));
      }
      function Ck(a) {
        var b = this,
          c = null;
        this.a = [];
        this.type = 'indexedDB';
        this.c = a;
        this.b = E()
          .then(function () {
            if (pk()) {
              var d = Qe(),
                e = '__sak' + d;
              rk || (rk = new ok());
              c = rk;
              return c
                .set(e, d)
                .then(function () {
                  return c.get(e);
                })
                .then(function (f) {
                  if (f !== d) throw Error('indexedDB not supported!');
                  return c.U(e);
                })
                .then(function () {
                  return c;
                })
                .o(function () {
                  return b.c;
                });
            }
            return b.c;
          })
          .then(function (d) {
            b.type = d.type;
            d.ca(function (e) {
              w(b.a, function (f) {
                f(e);
              });
            });
            return d;
          });
      }
      k = Ck.prototype;
      k.get = function (a) {
        return this.b.then(function (b) {
          return b.get(a);
        });
      };
      k.set = function (a, b) {
        return this.b.then(function (c) {
          return c.set(a, b);
        });
      };
      k.U = function (a) {
        return this.b.then(function (b) {
          return b.U(a);
        });
      };
      k.ca = function (a) {
        this.a.push(a);
      };
      k.ia = function (a) {
        Xa(this.a, function (b) {
          return b == a;
        });
      };
      function Dk() {
        this.a = {};
        this.type = 'inMemory';
      }
      k = Dk.prototype;
      k.get = function (a) {
        return E(this.a[a]);
      };
      k.set = function (a, b) {
        this.a[a] = b;
        return E();
      };
      k.U = function (a) {
        delete this.a[a];
        return E();
      };
      k.ca = function () {};
      k.ia = function () {};
      function Ek() {
        if (!Fk()) {
          if ('Node' == Ke()) throw new t('internal-error', 'The LocalStorage compatibility library was not found.');
          throw new t('web-storage-unsupported');
        }
        this.a = Gk() || firebase.INTERNAL.node.localStorage;
        this.type = 'localStorage';
      }
      function Gk() {
        try {
          var a = l.localStorage,
            b = Qe();
          a && (a.setItem(b, '1'), a.removeItem(b));
          return a;
        } catch (c) {
          return null;
        }
      }
      function Fk() {
        var a = 'Node' == Ke();
        a = Gk() || (a && firebase.INTERNAL.node && firebase.INTERNAL.node.localStorage);
        if (!a) return !1;
        try {
          return a.setItem('__sak', '1'), a.removeItem('__sak'), !0;
        } catch (b) {
          return !1;
        }
      }
      k = Ek.prototype;
      k.get = function (a) {
        var b = this;
        return E().then(function () {
          var c = b.a.getItem(a);
          return We(c);
        });
      };
      k.set = function (a, b) {
        var c = this;
        return E().then(function () {
          var d = Ue(b);
          null === d ? c.U(a) : c.a.setItem(a, d);
        });
      };
      k.U = function (a) {
        var b = this;
        return E().then(function () {
          b.a.removeItem(a);
        });
      };
      k.ca = function (a) {
        l.window && nd(l.window, 'storage', a);
      };
      k.ia = function (a) {
        l.window && xd(l.window, 'storage', a);
      };
      function Hk() {
        this.type = 'nullStorage';
      }
      k = Hk.prototype;
      k.get = function () {
        return E(null);
      };
      k.set = function () {
        return E();
      };
      k.U = function () {
        return E();
      };
      k.ca = function () {};
      k.ia = function () {};
      function Ik() {
        if (!Jk()) {
          if ('Node' == Ke()) throw new t('internal-error', 'The SessionStorage compatibility library was not found.');
          throw new t('web-storage-unsupported');
        }
        this.a = Kk() || firebase.INTERNAL.node.sessionStorage;
        this.type = 'sessionStorage';
      }
      function Kk() {
        try {
          var a = l.sessionStorage,
            b = Qe();
          a && (a.setItem(b, '1'), a.removeItem(b));
          return a;
        } catch (c) {
          return null;
        }
      }
      function Jk() {
        var a = 'Node' == Ke();
        a = Kk() || (a && firebase.INTERNAL.node && firebase.INTERNAL.node.sessionStorage);
        if (!a) return !1;
        try {
          return a.setItem('__sak', '1'), a.removeItem('__sak'), !0;
        } catch (b) {
          return !1;
        }
      }
      k = Ik.prototype;
      k.get = function (a) {
        var b = this;
        return E().then(function () {
          var c = b.a.getItem(a);
          return We(c);
        });
      };
      k.set = function (a, b) {
        var c = this;
        return E().then(function () {
          var d = Ue(b);
          null === d ? c.U(a) : c.a.setItem(a, d);
        });
      };
      k.U = function (a) {
        var b = this;
        return E().then(function () {
          b.a.removeItem(a);
        });
      };
      k.ca = function () {};
      k.ia = function () {};
      function Lk() {
        var a = {};
        a.Browser = Mk;
        a.Node = Nk;
        a.ReactNative = Ok;
        a.Worker = Pk;
        this.a = a[Ke()];
      }
      var Qk,
        Mk = { F: Ek, cb: Ik },
        Nk = { F: Ek, cb: Ik },
        Ok = { F: fk, cb: Hk },
        Pk = { F: Ek, cb: Hk };
      var Rk = { rd: 'local', NONE: 'none', td: 'session' };
      function Sk(a) {
        var b = new t('invalid-persistence-type'),
          c = new t('unsupported-persistence-type');
        a: {
          for (d in Rk)
            if (Rk[d] == a) {
              var d = !0;
              break a;
            }
          d = !1;
        }
        if (!d || 'string' !== typeof a) throw b;
        switch (Ke()) {
          case 'ReactNative':
            if ('session' === a) throw c;
            break;
          case 'Node':
            if ('none' !== a) throw c;
            break;
          case 'Worker':
            if ('session' === a || (!pk() && 'none' !== a)) throw c;
            break;
          default:
            if (!Pe() && 'none' !== a) throw c;
        }
      }
      function Tk() {
        var a = !Xe(K()) && Ie() ? !0 : !1,
          b = Te(),
          c = Pe();
        this.m = a;
        this.h = b;
        this.l = c;
        this.a = {};
        Qk || (Qk = new Lk());
        a = Qk;
        try {
          this.g = (!qe() && cf()) || !l.indexedDB ? new a.a.F() : new Ck(Je() ? new Dk() : new a.a.F());
        } catch (d) {
          (this.g = new Dk()), (this.h = !0);
        }
        try {
          this.i = new a.a.cb();
        } catch (d) {
          this.i = new Dk();
        }
        this.v = new Dk();
        this.f = q(this.Zb, this);
        this.b = {};
      }
      var Uk;
      function Vk() {
        Uk || (Uk = new Tk());
        return Uk;
      }
      function Wk(a, b) {
        switch (b) {
          case 'session':
            return a.i;
          case 'none':
            return a.v;
          default:
            return a.g;
        }
      }
      function Xk(a, b) {
        return 'firebase:' + a.name + (b ? ':' + b : '');
      }
      function Yk(a, b, c) {
        var d = Xk(b, c),
          e = Wk(a, b.F);
        return a.get(b, c).then(function (f) {
          var g = null;
          try {
            g = We(l.localStorage.getItem(d));
          } catch (h) {}
          if (g && !f) return l.localStorage.removeItem(d), a.set(b, g, c);
          g && f && 'localStorage' != e.type && l.localStorage.removeItem(d);
        });
      }
      k = Tk.prototype;
      k.get = function (a, b) {
        return Wk(this, a.F).get(Xk(a, b));
      };
      function Zk(a, b, c) {
        c = Xk(b, c);
        'local' == b.F && (a.b[c] = null);
        return Wk(a, b.F).U(c);
      }
      k.set = function (a, b, c) {
        var d = Xk(a, c),
          e = this,
          f = Wk(this, a.F);
        return f
          .set(d, b)
          .then(function () {
            return f.get(d);
          })
          .then(function (g) {
            'local' == a.F && (e.b[d] = g);
          });
      };
      k.addListener = function (a, b, c) {
        a = Xk(a, b);
        this.l && (this.b[a] = l.localStorage.getItem(a));
        mb(this.a) && (Wk(this, 'local').ca(this.f), this.h || ((qe() || !cf()) && l.indexedDB) || !this.l || $k(this));
        this.a[a] || (this.a[a] = []);
        this.a[a].push(c);
      };
      k.removeListener = function (a, b, c) {
        a = Xk(a, b);
        this.a[a] &&
          (Xa(this.a[a], function (d) {
            return d == c;
          }),
          0 == this.a[a].length && delete this.a[a]);
        mb(this.a) && (Wk(this, 'local').ia(this.f), al(this));
      };
      function $k(a) {
        al(a);
        a.c = setInterval(function () {
          for (var b in a.a) {
            var c = l.localStorage.getItem(b),
              d = a.b[b];
            c != d && ((a.b[b] = c), (c = new bd({ type: 'storage', key: b, target: window, oldValue: d, newValue: c, a: !0 })), a.Zb(c));
          }
        }, 1e3);
      }
      function al(a) {
        a.c && (clearInterval(a.c), (a.c = null));
      }
      k.Zb = function (a) {
        if (a && a.g) {
          var b = a.a.key;
          if (null == b)
            for (var c in this.a) {
              var d = this.b[c];
              'undefined' === typeof d && (d = null);
              var e = l.localStorage.getItem(c);
              e !== d && ((this.b[c] = e), this.nb(c));
            }
          else if (0 == b.indexOf('firebase:') && this.a[b]) {
            'undefined' !== typeof a.a.a ? Wk(this, 'local').ia(this.f) : al(this);
            if (this.m)
              if (((c = l.localStorage.getItem(b)), (d = a.a.newValue), d !== c)) null !== d ? l.localStorage.setItem(b, d) : l.localStorage.removeItem(b);
              else if (this.b[b] === d && 'undefined' === typeof a.a.a) return;
            var f = this;
            c = function () {
              if ('undefined' !== typeof a.a.a || f.b[b] !== l.localStorage.getItem(b)) (f.b[b] = l.localStorage.getItem(b)), f.nb(b);
            };
            Wb && ic && 10 == ic && l.localStorage.getItem(b) !== a.a.newValue && a.a.newValue !== a.a.oldValue ? setTimeout(c, 10) : c();
          }
        } else w(a, q(this.nb, this));
      };
      k.nb = function (a) {
        this.a[a] &&
          w(this.a[a], function (b) {
            b();
          });
      };
      function bl(a) {
        this.a = a;
        this.b = Vk();
      }
      var cl = { name: 'authEvent', F: 'local' };
      function dl(a) {
        return a.b.get(cl, a.a).then(function (b) {
          return th(b);
        });
      }
      function el() {
        this.a = Vk();
      }
      function fl() {
        this.b = -1;
      }
      function gl(a, b) {
        this.b = hl;
        this.f = l.Uint8Array ? new Uint8Array(this.b) : Array(this.b);
        this.g = this.c = 0;
        this.a = [];
        this.i = a;
        this.h = b;
        this.l = l.Int32Array ? new Int32Array(64) : Array(64);
        void 0 === il && (l.Int32Array ? (il = new Int32Array(jl)) : (il = jl));
        this.reset();
      }
      var il;
      r(gl, fl);
      for (var hl = 64, kl = hl - 1, ll = [], ml = 0; ml < kl; ml++) ll[ml] = 0;
      var nl = Ya(128, ll);
      gl.prototype.reset = function () {
        this.g = this.c = 0;
        this.a = l.Int32Array ? new Int32Array(this.h) : Za(this.h);
      };
      function ol(a) {
        for (var b = a.f, c = a.l, d = 0, e = 0; e < b.length; ) (c[d++] = (b[e] << 24) | (b[e + 1] << 16) | (b[e + 2] << 8) | b[e + 3]), (e = 4 * d);
        for (b = 16; 64 > b; b++) {
          e = c[b - 15] | 0;
          d = c[b - 2] | 0;
          var f = ((c[b - 16] | 0) + (((e >>> 7) | (e << 25)) ^ ((e >>> 18) | (e << 14)) ^ (e >>> 3))) | 0,
            g = ((c[b - 7] | 0) + (((d >>> 17) | (d << 15)) ^ ((d >>> 19) | (d << 13)) ^ (d >>> 10))) | 0;
          c[b] = (f + g) | 0;
        }
        d = a.a[0] | 0;
        e = a.a[1] | 0;
        var h = a.a[2] | 0,
          m = a.a[3] | 0,
          p = a.a[4] | 0,
          v = a.a[5] | 0,
          B = a.a[6] | 0;
        f = a.a[7] | 0;
        for (b = 0; 64 > b; b++) {
          var A = ((((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10))) + ((d & e) ^ (d & h) ^ (e & h))) | 0;
          g = (p & v) ^ (~p & B);
          f = (f + (((p >>> 6) | (p << 26)) ^ ((p >>> 11) | (p << 21)) ^ ((p >>> 25) | (p << 7)))) | 0;
          g = (g + (il[b] | 0)) | 0;
          g = (f + ((g + (c[b] | 0)) | 0)) | 0;
          f = B;
          B = v;
          v = p;
          p = (m + g) | 0;
          m = h;
          h = e;
          e = d;
          d = (g + A) | 0;
        }
        a.a[0] = (a.a[0] + d) | 0;
        a.a[1] = (a.a[1] + e) | 0;
        a.a[2] = (a.a[2] + h) | 0;
        a.a[3] = (a.a[3] + m) | 0;
        a.a[4] = (a.a[4] + p) | 0;
        a.a[5] = (a.a[5] + v) | 0;
        a.a[6] = (a.a[6] + B) | 0;
        a.a[7] = (a.a[7] + f) | 0;
      }
      function pl(a, b, c) {
        void 0 === c && (c = b.length);
        var d = 0,
          e = a.c;
        if ('string' === typeof b) for (; d < c; ) (a.f[e++] = b.charCodeAt(d++)), e == a.b && (ol(a), (e = 0));
        else if (na(b))
          for (; d < c; ) {
            var f = b[d++];
            if (!('number' == typeof f && 0 <= f && 255 >= f && f == (f | 0))) throw Error('message must be a byte array');
            a.f[e++] = f;
            e == a.b && (ol(a), (e = 0));
          }
        else throw Error('message must be string or array');
        a.c = e;
        a.g += c;
      }
      var jl = [
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206,
        2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671,
        3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411,
        3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779,
        1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
      ];
      function ql() {
        gl.call(this, 8, rl);
      }
      r(ql, gl);
      var rl = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
      function sl(a, b, c, d, e, f) {
        this.v = a;
        this.i = b;
        this.l = c;
        this.m = d || null;
        this.u = e || null;
        this.s = f;
        this.h = b + ':' + c;
        this.C = new el();
        this.g = new bl(this.h);
        this.f = null;
        this.b = [];
        this.a = this.c = null;
      }
      function tl(a) {
        return new t('invalid-cordova-configuration', a);
      }
      k = sl.prototype;
      k.ma = function () {
        return this.Ia
          ? this.Ia
          : (this.Ia = Fe().then(
              function () {
                if ('function' !== typeof L('universalLinks.subscribe', l)) throw tl('cordova-universal-links-plugin-fix is not installed');
                if ('undefined' === typeof L('BuildInfo.packageName', l)) throw tl('cordova-plugin-buildinfo is not installed');
                if ('function' !== typeof L('cordova.plugins.browsertab.openUrl', l)) throw tl('cordova-plugin-browsertab is not installed');
                if ('function' !== typeof L('cordova.InAppBrowser.open', l)) throw tl('cordova-plugin-inappbrowser is not installed');
              },
              function () {
                throw new t('cordova-not-ready');
              },
            ));
      };
      function ul() {
        for (var a = 20, b = []; 0 < a; ) b.push('1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.charAt(Math.floor(62 * Math.random()))), a--;
        return b.join('');
      }
      function vl(a) {
        var b = new ql();
        pl(b, a);
        a = [];
        var c = 8 * b.g;
        56 > b.c ? pl(b, nl, 56 - b.c) : pl(b, nl, b.b - (b.c - 56));
        for (var d = 63; 56 <= d; d--) (b.f[d] = c & 255), (c /= 256);
        ol(b);
        for (d = c = 0; d < b.i; d++) for (var e = 24; 0 <= e; e -= 8) a[c++] = (b.a[d] >> e) & 255;
        return cg(a);
      }
      k.Pb = function (a, b) {
        b(new t('operation-not-supported-in-this-environment'));
        return E();
      };
      k.Nb = function () {
        return F(new t('operation-not-supported-in-this-environment'));
      };
      k.ac = function () {
        return !1;
      };
      k.Yb = function () {
        return !0;
      };
      k.Ub = function () {
        return !0;
      };
      k.Ob = function (a, b, c, d) {
        if (this.c) return F(new t('redirect-operation-pending'));
        var e = this,
          f = l.document,
          g = null,
          h = null,
          m = null,
          p = null;
        return (this.c = E()
          .then(function () {
            rh(b);
            return wl(e);
          })
          .then(function () {
            return xl(e, a, b, c, d);
          })
          .then(function () {
            return new D(function (v, B) {
              h = function () {
                var A = L('cordova.plugins.browsertab.close', l);
                v();
                'function' === typeof A && A();
                e.a && 'function' === typeof e.a.close && (e.a.close(), (e.a = null));
                return !1;
              };
              e.Ea(h);
              m = function () {
                g ||
                  (g = Fd(2e3).then(function () {
                    B(new t('redirect-cancelled-by-user'));
                  }));
              };
              p = function () {
                $e() && m();
              };
              f.addEventListener('resume', m, !1);
              K()
                .toLowerCase()
                .match(/android/) || f.addEventListener('visibilitychange', p, !1);
            }).o(function (v) {
              return yl(e).then(function () {
                throw v;
              });
            });
          })
          .oa(function () {
            m && f.removeEventListener('resume', m, !1);
            p && f.removeEventListener('visibilitychange', p, !1);
            g && g.cancel();
            h && e.Ta(h);
            e.c = null;
          }));
      };
      function xl(a, b, c, d, e) {
        var f = ul(),
          g = new sh(b, d, null, f, new t('no-auth-event'), null, e),
          h = L('BuildInfo.packageName', l);
        if ('string' !== typeof h) throw new t('invalid-cordova-configuration');
        var m = L('BuildInfo.displayName', l),
          p = {};
        if (
          K()
            .toLowerCase()
            .match(/iphone|ipad|ipod/)
        )
          p.ibi = h;
        else if (
          K()
            .toLowerCase()
            .match(/android/)
        )
          p.apn = h;
        else return F(new t('operation-not-supported-in-this-environment'));
        m && (p.appDisplayName = m);
        f = vl(f);
        p.sessionId = f;
        var v = ek(a.v, a.i, a.l, b, c, null, d, a.m, p, a.u, e, a.s);
        return a
          .ma()
          .then(function () {
            var B = a.h;
            return a.C.a.set(cl, g.w(), B);
          })
          .then(function () {
            var B = L('cordova.plugins.browsertab.isAvailable', l);
            if ('function' !== typeof B) throw new t('invalid-cordova-configuration');
            var A = null;
            B(function (Q) {
              if (Q) {
                A = L('cordova.plugins.browsertab.openUrl', l);
                if ('function' !== typeof A) throw new t('invalid-cordova-configuration');
                A(v);
              } else {
                A = L('cordova.InAppBrowser.open', l);
                if ('function' !== typeof A) throw new t('invalid-cordova-configuration');
                Q = K();
                a.a = A(v, Q.match(/(iPad|iPhone|iPod).*OS 7_\d/i) || Q.match(/(iPad|iPhone|iPod).*OS 8_\d/i) ? '_blank' : '_system', 'location=yes');
              }
            });
          });
      }
      function zl(a, b) {
        for (var c = 0; c < a.b.length; c++)
          try {
            a.b[c](b);
          } catch (d) {}
      }
      function wl(a) {
        a.f ||
          (a.f = a.ma().then(function () {
            return new D(function (b) {
              function c(d) {
                b(d);
                a.Ta(c);
                return !1;
              }
              a.Ea(c);
              Al(a);
            });
          }));
        return a.f;
      }
      function yl(a) {
        var b = null;
        return dl(a.g)
          .then(function (c) {
            b = c;
            c = a.g;
            return Zk(c.b, cl, c.a);
          })
          .then(function () {
            return b;
          });
      }
      function Al(a) {
        function b(g) {
          d = !0;
          e && e.cancel();
          yl(a).then(function (h) {
            var m = c;
            if (h && g && g.url) {
              var p = null;
              m = xg(g.url);
              -1 != m.indexOf('/__/auth/callback') &&
                ((p = J(m)),
                (p = We(be(p, 'firebaseError') || null)),
                (p = (p = 'object' === typeof p ? Aa(p) : null) ? new sh(h.c, h.b, null, null, p, null, h.T()) : new sh(h.c, h.b, m, h.f, null, null, h.T())));
              m = p || c;
            }
            zl(a, m);
          });
        }
        var c = new sh('unknown', null, null, null, new t('no-auth-event')),
          d = !1,
          e = Fd(500).then(function () {
            return yl(a).then(function () {
              d || zl(a, c);
            });
          }),
          f = l.handleOpenURL;
        l.handleOpenURL = function (g) {
          0 == g.toLowerCase().indexOf(L('BuildInfo.packageName', l).toLowerCase() + '://') && b({ url: g });
          if ('function' === typeof f)
            try {
              f(g);
            } catch (h) {
              console.error(h);
            }
        };
        vh || (vh = new uh());
        wh(b);
      }
      k.Ea = function (a) {
        this.b.push(a);
        wl(this).o(function (b) {
          'auth/invalid-cordova-configuration' === b.code && ((b = new sh('unknown', null, null, null, new t('no-auth-event'))), a(b));
        });
      };
      k.Ta = function (a) {
        Xa(this.b, function (b) {
          return b == a;
        });
      };
      function Bl(a) {
        this.a = a;
        this.b = Vk();
      }
      var Cl = { name: 'pendingRedirect', F: 'session' };
      function Dl(a) {
        return a.b.set(Cl, 'pending', a.a);
      }
      function El(a) {
        return Zk(a.b, Cl, a.a);
      }
      function Fl(a) {
        return a.b.get(Cl, a.a).then(function (b) {
          return 'pending' == b;
        });
      }
      function Gl(a, b, c, d) {
        this.i = {};
        this.u = 0;
        this.D = a;
        this.v = b;
        this.m = c;
        this.J = d;
        this.h = [];
        this.f = !1;
        this.l = q(this.s, this);
        this.b = new Hl();
        this.C = new Il();
        this.g = new Bl(Jl(this.v, this.m));
        this.c = {};
        this.c.unknown = this.b;
        this.c.signInViaRedirect = this.b;
        this.c.linkViaRedirect = this.b;
        this.c.reauthViaRedirect = this.b;
        this.c.signInViaPopup = this.C;
        this.c.linkViaPopup = this.C;
        this.c.reauthViaPopup = this.C;
        this.a = Kl(this.D, this.v, this.m, Da, this.J);
      }
      function Kl(a, b, c, d, e) {
        var f = firebase.SDK_VERSION || null;
        return Ge() ? new sl(a, b, c, f, d, e) : new Yj(a, b, c, f, d, e);
      }
      Gl.prototype.reset = function () {
        this.f = !1;
        this.a.Ta(this.l);
        this.a = Kl(this.D, this.v, this.m, null, this.J);
        this.i = {};
      };
      function Ll(a) {
        a.f || ((a.f = !0), a.a.Ea(a.l));
        var b = a.a;
        return a.a.ma().o(function (c) {
          a.a == b && a.reset();
          throw c;
        });
      }
      function Ml(a) {
        a.a.Yb() &&
          Ll(a).o(function (b) {
            var c = new sh('unknown', null, null, null, new t('operation-not-supported-in-this-environment'));
            Nl(b) && a.s(c);
          });
        a.a.Ub() || Ol(a.b);
      }
      function Pl(a, b) {
        Va(a.h, b) || a.h.push(b);
        a.f ||
          Fl(a.g)
            .then(function (c) {
              c
                ? El(a.g).then(function () {
                    Ll(a).o(function (d) {
                      var e = new sh('unknown', null, null, null, new t('operation-not-supported-in-this-environment'));
                      Nl(d) && a.s(e);
                    });
                  })
                : Ml(a);
            })
            .o(function () {
              Ml(a);
            });
      }
      function Ql(a, b) {
        Xa(a.h, function (c) {
          return c == b;
        });
      }
      Gl.prototype.s = function (a) {
        if (!a) throw new t('invalid-auth-event');
        6e5 <= Date.now() - this.u && ((this.i = {}), (this.u = 0));
        if (a && a.getUid() && this.i.hasOwnProperty(a.getUid())) return !1;
        for (var b = !1, c = 0; c < this.h.length; c++) {
          var d = this.h[c];
          if (d.Gb(a.c, a.b)) {
            if ((b = this.c[a.c])) b.h(a, d), a && (a.f || a.b) && ((this.i[a.getUid()] = !0), (this.u = Date.now()));
            b = !0;
            break;
          }
        }
        Ol(this.b);
        return b;
      };
      var Rl = new Ze(2e3, 1e4),
        Sl = new Ze(3e4, 6e4);
      Gl.prototype.ra = function () {
        return this.b.ra();
      };
      function Tl(a, b, c, d, e, f, g) {
        return a.a.Nb(
          b,
          c,
          d,
          function () {
            a.f || ((a.f = !0), a.a.Ea(a.l));
          },
          function () {
            a.reset();
          },
          e,
          f,
          g,
        );
      }
      function Nl(a) {
        return a && 'auth/cordova-not-ready' == a.code ? !0 : !1;
      }
      function Ul(a, b, c, d, e) {
        var f;
        return Dl(a.g).then(function () {
          return a.a
            .Ob(b, c, d, e)
            .o(function (g) {
              if (Nl(g)) throw new t('operation-not-supported-in-this-environment');
              f = g;
              return El(a.g).then(function () {
                throw f;
              });
            })
            .then(function () {
              return a.a.ac()
                ? new D(function () {})
                : El(a.g)
                    .then(function () {
                      return a.ra();
                    })
                    .then(function () {})
                    .o(function () {});
            });
        });
      }
      function Vl(a, b, c, d, e) {
        return a.a.Pb(
          d,
          function (f) {
            b.na(c, null, f, e);
          },
          Rl.get(),
        );
      }
      var Wl = {};
      function Jl(a, b, c) {
        a = a + ':' + b;
        c && (a = a + ':' + c.url);
        return a;
      }
      function Xl(a, b, c, d) {
        var e = Jl(b, c, d);
        Wl[e] || (Wl[e] = new Gl(a, b, c, d));
        return Wl[e];
      }
      function Hl() {
        this.b = null;
        this.f = [];
        this.c = [];
        this.a = null;
        this.i = this.g = !1;
      }
      Hl.prototype.reset = function () {
        this.b = null;
        this.a && (this.a.cancel(), (this.a = null));
      };
      Hl.prototype.h = function (a, b) {
        if (a) {
          this.reset();
          this.g = !0;
          var c = a.c,
            d = a.b,
            e = a.a && 'auth/web-storage-unsupported' == a.a.code,
            f = a.a && 'auth/operation-not-supported-in-this-environment' == a.a.code;
          this.i = !(!e && !f);
          'unknown' != c || e || f ? (a.a ? (Yl(this, !0, null, a.a), E()) : b.Fa(c, d) ? Zl(this, a, b) : F(new t('invalid-auth-event'))) : (Yl(this, !1, null, null), E());
        } else F(new t('invalid-auth-event'));
      };
      function Ol(a) {
        a.g || ((a.g = !0), Yl(a, !1, null, null));
      }
      function $l(a) {
        a.g && !a.i && Yl(a, !1, null, null);
      }
      function Zl(a, b, c) {
        c = c.Fa(b.c, b.b);
        var d = b.g,
          e = b.f,
          f = b.i,
          g = b.T(),
          h = !!b.c.match(/Redirect$/);
        c(d, e, g, f)
          .then(function (m) {
            Yl(a, h, m, null);
          })
          .o(function (m) {
            Yl(a, h, null, m);
          });
      }
      function am(a, b) {
        a.b = function () {
          return F(b);
        };
        if (a.c.length) for (var c = 0; c < a.c.length; c++) a.c[c](b);
      }
      function bm(a, b) {
        a.b = function () {
          return E(b);
        };
        if (a.f.length) for (var c = 0; c < a.f.length; c++) a.f[c](b);
      }
      function Yl(a, b, c, d) {
        b ? (d ? am(a, d) : bm(a, c)) : bm(a, { user: null });
        a.f = [];
        a.c = [];
      }
      Hl.prototype.ra = function () {
        var a = this;
        return new D(function (b, c) {
          a.b ? a.b().then(b, c) : (a.f.push(b), a.c.push(c), cm(a));
        });
      };
      function cm(a) {
        var b = new t('timeout');
        a.a && a.a.cancel();
        a.a = Fd(Sl.get()).then(function () {
          a.b || ((a.g = !0), Yl(a, !0, null, b));
        });
      }
      function Il() {}
      Il.prototype.h = function (a, b) {
        if (a) {
          var c = a.c,
            d = a.b;
          a.a ? (b.na(a.c, null, a.a, a.b), E()) : b.Fa(c, d) ? dm(a, b) : F(new t('invalid-auth-event'));
        } else F(new t('invalid-auth-event'));
      };
      function dm(a, b) {
        var c = a.b,
          d = a.c;
        b.Fa(d, c)(a.g, a.f, a.T(), a.i)
          .then(function (e) {
            b.na(d, e, null, c);
          })
          .o(function (e) {
            b.na(d, null, e, c);
          });
      }
      function em() {
        this.jb = !1;
        Object.defineProperty(this, 'appVerificationDisabled', {
          get: function () {
            return this.jb;
          },
          set: function (a) {
            this.jb = a;
          },
          enumerable: !1,
        });
      }
      function fm(a, b) {
        this.a = b;
        M(this, 'verificationId', a);
      }
      fm.prototype.confirm = function (a) {
        a = ph(this.verificationId, a);
        return this.a(a);
      };
      function gm(a, b, c, d) {
        return new lh(a).gb(b, c).then(function (e) {
          return new fm(e, d);
        });
      }
      function hm(a) {
        var b = ig(a);
        if (!(b && b.exp && b.auth_time && b.iat))
          throw new t('internal-error', 'An internal error occurred. The token obtained by Firebase appears to be malformed. Please retry the operation.');
        N(this, {
          token: a,
          expirationTime: bf(1e3 * b.exp),
          authTime: bf(1e3 * b.auth_time),
          issuedAtTime: bf(1e3 * b.iat),
          signInProvider: b.firebase && b.firebase.sign_in_provider ? b.firebase.sign_in_provider : null,
          signInSecondFactor: b.firebase && b.firebase.sign_in_second_factor ? b.firebase.sign_in_second_factor : null,
          claims: b,
        });
      }
      function im(a, b, c) {
        var d = b && b[jm];
        if (!d) throw new t('argument-error', 'Internal assert: Invalid MultiFactorResolver');
        this.a = a;
        this.f = nb(b);
        this.g = c;
        this.c = new yg(null, d);
        this.b = [];
        var e = this;
        w(b[km] || [], function (f) {
          (f = tf(f)) && e.b.push(f);
        });
        M(this, 'auth', this.a);
        M(this, 'session', this.c);
        M(this, 'hints', this.b);
      }
      var km = 'mfaInfo',
        jm = 'mfaPendingCredential';
      im.prototype.Rc = function (a) {
        var b = this;
        return a.tb(this.a.a, this.c).then(function (c) {
          var d = nb(b.f);
          delete d[km];
          delete d[jm];
          z(d, c);
          return b.g(d);
        });
      };
      function lm(a, b, c, d) {
        t.call(this, 'multi-factor-auth-required', d, b);
        this.b = new im(a, b, c);
        M(this, 'resolver', this.b);
      }
      r(lm, t);
      function mm(a, b, c) {
        if (a && n(a.serverResponse) && 'auth/multi-factor-auth-required' === a.code)
          try {
            return new lm(b, a.serverResponse, c, a.message);
          } catch (d) {}
        return null;
      }
      function nm() {}
      nm.prototype.tb = function (a, b, c) {
        return b.type == zg ? om(this, a, b, c) : pm(this, a, b);
      };
      function om(a, b, c, d) {
        return c.Ha().then(function (e) {
          e = { idToken: e };
          'undefined' !== typeof d && (e.displayName = d);
          z(e, { phoneVerificationInfo: hh(a.a) });
          return O(b, Gj, e);
        });
      }
      function pm(a, b, c) {
        return c.Ha().then(function (d) {
          d = { mfaPendingCredential: d };
          z(d, { phoneVerificationInfo: hh(a.a) });
          return O(b, Hj, d);
        });
      }
      function qm(a) {
        M(this, 'factorId', a.fa);
        this.a = a;
      }
      r(qm, nm);
      function rm(a) {
        qm.call(this, a);
        if (this.a.fa != lh.PROVIDER_ID) throw new t('argument-error', 'firebase.auth.PhoneMultiFactorAssertion requires a valid firebase.auth.PhoneAuthCredential');
      }
      r(rm, qm);
      function sm(a, b) {
        G.call(this, a);
        for (var c in b) this[c] = b[c];
      }
      r(sm, G);
      function tm(a, b) {
        this.a = a;
        this.b = [];
        this.c = q(this.yc, this);
        nd(this.a, 'userReloaded', this.c);
        var c = [];
        b &&
          b.multiFactor &&
          b.multiFactor.enrolledFactors &&
          w(b.multiFactor.enrolledFactors, function (d) {
            var e = null,
              f = {};
            if (d) {
              d.uid && (f[qf] = d.uid);
              d.displayName && (f[rf] = d.displayName);
              d.enrollmentTime && (f[sf] = new Date(d.enrollmentTime).toISOString());
              d.phoneNumber && (f[pf] = d.phoneNumber);
              try {
                e = new uf(f);
              } catch (g) {}
              d = e;
            } else d = null;
            d && c.push(d);
          });
        um(this, c);
      }
      function vm(a) {
        var b = [];
        w(a.mfaInfo || [], function (c) {
          (c = tf(c)) && b.push(c);
        });
        return b;
      }
      k = tm.prototype;
      k.yc = function (a) {
        um(this, vm(a.hd));
      };
      function um(a, b) {
        a.b = b;
        M(a, 'enrolledFactors', b);
      }
      k.Sb = function () {
        return this.a.I().then(function (a) {
          return new yg(a, null);
        });
      };
      k.fc = function (a, b) {
        var c = this,
          d = this.a.a;
        return this.Sb()
          .then(function (e) {
            return a.tb(d, e, b);
          })
          .then(function (e) {
            wm(c.a, e);
            return c.a.reload();
          });
      };
      k.bd = function (a) {
        var b = this,
          c = 'string' === typeof a ? a : a.uid,
          d = this.a.a;
        return this.a
          .I()
          .then(function (e) {
            return O(d, Lj, { idToken: e, mfaEnrollmentId: c });
          })
          .then(function (e) {
            var f = Qa(b.b, function (g) {
              return g.uid != c;
            });
            um(b, f);
            wm(b.a, e);
            return b.a.reload().o(function (g) {
              if ('auth/user-token-expired' != g.code) throw g;
            });
          });
      };
      k.w = function () {
        return {
          multiFactor: {
            enrolledFactors: Ra(this.b, function (a) {
              return a.w();
            }),
          },
        };
      };
      function xm(a, b, c) {
        this.h = a;
        this.i = b;
        this.g = c;
        this.c = 3e4;
        this.f = 96e4;
        this.b = null;
        this.a = this.c;
        if (this.f < this.c) throw Error('Proactive refresh lower bound greater than upper bound!');
      }
      xm.prototype.start = function () {
        this.a = this.c;
        ym(this, !0);
      };
      function zm(a, b) {
        if (b) return (a.a = a.c), a.g();
        b = a.a;
        a.a *= 2;
        a.a > a.f && (a.a = a.f);
        return b;
      }
      function ym(a, b) {
        a.stop();
        a.b = Fd(zm(a, b))
          .then(function () {
            return af();
          })
          .then(function () {
            return a.h();
          })
          .then(function () {
            ym(a, !0);
          })
          .o(function (c) {
            a.i(c) && ym(a, !1);
          });
      }
      xm.prototype.stop = function () {
        this.b && (this.b.cancel(), (this.b = null));
      };
      function Am(a) {
        this.f = a;
        this.b = this.a = null;
        this.c = Date.now();
      }
      Am.prototype.w = function () {
        return { apiKey: this.f.c, refreshToken: this.a, accessToken: this.b && this.b.toString(), expirationTime: this.c };
      };
      function Bm(a, b) {
        'undefined' === typeof b && (a.b ? ((b = a.b), (b = b.a - b.g)) : (b = 0));
        a.c = Date.now() + 1e3 * b;
      }
      function Cm(a, b) {
        a.b = jg(b[Dg] || '');
        a.a = b.refreshToken;
        b = b.expiresIn;
        Bm(a, 'undefined' !== typeof b ? Number(b) : void 0);
      }
      function Dm(a, b) {
        a.b = b.b;
        a.a = b.a;
        a.c = b.c;
      }
      function Em(a, b) {
        return Wi(a.f, b)
          .then(function (c) {
            a.b = jg(c.access_token);
            a.a = c.refresh_token;
            Bm(a, c.expires_in);
            return { accessToken: a.b.toString(), refreshToken: a.a };
          })
          .o(function (c) {
            'auth/user-token-expired' == c.code && (a.a = null);
            throw c;
          });
      }
      Am.prototype.getToken = function (a) {
        a = !!a;
        return this.b && !this.a
          ? F(new t('user-token-expired'))
          : a || !this.b || Date.now() > this.c - 3e4
          ? this.a
            ? Em(this, { grant_type: 'refresh_token', refresh_token: this.a })
            : E(null)
          : E({ accessToken: this.b.toString(), refreshToken: this.a });
      };
      function Fm(a, b) {
        this.a = a || null;
        this.b = b || null;
        N(this, { lastSignInTime: bf(b || null), creationTime: bf(a || null) });
      }
      function Gm(a) {
        return new Fm(a.a, a.b);
      }
      Fm.prototype.w = function () {
        return { lastLoginAt: this.b, createdAt: this.a };
      };
      function Hm(a, b, c, d, e, f) {
        N(this, { uid: a, displayName: d || null, photoURL: e || null, email: c || null, phoneNumber: f || null, providerId: b });
      }
      function Im(a, b, c) {
        this.N = [];
        this.l = a.apiKey;
        this.m = a.appName;
        this.s = a.authDomain || null;
        var d = firebase.SDK_VERSION ? Oe(firebase.SDK_VERSION) : null;
        this.a = new Ii(this.l, Ca(Da), d);
        (this.u = a.emulatorConfig || null) && Pi(this.a, this.u);
        this.h = new Am(this.a);
        Jm(this, b[Dg]);
        Cm(this.h, b);
        M(this, 'refreshToken', this.h.a);
        Km(this, c || {});
        H.call(this);
        this.P = !1;
        this.s && Re() && (this.b = Xl(this.s, this.l, this.m, this.u));
        this.W = [];
        this.i = null;
        this.D = Lm(this);
        this.ba = q(this.ib, this);
        var e = this;
        this.za = null;
        this.Pa = function (f) {
          e.xa(f.h);
        };
        this.qa = null;
        this.Ba = function (f) {
          Mm(e, f.c);
        };
        this.$ = null;
        this.aa = [];
        this.Oa = function (f) {
          Nm(e, f.f);
        };
        this.ja = null;
        this.S = new tm(this, c);
        M(this, 'multiFactor', this.S);
      }
      r(Im, H);
      Im.prototype.xa = function (a) {
        this.za = a;
        Oi(this.a, a);
      };
      function Mm(a, b) {
        a.u = b;
        Pi(a.a, b);
        a.b && ((b = a.b), (a.b = Xl(a.s, a.l, a.m, a.u)), a.P && (Ql(b, a), Pl(a.b, a)));
      }
      Im.prototype.la = function () {
        return this.za;
      };
      function Om(a, b) {
        a.qa && xd(a.qa, 'languageCodeChanged', a.Pa);
        (a.qa = b) && nd(b, 'languageCodeChanged', a.Pa);
      }
      function Pm(a, b) {
        a.$ && xd(a.$, 'emulatorConfigChanged', a.Ba);
        (a.$ = b) && nd(b, 'emulatorConfigChanged', a.Ba);
      }
      function Nm(a, b) {
        a.aa = b;
        Ri(a.a, firebase.SDK_VERSION ? Oe(firebase.SDK_VERSION, a.aa) : null);
      }
      Im.prototype.Ga = function () {
        return Za(this.aa);
      };
      function Qm(a, b) {
        a.ja && xd(a.ja, 'frameworkChanged', a.Oa);
        (a.ja = b) && nd(b, 'frameworkChanged', a.Oa);
      }
      Im.prototype.ib = function () {
        this.D.b && (this.D.stop(), this.D.start());
      };
      function Rm(a) {
        try {
          return firebase.app(a.m).auth();
        } catch (b) {
          throw new t('internal-error', "No firebase.auth.Auth instance is available for the Firebase App '" + a.m + "'!");
        }
      }
      function Lm(a) {
        return new xm(
          function () {
            return a.I(!0);
          },
          function (b) {
            return b && 'auth/network-request-failed' == b.code ? !0 : !1;
          },
          function () {
            var b = a.h.c - Date.now() - 3e5;
            return 0 < b ? b : 0;
          },
        );
      }
      function Sm(a) {
        a.J || a.D.b || (a.D.start(), xd(a, 'tokenChanged', a.ba), nd(a, 'tokenChanged', a.ba));
      }
      function Tm(a) {
        xd(a, 'tokenChanged', a.ba);
        a.D.stop();
      }
      function Jm(a, b) {
        a.Aa = b;
        M(a, '_lat', b);
      }
      function Um(a, b) {
        Xa(a.W, function (c) {
          return c == b;
        });
      }
      function Vm(a) {
        for (var b = [], c = 0; c < a.W.length; c++) b.push(a.W[c](a));
        return Jc(b).then(function () {
          return a;
        });
      }
      function Wm(a) {
        a.b && !a.P && ((a.P = !0), Pl(a.b, a));
      }
      function Km(a, b) {
        N(a, {
          uid: b.uid,
          displayName: b.displayName || null,
          photoURL: b.photoURL || null,
          email: b.email || null,
          emailVerified: b.emailVerified || !1,
          phoneNumber: b.phoneNumber || null,
          isAnonymous: b.isAnonymous || !1,
          tenantId: b.tenantId || null,
          metadata: new Fm(b.createdAt, b.lastLoginAt),
          providerData: [],
        });
        a.a.b = a.tenantId;
      }
      M(Im.prototype, 'providerId', 'firebase');
      function Xm() {}
      function Ym(a) {
        return E().then(function () {
          if (a.J) throw new t('app-deleted');
        });
      }
      function Zm(a) {
        return Ra(a.providerData, function (b) {
          return b.providerId;
        });
      }
      function $m(a, b) {
        b && (an(a, b.providerId), a.providerData.push(b));
      }
      function an(a, b) {
        Xa(a.providerData, function (c) {
          return c.providerId == b;
        });
      }
      function bn(a, b, c) {
        ('uid' != b || c) && a.hasOwnProperty(b) && M(a, b, c);
      }
      function cn(a, b) {
        a != b &&
          (N(a, {
            uid: b.uid,
            displayName: b.displayName,
            photoURL: b.photoURL,
            email: b.email,
            emailVerified: b.emailVerified,
            phoneNumber: b.phoneNumber,
            isAnonymous: b.isAnonymous,
            tenantId: b.tenantId,
            providerData: [],
          }),
          b.metadata ? M(a, 'metadata', Gm(b.metadata)) : M(a, 'metadata', new Fm()),
          w(b.providerData, function (c) {
            $m(a, c);
          }),
          Dm(a.h, b.h),
          M(a, 'refreshToken', a.h.a),
          um(a.S, b.S.b));
      }
      k = Im.prototype;
      k.reload = function () {
        var a = this;
        return R(
          this,
          Ym(this).then(function () {
            return dn(a)
              .then(function () {
                return Vm(a);
              })
              .then(Xm);
          }),
        );
      };
      function dn(a) {
        return a.I().then(function (b) {
          var c = a.isAnonymous;
          return en(a, b).then(function () {
            c || bn(a, 'isAnonymous', !1);
            return b;
          });
        });
      }
      k.oc = function (a) {
        return this.I(a).then(function (b) {
          return new hm(b);
        });
      };
      k.I = function (a) {
        var b = this;
        return R(
          this,
          Ym(this)
            .then(function () {
              return b.h.getToken(a);
            })
            .then(function (c) {
              if (!c) throw new t('internal-error');
              c.accessToken != b.Aa && (Jm(b, c.accessToken), b.dispatchEvent(new sm('tokenChanged')));
              bn(b, 'refreshToken', c.refreshToken);
              return c.accessToken;
            }),
        );
      };
      function wm(a, b) {
        b[Dg] && a.Aa != b[Dg] && (Cm(a.h, b), a.dispatchEvent(new sm('tokenChanged')), Jm(a, b[Dg]), bn(a, 'refreshToken', a.h.a));
      }
      function en(a, b) {
        return O(a.a, Ij, { idToken: b }).then(q(a.Kc, a));
      }
      k.Kc = function (a) {
        a = a.users;
        if (!a || !a.length) throw new t('internal-error');
        a = a[0];
        Km(this, {
          uid: a.localId,
          displayName: a.displayName,
          photoURL: a.photoUrl,
          email: a.email,
          emailVerified: !!a.emailVerified,
          phoneNumber: a.phoneNumber,
          lastLoginAt: a.lastLoginAt,
          createdAt: a.createdAt,
          tenantId: a.tenantId,
        });
        for (var b = fn(a), c = 0; c < b.length; c++) $m(this, b[c]);
        bn(this, 'isAnonymous', !(this.email && a.passwordHash) && !(this.providerData && this.providerData.length));
        this.dispatchEvent(new sm('userReloaded', { hd: a }));
      };
      function fn(a) {
        return (a = a.providerUserInfo) && a.length
          ? Ra(a, function (b) {
              return new Hm(b.rawId, b.providerId, b.email, b.displayName, b.photoUrl, b.phoneNumber);
            })
          : [];
      }
      k.Lc = function (a) {
        gf('firebase.User.prototype.reauthenticateAndRetrieveDataWithCredential is deprecated. Please use firebase.User.prototype.reauthenticateWithCredential instead.');
        return this.ub(a);
      };
      k.ub = function (a) {
        var b = this,
          c = null;
        return R(
          this,
          a
            .c(this.a, this.uid)
            .then(function (d) {
              wm(b, d);
              c = gn(b, d, 'reauthenticate');
              b.i = null;
              return b.reload();
            })
            .then(function () {
              return c;
            }),
          !0,
        );
      };
      function hn(a, b) {
        return dn(a).then(function () {
          if (Va(Zm(a), b))
            return Vm(a).then(function () {
              throw new t('provider-already-linked');
            });
        });
      }
      k.Cc = function (a) {
        gf('firebase.User.prototype.linkAndRetrieveDataWithCredential is deprecated. Please use firebase.User.prototype.linkWithCredential instead.');
        return this.rb(a);
      };
      k.rb = function (a) {
        var b = this,
          c = null;
        return R(
          this,
          hn(this, a.providerId)
            .then(function () {
              return b.I();
            })
            .then(function (d) {
              return a.b(b.a, d);
            })
            .then(function (d) {
              c = gn(b, d, 'link');
              return jn(b, d);
            })
            .then(function () {
              return c;
            }),
        );
      };
      k.Dc = function (a, b) {
        var c = this;
        return R(
          this,
          hn(this, 'phone').then(function () {
            return gm(Rm(c), a, b, q(c.rb, c));
          }),
        );
      };
      k.Mc = function (a, b) {
        var c = this;
        return R(
          this,
          E().then(function () {
            return gm(Rm(c), a, b, q(c.ub, c));
          }),
          !0,
        );
      };
      function gn(a, b, c) {
        var d = qh(b);
        b = og(b);
        return kf({ user: a, credential: d, additionalUserInfo: b, operationType: c });
      }
      function jn(a, b) {
        wm(a, b);
        return a.reload().then(function () {
          return a;
        });
      }
      k.Cb = function (a) {
        var b = this;
        return R(
          this,
          this.I()
            .then(function (c) {
              return b.a.Cb(c, a);
            })
            .then(function (c) {
              wm(b, c);
              return b.reload();
            }),
        );
      };
      k.ed = function (a) {
        var b = this;
        return R(
          this,
          this.I()
            .then(function (c) {
              return a.b(b.a, c);
            })
            .then(function (c) {
              wm(b, c);
              return b.reload();
            }),
        );
      };
      k.Db = function (a) {
        var b = this;
        return R(
          this,
          this.I()
            .then(function (c) {
              return b.a.Db(c, a);
            })
            .then(function (c) {
              wm(b, c);
              return b.reload();
            }),
        );
      };
      k.Eb = function (a) {
        if (void 0 === a.displayName && void 0 === a.photoURL) return Ym(this);
        var b = this;
        return R(
          this,
          this.I()
            .then(function (c) {
              return b.a.Eb(c, { displayName: a.displayName, photoUrl: a.photoURL });
            })
            .then(function (c) {
              wm(b, c);
              bn(b, 'displayName', c.displayName || null);
              bn(b, 'photoURL', c.photoUrl || null);
              w(b.providerData, function (d) {
                'password' === d.providerId && (M(d, 'displayName', b.displayName), M(d, 'photoURL', b.photoURL));
              });
              return Vm(b);
            })
            .then(Xm),
        );
      };
      k.cd = function (a) {
        var b = this;
        return R(
          this,
          dn(this).then(function (c) {
            return Va(Zm(b), a)
              ? rj(b.a, c, [a]).then(function (d) {
                  var e = {};
                  w(d.providerUserInfo || [], function (f) {
                    e[f.providerId] = !0;
                  });
                  w(Zm(b), function (f) {
                    e[f] || an(b, f);
                  });
                  e[lh.PROVIDER_ID] || M(b, 'phoneNumber', null);
                  return Vm(b);
                })
              : Vm(b).then(function () {
                  throw new t('no-such-provider');
                });
          }),
        );
      };
      k.delete = function () {
        var a = this;
        return R(
          this,
          this.I()
            .then(function (b) {
              return O(a.a, Fj, { idToken: b });
            })
            .then(function () {
              a.dispatchEvent(new sm('userDeleted'));
            }),
        ).then(function () {
          for (var b = 0; b < a.N.length; b++) a.N[b].cancel('app-deleted');
          Om(a, null);
          Pm(a, null);
          Qm(a, null);
          a.N = [];
          a.J = !0;
          Tm(a);
          M(a, 'refreshToken', null);
          a.b && Ql(a.b, a);
        });
      };
      k.Gb = function (a, b) {
        return ('linkViaPopup' == a && (this.g || null) == b && this.f) ||
          ('reauthViaPopup' == a && (this.g || null) == b && this.f) ||
          ('linkViaRedirect' == a && (this.ga || null) == b) ||
          ('reauthViaRedirect' == a && (this.ga || null) == b)
          ? !0
          : !1;
      };
      k.na = function (a, b, c, d) {
        ('linkViaPopup' != a && 'reauthViaPopup' != a) ||
          d != (this.g || null) ||
          (c && this.C ? this.C(c) : b && !c && this.f && this.f(b), this.c && (this.c.cancel(), (this.c = null)), delete this.f, delete this.C);
      };
      k.Fa = function (a, b) {
        return 'linkViaPopup' == a && b == (this.g || null)
          ? q(this.Lb, this)
          : 'reauthViaPopup' == a && b == (this.g || null)
          ? q(this.Mb, this)
          : 'linkViaRedirect' == a && (this.ga || null) == b
          ? q(this.Lb, this)
          : 'reauthViaRedirect' == a && (this.ga || null) == b
          ? q(this.Mb, this)
          : null;
      };
      k.Ec = function (a) {
        var b = this;
        return kn(
          this,
          'linkViaPopup',
          a,
          function () {
            return hn(b, a.providerId).then(function () {
              return Vm(b);
            });
          },
          !1,
        );
      };
      k.Nc = function (a) {
        return kn(
          this,
          'reauthViaPopup',
          a,
          function () {
            return E();
          },
          !0,
        );
      };
      function kn(a, b, c, d, e) {
        if (!Re()) return F(new t('operation-not-supported-in-this-environment'));
        if (a.i && !e) return F(a.i);
        var f = ng(c.providerId),
          g = Qe(a.uid + ':::'),
          h = null;
        (!Te() || Ie()) && a.s && c.isOAuthProvider && (h = ek(a.s, a.l, a.m, b, c, null, g, firebase.SDK_VERSION || null, null, null, a.tenantId, a.u));
        var m = ze(h, f && f.va, f && f.ua);
        d = d()
          .then(function () {
            ln(a);
            if (!e) return a.I().then(function () {});
          })
          .then(function () {
            return Tl(a.b, m, b, c, g, !!h, a.tenantId);
          })
          .then(function () {
            return new D(function (p, v) {
              a.na(b, null, new t('cancelled-popup-request'), a.g || null);
              a.f = p;
              a.C = v;
              a.g = g;
              a.c = Vl(a.b, a, b, m, g);
            });
          })
          .then(function (p) {
            m && ye(m);
            return p ? kf(p) : null;
          })
          .o(function (p) {
            m && ye(m);
            throw p;
          });
        return R(a, d, e);
      }
      k.Fc = function (a) {
        var b = this;
        return mn(
          this,
          'linkViaRedirect',
          a,
          function () {
            return hn(b, a.providerId);
          },
          !1,
        );
      };
      k.Oc = function (a) {
        return mn(
          this,
          'reauthViaRedirect',
          a,
          function () {
            return E();
          },
          !0,
        );
      };
      function mn(a, b, c, d, e) {
        if (!Re()) return F(new t('operation-not-supported-in-this-environment'));
        if (a.i && !e) return F(a.i);
        var f = null,
          g = Qe(a.uid + ':::');
        d = d()
          .then(function () {
            ln(a);
            if (!e) return a.I().then(function () {});
          })
          .then(function () {
            a.ga = g;
            return Vm(a);
          })
          .then(function (h) {
            a.ha && ((h = a.ha), (h = h.b.set(nn, a.w(), h.a)));
            return h;
          })
          .then(function () {
            return Ul(a.b, b, c, g, a.tenantId);
          })
          .o(function (h) {
            f = h;
            if (a.ha) return on(a.ha);
            throw f;
          })
          .then(function () {
            if (f) throw f;
          });
        return R(a, d, e);
      }
      function ln(a) {
        if (!a.b || !a.P) {
          if (a.b && !a.P) throw new t('internal-error');
          throw new t('auth-domain-config-required');
        }
      }
      k.Lb = function (a, b, c, d) {
        var e = this;
        this.c && (this.c.cancel(), (this.c = null));
        var f = null;
        c = this.I()
          .then(function (g) {
            return Hg(e.a, { requestUri: a, postBody: d, sessionId: b, idToken: g });
          })
          .then(function (g) {
            f = gn(e, g, 'link');
            return jn(e, g);
          })
          .then(function () {
            return f;
          });
        return R(this, c);
      };
      k.Mb = function (a, b, c, d) {
        var e = this;
        this.c && (this.c.cancel(), (this.c = null));
        var f = null,
          g = E()
            .then(function () {
              return Cg(Ig(e.a, { requestUri: a, sessionId: b, postBody: d, tenantId: c }), e.uid);
            })
            .then(function (h) {
              f = gn(e, h, 'reauthenticate');
              wm(e, h);
              e.i = null;
              return e.reload();
            })
            .then(function () {
              return f;
            });
        return R(this, g, !0);
      };
      k.vb = function (a) {
        var b = this,
          c = null;
        return R(
          this,
          this.I()
            .then(function (d) {
              c = d;
              return 'undefined' === typeof a || mb(a) ? {} : bg(new Sf(a));
            })
            .then(function (d) {
              return b.a.vb(c, d);
            })
            .then(function (d) {
              if (b.email != d) return b.reload();
            })
            .then(function () {}),
        );
      };
      k.Fb = function (a, b) {
        var c = this,
          d = null;
        return R(
          this,
          this.I()
            .then(function (e) {
              d = e;
              return 'undefined' === typeof b || mb(b) ? {} : bg(new Sf(b));
            })
            .then(function (e) {
              return c.a.Fb(d, a, e);
            })
            .then(function (e) {
              if (c.email != e) return c.reload();
            })
            .then(function () {}),
        );
      };
      function R(a, b, c) {
        var d = pn(a, b, c);
        a.N.push(d);
        d.oa(function () {
          Wa(a.N, d);
        });
        return d.o(function (e) {
          var f = null;
          e && 'auth/multi-factor-auth-required' === e.code && (f = mm(e.w(), Rm(a), q(a.jc, a)));
          throw f || e;
        });
      }
      k.jc = function (a) {
        var b = null,
          c = this;
        a = Cg(E(a), c.uid)
          .then(function (d) {
            b = gn(c, d, 'reauthenticate');
            wm(c, d);
            c.i = null;
            return c.reload();
          })
          .then(function () {
            return b;
          });
        return R(this, a, !0);
      };
      function pn(a, b, c) {
        return a.i && !c
          ? (b.cancel(), F(a.i))
          : b.o(function (d) {
              !d || ('auth/user-disabled' != d.code && 'auth/user-token-expired' != d.code) || (a.i || a.dispatchEvent(new sm('userInvalidated')), (a.i = d));
              throw d;
            });
      }
      k.toJSON = function () {
        return this.w();
      };
      k.w = function () {
        var a = {
          uid: this.uid,
          displayName: this.displayName,
          photoURL: this.photoURL,
          email: this.email,
          emailVerified: this.emailVerified,
          phoneNumber: this.phoneNumber,
          isAnonymous: this.isAnonymous,
          tenantId: this.tenantId,
          providerData: [],
          apiKey: this.l,
          appName: this.m,
          authDomain: this.s,
          stsTokenManager: this.h.w(),
          redirectEventId: this.ga || null,
        };
        this.metadata && z(a, this.metadata.w());
        w(this.providerData, function (b) {
          a.providerData.push(lf(b));
        });
        z(a, this.S.w());
        return a;
      };
      function qn(a) {
        if (!a.apiKey) return null;
        var b = { apiKey: a.apiKey, authDomain: a.authDomain, appName: a.appName, emulatorConfig: a.emulatorConfig },
          c = {};
        if (a.stsTokenManager && a.stsTokenManager.accessToken) {
          c[Dg] = a.stsTokenManager.accessToken;
          c.refreshToken = a.stsTokenManager.refreshToken || null;
          var d = a.stsTokenManager.expirationTime;
          d && (c.expiresIn = (d - Date.now()) / 1e3);
        } else return null;
        var e = new Im(b, c, a);
        a.providerData &&
          w(a.providerData, function (f) {
            f && $m(e, kf(f));
          });
        a.redirectEventId && (e.ga = a.redirectEventId);
        return e;
      }
      function rn(a, b, c, d) {
        var e = new Im(a, b);
        c && (e.ha = c);
        d && Nm(e, d);
        return e.reload().then(function () {
          return e;
        });
      }
      function sn(a, b, c, d) {
        var e = a.h,
          f = {};
        f[Dg] = e.b && e.b.toString();
        f.refreshToken = e.a;
        b = new Im(b || { apiKey: a.l, authDomain: a.s, appName: a.m }, f);
        c && (b.ha = c);
        d && Nm(b, d);
        cn(b, a);
        return b;
      }
      function tn(a) {
        this.a = a;
        this.b = Vk();
      }
      var nn = { name: 'redirectUser', F: 'session' };
      function on(a) {
        return Zk(a.b, nn, a.a);
      }
      function un(a, b) {
        return a.b.get(nn, a.a).then(function (c) {
          c && b && (c.authDomain = b);
          return qn(c || {});
        });
      }
      function vn(a) {
        this.a = a;
        this.b = Vk();
        this.c = null;
        this.f = wn(this);
        this.b.addListener(xn('local'), this.a, q(this.g, this));
      }
      vn.prototype.g = function () {
        var a = this,
          b = xn('local');
        yn(this, function () {
          return E()
            .then(function () {
              return a.c && 'local' != a.c.F ? a.b.get(b, a.a) : null;
            })
            .then(function (c) {
              if (c)
                return zn(a, 'local').then(function () {
                  a.c = b;
                });
            });
        });
      };
      function zn(a, b) {
        var c = [],
          d;
        for (d in Rk) Rk[d] !== b && c.push(Zk(a.b, xn(Rk[d]), a.a));
        c.push(Zk(a.b, An, a.a));
        return Ic(c);
      }
      function wn(a) {
        var b = xn('local'),
          c = xn('session'),
          d = xn('none');
        return Yk(a.b, b, a.a)
          .then(function () {
            return a.b.get(c, a.a);
          })
          .then(function (e) {
            return e
              ? c
              : a.b.get(d, a.a).then(function (f) {
                  return f
                    ? d
                    : a.b.get(b, a.a).then(function (g) {
                        return g
                          ? b
                          : a.b.get(An, a.a).then(function (h) {
                              return h ? xn(h) : b;
                            });
                      });
                });
          })
          .then(function (e) {
            a.c = e;
            return zn(a, e.F);
          })
          .o(function () {
            a.c || (a.c = b);
          });
      }
      var An = { name: 'persistence', F: 'session' };
      function xn(a) {
        return { name: 'authUser', F: a };
      }
      vn.prototype.yb = function (a) {
        var b = null,
          c = this;
        Sk(a);
        return yn(this, function () {
          return a != c.c.F
            ? c.b
                .get(c.c, c.a)
                .then(function (d) {
                  b = d;
                  return zn(c, a);
                })
                .then(function () {
                  c.c = xn(a);
                  if (b) return c.b.set(c.c, b, c.a);
                })
            : E();
        });
      };
      function Bn(a) {
        return yn(a, function () {
          return a.b.set(An, a.c.F, a.a);
        });
      }
      function Cn(a, b) {
        return yn(a, function () {
          return a.b.set(a.c, b.w(), a.a);
        });
      }
      function Dn(a) {
        return yn(a, function () {
          return Zk(a.b, a.c, a.a);
        });
      }
      function En(a, b, c) {
        return yn(a, function () {
          return a.b.get(a.c, a.a).then(function (d) {
            d && b && (d.authDomain = b);
            d && c && (d.emulatorConfig = c);
            return qn(d || {});
          });
        });
      }
      function yn(a, b) {
        a.f = a.f.then(b, b);
        return a.f;
      }
      function Fn(a) {
        this.l = !1;
        M(this, 'settings', new em());
        M(this, 'app', a);
        if (S(this).options && S(this).options.apiKey)
          (a = firebase.SDK_VERSION ? Oe(firebase.SDK_VERSION) : null), (this.a = new Ii(S(this).options && S(this).options.apiKey, Ca(Da), a));
        else throw new t('invalid-api-key');
        this.P = [];
        this.s = [];
        this.N = [];
        this.Pa = firebase.INTERNAL.createSubscribe(q(this.zc, this));
        this.W = void 0;
        this.ib = firebase.INTERNAL.createSubscribe(q(this.Ac, this));
        Gn(this, null);
        this.i = new vn(S(this).options.apiKey + ':' + S(this).name);
        this.D = new tn(S(this).options.apiKey + ':' + S(this).name);
        this.$ = T(this, Hn(this));
        this.h = T(this, In(this));
        this.ba = !1;
        this.ja = q(this.Zc, this);
        this.Ba = q(this.da, this);
        this.qa = q(this.mc, this);
        this.za = q(this.wc, this);
        this.Aa = q(this.xc, this);
        this.b = null;
        Jn(this);
        this.INTERNAL = {};
        this.INTERNAL['delete'] = q(this.delete, this);
        this.INTERNAL.logFramework = q(this.Gc, this);
        this.u = 0;
        H.call(this);
        Kn(this);
        this.J = [];
        this.R = null;
      }
      r(Fn, H);
      function Ln(a) {
        G.call(this, 'languageCodeChanged');
        this.h = a;
      }
      r(Ln, G);
      function Mn(a) {
        G.call(this, 'emulatorConfigChanged');
        this.c = a;
      }
      r(Mn, G);
      function Nn(a) {
        G.call(this, 'frameworkChanged');
        this.f = a;
      }
      r(Nn, G);
      k = Fn.prototype;
      k.yb = function (a) {
        a = this.i.yb(a);
        return T(this, a);
      };
      k.xa = function (a) {
        this.aa === a || this.l || ((this.aa = a), Oi(this.a, this.aa), this.dispatchEvent(new Ln(this.la())));
      };
      k.la = function () {
        return this.aa;
      };
      k.fd = function () {
        var a = l.navigator;
        this.xa(a ? (a.languages && a.languages[0]) || a.language || a.userLanguage || null : null);
      };
      k.gd = function (a, b) {
        if (!this.R) {
          if (!/^https?:\/\//.test(a)) throw new t('argument-error', 'Emulator URL must start with a valid scheme (http:// or https://).');
          b = b ? !!b.disableWarnings : !1;
          On(b);
          this.R = { url: a, ec: b };
          this.settings.jb = !0;
          Pi(this.a, this.R);
          this.dispatchEvent(new Mn(this.R));
        }
      };
      function On(a) {
        'undefined' !== typeof console &&
          'function' === typeof console.info &&
          console.info('WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.');
        l.document &&
          !a &&
          Ee().then(function () {
            var b = l.document.createElement('div');
            b.innerText = 'Running in emulator mode. Do not use with production credentials.';
            b.style.position = 'fixed';
            b.style.width = '100%';
            b.style.backgroundColor = '#ffffff';
            b.style.border = '.1em solid #000000';
            b.style.color = '#b50000';
            b.style.bottom = '0px';
            b.style.left = '0px';
            b.style.margin = '0px';
            b.style.zIndex = 1e4;
            b.style.textAlign = 'center';
            b.classList.add('firebase-emulator-warning');
            l.document.body.appendChild(b);
          });
      }
      k.Gc = function (a) {
        this.J.push(a);
        Ri(this.a, firebase.SDK_VERSION ? Oe(firebase.SDK_VERSION, this.J) : null);
        this.dispatchEvent(new Nn(this.J));
      };
      k.Ga = function () {
        return Za(this.J);
      };
      k.zb = function (a) {
        this.S === a || this.l || ((this.S = a), (this.a.b = this.S));
      };
      k.T = function () {
        return this.S;
      };
      function Kn(a) {
        Object.defineProperty(a, 'lc', {
          get: function () {
            return this.la();
          },
          set: function (b) {
            this.xa(b);
          },
          enumerable: !1,
        });
        a.aa = null;
        Object.defineProperty(a, 'ti', {
          get: function () {
            return this.T();
          },
          set: function (b) {
            this.zb(b);
          },
          enumerable: !1,
        });
        a.S = null;
        Object.defineProperty(a, 'emulatorConfig', {
          get: function () {
            if (this.R) {
              var b = J(this.R.url);
              b = kf({ protocol: b.c, host: b.a, port: b.g, options: kf({ disableWarnings: this.R.ec }) });
            } else b = null;
            return b;
          },
          enumerable: !1,
        });
      }
      k.toJSON = function () {
        return { apiKey: S(this).options.apiKey, authDomain: S(this).options.authDomain, appName: S(this).name, currentUser: U(this) && U(this).w() };
      };
      function Pn(a) {
        return a.Oa || F(new t('auth-domain-config-required'));
      }
      function Jn(a) {
        var b = S(a).options.authDomain,
          c = S(a).options.apiKey;
        b &&
          Re() &&
          (a.Oa = a.$.then(function () {
            if (!a.l) {
              a.b = Xl(b, c, S(a).name, a.R);
              Pl(a.b, a);
              U(a) && Wm(U(a));
              if (a.m) {
                Wm(a.m);
                var d = a.m;
                d.xa(a.la());
                Om(d, a);
                d = a.m;
                Nm(d, a.J);
                Qm(d, a);
                d = a.m;
                Mm(d, a.R);
                Pm(d, a);
                a.m = null;
              }
              return a.b;
            }
          }));
      }
      k.Gb = function (a, b) {
        switch (a) {
          case 'unknown':
          case 'signInViaRedirect':
            return !0;
          case 'signInViaPopup':
            return this.g == b && !!this.f;
          default:
            return !1;
        }
      };
      k.na = function (a, b, c, d) {
        'signInViaPopup' == a &&
          this.g == d &&
          (c && this.C ? this.C(c) : b && !c && this.f && this.f(b), this.c && (this.c.cancel(), (this.c = null)), delete this.f, delete this.C);
      };
      k.Fa = function (a, b) {
        return 'signInViaRedirect' == a || ('signInViaPopup' == a && this.g == b && this.f) ? q(this.ic, this) : null;
      };
      k.ic = function (a, b, c, d) {
        var e = this,
          f = { requestUri: a, postBody: d, sessionId: b, tenantId: c };
        this.c && (this.c.cancel(), (this.c = null));
        return e.$.then(function () {
          return Qn(e, Fg(e.a, f));
        });
      };
      k.Xc = function (a) {
        if (!Re()) return F(new t('operation-not-supported-in-this-environment'));
        var b = this,
          c = ng(a.providerId),
          d = Qe(),
          e = null;
        (!Te() || Ie()) &&
          S(this).options.authDomain &&
          a.isOAuthProvider &&
          (e = ek(S(this).options.authDomain, S(this).options.apiKey, S(this).name, 'signInViaPopup', a, null, d, firebase.SDK_VERSION || null, null, null, this.T(), this.R));
        var f = ze(e, c && c.va, c && c.ua);
        c = Pn(this)
          .then(function (g) {
            return Tl(g, f, 'signInViaPopup', a, d, !!e, b.T());
          })
          .then(function () {
            return new D(function (g, h) {
              b.na('signInViaPopup', null, new t('cancelled-popup-request'), b.g);
              b.f = g;
              b.C = h;
              b.g = d;
              b.c = Vl(b.b, b, 'signInViaPopup', f, d);
            });
          })
          .then(function (g) {
            f && ye(f);
            return g ? kf(g) : null;
          })
          .o(function (g) {
            f && ye(f);
            throw g;
          });
        return T(this, c);
      };
      k.Yc = function (a) {
        if (!Re()) return F(new t('operation-not-supported-in-this-environment'));
        var b = this,
          c = Pn(this)
            .then(function () {
              return Bn(b.i);
            })
            .then(function () {
              return Ul(b.b, 'signInViaRedirect', a, void 0, b.T());
            });
        return T(this, c);
      };
      function Rn(a) {
        if (!Re()) return F(new t('operation-not-supported-in-this-environment'));
        var b = Pn(a)
          .then(function () {
            return a.b.ra();
          })
          .then(function (c) {
            return c ? kf(c) : null;
          });
        return T(a, b);
      }
      k.ra = function () {
        var a = this;
        return Rn(this)
          .then(function (b) {
            a.b && $l(a.b.b);
            return b;
          })
          .o(function (b) {
            a.b && $l(a.b.b);
            throw b;
          });
      };
      k.dd = function (a) {
        if (!a) return F(new t('null-user'));
        if (this.S != a.tenantId) return F(new t('tenant-id-mismatch'));
        var b = this,
          c = {};
        c.apiKey = S(this).options.apiKey;
        c.authDomain = S(this).options.authDomain;
        c.appName = S(this).name;
        var d = sn(a, c, b.D, b.Ga());
        return T(
          this,
          this.h
            .then(function () {
              if (S(b).options.apiKey != a.l) return d.reload();
            })
            .then(function () {
              if (U(b) && a.uid == U(b).uid) return cn(U(b), a), b.da(a);
              Gn(b, d);
              Wm(d);
              return b.da(d);
            })
            .then(function () {
              Sn(b);
            }),
        );
      };
      function Tn(a, b) {
        var c = {};
        c.apiKey = S(a).options.apiKey;
        c.authDomain = S(a).options.authDomain;
        c.appName = S(a).name;
        a.R && (c.emulatorConfig = a.R);
        return a.$.then(function () {
          return rn(c, b, a.D, a.Ga());
        })
          .then(function (d) {
            if (U(a) && d.uid == U(a).uid) return cn(U(a), d), a.da(d);
            Gn(a, d);
            Wm(d);
            return a.da(d);
          })
          .then(function () {
            Sn(a);
          });
      }
      function Gn(a, b) {
        U(a) && (Um(U(a), a.Ba), xd(U(a), 'tokenChanged', a.qa), xd(U(a), 'userDeleted', a.za), xd(U(a), 'userInvalidated', a.Aa), Tm(U(a)));
        b && (b.W.push(a.Ba), nd(b, 'tokenChanged', a.qa), nd(b, 'userDeleted', a.za), nd(b, 'userInvalidated', a.Aa), 0 < a.u && Sm(b));
        M(a, 'currentUser', b);
        b && (b.xa(a.la()), Om(b, a), Nm(b, a.J), Qm(b, a), Mm(b, a.R), Pm(b, a));
      }
      k.Bb = function () {
        var a = this,
          b = this.h.then(function () {
            a.b && $l(a.b.b);
            if (!U(a)) return E();
            Gn(a, null);
            return Dn(a.i).then(function () {
              Sn(a);
            });
          });
        return T(this, b);
      };
      function Un(a) {
        var b = un(a.D, S(a).options.authDomain).then(function (c) {
          if ((a.m = c)) c.ha = a.D;
          return on(a.D);
        });
        return T(a, b);
      }
      function Hn(a) {
        var b = S(a).options.authDomain,
          c = Un(a)
            .then(function () {
              return En(a.i, b, a.R);
            })
            .then(function (d) {
              return d
                ? ((d.ha = a.D),
                  a.m && (a.m.ga || null) == (d.ga || null)
                    ? d
                    : d
                        .reload()
                        .then(function () {
                          return Cn(a.i, d).then(function () {
                            return d;
                          });
                        })
                        .o(function (e) {
                          return 'auth/network-request-failed' == e.code ? d : Dn(a.i);
                        }))
                : null;
            })
            .then(function (d) {
              Gn(a, d || null);
            });
        return T(a, c);
      }
      function In(a) {
        return a.$.then(function () {
          return Rn(a);
        })
          .o(function () {})
          .then(function () {
            if (!a.l) return a.ja();
          })
          .o(function () {})
          .then(function () {
            if (!a.l) {
              a.ba = !0;
              var b = a.i;
              b.b.addListener(xn('local'), b.a, a.ja);
            }
          });
      }
      k.Zc = function () {
        var a = this;
        return En(this.i, S(this).options.authDomain).then(function (b) {
          if (!a.l) {
            var c;
            if ((c = U(a) && b)) {
              c = U(a).uid;
              var d = b.uid;
              c = void 0 === c || null === c || '' === c || void 0 === d || null === d || '' === d ? !1 : c == d;
            }
            if (c) return cn(U(a), b), U(a).I();
            if (U(a) || b) Gn(a, b), b && (Wm(b), (b.ha = a.D)), a.b && Pl(a.b, a), Sn(a);
          }
        });
      };
      k.da = function (a) {
        return Cn(this.i, a);
      };
      k.mc = function () {
        Sn(this);
        this.da(U(this));
      };
      k.wc = function () {
        this.Bb();
      };
      k.xc = function () {
        this.Bb();
      };
      function Qn(a, b) {
        var c = null,
          d = null;
        return T(
          a,
          b
            .then(
              function (e) {
                c = qh(e);
                d = og(e);
                return Tn(a, e);
              },
              function (e) {
                var f = null;
                e && 'auth/multi-factor-auth-required' === e.code && (f = mm(e.w(), a, q(a.kc, a)));
                throw f || e;
              },
            )
            .then(function () {
              return kf({ user: U(a), credential: c, additionalUserInfo: d, operationType: 'signIn' });
            }),
        );
      }
      k.kc = function (a) {
        var b = this;
        return this.h.then(function () {
          return Qn(b, E(a));
        });
      };
      k.zc = function (a) {
        var b = this;
        this.addAuthTokenListener(function () {
          a.next(U(b));
        });
      };
      k.Ac = function (a) {
        var b = this;
        Vn(this, function () {
          a.next(U(b));
        });
      };
      k.Ic = function (a, b, c) {
        var d = this;
        this.ba &&
          Promise.resolve().then(function () {
            'function' === typeof a ? a(U(d)) : 'function' === typeof a.next && a.next(U(d));
          });
        return this.Pa(a, b, c);
      };
      k.Hc = function (a, b, c) {
        var d = this;
        this.ba &&
          Promise.resolve().then(function () {
            d.W = d.getUid();
            'function' === typeof a ? a(U(d)) : 'function' === typeof a.next && a.next(U(d));
          });
        return this.ib(a, b, c);
      };
      k.nc = function (a) {
        var b = this,
          c = this.h.then(function () {
            return U(b)
              ? U(b)
                  .I(a)
                  .then(function (d) {
                    return { accessToken: d };
                  })
              : null;
          });
        return T(this, c);
      };
      k.Tc = function (a) {
        var b = this;
        return this.h
          .then(function () {
            return Qn(b, O(b.a, Kj, { token: a }));
          })
          .then(function (c) {
            var d = c.user;
            bn(d, 'isAnonymous', !1);
            b.da(d);
            return c;
          });
      };
      k.Uc = function (a, b) {
        var c = this;
        return this.h.then(function () {
          return Qn(c, O(c.a, ah, { email: a, password: b }));
        });
      };
      k.dc = function (a, b) {
        var c = this;
        return this.h.then(function () {
          return Qn(c, O(c.a, Ej, { email: a, password: b }));
        });
      };
      k.ab = function (a) {
        var b = this;
        return this.h.then(function () {
          return Qn(b, a.ka(b.a));
        });
      };
      k.Sc = function (a) {
        gf('firebase.auth.Auth.prototype.signInAndRetrieveDataWithCredential is deprecated. Please use firebase.auth.Auth.prototype.signInWithCredential instead.');
        return this.ab(a);
      };
      k.Ab = function () {
        var a = this;
        return this.h.then(function () {
          var b = U(a);
          if (b && b.isAnonymous) {
            var c = kf({ providerId: null, isNewUser: !1 });
            return kf({ user: b, credential: null, additionalUserInfo: c, operationType: 'signIn' });
          }
          return Qn(a, a.a.Ab()).then(function (d) {
            var e = d.user;
            bn(e, 'isAnonymous', !0);
            a.da(e);
            return d;
          });
        });
      };
      function S(a) {
        return a.app;
      }
      function U(a) {
        return a.currentUser;
      }
      k.getUid = function () {
        return (U(this) && U(this).uid) || null;
      };
      function Wn(a) {
        return (U(a) && U(a)._lat) || null;
      }
      function Sn(a) {
        if (a.ba) {
          for (var b = 0; b < a.s.length; b++) if (a.s[b]) a.s[b](Wn(a));
          if (a.W !== a.getUid() && a.N.length) for (a.W = a.getUid(), b = 0; b < a.N.length; b++) if (a.N[b]) a.N[b](Wn(a));
        }
      }
      k.cc = function (a) {
        this.addAuthTokenListener(a);
        this.u++;
        0 < this.u && U(this) && Sm(U(this));
      };
      k.Pc = function (a) {
        var b = this;
        w(this.s, function (c) {
          c == a && b.u--;
        });
        0 > this.u && (this.u = 0);
        0 == this.u && U(this) && Tm(U(this));
        this.removeAuthTokenListener(a);
      };
      k.addAuthTokenListener = function (a) {
        var b = this;
        this.s.push(a);
        T(
          this,
          this.h.then(function () {
            b.l || (Va(b.s, a) && a(Wn(b)));
          }),
        );
      };
      k.removeAuthTokenListener = function (a) {
        Xa(this.s, function (b) {
          return b == a;
        });
      };
      function Vn(a, b) {
        a.N.push(b);
        T(
          a,
          a.h.then(function () {
            !a.l && Va(a.N, b) && a.W !== a.getUid() && ((a.W = a.getUid()), b(Wn(a)));
          }),
        );
      }
      k.delete = function () {
        this.l = !0;
        for (var a = 0; a < this.P.length; a++) this.P[a].cancel('app-deleted');
        this.P = [];
        this.i && ((a = this.i), a.b.removeListener(xn('local'), a.a, this.ja));
        this.b && (Ql(this.b, this), $l(this.b.b));
        return Promise.resolve();
      };
      function T(a, b) {
        a.P.push(b);
        b.oa(function () {
          Wa(a.P, b);
        });
        return b;
      }
      k.hc = function (a) {
        return T(this, aj(this.a, a));
      };
      k.Bc = function (a) {
        return !!fh(a);
      };
      k.xb = function (a, b) {
        var c = this;
        return T(
          this,
          E()
            .then(function () {
              var d = new Sf(b);
              if (!d.c) throw new t('argument-error', $f + ' must be true when sending sign in link to email');
              return bg(d);
            })
            .then(function (d) {
              return c.a.xb(a, d);
            })
            .then(function () {}),
        );
      };
      k.jd = function (a) {
        return this.Sa(a).then(function (b) {
          return b.data.email;
        });
      };
      k.ob = function (a, b) {
        return T(
          this,
          this.a.ob(a, b).then(function () {}),
        );
      };
      k.Sa = function (a) {
        return T(
          this,
          this.a.Sa(a).then(function (b) {
            return new vf(b);
          }),
        );
      };
      k.kb = function (a) {
        return T(
          this,
          this.a.kb(a).then(function () {}),
        );
      };
      k.wb = function (a, b) {
        var c = this;
        return T(
          this,
          E()
            .then(function () {
              return 'undefined' === typeof b || mb(b) ? {} : bg(new Sf(b));
            })
            .then(function (d) {
              return c.a.wb(a, d);
            })
            .then(function () {}),
        );
      };
      k.Wc = function (a, b) {
        return T(this, gm(this, a, b, q(this.ab, this)));
      };
      k.Vc = function (a, b) {
        var c = this;
        return T(
          this,
          E().then(function () {
            var d = b || re(),
              e = eh(a, d);
            d = fh(d);
            if (!d) throw new t('argument-error', 'Invalid email link!');
            if (d.tenantId !== c.T()) throw new t('tenant-id-mismatch');
            return c.ab(e);
          }),
        );
      };
      function Xn() {}
      Xn.prototype.render = function () {};
      Xn.prototype.reset = function () {};
      Xn.prototype.getResponse = function () {};
      Xn.prototype.execute = function () {};
      function Yn() {
        this.a = {};
        this.b = 1e12;
      }
      var Zn = null;
      Yn.prototype.render = function (a, b) {
        this.a[this.b.toString()] = new $n(a, b);
        return this.b++;
      };
      Yn.prototype.reset = function (a) {
        var b = ao(this, a);
        a = bo(a);
        b && a && (b.delete(), delete this.a[a]);
      };
      Yn.prototype.getResponse = function (a) {
        return (a = ao(this, a)) ? a.getResponse() : null;
      };
      Yn.prototype.execute = function (a) {
        (a = ao(this, a)) && a.execute();
      };
      function ao(a, b) {
        return (b = bo(b)) ? a.a[b] || null : null;
      }
      function bo(a) {
        return (a = 'undefined' === typeof a ? 1e12 : a) ? a.toString() : null;
      }
      function $n(a, b) {
        this.g = !1;
        this.c = b;
        this.a = this.b = null;
        this.h = 'invisible' !== this.c.size;
        this.f = kc(a);
        var c = this;
        this.i = function () {
          c.execute();
        };
        this.h ? this.execute() : nd(this.f, 'click', this.i);
      }
      $n.prototype.getResponse = function () {
        co(this);
        return this.b;
      };
      $n.prototype.execute = function () {
        co(this);
        var a = this;
        this.a ||
          (this.a = setTimeout(function () {
            a.b = Me();
            var b = a.c.callback,
              c = a.c['expired-callback'];
            if (b)
              try {
                b(a.b);
              } catch (d) {}
            a.a = setTimeout(function () {
              a.a = null;
              a.b = null;
              if (c)
                try {
                  c();
                } catch (d) {}
              a.h && a.execute();
            }, 6e4);
          }, 500));
      };
      $n.prototype.delete = function () {
        co(this);
        this.g = !0;
        clearTimeout(this.a);
        this.a = null;
        xd(this.f, 'click', this.i);
      };
      function co(a) {
        if (a.g) throw Error('reCAPTCHA mock was already deleted!');
      }
      function eo() {}
      M(eo, 'FACTOR_ID', 'phone');
      function fo() {}
      fo.prototype.g = function () {
        Zn || (Zn = new Yn());
        return E(Zn);
      };
      fo.prototype.c = function () {};
      var go = null;
      function ho() {
        this.b = l.grecaptcha ? Infinity : 0;
        this.f = null;
        this.a = '__rcb' + Math.floor(1e6 * Math.random()).toString();
      }
      var io = new qb(rb, 'https://www.google.com/recaptcha/api.js?onload=%{onload}&render=explicit&hl=%{hl}'),
        jo = new Ze(3e4, 6e4);
      ho.prototype.g = function (a) {
        var b = this;
        return new D(function (c, d) {
          var e = setTimeout(function () {
            d(new t('network-request-failed'));
          }, jo.get());
          if (!l.grecaptcha || (a !== b.f && !b.b)) {
            l[b.a] = function () {
              if (l.grecaptcha) {
                b.f = a;
                var g = l.grecaptcha.render;
                l.grecaptcha.render = function (h, m) {
                  h = g(h, m);
                  b.b++;
                  return h;
                };
                clearTimeout(e);
                c(l.grecaptcha);
              } else clearTimeout(e), d(new t('internal-error'));
              delete l[b.a];
            };
            var f = zb(io, { onload: b.a, hl: a || '' });
            E(Bi(f)).o(function () {
              clearTimeout(e);
              d(new t('internal-error', 'Unable to load external reCAPTCHA dependencies!'));
            });
          } else clearTimeout(e), c(l.grecaptcha);
        });
      };
      ho.prototype.c = function () {
        this.b--;
      };
      var ko = null;
      function lo(a, b, c, d, e, f, g) {
        M(this, 'type', 'recaptcha');
        this.c = this.f = null;
        this.J = !1;
        this.v = b;
        this.g = null;
        g ? (go || (go = new fo()), (g = go)) : (ko || (ko = new ho()), (g = ko));
        this.m = g;
        this.a = c || { theme: 'light', type: 'image' };
        this.h = [];
        if (this.a[mo]) throw new t('argument-error', 'sitekey should not be provided for reCAPTCHA as one is automatically provisioned for the current project.');
        this.i = 'invisible' === this.a[no];
        if (!l.document) throw new t('operation-not-supported-in-this-environment', 'RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment with DOM support.');
        if (!kc(b) || (!this.i && kc(b).hasChildNodes())) throw new t('argument-error', 'reCAPTCHA container is either not found or already contains inner elements!');
        this.s = new Ii(a, f || null, e || null);
        this.u =
          d ||
          function () {
            return null;
          };
        var h = this;
        this.l = [];
        var m = this.a[oo];
        this.a[oo] = function (v) {
          po(h, v);
          if ('function' === typeof m) m(v);
          else if ('string' === typeof m) {
            var B = L(m, l);
            'function' === typeof B && B(v);
          }
        };
        var p = this.a[qo];
        this.a[qo] = function () {
          po(h, null);
          if ('function' === typeof p) p();
          else if ('string' === typeof p) {
            var v = L(p, l);
            'function' === typeof v && v();
          }
        };
      }
      var oo = 'callback',
        qo = 'expired-callback',
        mo = 'sitekey',
        no = 'size';
      function po(a, b) {
        for (var c = 0; c < a.l.length; c++)
          try {
            a.l[c](b);
          } catch (d) {}
      }
      function ro(a, b) {
        Xa(a.l, function (c) {
          return c == b;
        });
      }
      function so(a, b) {
        a.h.push(b);
        b.oa(function () {
          Wa(a.h, b);
        });
        return b;
      }
      k = lo.prototype;
      k.Ia = function () {
        var a = this;
        return this.f
          ? this.f
          : (this.f = so(
              this,
              E()
                .then(function () {
                  if (Se() && !Je()) return Ee();
                  throw new t('operation-not-supported-in-this-environment', 'RecaptchaVerifier is only supported in a browser HTTP/HTTPS environment.');
                })
                .then(function () {
                  return a.m.g(a.u());
                })
                .then(function (b) {
                  a.g = b;
                  return O(a.s, Jj, {});
                })
                .then(function (b) {
                  a.a[mo] = b.recaptchaSiteKey;
                })
                .o(function (b) {
                  a.f = null;
                  throw b;
                }),
            ));
      };
      k.render = function () {
        to(this);
        var a = this;
        return so(
          this,
          this.Ia().then(function () {
            if (null === a.c) {
              var b = a.v;
              if (!a.i) {
                var c = kc(b);
                b = nc('DIV');
                c.appendChild(b);
              }
              a.c = a.g.render(b, a.a);
            }
            return a.c;
          }),
        );
      };
      k.verify = function () {
        to(this);
        var a = this;
        return so(
          this,
          this.render().then(function (b) {
            return new D(function (c) {
              var d = a.g.getResponse(b);
              if (d) c(d);
              else {
                var e = function (f) {
                  f && (ro(a, e), c(f));
                };
                a.l.push(e);
                a.i && a.g.execute(a.c);
              }
            });
          }),
        );
      };
      k.reset = function () {
        to(this);
        null !== this.c && this.g.reset(this.c);
      };
      function to(a) {
        if (a.J) throw new t('internal-error', 'RecaptchaVerifier instance has been destroyed.');
      }
      k.clear = function () {
        to(this);
        this.J = !0;
        this.m.c();
        for (var a = 0; a < this.h.length; a++) this.h[a].cancel('RecaptchaVerifier instance has been destroyed.');
        if (!this.i) {
          a = kc(this.v);
          for (var b; (b = a.firstChild); ) a.removeChild(b);
        }
      };
      function uo(a, b, c) {
        var d = !1;
        try {
          this.b = c || firebase.app();
        } catch (g) {
          throw new t('argument-error', 'No firebase.app.App instance is currently initialized.');
        }
        if (this.b.options && this.b.options.apiKey) c = this.b.options.apiKey;
        else throw new t('invalid-api-key');
        var e = this,
          f = null;
        try {
          f = this.b.auth().Ga();
        } catch (g) {}
        try {
          d = this.b.auth().settings.appVerificationDisabledForTesting;
        } catch (g) {}
        f = firebase.SDK_VERSION ? Oe(firebase.SDK_VERSION, f) : null;
        lo.call(
          this,
          c,
          a,
          b,
          function () {
            try {
              var g = e.b.auth().la();
            } catch (h) {
              g = null;
            }
            return g;
          },
          f,
          Ca(Da),
          d,
        );
      }
      r(uo, lo);
      function vo(a, b, c, d) {
        a: {
          c = Array.prototype.slice.call(c);
          var e = 0;
          for (var f = !1, g = 0; g < b.length; g++)
            if (b[g].optional) f = !0;
            else {
              if (f) throw new t('internal-error', 'Argument validator encountered a required argument after an optional argument.');
              e++;
            }
          f = b.length;
          if (c.length < e || f < c.length) d = 'Expected ' + (e == f ? (1 == e ? '1 argument' : e + ' arguments') : e + '-' + f + ' arguments') + ' but got ' + c.length + '.';
          else {
            for (e = 0; e < c.length; e++)
              if (((f = b[e].optional && void 0 === c[e]), !b[e].M(c[e]) && !f)) {
                b = b[e];
                if (0 > e || e >= wo.length) throw new t('internal-error', 'Argument validator received an unsupported number of arguments.');
                c = wo[e];
                d = (d ? '' : c + ' argument ') + (b.name ? '"' + b.name + '" ' : '') + 'must be ' + b.K + '.';
                break a;
              }
            d = null;
          }
        }
        if (d) throw new t('argument-error', a + ' failed: ' + d);
      }
      var wo = 'First Second Third Fourth Fifth Sixth Seventh Eighth Ninth'.split(' ');
      function V(a, b) {
        return {
          name: a || '',
          K: 'a valid string',
          optional: !!b,
          M: function (c) {
            return 'string' === typeof c;
          },
        };
      }
      function xo(a, b) {
        return {
          name: a || '',
          K: 'a boolean',
          optional: !!b,
          M: function (c) {
            return 'boolean' === typeof c;
          },
        };
      }
      function W(a, b) {
        return { name: a || '', K: 'a valid object', optional: !!b, M: n };
      }
      function yo(a, b) {
        return {
          name: a || '',
          K: 'a function',
          optional: !!b,
          M: function (c) {
            return 'function' === typeof c;
          },
        };
      }
      function zo(a, b) {
        return {
          name: a || '',
          K: 'null',
          optional: !!b,
          M: function (c) {
            return null === c;
          },
        };
      }
      function Ao() {
        return {
          name: '',
          K: 'an HTML element',
          optional: !1,
          M: function (a) {
            return !!(a && a instanceof Element);
          },
        };
      }
      function Bo() {
        return {
          name: 'auth',
          K: 'an instance of Firebase Auth',
          optional: !0,
          M: function (a) {
            return !!(a && a instanceof Fn);
          },
        };
      }
      function Co() {
        return {
          name: 'app',
          K: 'an instance of Firebase App',
          optional: !0,
          M: function (a) {
            return !!(a && a instanceof firebase.app.App);
          },
        };
      }
      function Do(a) {
        return {
          name: a ? a + 'Credential' : 'credential',
          K: a ? 'a valid ' + a + ' credential' : 'a valid credential',
          optional: !1,
          M: function (b) {
            if (!b) return !1;
            var c = !a || b.providerId === a;
            return !(!b.ka || !c);
          },
        };
      }
      function Eo() {
        return {
          name: 'multiFactorAssertion',
          K: 'a valid multiFactorAssertion',
          optional: !1,
          M: function (a) {
            return a ? !!a.tb : !1;
          },
        };
      }
      function Fo() {
        return {
          name: 'authProvider',
          K: 'a valid Auth provider',
          optional: !1,
          M: function (a) {
            return !!(a && a.providerId && a.hasOwnProperty && a.hasOwnProperty('isOAuthProvider'));
          },
        };
      }
      function Go(a, b) {
        return n(a) && 'string' === typeof a.type && a.type === b && 'function' === typeof a.Ha;
      }
      function Ho(a) {
        return n(a) && 'string' === typeof a.uid;
      }
      function Io() {
        return {
          name: 'applicationVerifier',
          K: 'an implementation of firebase.auth.ApplicationVerifier',
          optional: !1,
          M: function (a) {
            return !(!a || 'string' !== typeof a.type || 'function' !== typeof a.verify);
          },
        };
      }
      function X(a, b, c, d) {
        return {
          name: c || '',
          K: a.K + ' or ' + b.K,
          optional: !!d,
          M: function (e) {
            return a.M(e) || b.M(e);
          },
        };
      }
      function Y(a, b) {
        for (var c in b) {
          var d = b[c].name;
          a[d] = Jo(d, a[c], b[c].j);
        }
      }
      function Ko(a, b) {
        for (var c in b) {
          var d = b[c].name;
          d !== c &&
            Object.defineProperty(a, d, {
              get: ua(function (e) {
                return this[e];
              }, c),
              set: ua(
                function (e, f, g, h) {
                  vo(e, [g], [h], !0);
                  this[f] = h;
                },
                d,
                c,
                b[c].lb,
              ),
              enumerable: !0,
            });
        }
      }
      function Z(a, b, c, d) {
        a[b] = Jo(b, c, d);
      }
      function Jo(a, b, c) {
        function d() {
          var g = Array.prototype.slice.call(arguments);
          vo(e, c, g);
          return b.apply(this, g);
        }
        if (!c) return b;
        var e = Lo(a),
          f;
        for (f in b) d[f] = b[f];
        for (f in b.prototype) d.prototype[f] = b.prototype[f];
        return d;
      }
      function Lo(a) {
        a = a.split('.');
        return a[a.length - 1];
      }
      Y(Fn.prototype, {
        kb: { name: 'applyActionCode', j: [V('code')] },
        Sa: { name: 'checkActionCode', j: [V('code')] },
        ob: { name: 'confirmPasswordReset', j: [V('code'), V('newPassword')] },
        dc: { name: 'createUserWithEmailAndPassword', j: [V('email'), V('password')] },
        hc: { name: 'fetchSignInMethodsForEmail', j: [V('email')] },
        ra: { name: 'getRedirectResult', j: [] },
        Bc: { name: 'isSignInWithEmailLink', j: [V('emailLink')] },
        Hc: { name: 'onAuthStateChanged', j: [X(W(), yo(), 'nextOrObserver'), yo('opt_error', !0), yo('opt_completed', !0)] },
        Ic: { name: 'onIdTokenChanged', j: [X(W(), yo(), 'nextOrObserver'), yo('opt_error', !0), yo('opt_completed', !0)] },
        wb: { name: 'sendPasswordResetEmail', j: [V('email'), X(W('opt_actionCodeSettings', !0), zo(null, !0), 'opt_actionCodeSettings', !0)] },
        xb: { name: 'sendSignInLinkToEmail', j: [V('email'), W('actionCodeSettings')] },
        yb: { name: 'setPersistence', j: [V('persistence')] },
        Sc: { name: 'signInAndRetrieveDataWithCredential', j: [Do()] },
        Ab: { name: 'signInAnonymously', j: [] },
        ab: { name: 'signInWithCredential', j: [Do()] },
        Tc: { name: 'signInWithCustomToken', j: [V('token')] },
        Uc: { name: 'signInWithEmailAndPassword', j: [V('email'), V('password')] },
        Vc: { name: 'signInWithEmailLink', j: [V('email'), V('emailLink', !0)] },
        Wc: { name: 'signInWithPhoneNumber', j: [V('phoneNumber'), Io()] },
        Xc: { name: 'signInWithPopup', j: [Fo()] },
        Yc: { name: 'signInWithRedirect', j: [Fo()] },
        dd: {
          name: 'updateCurrentUser',
          j: [
            X(
              (function (a) {
                return {
                  name: 'user',
                  K: 'an instance of Firebase User',
                  optional: !!a,
                  M: function (b) {
                    return !!(b && b instanceof Im);
                  },
                };
              })(),
              zo(),
              'user',
            ),
          ],
        },
        Bb: { name: 'signOut', j: [] },
        toJSON: { name: 'toJSON', j: [V(null, !0)] },
        fd: { name: 'useDeviceLanguage', j: [] },
        gd: { name: 'useEmulator', j: [V('url'), W('options', !0)] },
        jd: { name: 'verifyPasswordResetCode', j: [V('code')] },
      });
      Ko(Fn.prototype, { lc: { name: 'languageCode', lb: X(V(), zo(), 'languageCode') }, ti: { name: 'tenantId', lb: X(V(), zo(), 'tenantId') } });
      Fn.Persistence = Rk;
      Fn.Persistence.LOCAL = 'local';
      Fn.Persistence.SESSION = 'session';
      Fn.Persistence.NONE = 'none';
      Y(Im.prototype, {
        delete: { name: 'delete', j: [] },
        oc: { name: 'getIdTokenResult', j: [xo('opt_forceRefresh', !0)] },
        I: { name: 'getIdToken', j: [xo('opt_forceRefresh', !0)] },
        Cc: { name: 'linkAndRetrieveDataWithCredential', j: [Do()] },
        rb: { name: 'linkWithCredential', j: [Do()] },
        Dc: { name: 'linkWithPhoneNumber', j: [V('phoneNumber'), Io()] },
        Ec: { name: 'linkWithPopup', j: [Fo()] },
        Fc: { name: 'linkWithRedirect', j: [Fo()] },
        Lc: { name: 'reauthenticateAndRetrieveDataWithCredential', j: [Do()] },
        ub: { name: 'reauthenticateWithCredential', j: [Do()] },
        Mc: { name: 'reauthenticateWithPhoneNumber', j: [V('phoneNumber'), Io()] },
        Nc: { name: 'reauthenticateWithPopup', j: [Fo()] },
        Oc: { name: 'reauthenticateWithRedirect', j: [Fo()] },
        reload: { name: 'reload', j: [] },
        vb: { name: 'sendEmailVerification', j: [X(W('opt_actionCodeSettings', !0), zo(null, !0), 'opt_actionCodeSettings', !0)] },
        toJSON: { name: 'toJSON', j: [V(null, !0)] },
        cd: { name: 'unlink', j: [V('provider')] },
        Cb: { name: 'updateEmail', j: [V('email')] },
        Db: { name: 'updatePassword', j: [V('password')] },
        ed: { name: 'updatePhoneNumber', j: [Do('phone')] },
        Eb: { name: 'updateProfile', j: [W('profile')] },
        Fb: { name: 'verifyBeforeUpdateEmail', j: [V('email'), X(W('opt_actionCodeSettings', !0), zo(null, !0), 'opt_actionCodeSettings', !0)] },
      });
      Y(Yn.prototype, { execute: { name: 'execute' }, render: { name: 'render' }, reset: { name: 'reset' }, getResponse: { name: 'getResponse' } });
      Y(Xn.prototype, { execute: { name: 'execute' }, render: { name: 'render' }, reset: { name: 'reset' }, getResponse: { name: 'getResponse' } });
      Y(D.prototype, { oa: { name: 'finally' }, o: { name: 'catch' }, then: { name: 'then' } });
      Ko(em.prototype, { appVerificationDisabled: { name: 'appVerificationDisabledForTesting', lb: xo('appVerificationDisabledForTesting') } });
      Y(fm.prototype, { confirm: { name: 'confirm', j: [V('verificationCode')] } });
      Z(
        Bg,
        'fromJSON',
        function (a) {
          a = 'string' === typeof a ? JSON.parse(a) : a;
          for (var b, c = [Mg, dh, kh, Jg], d = 0; d < c.length; d++) if ((b = c[d](a))) return b;
          return null;
        },
        [X(V(), W(), 'json')],
      );
      Z(
        Zg,
        'credential',
        function (a, b) {
          return new Yg(a, b);
        },
        [V('email'), V('password')],
      );
      Y(Yg.prototype, { w: { name: 'toJSON', j: [V(null, !0)] } });
      Y(Qg.prototype, { Ca: { name: 'addScope', j: [V('scope')] }, Ka: { name: 'setCustomParameters', j: [W('customOAuthParameters')] } });
      Z(Qg, 'credential', Rg, [X(V(), W(), 'token')]);
      Z(Zg, 'credentialWithLink', eh, [V('email'), V('emailLink')]);
      Y(Sg.prototype, { Ca: { name: 'addScope', j: [V('scope')] }, Ka: { name: 'setCustomParameters', j: [W('customOAuthParameters')] } });
      Z(Sg, 'credential', Tg, [X(V(), W(), 'token')]);
      Y(Ug.prototype, { Ca: { name: 'addScope', j: [V('scope')] }, Ka: { name: 'setCustomParameters', j: [W('customOAuthParameters')] } });
      Z(Ug, 'credential', Vg, [X(V(), X(W(), zo()), 'idToken'), X(V(), zo(), 'accessToken', !0)]);
      Y(Wg.prototype, { Ka: { name: 'setCustomParameters', j: [W('customOAuthParameters')] } });
      Z(Wg, 'credential', Xg, [X(V(), W(), 'token'), V('secret', !0)]);
      Y(Pg.prototype, {
        Ca: { name: 'addScope', j: [V('scope')] },
        credential: { name: 'credential', j: [X(V(), X(W(), zo()), 'optionsOrIdToken'), X(V(), zo(), 'accessToken', !0)] },
        Ka: { name: 'setCustomParameters', j: [W('customOAuthParameters')] },
      });
      Y(Kg.prototype, { w: { name: 'toJSON', j: [V(null, !0)] } });
      Y(Eg.prototype, { w: { name: 'toJSON', j: [V(null, !0)] } });
      Z(lh, 'credential', ph, [V('verificationId'), V('verificationCode')]);
      Y(lh.prototype, {
        gb: {
          name: 'verifyPhoneNumber',
          j: [
            X(
              V(),
              (function (a, b) {
                return {
                  name: a || 'phoneInfoOptions',
                  K: 'valid phone info options',
                  optional: !!b,
                  M: function (c) {
                    return c
                      ? c.session && c.phoneNumber
                        ? Go(c.session, zg) && 'string' === typeof c.phoneNumber
                        : c.session && c.multiFactorHint
                        ? Go(c.session, Ag) && Ho(c.multiFactorHint)
                        : c.session && c.multiFactorUid
                        ? Go(c.session, Ag) && 'string' === typeof c.multiFactorUid
                        : c.phoneNumber
                        ? 'string' === typeof c.phoneNumber
                        : !1
                      : !1;
                  },
                };
              })(),
              'phoneInfoOptions',
            ),
            Io(),
          ],
        },
      });
      Y(gh.prototype, { w: { name: 'toJSON', j: [V(null, !0)] } });
      Y(t.prototype, { toJSON: { name: 'toJSON', j: [V(null, !0)] } });
      Y(yh.prototype, { toJSON: { name: 'toJSON', j: [V(null, !0)] } });
      Y(xh.prototype, { toJSON: { name: 'toJSON', j: [V(null, !0)] } });
      Y(lm.prototype, { toJSON: { name: 'toJSON', j: [V(null, !0)] } });
      Y(im.prototype, { Rc: { name: 'resolveSignIn', j: [Eo()] } });
      Y(tm.prototype, {
        Sb: { name: 'getSession', j: [] },
        fc: { name: 'enroll', j: [Eo(), V('displayName', !0)] },
        bd: { name: 'unenroll', j: [X({ name: 'multiFactorInfo', K: 'a valid multiFactorInfo', optional: !1, M: Ho }, V(), 'multiFactorInfoIdentifier')] },
      });
      Y(uo.prototype, { clear: { name: 'clear', j: [] }, render: { name: 'render', j: [] }, verify: { name: 'verify', j: [] } });
      Z(Jf, 'parseLink', Rf, [V('link')]);
      Z(
        eo,
        'assertion',
        function (a) {
          return new rm(a);
        },
        [Do('phone')],
      );
      (function () {
        if ('undefined' !== typeof firebase && firebase.INTERNAL && firebase.INTERNAL.registerComponent) {
          var a = {
            ActionCodeInfo: {
              Operation: {
                EMAIL_SIGNIN: Af,
                PASSWORD_RESET: 'PASSWORD_RESET',
                RECOVER_EMAIL: 'RECOVER_EMAIL',
                REVERT_SECOND_FACTOR_ADDITION: Cf,
                VERIFY_AND_CHANGE_EMAIL: Bf,
                VERIFY_EMAIL: 'VERIFY_EMAIL',
              },
            },
            Auth: Fn,
            AuthCredential: Bg,
            Error: t,
          };
          Z(a, 'EmailAuthProvider', Zg, []);
          Z(a, 'FacebookAuthProvider', Qg, []);
          Z(a, 'GithubAuthProvider', Sg, []);
          Z(a, 'GoogleAuthProvider', Ug, []);
          Z(a, 'TwitterAuthProvider', Wg, []);
          Z(a, 'OAuthProvider', Pg, [V('providerId')]);
          Z(a, 'SAMLAuthProvider', Og, [V('providerId')]);
          Z(a, 'PhoneAuthProvider', lh, [Bo()]);
          Z(a, 'RecaptchaVerifier', uo, [X(V(), Ao(), 'recaptchaContainer'), W('recaptchaParameters', !0), Co()]);
          Z(a, 'ActionCodeURL', Jf, []);
          Z(a, 'PhoneMultiFactorGenerator', eo, []);
          firebase.INTERNAL.registerComponent({
            name: 'auth',
            instanceFactory: function (b) {
              b = b.getProvider('app').getImmediate();
              return new Fn(b);
            },
            multipleInstances: !1,
            serviceProps: a,
            instantiationMode: 'LAZY',
            type: 'PUBLIC',
            onInstanceCreated: function (b) {
              b.getProvider('auth-internal').initialize();
            },
          });
          firebase.INTERNAL.registerComponent({
            name: 'auth-internal',
            instanceFactory: function (b) {
              b = b.getProvider('auth').getImmediate();
              return { getUid: q(b.getUid, b), getToken: q(b.nc, b), addAuthTokenListener: q(b.cc, b), removeAuthTokenListener: q(b.Pc, b) };
            },
            multipleInstances: !1,
            instantiationMode: 'LAZY',
            type: 'PRIVATE',
          });
          firebase.registerVersion('@firebase/auth', '0.16.8');
          firebase.INTERNAL.extendNamespace({ User: Im });
        } else throw Error('Cannot find the firebase namespace; be sure to include firebase-app.js before this library.');
      })();
    }.apply(typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {}));

    var name = 'firebase';
    var version = '8.10.0';

    /**
     * @license
     * Copyright 2018 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    firebase.registerVersion(name, version, 'app');
    firebase.SDK_VERSION = version;

    var index_esm = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      default: firebase,
    });

    class GoogleSignInResult {
      constructor(idToken) {
        this.idToken = idToken;
        this.providerId = firebase.auth.GoogleAuthProvider.PROVIDER_ID;
      }
    }
    class TwitterSignInResult {
      constructor(idToken, secret) {
        this.idToken = idToken;
        this.secret = secret;
        this.providerId = firebase.auth.TwitterAuthProvider.PROVIDER_ID;
      }
    }
    class FacebookSignInResult {
      constructor(idToken) {
        this.idToken = idToken;
        this.providerId = firebase.auth.FacebookAuthProvider.PROVIDER_ID;
      }
    }
    class AppleSignInResult {
      constructor(idToken, rawNonce, accessToken, secret) {
        this.idToken = idToken;
        this.rawNonce = rawNonce;
        this.accessToken = accessToken;
        this.secret = secret;
        this.providerId = firebase.auth.FacebookAuthProvider.PROVIDER_ID;
      }
    }
    class PhoneSignInResult {
      constructor(verificationId, verificationCode) {
        this.verificationId = verificationId;
        this.verificationCode = verificationCode;
        this.providerId = firebase.auth.PhoneAuthProvider.PROVIDER_ID;
      }
    }

    function isFunction$1(x) {
      return typeof x === 'function';
    }

    let _enable_super_gross_mode_that_will_cause_bad_things = false;
    const config$1 = {
      Promise: undefined,
      set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
          const error = new Error();
          console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
          console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
      },
      get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
      },
    };

    function hostReportError(err) {
      setTimeout(() => {
        throw err;
      }, 0);
    }

    const empty = {
      closed: true,
      next(value) {},
      error(err) {
        if (config$1.useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          hostReportError(err);
        }
      },
      complete() {},
    };

    const isArray$1 = (() => Array.isArray || (x => x && typeof x.length === 'number'))();

    function isObject$3(x) {
      return x !== null && typeof x === 'object';
    }

    const UnsubscriptionErrorImpl = (() => {
      function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors
          ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\n  ')}`
          : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
      }
      UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
      return UnsubscriptionErrorImpl;
    })();
    const UnsubscriptionError$1 = UnsubscriptionErrorImpl;

    class Subscription$1 {
      constructor(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
          this._ctorUnsubscribe = true;
          this._unsubscribe = unsubscribe;
        }
      }
      unsubscribe() {
        let errors;
        if (this.closed) {
          return;
        }
        let { _parentOrParents, _ctorUnsubscribe, _unsubscribe, _subscriptions } = this;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription$1) {
          _parentOrParents.remove(this);
        } else if (_parentOrParents !== null) {
          for (let index = 0; index < _parentOrParents.length; ++index) {
            const parent = _parentOrParents[index];
            parent.remove(this);
          }
        }
        if (isFunction$1(_unsubscribe)) {
          if (_ctorUnsubscribe) {
            this._unsubscribe = undefined;
          }
          try {
            _unsubscribe.call(this);
          } catch (e) {
            errors = e instanceof UnsubscriptionError$1 ? flattenUnsubscriptionErrors(e.errors) : [e];
          }
        }
        if (isArray$1(_subscriptions)) {
          let index = -1;
          let len = _subscriptions.length;
          while (++index < len) {
            const sub = _subscriptions[index];
            if (isObject$3(sub)) {
              try {
                sub.unsubscribe();
              } catch (e) {
                errors = errors || [];
                if (e instanceof UnsubscriptionError$1) {
                  errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                } else {
                  errors.push(e);
                }
              }
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError$1(errors);
        }
      }
      add(teardown) {
        let subscription = teardown;
        if (!teardown) {
          return Subscription$1.EMPTY;
        }
        switch (typeof teardown) {
          case 'function':
            subscription = new Subscription$1(teardown);
          case 'object':
            if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (!(subscription instanceof Subscription$1)) {
              const tmp = subscription;
              subscription = new Subscription$1();
              subscription._subscriptions = [tmp];
            }
            break;
          default: {
            throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
          }
        }
        let { _parentOrParents } = subscription;
        if (_parentOrParents === null) {
          subscription._parentOrParents = this;
        } else if (_parentOrParents instanceof Subscription$1) {
          if (_parentOrParents === this) {
            return subscription;
          }
          subscription._parentOrParents = [_parentOrParents, this];
        } else if (_parentOrParents.indexOf(this) === -1) {
          _parentOrParents.push(this);
        } else {
          return subscription;
        }
        const subscriptions = this._subscriptions;
        if (subscriptions === null) {
          this._subscriptions = [subscription];
        } else {
          subscriptions.push(subscription);
        }
        return subscription;
      }
      remove(subscription) {
        const subscriptions = this._subscriptions;
        if (subscriptions) {
          const subscriptionIndex = subscriptions.indexOf(subscription);
          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      }
    }
    Subscription$1.EMPTY = (function (empty) {
      empty.closed = true;
      return empty;
    })(new Subscription$1());
    function flattenUnsubscriptionErrors(errors) {
      return errors.reduce((errs, err) => errs.concat(err instanceof UnsubscriptionError$1 ? err.errors : err), []);
    }

    const rxSubscriber = (() => (typeof Symbol === 'function' ? Symbol('rxSubscriber') : '@@rxSubscriber_' + Math.random()))();

    class Subscriber$1 extends Subscription$1 {
      constructor(destinationOrNext, error, complete) {
        super();
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;
        switch (arguments.length) {
          case 0:
            this.destination = empty;
            break;
          case 1:
            if (!destinationOrNext) {
              this.destination = empty;
              break;
            }
            if (typeof destinationOrNext === 'object') {
              if (destinationOrNext instanceof Subscriber$1) {
                this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                this.destination = destinationOrNext;
                destinationOrNext.add(this);
              } else {
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber$1(this, destinationOrNext);
              }
              break;
            }
          default:
            this.syncErrorThrowable = true;
            this.destination = new SafeSubscriber$1(this, destinationOrNext, error, complete);
            break;
        }
      }
      [rxSubscriber]() {
        return this;
      }
      static create(next, error, complete) {
        const subscriber = new Subscriber$1(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
      }
      next(value) {
        if (!this.isStopped) {
          this._next(value);
        }
      }
      error(err) {
        if (!this.isStopped) {
          this.isStopped = true;
          this._error(err);
        }
      }
      complete() {
        if (!this.isStopped) {
          this.isStopped = true;
          this._complete();
        }
      }
      unsubscribe() {
        if (this.closed) {
          return;
        }
        this.isStopped = true;
        super.unsubscribe();
      }
      _next(value) {
        this.destination.next(value);
      }
      _error(err) {
        this.destination.error(err);
        this.unsubscribe();
      }
      _complete() {
        this.destination.complete();
        this.unsubscribe();
      }
      _unsubscribeAndRecycle() {
        const { _parentOrParents } = this;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
      }
    }
    class SafeSubscriber$1 extends Subscriber$1 {
      constructor(_parentSubscriber, observerOrNext, error, complete) {
        super();
        this._parentSubscriber = _parentSubscriber;
        let next;
        let context = this;
        if (isFunction$1(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error = observerOrNext.error;
          complete = observerOrNext.complete;
          if (observerOrNext !== empty) {
            context = Object.create(observerOrNext);
            if (isFunction$1(context.unsubscribe)) {
              this.add(context.unsubscribe.bind(context));
            }
            context.unsubscribe = this.unsubscribe.bind(this);
          }
        }
        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
      }
      next(value) {
        if (!this.isStopped && this._next) {
          const { _parentSubscriber } = this;
          if (!config$1.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._next, value);
          } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
            this.unsubscribe();
          }
        }
      }
      error(err) {
        if (!this.isStopped) {
          const { _parentSubscriber } = this;
          const { useDeprecatedSynchronousErrorHandling } = config$1;
          if (this._error) {
            if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(this._error, err);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, this._error, err);
              this.unsubscribe();
            }
          } else if (!_parentSubscriber.syncErrorThrowable) {
            this.unsubscribe();
            if (useDeprecatedSynchronousErrorHandling) {
              throw err;
            }
            hostReportError(err);
          } else {
            if (useDeprecatedSynchronousErrorHandling) {
              _parentSubscriber.syncErrorValue = err;
              _parentSubscriber.syncErrorThrown = true;
            } else {
              hostReportError(err);
            }
            this.unsubscribe();
          }
        }
      }
      complete() {
        if (!this.isStopped) {
          const { _parentSubscriber } = this;
          if (this._complete) {
            const wrappedComplete = () => this._complete.call(this._context);
            if (!config$1.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(wrappedComplete);
              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, wrappedComplete);
              this.unsubscribe();
            }
          } else {
            this.unsubscribe();
          }
        }
      }
      __tryOrUnsub(fn, value) {
        try {
          fn.call(this._context, value);
        } catch (err) {
          this.unsubscribe();
          if (config$1.useDeprecatedSynchronousErrorHandling) {
            throw err;
          } else {
            hostReportError(err);
          }
        }
      }
      __tryOrSetError(parent, fn, value) {
        if (!config$1.useDeprecatedSynchronousErrorHandling) {
          throw new Error('bad call');
        }
        try {
          fn.call(this._context, value);
        } catch (err) {
          if (config$1.useDeprecatedSynchronousErrorHandling) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
          } else {
            hostReportError(err);
            return true;
          }
        }
        return false;
      }
      _unsubscribe() {
        const { _parentSubscriber } = this;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
      }
    }

    function canReportError(observer) {
      while (observer) {
        const { closed, destination, isStopped } = observer;
        if (closed || isStopped) {
          return false;
        } else if (destination && destination instanceof Subscriber$1) {
          observer = destination;
        } else {
          observer = null;
        }
      }
      return true;
    }

    function toSubscriber(nextOrObserver, error, complete) {
      if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber$1) {
          return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber]) {
          return nextOrObserver[rxSubscriber]();
        }
      }
      if (!nextOrObserver && !error && !complete) {
        return new Subscriber$1(empty);
      }
      return new Subscriber$1(nextOrObserver, error, complete);
    }

    const observable$1 = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();

    function identity$1(x) {
      return x;
    }

    function pipe(...fns) {
      return pipeFromArray$1(fns);
    }
    function pipeFromArray$1(fns) {
      if (fns.length === 0) {
        return identity$1;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce((prev, fn) => fn(prev), input);
      };
    }

    class Observable$1 {
      constructor(subscribe) {
        this._isScalar = false;
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      lift(operator) {
        const observable = new Observable$1();
        observable.source = this;
        observable.operator = operator;
        return observable;
      }
      subscribe(observerOrNext, error, complete) {
        const { operator } = this;
        const sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
          sink.add(operator.call(sink, this.source));
        } else {
          sink.add(this.source || (config$1.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (config$1.useDeprecatedSynchronousErrorHandling) {
          if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;
            if (sink.syncErrorThrown) {
              throw sink.syncErrorValue;
            }
          }
        }
        return sink;
      }
      _trySubscribe(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          if (config$1.useDeprecatedSynchronousErrorHandling) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
          }
          if (canReportError(sink)) {
            sink.error(err);
          } else {
            console.warn(err);
          }
        }
      }
      forEach(next, promiseCtor) {
        promiseCtor = getPromiseCtor$1(promiseCtor);
        return new promiseCtor((resolve, reject) => {
          let subscription;
          subscription = this.subscribe(
            value => {
              try {
                next(value);
              } catch (err) {
                reject(err);
                if (subscription) {
                  subscription.unsubscribe();
                }
              }
            },
            reject,
            resolve,
          );
        });
      }
      _subscribe(subscriber) {
        const { source } = this;
        return source && source.subscribe(subscriber);
      }
      [observable$1]() {
        return this;
      }
      pipe(...operations) {
        if (operations.length === 0) {
          return this;
        }
        return pipeFromArray$1(operations)(this);
      }
      toPromise(promiseCtor) {
        promiseCtor = getPromiseCtor$1(promiseCtor);
        return new promiseCtor((resolve, reject) => {
          let value;
          this.subscribe(
            x => (value = x),
            err => reject(err),
            () => resolve(value),
          );
        });
      }
    }
    Observable$1.create = subscribe => {
      return new Observable$1(subscribe);
    };
    function getPromiseCtor$1(promiseCtor) {
      if (!promiseCtor) {
        promiseCtor = Promise;
      }
      if (!promiseCtor) {
        throw new Error('no Promise impl found');
      }
      return promiseCtor;
    }

    function throwError(error, scheduler) {
      if (!scheduler) {
        return new Observable$1(subscriber => subscriber.error(error));
      } else {
        return new Observable$1(subscriber => scheduler.schedule(dispatch, 0, { error, subscriber }));
      }
    }
    function dispatch({ error, subscriber }) {
      subscriber.error(error);
    }

    function map$1(project, thisArg) {
      return function mapOperation(source) {
        if (typeof project !== 'function') {
          throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
      };
    }
    class MapOperator {
      constructor(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
      }
      call(subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      }
    }
    class MapSubscriber extends Subscriber$1 {
      constructor(destination, project, thisArg) {
        super(destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
      }
      _next(value) {
        let result;
        try {
          result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }
        this.destination.next(result);
      }
    }

    const CapacitorFirebaseAuth = registerPlugin('CapacitorFirebaseAuth', {
      web: () =>
        Promise.resolve()
          .then(function () {
            return web;
          })
          .then(m => new m.CapacitorFirebaseAuthWeb()),
    });
    const plugin = CapacitorFirebaseAuth;
    /**
     * Call the sign in method on native layer and sign in on web layer with retrieved credentials.
     * @param providerId The provider identification.
     * @param data The provider additional information (optional).
     */
    const cfaSignIn = (providerId, data) => {
      const googleProvider = new firebase.auth.GoogleAuthProvider().providerId;
      const facebookProvider = new firebase.auth.FacebookAuthProvider().providerId;
      const twitterProvider = new firebase.auth.TwitterAuthProvider().providerId;
      const phoneProvider = new firebase.auth.PhoneAuthProvider().providerId;
      switch (providerId) {
        case googleProvider:
          return cfaSignInGoogle();
        case twitterProvider:
          return cfaSignInTwitter();
        case facebookProvider:
          return cfaSignInFacebook();
        case cfaSignInAppleProvider:
          return cfaSignInApple();
        case phoneProvider:
          if (!data) {
            throw new Error('Phone and Verification data must be provided.');
          }
          return cfaSignInPhone(data.phone, data.verificationCode);
        default:
          return throwError(new Error(`The '${providerId}' provider was not supported`));
      }
    };
    /**
     * Call the Google sign in method on native layer and sign in on web layer with retrieved credentials.
     */
    const cfaSignInGoogle = () => {
      return new Observable$1(observer => {
        // get the provider id
        const providerId = firebase.auth.GoogleAuthProvider.PROVIDER_ID;
        // native sign in
        plugin
          .signIn({ providerId })
          .then(result => {
            // create the credentials
            const credential = firebase.auth.GoogleAuthProvider.credential(result.idToken);
            // web sign in
            firebase
              .app()
              .auth()
              .signInWithCredential(credential)
              .then(userCredential => {
                if (!userCredential.user) {
                  throw new Error('Firebase User was not received.');
                }
                observer.next(userCredential.user);
                observer.complete();
              })
              .catch(reject => {
                observer.error(reject);
              });
          })
          .catch(reject => {
            observer.error(reject);
          });
      });
    };
    /**
     * Call the Twitter sign in method on native and sign in on web layer with retrieved credentials.
     */
    const cfaSignInTwitter = () => {
      return new Observable$1(observer => {
        // get the provider id
        const providerId = firebase.auth.TwitterAuthProvider.PROVIDER_ID;
        // native sign in
        plugin
          .signIn({ providerId })
          .then(result => {
            // create the credentials
            const credential = firebase.auth.TwitterAuthProvider.credential(result.idToken, result.secret);
            // web sign in
            firebase
              .app()
              .auth()
              .signInWithCredential(credential)
              .then(userCredential => {
                if (!userCredential.user) {
                  throw new Error('Firebase User was not received.');
                }
                observer.next(userCredential.user);
                observer.complete();
              })
              .catch(reject => observer.error(reject));
          })
          .catch(reject => observer.error(reject));
      });
    };
    /**
     * Call the Facebook sign in method on native and sign in on web layer with retrieved credentials.
     */
    const cfaSignInFacebook = () => {
      return new Observable$1(observer => {
        // get the provider id
        const providerId = firebase.auth.FacebookAuthProvider.PROVIDER_ID;
        // native sign in
        plugin
          .signIn({ providerId })
          .then(result => {
            // create the credentials
            const credential = firebase.auth.FacebookAuthProvider.credential(result.idToken);
            // web sign in
            firebase
              .app()
              .auth()
              .signInWithCredential(credential)
              .then(userCredential => {
                if (!userCredential.user) {
                  throw new Error('Firebase User was not received.');
                }
                observer.next(userCredential.user);
                observer.complete();
              })
              .catch(reject => observer.error(reject));
          })
          .catch(reject => observer.error(reject));
      });
    };
    const cfaSignInAppleProvider = 'apple.com';
    /**
     * Call the Apple sign in method on native and sign in on web layer with retrieved credentials.
     */
    const cfaSignInApple = () => {
      return new Observable$1(observer => {
        // native sign in
        plugin
          .signIn({ providerId: cfaSignInAppleProvider })
          .then(result => {
            const { idToken, rawNonce } = result;
            const provider = new firebase.auth.OAuthProvider('apple.com');
            provider.addScope('email');
            provider.addScope('name');
            const credential = provider.credential({ idToken, rawNonce });
            // web sign in
            firebase
              .app()
              .auth()
              .signInWithCredential(credential)
              .then(userCredential => {
                if (!userCredential.user) {
                  throw new Error('Firebase User was not received.');
                }
                observer.next(userCredential.user);
                observer.complete();
              })
              .catch(reject => observer.error(reject));
          })
          .catch(reject => observer.error(reject));
      });
    };
    /**
     * Call the Phone verification sign in, handling send and retrieve to code on native, but only sign in on web with retrieved credentials.
     * @param phone The user phone number.
     * @param verificationCode The verification code sent by SMS (optional).
     */
    const cfaSignInPhone = (phone, verificationCode) => {
      return new Observable$1(observer => {
        // get the provider id
        const providerId = firebase.auth.PhoneAuthProvider.PROVIDER_ID;
        plugin
          .signIn({ providerId, data: { phone, verificationCode } })
          .then(result => {
            // if there is no verification code
            if (!result.verificationCode) {
              return observer.complete();
            }
            // create the credentials
            const credential = firebase.auth.PhoneAuthProvider.credential(result.verificationId, result.verificationCode);
            // web sign in
            firebase
              .app()
              .auth()
              .signInWithCredential(credential)
              .then(userCredential => {
                if (!userCredential.user) {
                  throw new Error('Firebase User was not received.');
                }
                observer.next(userCredential.user);
                observer.complete();
              })
              .catch(reject => observer.error(reject));
          })
          .catch(reject => observer.error(reject));
      });
    };
    /**
     * Observable of one notification of <code>On Code Sent</code>event from Phone Verification process.
     */
    const cfaSignInPhoneOnCodeSent = () => {
      return new Observable$1(observer => {
        // @ts-ignore
        return plugin.addListener('cfaSignInPhoneOnCodeSent', event => {
          observer.next(event.verificationId);
          observer.complete();
        });
      });
    };
    /**
     * Observable of one notification of <code>On Code Received</code> event from Phone Verification process.
     */
    const cfaSignInPhoneOnCodeReceived = () => {
      return new Observable$1(observer => {
        // @ts-ignore
        return plugin.addListener('cfaSignInPhoneOnCodeReceived', event => {
          observer.next(event);
          observer.complete();
        });
      });
    };
    /**
     * Call Google sign out method on native and web layers.
     */
    const cfaSignOut = () => {
      return new Observable$1(observer => {
        plugin.signOut({}).then(() => {
          // web sign out
          firebase
            .app()
            .auth()
            .signOut()
            .then(() => {
              observer.next();
              observer.complete();
            })
            .catch(reject => observer.error(reject));
        });
      });
    };

    /**
     * Operator to map firebase.User to firebase.UserInfo.
     *
     * Sample of use:
     *
     * ```ts
     * import {cfaSignIn, mapUserToUserInfo} from 'capacitor-firebase-auth';
     * import {UserInfo} from 'firebase/app';
     *
     * cfaSignIn('google.com').pipe(
     *     mapUserToUserInfo(),
     * ).subscribe(
     *     (user: UserInfo) => console.log(user.displayName);
     * )
     * ```
     */
    const mapUserToUserInfo = () =>
      pipe(
        map$1(user => {
          if (user) {
            const { uid, providerId, displayName, photoURL, phoneNumber, email } = user;
            return { uid, providerId, displayName, photoURL, phoneNumber, email };
          }
          return user;
        }),
      );
    /**
     * Operator to map firebase.auth.UserCredential to firebase.UserInfo.
     *
     * For use with alternative facade only.
     *
     * Sample of use:
     *
     * ```ts
     * import {cfaSignIn, mapUserToUserInfo} from 'capacitor-firebase-auth/alternative';
     * import {UserInfo} from 'firebase/app';
     *
     * cfaSignIn('google.com').pipe(
     *     mapUserToUserInfo(),
     * ).subscribe(
     *     (user: UserInfo) => console.log(user.displayName);
     * )
     * ```
     */
    const mapUserCredentialToUserInfo = () =>
      pipe(
        map$1(({ userCredential }) => {
          if (userCredential === null || userCredential === void 0 ? void 0 : userCredential.user) {
            const { uid, providerId, displayName, photoURL, phoneNumber, email } = userCredential.user;
            return { uid, providerId, displayName, photoURL, phoneNumber, email };
          }
          return null;
        }),
      );

    var esm = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      GoogleSignInResult: GoogleSignInResult,
      TwitterSignInResult: TwitterSignInResult,
      FacebookSignInResult: FacebookSignInResult,
      AppleSignInResult: AppleSignInResult,
      PhoneSignInResult: PhoneSignInResult,
      CapacitorFirebaseAuth: CapacitorFirebaseAuth,
      cfaSignIn: cfaSignIn,
      cfaSignInGoogle: cfaSignInGoogle,
      cfaSignInTwitter: cfaSignInTwitter,
      cfaSignInFacebook: cfaSignInFacebook,
      cfaSignInAppleProvider: cfaSignInAppleProvider,
      cfaSignInApple: cfaSignInApple,
      cfaSignInPhone: cfaSignInPhone,
      cfaSignInPhoneOnCodeSent: cfaSignInPhoneOnCodeSent,
      cfaSignInPhoneOnCodeReceived: cfaSignInPhoneOnCodeReceived,
      cfaSignOut: cfaSignOut,
      mapUserToUserInfo: mapUserToUserInfo,
      mapUserCredentialToUserInfo: mapUserCredentialToUserInfo,
    });

    var capacitor_firebase_auth_1 = /*@__PURE__*/ getAugmentedNamespace(esm);

    var require$$0 = /*@__PURE__*/ getAugmentedNamespace(index_esm);

    var fireAuth = createCommonjsModule(function (module, exports) {
      var __awaiter =
        (commonjsGlobal && commonjsGlobal.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator['throw'](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
      var __importDefault =
        (commonjsGlobal && commonjsGlobal.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      exports.checkCodeWeb =
        exports.loginWithPhoneWeb =
        exports.checkCodeNative =
        exports.loginWithPhoneNative =
        exports.loginWithApple =
        exports.loginWithGoogle =
        exports.loginWithFacebook =
        exports.createRecapcha =
          void 0;

      const app_1 = __importDefault(require$$0);

      function createRecapcha() {
        const capchaContainer = document.createElement('div');
        capchaContainer.id = 'fire-auth-recapcha-button';
        document.body.appendChild(capchaContainer);
        return new app_1.default.auth.RecaptchaVerifier(capchaContainer.id, {
          size: 'invisible',
        });
      }
      exports.createRecapcha = createRecapcha;
      function loginWithFacebook() {
        return capacitor_firebase_auth_1.cfaSignIn('facebook.com').toPromise();
      }
      exports.loginWithFacebook = loginWithFacebook;
      function loginWithGoogle() {
        return capacitor_firebase_auth_1.cfaSignIn('google.com').toPromise();
      }
      exports.loginWithGoogle = loginWithGoogle;
      function loginWithApple() {
        return capacitor_firebase_auth_1.cfaSignIn('apple.com').toPromise();
      }
      exports.loginWithApple = loginWithApple;
      function loginWithPhoneNative(phone, onVerificationReceived, onCodeReceived) {
        capacitor_firebase_auth_1.cfaSignInPhoneOnCodeSent().subscribe(verificationId => {
          onVerificationReceived(verificationId);
        });
        capacitor_firebase_auth_1.cfaSignInPhoneOnCodeReceived().subscribe(({ verificationId, verificationCode }) => {
          onCodeReceived(verificationId, verificationCode);
        });
        return capacitor_firebase_auth_1.cfaSignIn('phone', { phone }).toPromise();
      }
      exports.loginWithPhoneNative = loginWithPhoneNative;
      function checkCodeNative(code, verificationId) {
        return __awaiter(this, void 0, void 0, function* () {
          const credential = app_1.default.auth.PhoneAuthProvider.credential(verificationId, code);
          const { user } = yield app_1.default.auth().signInWithCredential(credential);
          return user;
        });
      }
      exports.checkCodeNative = checkCodeNative;
      function loginWithPhoneWeb(phone, recapcha) {
        app_1.default.auth().languageCode = user_store.userState.language;
        return app_1.default.auth().signInWithPhoneNumber(phone, recapcha);
      }
      exports.loginWithPhoneWeb = loginWithPhoneWeb;
      function checkCodeWeb(code, confirmationResult) {
        return __awaiter(this, void 0, void 0, function* () {
          const { user } = yield confirmationResult.confirm(code);
          return user;
        });
      }
      exports.checkCodeWeb = checkCodeWeb;
    });

    var dist = createCommonjsModule(function (module, exports) {
      var __createBinding =
        (commonjsGlobal && commonjsGlobal.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              Object.defineProperty(o, k2, {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              });
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (commonjsGlobal && commonjsGlobal.__exportStar) ||
        function (m, exports) {
          for (var p in m) if (p !== 'default' && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, '__esModule', { value: true });
      __exportStar(models, exports);
      __exportStar(game_service, exports);
      __exportStar(globalSearch_service, exports);
      __exportStar(ip_service, exports);
      __exportStar(league_service, exports);
      __exportStar(licenseAgreement_service, exports);
      __exportStar(news_service, exports);
      __exportStar(person_service, exports);
      __exportStar(player_service, exports);
      __exportStar(profile_service, exports);
      __exportStar(season_service, exports);
      __exportStar(team_service, exports);
      __exportStar(stadium_service, exports);
      __exportStar(user_service, exports);
      __exportStar(buildRoute_1, exports);
      __exportStar(helpers, exports);
      __exportStar(relativeDate_1, exports);
      __exportStar(translations, exports);
      __exportStar(plural, exports);
      __exportStar(filter_1, exports);
      __exportStar(storage, exports);
      __exportStar(validators, exports);
      __exportStar(playersPositions, exports);
      __exportStar(graphql_client, exports);
      __exportStar(http_client, exports);
      __exportStar(fireAuth, exports);
      __exportStar(user_store, exports);
      __exportStar(env_store, exports);
      __exportStar(routing_store, exports);
    });

    const ffspbContentComponentCss =
      'ffspb-content{display:block;height:100%}ffspb-content .ffspb-content__desktop-wrapper{display:block;width:100%;background:#414141;min-width:var(--min-content-width);margin-top:80px;height:100%;max-height:calc(100% - 80px);overflow-y:auto}ffspb-content .ffspb-content__desktop-wrapper::-webkit-scrollbar{width:10px}ffspb-content .ffspb-content__desktop-wrapper::-webkit-scrollbar-track{background-color:#313131}ffspb-content .ffspb-content__desktop-wrapper::-webkit-scrollbar-thumb{box-shadow:inset 0 0 10px silver;border-radius:5px}';

    class FfspbContent {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null, hAsync('div', { class: 'ffspb-content__desktop-wrapper' }, hAsync('slot', null)));
      }
      renderMobile() {
        return hAsync('ion-content', { scrollEvents: true }, hAsync('slot', null));
      }
      static get style() {
        return ffspbContentComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 4,
          $tagName$: 'ffspb-content',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbContentInnerComponentCss =
      'ffspb-content-inner{display:block}ffspb-content-inner.desktop-wrapper{min-height:calc(100% - 511px);max-width:calc(var(--content-width));margin:0 auto;background:red}';

    class FfspbContentInner {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, { class: 'desktop-wrapper' }, hAsync('slot', null));
      }
      renderMobile() {
        return hAsync(Host, null, hAsync('slot', null));
      }
      static get style() {
        return ffspbContentInnerComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 4,
          $tagName$: 'ffspb-content-inner',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbCookiePolicyPageComponentCss = '';

    class FfspbCookiePolicyPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null, hAsync('ffspb-header', null), hAsync('ffspb-content', null, hAsync('ffspb-content-inner', null, 'COOKIE POLICY'), hAsync('ffspb-footer', null)));
      }
      renderMobile() {
        return [hAsync('ffspb-header', null), hAsync('ion-content', null, 'COOKIE POLICY', hAsync('ffspb-footer', null))];
      }
      static get style() {
        return ffspbCookiePolicyPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-cookie-policy-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    var CopyrightIcon = `<svg width="17" height="17" viewBox="0 0 17 17"  xmlns="http://www.w3.org/2000/svg">
<path d="M8.5 1.0625C4.39277 1.0625 1.0625 4.39277 1.0625 8.5C1.0625 12.6072 4.39277 15.9375 8.5 15.9375C12.6072 15.9375 15.9375 12.6072 15.9375 8.5C15.9375 4.39277 12.6072 1.0625 8.5 1.0625ZM8.5 14.6758C5.09004 14.6758 2.32422 11.91 2.32422 8.5C2.32422 5.09004 5.09004 2.32422 8.5 2.32422C11.91 2.32422 14.6758 5.09004 14.6758 8.5C14.6758 11.91 11.91 14.6758 8.5 14.6758ZM8.59297 5.83213C9.47285 5.83213 10.0705 6.39326 10.1369 7.2167C10.1419 7.28643 10.2 7.33955 10.2697 7.33955H11.211C11.2542 7.33955 11.2891 7.30469 11.2891 7.26152C11.2891 5.82217 10.1535 4.81445 8.58799 4.81445C6.76348 4.81445 5.71094 6.04629 5.71094 8.08164V8.9499C5.71094 10.9703 6.76348 12.1855 8.58799 12.1855C10.1485 12.1855 11.2891 11.2094 11.2891 9.83809C11.2891 9.79492 11.2542 9.76006 11.211 9.76006H10.2681C10.1983 9.76006 10.1419 9.81318 10.1353 9.88125C10.0655 10.6466 9.46953 11.1729 8.59131 11.1729C7.50723 11.1729 6.89629 10.3776 6.89629 8.95488V8.08164C6.89795 6.6373 7.51055 5.83213 8.59297 5.83213Z"/>
</svg>
`;

    var AppleIcon = `<?xml version="1.0" encoding="iso-8859-1"?>
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 512.003 512.003" style="enable-background:new 0 0 512.003 512.003;" xml:space="preserve">
	<g>
		<path d="M351.98,0c-27.296,1.888-59.2,19.36-77.792,42.112c-16.96,20.64-30.912,51.296-25.472,81.088
			c29.824,0.928,60.64-16.96,78.496-40.096C343.916,61.568,356.556,31.104,351.98,0z"/>
	</g>
	<g>
		<path d="M459.852,171.776c-26.208-32.864-63.04-51.936-97.824-51.936c-45.92,0-65.344,21.984-97.248,21.984
			c-32.896,0-57.888-21.92-97.6-21.92c-39.008,0-80.544,23.84-106.88,64.608c-37.024,57.408-30.688,165.344,29.312,257.28
			c21.472,32.896,50.144,69.888,87.648,70.208c33.376,0.32,42.784-21.408,88-21.632c45.216-0.256,53.792,21.92,87.104,21.568
			c37.536-0.288,67.776-41.28,89.248-74.176c15.392-23.584,21.12-35.456,33.056-62.08
			C387.852,342.624,373.932,219.168,459.852,171.776z"/>
	</g>
</svg>
`;

    var GoogleIcon = `<svg xmlns="http://www.w3.org/2000/svg" height="800" width="1200" id="svg60" version="1.1" viewBox="-4.12599 -7.65905 35.75858 45.9543"><defs id="defs38"><linearGradient gradientUnits="userSpaceOnUse" y2="21.86" x2="-5.9" y1="1.87" x1="14.09" id="linear-gradient"><stop id="stop4" stop-color="#008eff" offset="0"/><stop id="stop6" stop-color="#008fff" offset=".01"/><stop id="stop8" stop-color="#00acff" offset=".26"/><stop id="stop10" stop-color="#00c0ff" offset=".51"/><stop id="stop12" stop-color="#00cdff" offset=".76"/><stop id="stop14" stop-color="#00d1ff" offset="1"/></linearGradient><linearGradient gradientUnits="userSpaceOnUse" y2="15.32" x2="-2.37" y1="15.32" x1="26.45" id="linear-gradient-2"><stop id="stop17" stop-color="#ffd800" offset="0"/><stop id="stop19" stop-color="#ff8a00" offset="1"/></linearGradient><linearGradient gradientUnits="userSpaceOnUse" y2="45.15" x2="-9.41" y1="18.05" x1="17.69" id="linear-gradient-3"><stop id="stop22" stop-color="#ff3a44" offset="0"/><stop id="stop24" stop-color="#b11162" offset="1"/></linearGradient><linearGradient gradientUnits="userSpaceOnUse" y2="3.81" x2="8.92" y1="-8.29" x1="-3.19" id="linear-gradient-4"><stop id="stop27" stop-color="#328e71" offset="0"/><stop id="stop29" stop-color="#2d9571" offset=".07"/><stop id="stop31" stop-color="#15bd74" offset=".48"/><stop id="stop33" stop-color="#06d575" offset=".8"/><stop id="stop35" stop-color="#00de76" offset="1"/></linearGradient><style id="style2">.cls-7{opacity:.07}</style></defs><g transform="translate(.004)" id="g58"><g id="g56"><path id="path40" d="M.55.48A2.39 2.39 0 000 2.15v26.34a2.41 2.41 0 00.55 1.67l.09.09 14.75-14.76v-.35L.64.39z" fill="url(#linear-gradient)"/><path id="path42" d="M20.31 20.41l-4.92-4.92v-.35l4.92-4.91.11.06 5.83 3.31c1.67.94 1.67 2.49 0 3.44l-5.83 3.31z" fill="url(#linear-gradient-2)"/><path id="path44" d="M20.42 20.35l-5-5L.55 30.16a2 2 0 002.45.07l17.39-9.88" fill="url(#linear-gradient-3)"/><path id="path46" d="M20.42 10.29L3 .4A1.93 1.93 0 00.55.48l14.84 14.84z" fill="url(#linear-gradient-4)"/><path id="path48" d="M20.31 20.24L3 30.06a2 2 0 01-2.39 0l-.09.09.09.09a2 2 0 002.39 0l17.39-9.88z" opacity=".1"/><path id="path50" d="M.55 30A2.43 2.43 0 010 28.32v.17a2.41 2.41 0 00.55 1.67l.09-.09z" class="cls-7"/><path id="path52" d="M26.25 16.86l-5.94 3.38.11.11L26.25 17a2.11 2.11 0 001.25-1.72 2.21 2.21 0 01-1.25 1.58z" class="cls-7"/><path id="path54" d="M3 .58l23.25 13.19a2.2 2.2 0 011.25 1.55 2.09 2.09 0 00-1.25-1.72L3 .4C1.36-.54 0 .24 0 2.15v.17C0 .42 1.36-.37 3 .58z" fill="#fff" opacity=".3"/></g></g></svg>`;

    var EmailIcon = `<svg width="25" height="25" viewBox="0 0 25 25" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M22.6562 3.90625H2.34375C1.91162 3.90625 1.5625 4.25537 1.5625 4.6875V20.3125C1.5625 20.7446 1.91162 21.0938 2.34375 21.0938H22.6562C23.0884 21.0938 23.4375 20.7446 23.4375 20.3125V4.6875C23.4375 4.25537 23.0884 3.90625 22.6562 3.90625ZM20.6836 6.56494L12.981 12.5586C12.7905 12.7075 12.5244 12.7075 12.334 12.5586L4.62891 6.56494C4.59986 6.54253 4.57856 6.51158 4.56798 6.47645C4.5574 6.44132 4.55809 6.40376 4.56993 6.36904C4.58177 6.33431 4.60419 6.30416 4.63403 6.28282C4.66387 6.26147 4.69964 6.24999 4.73633 6.25H20.5762C20.6129 6.24999 20.6486 6.26147 20.6785 6.28282C20.7083 6.30416 20.7307 6.33431 20.7426 6.36904C20.7544 6.40376 20.7551 6.44132 20.7445 6.47645C20.7339 6.51158 20.7126 6.54253 20.6836 6.56494Z" fill="url(#paint0_linear_250:606)"/>
<defs>
<linearGradient id="paint0_linear_250:606" x1="1.5625" y1="3.90625" x2="25.9537" y2="16.0326" gradientUnits="userSpaceOnUse">
<stop stop-color="#C9C9C9"/>
<stop offset="0.471875" stop-color="#FEFEFE"/>
<stop offset="1" stop-color="#C9C9C9"/>
</linearGradient>
</defs>
</svg>
`;

    var TwitterIcon = `<svg width="28" height="28" viewBox="0 0 28 28" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M24.0625 3.0625H3.9375C3.45352 3.0625 3.0625 3.45352 3.0625 3.9375V24.0625C3.0625 24.5465 3.45352 24.9375 3.9375 24.9375H24.0625C24.5465 24.9375 24.9375 24.5465 24.9375 24.0625V3.9375C24.9375 3.45352 24.5465 3.0625 24.0625 3.0625ZM19.8871 10.984C19.8953 11.1125 19.8953 11.2465 19.8953 11.3777C19.8953 15.3918 16.8383 20.0156 11.252 20.0156C9.5293 20.0156 7.93242 19.5152 6.58711 18.6539C6.8332 18.6813 7.06836 18.6922 7.31992 18.6922C8.7418 18.6922 10.0488 18.2109 11.0906 17.3961C9.75625 17.3688 8.63516 16.4938 8.25234 15.2906C8.71992 15.359 9.14102 15.359 9.62227 15.2359C8.93519 15.0963 8.31763 14.7232 7.8745 14.1799C7.43137 13.6366 7.19 12.9566 7.19141 12.2555V12.2172C7.59336 12.4441 8.06641 12.5836 8.56133 12.6027C8.14527 12.3255 7.80406 11.9498 7.56796 11.5091C7.33186 11.0683 7.20815 10.5762 7.20781 10.0762C7.20781 9.51016 7.35547 8.99336 7.6207 8.54492C8.38333 9.48373 9.33497 10.2516 10.4138 10.7985C11.4926 11.3454 12.6744 11.6592 13.8824 11.7195C13.4531 9.65508 14.9953 7.98438 16.8492 7.98438C17.7242 7.98438 18.5117 8.35078 19.0668 8.94141C19.7531 8.81289 20.4094 8.55586 20.9945 8.21133C20.7676 8.91406 20.2918 9.50742 19.6602 9.88203C20.2727 9.81641 20.8633 9.64688 21.4102 9.40898C20.9973 10.016 20.4805 10.5547 19.8871 10.984Z" fill="url(#paint0_linear_250:615)"/>
<defs>
<linearGradient id="paint0_linear_250:615" x1="3.0625" y1="3.0625" x2="29.4552" y2="13.3722" gradientUnits="userSpaceOnUse">
<stop stop-color="#C9C9C9"/>
<stop offset="0.471875" stop-color="#FEFEFE"/>
<stop offset="1" stop-color="#C9C9C9"/>
</linearGradient>
</defs>
</svg>
`;

    var IgIcon = `<svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M22.5 3.75H7.5C5.375 3.75 3.75 5.375 3.75 7.5V22.5C3.75 24.625 5.375 26.25 7.5 26.25H22.5C24.625 26.25 26.25 24.625 26.25 22.5V7.5C26.25 5.375 24.625 3.75 22.5 3.75ZM15 11.25C17.125 11.25 18.75 12.875 18.75 15C18.75 17.125 17.125 18.75 15 18.75C12.875 18.75 11.25 17.125 11.25 15C11.25 12.875 12.875 11.25 15 11.25ZM19.75 8.75C19.75 7.875 20.5 7.25 21.25 7.25C22 7.25 22.75 8 22.75 8.75C22.75 9.5 22.125 10.25 21.25 10.25C20.375 10.25 19.75 9.625 19.75 8.75ZM22.5 23.75H7.5C6.75 23.75 6.25 23.25 6.25 22.5V15H8.75C8.75 18.5 11.5 21.25 15 21.25C18.5 21.25 21.25 18.5 21.25 15H23.75V22.5C23.75 23.25 23.25 23.75 22.5 23.75Z" fill="url(#paint0_linear_250:611)"/>
<defs>
<linearGradient id="paint0_linear_250:611" x1="3.75" y1="3.75" x2="30.8968" y2="14.3542" gradientUnits="userSpaceOnUse">
<stop stop-color="#C9C9C9"/>
<stop offset="0.471875" stop-color="#FEFEFE"/>
<stop offset="1" stop-color="#C9C9C9"/>
</linearGradient>
</defs>
</svg>
`;

    var FbIcon = `<svg width="30" height="30" viewBox="0 0 30 30" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M24.607 4.19971H5.39142C5.07523 4.19971 4.77199 4.32531 4.54841 4.54889C4.32483 4.77248 4.19922 5.07572 4.19922 5.39191V24.6078C4.1993 24.9239 4.32494 25.2271 4.54851 25.4506C4.77208 25.6741 5.07528 25.7997 5.39142 25.7997H15.7363V17.4351H12.9214V14.1753H15.7363V11.7711C15.7363 8.98111 17.4403 7.46221 19.9291 7.46221C21.1213 7.46221 22.1458 7.55071 22.4446 7.59061V10.5063L20.7184 10.5072C19.3648 10.5072 19.1029 11.1504 19.1029 12.0942V14.1756H22.3309L21.9106 17.4354H19.1029V25.7997H24.6073C24.9235 25.7996 25.2266 25.674 25.4501 25.4504C25.6737 25.2268 25.7992 24.9236 25.7992 24.6075V5.39191C25.7992 5.07572 25.6736 4.77248 25.45 4.54889C25.2265 4.32531 24.9232 4.19971 24.607 4.19971Z" fill="url(#paint0_linear_250:609)"/>
<defs>
<linearGradient id="paint0_linear_250:609" x1="4.19922" y1="4.19971" x2="30.2601" y2="14.3798" gradientUnits="userSpaceOnUse">
<stop stop-color="#C9C9C9"/>
<stop offset="0.471875" stop-color="#FEFEFE"/>
<stop offset="1" stop-color="#C9C9C9"/>
</linearGradient>
</defs>
</svg>
`;

    var VkIcon = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M22.8002 20.4002V3.6002C22.8002 2.2802 21.7166 1.2002 20.3942 1.2002H3.6062C2.2262 1.2002 1.2002 2.2238 1.2002 3.6002V20.4002C1.2002 21.7778 2.2262 22.8002 3.6062 22.8002H20.3942C21.031 22.7993 21.6415 22.5463 22.0923 22.0966C22.5432 21.6469 22.7977 21.037 22.8002 20.4002ZM18.221 13.9286C18.221 13.9286 19.5794 15.269 19.9142 15.8906C19.9238 15.9038 19.9274 15.9158 19.931 15.9206C20.0666 16.1486 20.1014 16.3286 20.033 16.4606C19.9202 16.6802 19.5362 16.7906 19.4054 16.8002H17.0066C16.8386 16.8002 16.4906 16.757 16.0682 16.4654C15.7442 16.2398 15.4238 15.8666 15.1118 15.503C14.6462 14.963 14.243 14.495 13.8374 14.495C13.7859 14.4949 13.7348 14.5034 13.6862 14.5202C13.3778 14.6186 12.9866 15.0566 12.9866 16.2266C12.9866 16.5926 12.6986 16.8014 12.4946 16.8014H11.3954C11.021 16.8014 9.071 16.6706 7.3442 14.8478C5.225 12.6158 3.3218 8.1386 3.305 8.099C3.185 7.8098 3.4334 7.6526 3.7034 7.6526H6.1274C6.4526 7.6526 6.557 7.8494 6.6314 8.0258C6.7154 8.2262 7.0322 9.035 7.5506 9.9446C8.3942 11.4242 8.9138 12.0266 9.3278 12.0266C9.40521 12.0262 9.48122 12.0059 9.5486 11.9678C10.0898 11.669 9.989 9.7394 9.965 9.341C9.965 9.2654 9.9638 8.4782 9.6878 8.1002C9.4886 7.8266 9.1514 7.7222 8.9474 7.6826C9.03058 7.56797 9.14004 7.47497 9.2666 7.4114C9.6374 7.2266 10.3058 7.2002 10.9706 7.2002H11.3402C12.0614 7.2098 12.2486 7.2566 12.509 7.3226C13.0358 7.4486 13.0466 7.7906 12.9998 8.9546C12.9866 9.2858 12.9722 9.6614 12.9722 10.1018C12.9722 10.1966 12.9686 10.301 12.9686 10.409C12.9518 11.0042 12.9326 11.6774 13.3526 11.9534C13.407 11.9874 13.4697 12.0057 13.5338 12.0062C13.6802 12.0062 14.1182 12.0062 15.305 9.9698C15.827 9.071 16.229 8.0102 16.2566 7.931C16.2985 7.84537 16.3592 7.7703 16.4342 7.7114C16.4957 7.67947 16.5641 7.66338 16.6334 7.6646H19.4834C19.7954 7.6646 20.0066 7.7114 20.0462 7.8302C20.1146 8.021 20.033 8.603 18.731 10.3622L18.1514 11.1302C16.9706 12.6758 16.9706 12.755 18.221 13.9286Z" fill="url(#paint0_linear_250:613)"/>
<defs>
<linearGradient id="paint0_linear_250:613" x1="1.2002" y1="1.2002" x2="27.2611" y2="11.3802" gradientUnits="userSpaceOnUse">
<stop stop-color="#C9C9C9"/>
<stop offset="0.471875" stop-color="#FEFEFE"/>
<stop offset="1" stop-color="#C9C9C9"/>
</linearGradient>
</defs>
</svg>
`;

    const routes = {
      home: '/',
      license_agreement: 'license',
      cookie_policy: 'cookies',
      changelog: 'changelog',
      vacancies: 'career',
      advertisement: 'sales',
      partnership: 'partnership',
      healthcheck: 'healthcheck',
      about: 'about',
      league: '/leagues/:leagueId/:leagueName',
      league_hall_of_fame: '/leagues/:leagueId/:leagueName/hall-of-fame',
      league_contacts: '/leagues/:leagueId/:leagueName/contacts',
      team: '/teams/:teamId/:teamName',
      team_games: '/teams/:teamId/:teamName/games',
      team_players_stats: '/teams/:teamId/:teamName/players',
      team_transfers: '/teams/:teamId/:teamName/transfers',
      player: '/players/:playerId/:playerName',
      player_games: '/players/:playerId/:playerName/games',
      stadiums: '/stadiums',
      stadium: '/stadium/:stadiumId/:stadiumName',
      game: '/games/:gameId/:gameTitle',
      season: '/seasons/:seasonId/:tournamentName',
      season_calendar: '/seasons/:seasonId/:tournamentName/calendar',
      season_players: '/seasons/:seasonId/:tournamentName/players',
      season_stadiums: '/seasons/:seasonId/:tournamentName/stadiums',
      season_staff: '/seasons/:seasonId/:tournamentName/staff',
      referees: '/referees',
      referee: '/referee/:refereeId/:refereeName',
      news: '/news',
      post: '/news/:postId/:postTitle',
      login: '/login',
      profile: '/profile',
    };

    const ffspbFooterComponentCss =
      'ffspb-footer .desktop-wrapper{margin-top:120px;width:100%;background:#292929;display:block;text-align:center}ffspb-footer .desktop-wrapper .footer-content{padding:44px 0;max-width:1600px;margin:0 auto}ffspb-footer .desktop-wrapper .footer-content .columns{display:flex;align-items:flex-start;justify-content:space-evenly}ffspb-footer .desktop-wrapper .footer-content .columns .column{margin-bottom:10%;padding:0 20px}ffspb-footer .desktop-wrapper .footer-content .columns .column h4{margin:0;font-weight:700;color:white;font-size:16px;text-align:left}ffspb-footer .desktop-wrapper .footer-content .columns .column h5{font-weight:400;color:white;font-size:16px;text-align:left;margin-top:15px}ffspb-footer .desktop-wrapper .footer-content .columns .column .line{display:flex;align-items:center;font-size:16px;color:#adadad;margin-top:15px;text-align:left;transition:color 0.2s ease-in-out;cursor:pointer;text-decoration:none}ffspb-footer .desktop-wrapper .footer-content .columns .column .line:hover{text-decoration:underline}ffspb-footer .desktop-wrapper .footer-content .columns .column .line ftb-icon{margin-right:11px;height:25px}ffspb-footer .desktop-wrapper .footer-content .columns .column .socials{display:flex;align-items:center;margin-bottom:50px}ffspb-footer .desktop-wrapper .footer-content .columns .column .socials ftb-icon{height:22px;margin-right:17px;border-radius:4px;opacity:0.95;transition:opacity 0.2s ease-in-out}ffspb-footer .desktop-wrapper .footer-content .columns .column .socials ftb-icon.vk-icon{height:18px}ffspb-footer .desktop-wrapper .footer-content .columns .column .socials ftb-icon:hover{opacity:1}ffspb-footer .desktop-wrapper .footer-content .columns .column .stores{margin-top:15px}ffspb-footer .desktop-wrapper .footer-content .columns .column .stores .store{margin-top:10px;background:black;display:flex;align-items:center;width:175px;height:60px;border-radius:10px;cursor:pointer}ffspb-footer .desktop-wrapper .footer-content .columns .column .stores .store:hover ftb-icon{transform:scale(1.05)}ffspb-footer .desktop-wrapper .footer-content .columns .column .stores .store .download-link{white-space:nowrap}ffspb-footer .desktop-wrapper .footer-content .columns .column .stores .store ftb-icon{fill:white;height:30px;width:30px;margin:0 25px;transition:transform 0.2s ease-in-out}ffspb-footer .desktop-wrapper .footer-content .columns .column .stores .store ftb-icon.google-icon{height:40px}ffspb-footer .desktop-wrapper .footer-content .columns .column .stores .store .text{color:white;text-align:left}ffspb-footer .desktop-wrapper .footer-content .columns .column .stores .store .text .download-link{font-size:12px}ffspb-footer .desktop-wrapper .footer-content .columns .column .stores .store .text .store-link{font-size:14px}@media only screen and (max-width: 1150px){ffspb-footer .desktop-wrapper .footer-content .columns .column .line{font-size:14px !important}ffspb-footer .desktop-wrapper .footer-content .columns .column .store{height:50px !important}}ffspb-footer .desktop-wrapper .footer-content .copyright-line{color:#515151;font-size:16px;display:flex;align-items:center;justify-content:center}ffspb-footer .desktop-wrapper .footer-content .copyright-line ftb-icon{height:17px;margin-right:5px;fill:#515151;margin-top:-2px}ffspb-footer .mobile-wrapper{background:#292929;margin-top:60px;display:flex;flex-wrap:wrap;justify-content:space-evenly}@media only screen and (max-width: 600px){ffspb-footer .mobile-wrapper{justify-content:space-between}}ffspb-footer .mobile-wrapper .column{padding-left:22px;padding-top:35px;min-width:300px}ffspb-footer .mobile-wrapper .column h4{margin:0;font-weight:700;color:white;font-size:16px;text-align:left}ffspb-footer .mobile-wrapper .column h5{font-weight:400;color:white;font-size:16px;text-align:left;margin-top:15px}ffspb-footer .mobile-wrapper .column .line{display:flex;align-items:center;font-size:16px;color:#adadad;margin-top:15px;text-align:left;transition:color 0.2s ease-in-out;cursor:pointer;text-decoration:none}ffspb-footer .mobile-wrapper .column .line:hover{text-decoration:underline}ffspb-footer .mobile-wrapper .column .line ftb-icon{margin-right:11px;height:25px}ffspb-footer .mobile-wrapper .stores{display:flex;margin-top:20px}ffspb-footer .mobile-wrapper .stores .store{background:black;display:flex;align-items:center;width:150px;height:50px;border-radius:10px;margin-right:10px}ffspb-footer .mobile-wrapper .stores .store .download-link{white-space:nowrap}ffspb-footer .mobile-wrapper .stores .store ftb-icon{fill:white;height:25px;width:25px;margin:0 20px;transition:transform 0.2s ease-in-out}ffspb-footer .mobile-wrapper .stores .store ftb-icon.google-icon{height:35px}ffspb-footer .mobile-wrapper .stores .store .text{color:white;text-align:left}ffspb-footer .mobile-wrapper .stores .store .text .download-link{font-size:12px}ffspb-footer .mobile-wrapper .stores .store .text .store-link{font-size:14px}ffspb-footer .mobile-wrapper .socials{display:flex;align-items:center;margin-top:10px}ffspb-footer .mobile-wrapper .socials ftb-icon{height:32px;margin-right:10px;border-radius:4px}ffspb-footer .mobile-wrapper .socials ftb-icon.vk-icon{height:27px}ffspb-footer .mobile-wrapper .copyright-line{color:#515151;font-size:16px;width:100%;display:flex;align-items:center;justify-content:center;padding-bottom:40px;padding-top:40px}ffspb-footer .mobile-wrapper .copyright-line ftb-icon{height:17px;width:17px;margin-right:5px;fill:#515151;margin-top:-2px}';

    class FfspbFooter {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'desktop-wrapper' },
            hAsync(
              'div',
              { class: 'footer-content' },
              hAsync(
                'div',
                { class: 'columns' },
                hAsync(
                  'div',
                  { class: 'column' },
                  hAsync('h4', null, '\u041A\u043E\u043D\u0442\u0430\u043A\u0442\u044B'),
                  hAsync(
                    'h5',
                    null,
                    '\u0424\u0435\u0434\u0435\u0440\u0430\u0446\u0438\u044F \u0444\u0443\u0442\u0431\u043E\u043B\u0430 \u0421\u0430\u043D\u043A\u0442-\u041F\u0435\u0442\u0435\u0440\u0431\u0443\u0440\u0433\u0430',
                  ),
                  hAsync('a', { class: 'line', href: 'tel:+78123692431' }, '+7 (812) 369 24 31'),
                  hAsync('a', { class: 'line', href: 'mailto: ffspb@mail.ru', target: '_blank' }, 'ffspb@mail.ru'),
                ),
                hAsync(
                  'div',
                  { class: 'column' },
                  hAsync('h4', null, '\u0421\u0441\u044B\u043B\u043A\u0438'),
                  hAsync(
                    'a',
                    { class: 'line' },
                    '\u041A\u0430\u043B\u0435\u043D\u0434\u0430\u0440\u043D\u044B\u0439 \u043F\u043B\u0430\u043D \u0441\u043E\u0440\u0435\u0432\u043D\u043E\u0432\u0430\u043D\u0438\u0439',
                  ),
                  hAsync(
                    'ion-router-link',
                    { href: routes.healthcheck, class: 'line' },
                    '\u0417\u0430\u0434\u0430\u0442\u044C \u0432\u043E\u043F\u0440\u043E\u0441 \u0432 \u0442\u0435\u0445\u043F\u043E\u0434\u0434\u0435\u0440\u0436\u043A\u0443',
                  ),
                  hAsync('ion-router-link', { class: 'line', href: routes.cookie_policy }, '\u041F\u043E\u043B\u0438\u0442\u0438\u043A\u0430 Cookie'),
                  hAsync(
                    'ion-router-link',
                    { class: 'line', href: routes.license_agreement },
                    '\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u043E\u0435 \u0441\u043E\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u0435',
                  ),
                ),
                hAsync(
                  'div',
                  { class: 'column' },
                  hAsync('h4', null, '\u041F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u044F'),
                  hAsync(
                    'div',
                    { class: 'stores' },
                    hAsync(
                      'a',
                      { class: 'store' },
                      hAsync('ftb-icon', { svg: AppleIcon, class: 'apple-icon' }),
                      hAsync(
                        'div',
                        { class: 'text' },
                        hAsync('div', { class: 'download-link' }, '\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 \u0432'),
                        hAsync('div', { class: 'store-link' }, 'App Store'),
                      ),
                    ),
                    hAsync(
                      'a',
                      { class: 'store' },
                      hAsync('ftb-icon', { svg: GoogleIcon, class: 'google-icon' }),
                      hAsync(
                        'div',
                        { class: 'text' },
                        hAsync('div', { class: 'download-link' }, '\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 \u0432'),
                        hAsync('div', { class: 'store-link' }, 'Google Play'),
                      ),
                    ),
                  ),
                ),
                hAsync(
                  'div',
                  { class: 'column' },
                  hAsync(
                    'div',
                    { class: 'socials' },
                    hAsync('a', { href: '' }, hAsync('ftb-icon', { svg: FbIcon })),
                    hAsync('a', { href: '' }, hAsync('ftb-icon', { svg: IgIcon })),
                    hAsync('a', { href: '' }, hAsync('ftb-icon', { svg: VkIcon, class: 'vk-icon' })),
                    hAsync('a', { href: '' }, hAsync('ftb-icon', { svg: TwitterIcon })),
                  ),
                  hAsync('h4', null, '\u0420\u0430\u0441\u0441\u044B\u043B\u043A\u0430'),
                  hAsync(
                    'a',
                    { class: 'line' },
                    hAsync('ftb-icon', { svg: EmailIcon }),
                    '\u041F\u043E\u0434\u043F\u0438\u0441\u0430\u0442\u044C\u0441\u044F \u043D\u0430 \u043D\u043E\u0432\u043E\u0441\u0442\u0438',
                  ),
                ),
              ),
              hAsync(
                'div',
                { class: 'copyright-line' },
                hAsync('ftb-icon', { svg: CopyrightIcon }),
                '\u0424\u0435\u0434\u0435\u0440\u0430\u0446\u0438\u044F \u0424\u0443\u0442\u0431\u043E\u043B\u0430 \u0421\u0430\u043D\u043A\u0442-\u041F\u0435\u0442\u0435\u0440\u0431\u0443\u0440\u0433\u0430',
              ),
            ),
          ),
        );
      }
      renderMobile() {
        return hAsync(
          'div',
          { class: 'mobile-wrapper' },
          hAsync(
            'div',
            { class: 'side' },
            hAsync(
              'div',
              { class: 'column' },
              hAsync('h4', null, '\u041A\u043E\u043D\u0442\u0430\u043A\u0442\u044B'),
              hAsync(
                'h5',
                null,
                '\u0424\u0435\u0434\u0435\u0440\u0430\u0446\u0438\u044F \u0444\u0443\u0442\u0431\u043E\u043B\u0430 \u0421\u0430\u043D\u043A\u0442-\u041F\u0435\u0442\u0435\u0440\u0431\u0443\u0440\u0433\u0430',
              ),
              hAsync('a', { class: 'line', href: 'tel:+78123692431' }, '+7 (812) 369 24 31'),
              hAsync('a', { class: 'line', href: 'mailto: ffspb@mail.ru', target: '_blank' }, 'ffspb@mail.ru'),
            ),
            hAsync(
              'div',
              { class: 'column' },
              hAsync('h4', null, '\u0421\u0441\u044B\u043B\u043A\u0438'),
              hAsync(
                'a',
                { class: 'line' },
                '\u041A\u0430\u043B\u0435\u043D\u0434\u0430\u0440\u043D\u044B\u0439 \u043F\u043B\u0430\u043D \u0441\u043E\u0440\u0435\u0432\u043D\u043E\u0432\u0430\u043D\u0438\u0439',
              ),
              hAsync(
                'a',
                { class: 'line' },
                '\u0417\u0430\u0434\u0430\u0442\u044C \u0432\u043E\u043F\u0440\u043E\u0441 \u0432 \u0442\u0435\u0445\u043F\u043E\u0434\u0434\u0435\u0440\u0436\u043A\u0443',
              ),
              hAsync('a', { class: 'line', href: routes.cookie_policy }, '\u041F\u043E\u043B\u0438\u0442\u0438\u043A\u0430 Cookie'),
              hAsync(
                'a',
                { class: 'line', href: routes.license_agreement },
                '\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u043E\u0435 \u0441\u043E\u0433\u043B\u0430\u0448\u0435\u043D\u0438\u0435',
              ),
            ),
          ),
          hAsync(
            'div',
            { class: 'side' },
            hAsync(
              'div',
              { class: 'column' },
              hAsync('h4', null, '\u0420\u0430\u0441\u0441\u044B\u043B\u043A\u0430'),
              hAsync(
                'a',
                { class: 'line' },
                hAsync('ftb-icon', { svg: EmailIcon }),
                '\u041F\u043E\u0434\u043F\u0438\u0441\u0430\u0442\u044C\u0441\u044F \u043D\u0430 \u043D\u043E\u0432\u043E\u0441\u0442\u0438',
              ),
            ),
            hAsync(
              'div',
              { class: 'column' },
              hAsync('h4', null, '\u0421\u043E\u0446\u0441\u0435\u0442\u0438'),
              hAsync(
                'div',
                { class: 'socials' },
                hAsync('a', { href: '' }, hAsync('ftb-icon', { svg: FbIcon })),
                hAsync('a', { href: '' }, hAsync('ftb-icon', { svg: IgIcon })),
                hAsync('a', { href: '' }, hAsync('ftb-icon', { svg: VkIcon, class: 'vk-icon' })),
                hAsync('a', { href: '' }, hAsync('ftb-icon', { svg: TwitterIcon })),
              ),
            ),
            hAsync(
              'div',
              { class: 'column' },
              hAsync('h4', null, '\u041F\u0440\u0438\u043B\u043E\u0436\u0435\u043D\u0438\u044F'),
              hAsync(
                'div',
                { class: 'stores' },
                hAsync(
                  'a',
                  { class: 'store' },
                  hAsync('ftb-icon', { svg: AppleIcon, class: 'apple-icon' }),
                  hAsync(
                    'div',
                    { class: 'text' },
                    hAsync('div', { class: 'download-link' }, '\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 \u0432'),
                    hAsync('div', { class: 'store-link' }, 'App Store'),
                  ),
                ),
                hAsync(
                  'a',
                  { class: 'store' },
                  hAsync('ftb-icon', { svg: GoogleIcon, class: 'google-icon' }),
                  hAsync(
                    'div',
                    { class: 'text' },
                    hAsync('div', { class: 'download-link' }, '\u0437\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u0435 \u0432'),
                    hAsync('div', { class: 'store-link' }, 'Google Play'),
                  ),
                ),
              ),
            ),
          ),
          hAsync(
            'div',
            { class: 'copyright-line' },
            hAsync('ftb-icon', { svg: CopyrightIcon }),
            '\u0424\u0435\u0434\u0435\u0440\u0430\u0446\u0438\u044F \u0424\u0443\u0442\u0431\u043E\u043B\u0430 \u0421\u0430\u043D\u043A\u0442-\u041F\u0435\u0442\u0435\u0440\u0431\u0443\u0440\u0433\u0430',
          ),
        );
      }
      static get style() {
        return ffspbFooterComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-footer',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbGanePageComponentCss = '';

    class FfspbGanePage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbGanePageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-gane-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    var ChevronIcon$1 = `<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 width="444.819px" height="444.819px" viewBox="0 0 444.819 444.819" style="enable-background:new 0 0 444.819 444.819;"
	 xml:space="preserve">
<g>
	<path d="M434.252,114.203l-21.409-21.416c-7.419-7.04-16.084-10.561-25.975-10.561c-10.095,0-18.657,3.521-25.7,10.561
		L222.41,231.549L83.653,92.791c-7.042-7.04-15.606-10.561-25.697-10.561c-9.896,0-18.559,3.521-25.979,10.561l-21.128,21.416
		C3.615,121.436,0,130.099,0,140.188c0,10.277,3.619,18.842,10.848,25.693l185.864,185.865c6.855,7.23,15.416,10.848,25.697,10.848
		c10.088,0,18.75-3.617,25.977-10.848l185.865-185.865c7.043-7.044,10.567-15.608,10.567-25.693
		C444.819,130.287,441.295,121.629,434.252,114.203z"/>
</g>
</svg>
`;

    var SearchIcon = `<?xml version="1.0" encoding="iso-8859-1"?>
<svg version="1.1"  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 512.005 512.005" style="enable-background:new 0 0 512.005 512.005;" xml:space="preserve">
	<g>
		<path d="M505.749,475.587l-145.6-145.6c28.203-34.837,45.184-79.104,45.184-127.317c0-111.744-90.923-202.667-202.667-202.667
			S0,90.925,0,202.669s90.923,202.667,202.667,202.667c48.213,0,92.48-16.981,127.317-45.184l145.6,145.6
			c4.16,4.16,9.621,6.251,15.083,6.251s10.923-2.091,15.083-6.251C514.091,497.411,514.091,483.928,505.749,475.587z
			 M202.667,362.669c-88.235,0-160-71.765-160-160s71.765-160,160-160s160,71.765,160,160S290.901,362.669,202.667,362.669z"/>
	</g>
</svg>
`;

    function isFunction(value) {
      return typeof value === 'function';
    }

    function createErrorClass(createImpl) {
      const _super = instance => {
        Error.call(instance);
        instance.stack = new Error().stack;
      };
      const ctorFunc = createImpl(_super);
      ctorFunc.prototype = Object.create(Error.prototype);
      ctorFunc.prototype.constructor = ctorFunc;
      return ctorFunc;
    }

    const UnsubscriptionError = createErrorClass(
      _super =>
        function UnsubscriptionErrorImpl(errors) {
          _super(this);
          this.message = errors
            ? `${errors.length} errors occurred during unsubscription:
${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\n  ')}`
            : '';
          this.name = 'UnsubscriptionError';
          this.errors = errors;
        },
    );

    function arrRemove(arr, item) {
      if (arr) {
        const index = arr.indexOf(item);
        0 <= index && arr.splice(index, 1);
      }
    }

    class Subscription {
      constructor(initialTeardown) {
        this.initialTeardown = initialTeardown;
        this.closed = false;
        this._parentage = null;
        this._teardowns = null;
      }
      unsubscribe() {
        let errors;
        if (!this.closed) {
          this.closed = true;
          const { _parentage } = this;
          if (_parentage) {
            this._parentage = null;
            if (Array.isArray(_parentage)) {
              for (const parent of _parentage) {
                parent.remove(this);
              }
            } else {
              _parentage.remove(this);
            }
          }
          const { initialTeardown } = this;
          if (isFunction(initialTeardown)) {
            try {
              initialTeardown();
            } catch (e) {
              errors = e instanceof UnsubscriptionError ? e.errors : [e];
            }
          }
          const { _teardowns } = this;
          if (_teardowns) {
            this._teardowns = null;
            for (const teardown of _teardowns) {
              try {
                execTeardown(teardown);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = [...errors, ...err.errors];
                } else {
                  errors.push(err);
                }
              }
            }
          }
          if (errors) {
            throw new UnsubscriptionError(errors);
          }
        }
      }
      add(teardown) {
        var _a;
        if (teardown && teardown !== this) {
          if (this.closed) {
            execTeardown(teardown);
          } else {
            if (teardown instanceof Subscription) {
              if (teardown.closed || teardown._hasParent(this)) {
                return;
              }
              teardown._addParent(this);
            }
            (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
          }
        }
      }
      _hasParent(parent) {
        const { _parentage } = this;
        return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));
      }
      _addParent(parent) {
        const { _parentage } = this;
        this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
      }
      _removeParent(parent) {
        const { _parentage } = this;
        if (_parentage === parent) {
          this._parentage = null;
        } else if (Array.isArray(_parentage)) {
          arrRemove(_parentage, parent);
        }
      }
      remove(teardown) {
        const { _teardowns } = this;
        _teardowns && arrRemove(_teardowns, teardown);
        if (teardown instanceof Subscription) {
          teardown._removeParent(this);
        }
      }
    }
    Subscription.EMPTY = (() => {
      const empty = new Subscription();
      empty.closed = true;
      return empty;
    })();
    const EMPTY_SUBSCRIPTION = Subscription.EMPTY;
    function isSubscription(value) {
      return value instanceof Subscription || (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe));
    }
    function execTeardown(teardown) {
      if (isFunction(teardown)) {
        teardown();
      } else {
        teardown.unsubscribe();
      }
    }

    const config = {
      onUnhandledError: null,
      onStoppedNotification: null,
      Promise: undefined,
      useDeprecatedSynchronousErrorHandling: false,
      useDeprecatedNextContext: false,
    };

    const timeoutProvider = {
      setTimeout(...args) {
        const { delegate } = timeoutProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout)(...args);
      },
      clearTimeout(handle) {
        const { delegate } = timeoutProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
      },
      delegate: undefined,
    };

    function reportUnhandledError(err) {
      timeoutProvider.setTimeout(() => {
        const { onUnhandledError } = config;
        if (onUnhandledError) {
          onUnhandledError(err);
        } else {
          throw err;
        }
      });
    }

    function noop() {}

    const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined))();
    function errorNotification(error) {
      return createNotification('E', undefined, error);
    }
    function nextNotification(value) {
      return createNotification('N', value, undefined);
    }
    function createNotification(kind, value, error) {
      return {
        kind,
        value,
        error,
      };
    }

    function errorContext(cb) {
      {
        cb();
      }
    }

    class Subscriber extends Subscription {
      constructor(destination) {
        super();
        this.isStopped = false;
        if (destination) {
          this.destination = destination;
          if (isSubscription(destination)) {
            destination.add(this);
          }
        } else {
          this.destination = EMPTY_OBSERVER;
        }
      }
      static create(next, error, complete) {
        return new SafeSubscriber(next, error, complete);
      }
      next(value) {
        if (this.isStopped) {
          handleStoppedNotification(nextNotification(value), this);
        } else {
          this._next(value);
        }
      }
      error(err) {
        if (this.isStopped) {
          handleStoppedNotification(errorNotification(err), this);
        } else {
          this.isStopped = true;
          this._error(err);
        }
      }
      complete() {
        if (this.isStopped) {
          handleStoppedNotification(COMPLETE_NOTIFICATION, this);
        } else {
          this.isStopped = true;
          this._complete();
        }
      }
      unsubscribe() {
        if (!this.closed) {
          this.isStopped = true;
          super.unsubscribe();
          this.destination = null;
        }
      }
      _next(value) {
        this.destination.next(value);
      }
      _error(err) {
        try {
          this.destination.error(err);
        } finally {
          this.unsubscribe();
        }
      }
      _complete() {
        try {
          this.destination.complete();
        } finally {
          this.unsubscribe();
        }
      }
    }
    class SafeSubscriber extends Subscriber {
      constructor(observerOrNext, error, complete) {
        super();
        let next;
        if (isFunction(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          ({ next, error, complete } = observerOrNext);
          let context;
          if (this && config.useDeprecatedNextContext) {
            context = Object.create(observerOrNext);
            context.unsubscribe = () => this.unsubscribe();
          } else {
            context = observerOrNext;
          }
          next = next === null || next === void 0 ? void 0 : next.bind(context);
          error = error === null || error === void 0 ? void 0 : error.bind(context);
          complete = complete === null || complete === void 0 ? void 0 : complete.bind(context);
        }
        this.destination = {
          next: next ? wrapForErrorHandling(next) : noop,
          error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler),
          complete: complete ? wrapForErrorHandling(complete) : noop,
        };
      }
    }
    function wrapForErrorHandling(handler, instance) {
      return (...args) => {
        try {
          handler(...args);
        } catch (err) {
          {
            reportUnhandledError(err);
          }
        }
      };
    }
    function defaultErrorHandler(err) {
      throw err;
    }
    function handleStoppedNotification(notification, subscriber) {
      const { onStoppedNotification } = config;
      onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));
    }
    const EMPTY_OBSERVER = {
      closed: true,
      next: noop,
      error: defaultErrorHandler,
      complete: noop,
    };

    const observable = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();

    function identity(x) {
      return x;
    }

    function pipeFromArray(fns) {
      if (fns.length === 0) {
        return identity;
      }
      if (fns.length === 1) {
        return fns[0];
      }
      return function piped(input) {
        return fns.reduce((prev, fn) => fn(prev), input);
      };
    }

    class Observable {
      constructor(subscribe) {
        if (subscribe) {
          this._subscribe = subscribe;
        }
      }
      lift(operator) {
        const observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
      }
      subscribe(observerOrNext, error, complete) {
        const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
        errorContext(() => {
          const { operator, source } = this;
          subscriber.add(operator ? operator.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));
        });
        return subscriber;
      }
      _trySubscribe(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          sink.error(err);
        }
      }
      forEach(next, promiseCtor) {
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor((resolve, reject) => {
          let subscription;
          subscription = this.subscribe(
            value => {
              try {
                next(value);
              } catch (err) {
                reject(err);
                subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
              }
            },
            reject,
            resolve,
          );
        });
      }
      _subscribe(subscriber) {
        var _a;
        return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
      }
      [observable]() {
        return this;
      }
      pipe(...operations) {
        return pipeFromArray(operations)(this);
      }
      toPromise(promiseCtor) {
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor((resolve, reject) => {
          let value;
          this.subscribe(
            x => (value = x),
            err => reject(err),
            () => resolve(value),
          );
        });
      }
    }
    Observable.create = subscribe => {
      return new Observable(subscribe);
    };
    function getPromiseCtor(promiseCtor) {
      var _a;
      return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
    }
    function isObserver(value) {
      return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
    }
    function isSubscriber(value) {
      return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));
    }

    function hasLift(source) {
      return isFunction(source === null || source === void 0 ? void 0 : source.lift);
    }
    function operate(init) {
      return source => {
        if (hasLift(source)) {
          return source.lift(function (liftedSource) {
            try {
              return init(liftedSource, this);
            } catch (err) {
              this.error(err);
            }
          });
        }
        throw new TypeError('Unable to lift unknown Observable type');
      };
    }

    class OperatorSubscriber extends Subscriber {
      constructor(destination, onNext, onComplete, onError, onFinalize) {
        super(destination);
        this.onFinalize = onFinalize;
        this._next = onNext
          ? function (value) {
              try {
                onNext(value);
              } catch (err) {
                destination.error(err);
              }
            }
          : super._next;
        this._error = onError
          ? function (err) {
              try {
                onError(err);
              } catch (err) {
                destination.error(err);
              } finally {
                this.unsubscribe();
              }
            }
          : super._error;
        this._complete = onComplete
          ? function () {
              try {
                onComplete();
              } catch (err) {
                destination.error(err);
              } finally {
                this.unsubscribe();
              }
            }
          : super._complete;
      }
      unsubscribe() {
        var _a;
        const { closed } = this;
        super.unsubscribe();
        !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
      }
    }

    const ObjectUnsubscribedError = createErrorClass(
      _super =>
        function ObjectUnsubscribedErrorImpl() {
          _super(this);
          this.name = 'ObjectUnsubscribedError';
          this.message = 'object unsubscribed';
        },
    );

    class Subject extends Observable {
      constructor() {
        super();
        this.closed = false;
        this.observers = [];
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
      }
      lift(operator) {
        const subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      }
      _throwIfClosed() {
        if (this.closed) {
          throw new ObjectUnsubscribedError();
        }
      }
      next(value) {
        errorContext(() => {
          this._throwIfClosed();
          if (!this.isStopped) {
            const copy = this.observers.slice();
            for (const observer of copy) {
              observer.next(value);
            }
          }
        });
      }
      error(err) {
        errorContext(() => {
          this._throwIfClosed();
          if (!this.isStopped) {
            this.hasError = this.isStopped = true;
            this.thrownError = err;
            const { observers } = this;
            while (observers.length) {
              observers.shift().error(err);
            }
          }
        });
      }
      complete() {
        errorContext(() => {
          this._throwIfClosed();
          if (!this.isStopped) {
            this.isStopped = true;
            const { observers } = this;
            while (observers.length) {
              observers.shift().complete();
            }
          }
        });
      }
      unsubscribe() {
        this.isStopped = this.closed = true;
        this.observers = null;
      }
      get observed() {
        var _a;
        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      }
      _trySubscribe(subscriber) {
        this._throwIfClosed();
        return super._trySubscribe(subscriber);
      }
      _subscribe(subscriber) {
        this._throwIfClosed();
        this._checkFinalizedStatuses(subscriber);
        return this._innerSubscribe(subscriber);
      }
      _innerSubscribe(subscriber) {
        const { hasError, isStopped, observers } = this;
        return hasError || isStopped ? EMPTY_SUBSCRIPTION : (observers.push(subscriber), new Subscription(() => arrRemove(observers, subscriber)));
      }
      _checkFinalizedStatuses(subscriber) {
        const { hasError, thrownError, isStopped } = this;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped) {
          subscriber.complete();
        }
      }
      asObservable() {
        const observable = new Observable();
        observable.source = this;
        return observable;
      }
    }
    Subject.create = (destination, source) => {
      return new AnonymousSubject(destination, source);
    };
    class AnonymousSubject extends Subject {
      constructor(destination, source) {
        super();
        this.destination = destination;
        this.source = source;
      }
      next(value) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
      }
      error(err) {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
      }
      complete() {
        var _a, _b;
        (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      _subscribe(subscriber) {
        var _a, _b;
        return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
      }
    }

    const dateTimestampProvider = {
      now() {
        return (dateTimestampProvider.delegate || Date).now();
      },
      delegate: undefined,
    };

    class AsyncSubject extends Subject {
      constructor() {
        super(...arguments);
        this._value = null;
        this._hasValue = false;
        this._isComplete = false;
      }
      _checkFinalizedStatuses(subscriber) {
        const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;
        if (hasError) {
          subscriber.error(thrownError);
        } else if (isStopped || _isComplete) {
          _hasValue && subscriber.next(_value);
          subscriber.complete();
        }
      }
      next(value) {
        if (!this.isStopped) {
          this._value = value;
          this._hasValue = true;
        }
      }
      complete() {
        const { _hasValue, _value, _isComplete } = this;
        if (!_isComplete) {
          this._isComplete = true;
          _hasValue && super.next(_value);
          super.complete();
        }
      }
    }

    class Action extends Subscription {
      constructor(scheduler, work) {
        super();
      }
      schedule(state, delay = 0) {
        return this;
      }
    }

    const intervalProvider = {
      setInterval(...args) {
        const { delegate } = intervalProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) || setInterval)(...args);
      },
      clearInterval(handle) {
        const { delegate } = intervalProvider;
        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
      },
      delegate: undefined,
    };

    class AsyncAction extends Action {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
      }
      schedule(state, delay = 0) {
        if (this.closed) {
          return this;
        }
        this.state = state;
        const id = this.id;
        const scheduler = this.scheduler;
        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
      }
      requestAsyncId(scheduler, _id, delay = 0) {
        return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
      }
      recycleAsyncId(_scheduler, id, delay = 0) {
        if (delay != null && this.delay === delay && this.pending === false) {
          return id;
        }
        intervalProvider.clearInterval(id);
        return undefined;
      }
      execute(state, delay) {
        if (this.closed) {
          return new Error('executing a cancelled action');
        }
        this.pending = false;
        const error = this._execute(state, delay);
        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      }
      _execute(state, _delay) {
        let errored = false;
        let errorValue;
        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = e ? e : new Error('Scheduled action threw falsy error');
        }
        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      }
      unsubscribe() {
        if (!this.closed) {
          const { id, scheduler } = this;
          const { actions } = scheduler;
          this.work = this.state = this.scheduler = null;
          this.pending = false;
          arrRemove(actions, this);
          if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
          super.unsubscribe();
        }
      }
    }

    class Scheduler {
      constructor(schedulerActionCtor, now = Scheduler.now) {
        this.schedulerActionCtor = schedulerActionCtor;
        this.now = now;
      }
      schedule(work, delay = 0, state) {
        return new this.schedulerActionCtor(this, work).schedule(state, delay);
      }
    }
    Scheduler.now = dateTimestampProvider.now;

    class AsyncScheduler extends Scheduler {
      constructor(SchedulerAction, now = Scheduler.now) {
        super(SchedulerAction, now);
        this.actions = [];
        this._active = false;
        this._scheduled = undefined;
      }
      flush(action) {
        const { actions } = this;
        if (this._active) {
          actions.push(action);
          return;
        }
        let error;
        this._active = true;
        do {
          if ((error = action.execute(action.state, action.delay))) {
            break;
          }
        } while ((action = actions.shift()));
        this._active = false;
        if (error) {
          while ((action = actions.shift())) {
            action.unsubscribe();
          }
          throw error;
        }
      }
    }

    const asyncScheduler = new AsyncScheduler(AsyncAction);
    const async = asyncScheduler;

    function isScheduler(value) {
      return value && isFunction(value.schedule);
    }

    /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P
          ? value
          : new P(function (resolve) {
              resolve(value);
            });
      }
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator['throw'](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    function __values(o) {
      var s = typeof Symbol === 'function' && Symbol.iterator,
        m = s && o[s],
        i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === 'number')
        return {
          next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
          },
        };
      throw new TypeError(s ? 'Object is not iterable.' : 'Symbol.iterator is not defined.');
    }

    function __await(v) {
      return this instanceof __await ? ((this.v = v), this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
      var g = generator.apply(thisArg, _arguments || []),
        i,
        q = [];
      return (
        (i = {}),
        verb('next'),
        verb('throw'),
        verb('return'),
        (i[Symbol.asyncIterator] = function () {
          return this;
        }),
        i
      );
      function verb(n) {
        if (g[n])
          i[n] = function (v) {
            return new Promise(function (a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume('next', value);
      }
      function reject(value) {
        resume('throw', value);
      }
      function settle(f, v) {
        if ((f(v), q.shift(), q.length)) resume(q[0][0], q[0][1]);
      }
    }

    function __asyncValues(o) {
      if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.');
      var m = o[Symbol.asyncIterator],
        i;
      return m
        ? m.call(o)
        : ((o = typeof __values === 'function' ? __values(o) : o[Symbol.iterator]()),
          (i = {}),
          verb('next'),
          verb('throw'),
          verb('return'),
          (i[Symbol.asyncIterator] = function () {
            return this;
          }),
          i);
      function verb(n) {
        i[n] =
          o[n] &&
          function (v) {
            return new Promise(function (resolve, reject) {
              (v = o[n](v)), settle(resolve, reject, v.done, v.value);
            });
          };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
          resolve({ value: v, done: d });
        }, reject);
      }
    }

    const isArrayLike = x => x && typeof x.length === 'number' && typeof x !== 'function';

    function isPromise(value) {
      return isFunction(value === null || value === void 0 ? void 0 : value.then);
    }

    function isInteropObservable(input) {
      return isFunction(input[observable]);
    }

    function isAsyncIterable(obj) {
      return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
    }

    function createInvalidObservableTypeError(input) {
      return new TypeError(
        `You provided ${
          input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`
        } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`,
      );
    }

    function getSymbolIterator() {
      if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
      }
      return Symbol.iterator;
    }
    const iterator = getSymbolIterator();

    function isIterable(input) {
      return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
    }

    function readableStreamLikeToAsyncGenerator(readableStream) {
      return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {
        const reader = readableStream.getReader();
        try {
          while (true) {
            const { value, done } = yield __await(reader.read());
            if (done) {
              return yield __await(void 0);
            }
            yield yield __await(value);
          }
        } finally {
          reader.releaseLock();
        }
      });
    }
    function isReadableStreamLike(obj) {
      return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
    }

    function innerFrom(input) {
      if (input instanceof Observable) {
        return input;
      }
      if (input != null) {
        if (isInteropObservable(input)) {
          return fromInteropObservable(input);
        }
        if (isArrayLike(input)) {
          return fromArrayLike(input);
        }
        if (isPromise(input)) {
          return fromPromise(input);
        }
        if (isAsyncIterable(input)) {
          return fromAsyncIterable(input);
        }
        if (isIterable(input)) {
          return fromIterable(input);
        }
        if (isReadableStreamLike(input)) {
          return fromReadableStreamLike(input);
        }
      }
      throw createInvalidObservableTypeError(input);
    }
    function fromInteropObservable(obj) {
      return new Observable(subscriber => {
        const obs = obj[observable]();
        if (isFunction(obs.subscribe)) {
          return obs.subscribe(subscriber);
        }
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
      });
    }
    function fromArrayLike(array) {
      return new Observable(subscriber => {
        for (let i = 0; i < array.length && !subscriber.closed; i++) {
          subscriber.next(array[i]);
        }
        subscriber.complete();
      });
    }
    function fromPromise(promise) {
      return new Observable(subscriber => {
        promise
          .then(
            value => {
              if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
              }
            },
            err => subscriber.error(err),
          )
          .then(null, reportUnhandledError);
      });
    }
    function fromIterable(iterable) {
      return new Observable(subscriber => {
        for (const value of iterable) {
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
        subscriber.complete();
      });
    }
    function fromAsyncIterable(asyncIterable) {
      return new Observable(subscriber => {
        process$1(asyncIterable, subscriber).catch(err => subscriber.error(err));
      });
    }
    function fromReadableStreamLike(readableStream) {
      return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
    }
    function process$1(asyncIterable, subscriber) {
      var asyncIterable_1, asyncIterable_1_1;
      var e_1, _a;
      return __awaiter(this, void 0, void 0, function* () {
        try {
          for (asyncIterable_1 = __asyncValues(asyncIterable); (asyncIterable_1_1 = yield asyncIterable_1.next()), !asyncIterable_1_1.done; ) {
            const value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)) yield _a.call(asyncIterable_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        subscriber.complete();
      });
    }

    function executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {
      const scheduleSubscription = scheduler.schedule(function () {
        work();
        if (repeat) {
          parentSubscription.add(this.schedule(null, delay));
        } else {
          this.unsubscribe();
        }
      }, delay);
      parentSubscription.add(scheduleSubscription);
      if (!repeat) {
        return scheduleSubscription;
      }
    }

    function isValidDate(value) {
      return value instanceof Date && !isNaN(value);
    }

    function map(project, thisArg) {
      return operate((source, subscriber) => {
        let index = 0;
        source.subscribe(
          new OperatorSubscriber(subscriber, value => {
            subscriber.next(project.call(thisArg, value, index++));
          }),
        );
      });
    }

    const { isArray } = Array;
    function callOrApply(fn, args) {
      return isArray(args) ? fn(...args) : fn(args);
    }
    function mapOneOrManyArgs(fn) {
      return map(args => callOrApply(fn, args));
    }

    function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalTeardown) {
      const buffer = [];
      let active = 0;
      let index = 0;
      let isComplete = false;
      const checkComplete = () => {
        if (isComplete && !buffer.length && !active) {
          subscriber.complete();
        }
      };
      const outerNext = value => (active < concurrent ? doInnerSub(value) : buffer.push(value));
      const doInnerSub = value => {
        expand && subscriber.next(value);
        active++;
        let innerComplete = false;
        innerFrom(project(value, index++)).subscribe(
          new OperatorSubscriber(
            subscriber,
            innerValue => {
              onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
              if (expand) {
                outerNext(innerValue);
              } else {
                subscriber.next(innerValue);
              }
            },
            () => {
              innerComplete = true;
            },
            undefined,
            () => {
              if (innerComplete) {
                try {
                  active--;
                  while (buffer.length && active < concurrent) {
                    const bufferedValue = buffer.shift();
                    if (innerSubScheduler) {
                      executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));
                    } else {
                      doInnerSub(bufferedValue);
                    }
                  }
                  checkComplete();
                } catch (err) {
                  subscriber.error(err);
                }
              }
            },
          ),
        );
      };
      source.subscribe(
        new OperatorSubscriber(subscriber, outerNext, () => {
          isComplete = true;
          checkComplete();
        }),
      );
      return () => {
        additionalTeardown === null || additionalTeardown === void 0 ? void 0 : additionalTeardown();
      };
    }

    function mergeMap(project, resultSelector, concurrent = Infinity) {
      if (isFunction(resultSelector)) {
        return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);
      } else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
      }
      return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));
    }

    const nodeEventEmitterMethods = ['addListener', 'removeListener'];
    const eventTargetMethods = ['addEventListener', 'removeEventListener'];
    const jqueryMethods = ['on', 'off'];
    function fromEvent(target, eventName, options, resultSelector) {
      if (isFunction(options)) {
        resultSelector = options;
        options = undefined;
      }
      if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
      }
      const [add, remove] = isEventTarget(target)
        ? eventTargetMethods.map(methodName => handler => target[methodName](eventName, handler, options))
        : isNodeStyleEventEmitter(target)
        ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))
        : isJQueryStyleEventEmitter(target)
        ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))
        : [];
      if (!add) {
        if (isArrayLike(target)) {
          return mergeMap(subTarget => fromEvent(subTarget, eventName, options))(innerFrom(target));
        }
      }
      if (!add) {
        throw new TypeError('Invalid event target');
      }
      return new Observable(subscriber => {
        const handler = (...args) => subscriber.next(1 < args.length ? args : args[0]);
        add(handler);
        return () => remove(handler);
      });
    }
    function toCommonHandlerRegistry(target, eventName) {
      return methodName => handler => target[methodName](eventName, handler);
    }
    function isNodeStyleEventEmitter(target) {
      return isFunction(target.addListener) && isFunction(target.removeListener);
    }
    function isJQueryStyleEventEmitter(target) {
      return isFunction(target.on) && isFunction(target.off);
    }
    function isEventTarget(target) {
      return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
    }

    function timer(dueTime = 0, intervalOrScheduler, scheduler = async) {
      let intervalDuration = -1;
      if (intervalOrScheduler != null) {
        if (isScheduler(intervalOrScheduler)) {
          scheduler = intervalOrScheduler;
        } else {
          intervalDuration = intervalOrScheduler;
        }
      }
      return new Observable(subscriber => {
        let due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
        if (due < 0) {
          due = 0;
        }
        let n = 0;
        return scheduler.schedule(function () {
          if (!subscriber.closed) {
            subscriber.next(n++);
            if (0 <= intervalDuration) {
              this.schedule(undefined, intervalDuration);
            } else {
              subscriber.complete();
            }
          }
        }, due);
      });
    }

    function interval(period = 0, scheduler = asyncScheduler) {
      if (period < 0) {
        period = 0;
      }
      return timer(period, period, scheduler);
    }

    function takeUntil(notifier) {
      return operate((source, subscriber) => {
        innerFrom(notifier).subscribe(new OperatorSubscriber(subscriber, () => subscriber.complete(), noop));
        !subscriber.closed && source.subscribe(subscriber);
      });
    }

    const ffspbHeaderComponentCss =
      'ffspb-header .desktop-wrapper{height:80px;background:linear-gradient(90deg, #212121 0%, #454545 100%);box-shadow:0px 4px 4px rgba(0, 0, 0, 0.35);display:flex;align-items:center;position:fixed;top:0;left:0;width:100%;z-index:10000000;min-width:800px}ffspb-header .desktop-wrapper .logo-wrapper{display:flex;align-items:center;justify-content:flex-start;flex:1}ffspb-header .desktop-wrapper .logo-wrapper .left-margin{height:50px;max-width:25px;flex:1}ffspb-header .desktop-wrapper .logo-wrapper .main-logo{height:50px;min-width:148px}ffspb-header .desktop-wrapper .logo-wrapper .logo-text{color:white;font-weight:400;font-size:24px;line-height:24px;margin-top:9px;margin-left:15px}ffspb-header .desktop-wrapper .logo-wrapper .logo-text div{background:-webkit-linear-gradient(#d3d3d3 50%, #888);-webkit-background-clip:text;-webkit-text-fill-color:transparent}@media only screen and (max-width: 950px){ffspb-header .desktop-wrapper .logo-wrapper .logo-text{display:none}}ffspb-header .desktop-wrapper .menu{flex:1;display:flex;align-items:center;justify-content:flex-end;font-size:18px;margin-right:74px;transition:opacity 0.3s linear 0.3s}ffspb-header .desktop-wrapper .menu .menu-item{margin:0 15px;cursor:pointer;transition:color 0.3s ease-in-out;display:flex;align-items:center;user-select:none;position:relative;color:#adadad;text-decoration:none}ffspb-header .desktop-wrapper .menu .menu-item ftb-icon{fill:#adadad;height:9px;transition:fill 0.3s ease-in-out, transform 0.3s ease-in-out;margin-left:5px;margin-top:3px}ffspb-header .desktop-wrapper .menu .menu-item:hover{color:#eeeeee}ffspb-header .desktop-wrapper .menu .menu-item:hover ftb-icon{fill:#eeeeee}ffspb-header .desktop-wrapper .menu .menu-item.open{color:#eeeeee}ffspb-header .desktop-wrapper .menu .menu-item.open ftb-icon{fill:#eeeeee;transform:rotate(180deg)}ffspb-header .desktop-wrapper .menu .menu-item .dropdown{position:absolute;top:35px;left:50%;transform:translateX(-50%);background:linear-gradient(90deg, #212121 -50%, #454545 100%);box-shadow:2px 2px 2px 2px rgba(0, 0, 0, 0.2);border-radius:2px;overflow:hidden;transition:opacity 0.2s ease-in-out}ffspb-header .desktop-wrapper .menu .menu-item .dropdown .dropdown-item{white-space:nowrap;padding:10px 20px;display:block;text-decoration:none;color:#adadad}ffspb-header .desktop-wrapper .menu .menu-item .dropdown .dropdown-item:hover{color:#eeeeee}ffspb-header .desktop-wrapper .menu .menu-item:not(.open) .dropdown{height:0;opacity:0;transition:height 0s ease-in-out 0.2s}ffspb-header .desktop-wrapper .menu.hidden{opacity:0;transition:opacity 0s linear}ffspb-header .desktop-wrapper .menu:after{display:block;content:" ";height:26px;width:1px;background:#616161;margin-left:10px}ffspb-header .desktop-wrapper .menu-dropdown{position:absolute;top:80px;left:0;overflow:hidden;width:100%}ffspb-header .desktop-wrapper .menu-dropdown .menu-dropdown__content{width:100%;padding:25px;transition:all 0.3s ease-in-out;transform:translateY(calc(-100% - 5px));display:flex;align-items:center;justify-content:flex-end;background:linear-gradient(to right, #373737, #454545);box-sizing:border-box;box-shadow:0 0 2px 2px rgba(0, 0, 0, 0.1);margin-bottom:15px;border-bottom:2px solid #3f3f3f;position:relative}ffspb-header .desktop-wrapper .menu-dropdown .menu-dropdown__content:before{content:" ";display:block;width:100%;height:0;box-shadow:0 0 2px 2px rgba(0, 0, 0, 0.1);position:absolute;top:0;left:0}ffspb-header .desktop-wrapper .menu-dropdown .menu-dropdown__content.open{transform:translateY(0)}ffspb-header .desktop-wrapper .menu-dropdown .menu-dropdown__content .dropdown-column{padding:0 24px;border-left:1px solid #555555;width:fit-content}ffspb-header .desktop-wrapper .menu-dropdown .menu-dropdown__content .dropdown-column .dropdown-item{white-space:nowrap;padding:10px 20px;display:block;text-decoration:none;color:#adadad}ffspb-header .desktop-wrapper .menu-dropdown .menu-dropdown__content .dropdown-column .dropdown-item:hover{color:#eeeeee}ffspb-header .desktop-wrapper .searchbar{position:absolute;left:100%;width:calc(100vw - 290px);height:80px;display:flex;align-items:center;cursor:pointer;transition:transform 0.3s ease-in-out;margin-left:-40px;transform:translateX(-30px)}ffspb-header .desktop-wrapper .searchbar .search-icon{height:20px;width:20px;margin-left:16px;fill:#969696;transition:fill 0.3s ease-in-out}ffspb-header .desktop-wrapper .searchbar input{width:100%;background:transparent;border:none;box-shadow:none;outline:none;transition:transform 0.3s ease-in-out;border-bottom:1px solid #616161;margin-left:16px;height:40px;color:#eeeeee;transform:translateX(45px)}ffspb-header .desktop-wrapper .searchbar:hover{color:#eeeeee}ffspb-header .desktop-wrapper .searchbar:hover ftb-icon{fill:#eeeeee}ffspb-header .desktop-wrapper .searchbar:not(.open) input{cursor:pointer;border-bottom:none}ffspb-header .desktop-wrapper .searchbar.open{transform:translateX(-100%)}ffspb-header .desktop-wrapper .searchbar.open input{transform:translateX(0)}@media only screen and (max-width: 950px){ffspb-header .desktop-wrapper .searchbar{width:calc(100vw - 130px)}}ffspb-header ion-header ion-toolbar{--background:linear-gradient(90deg, #212121 0%, #454545 100%)}ffspb-header ion-header ion-toolbar ftb-icon{height:30px;margin-left:20px;margin-top:-7px}ffspb-header ion-header ion-toolbar .title{background:-webkit-linear-gradient(#d3d3d3 50%, #888888);-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-size:22px}ffspb-header ion-header ion-toolbar ion-menu-button{color:#d3d3d3}ffspb-header ion-header ion-toolbar .main-logo{height:30px;margin-left:20px;margin-top:-7px}';

    class FfspbHeader {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.searchOpen = false;
        this.openMenuIdx = -1;
        this.lastOpenMenuIdx = -1;
        this.onDestroyed$ = new AsyncSubject();
        this.menuItems = [
          { title: 'Новости', link: '', dropdowns: [] },
          { title: 'Федерация', dropdowns: [{ title: 'О Федерации футбола', link: '' }] },
          {
            title: 'Судейство',
            dropdowns: [
              { title: 'Судьи ', link: '' },
              { title: 'Инспекторы ', link: '' },
              { title: 'Центр подготовки судей ', link: '' },
            ],
          },
          { title: 'Стадионы', link: '' },
          { title: 'Информация', dropdowns: [{ title: 'Информация', link: '' }] },
          { title: 'Документы', link: '' },
        ];
      }
      componentWillLoad() {
        fromEvent(window, 'click')
          .pipe(takeUntil(this.onDestroyed$))
          .subscribe(() => (this.openMenuIdx = -1));
      }
      disconnectedCallback() {
        this.onDestroyed$.next(true);
        this.onDestroyed$.complete();
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'desktop-wrapper' },
            hAsync('div', { class: 'logo-wrapper' }, hAsync('div', { class: 'left-margin' }), hAsync('img', { src: '/assets/img/logo-silver.png', class: 'main-logo' })),
            hAsync(
              'div',
              { class: 'menu' + (this.searchOpen ? ' hidden' : '') },
              this.menuItems.map((i, idx) => {
                var _a;
                return hAsync(
                  'a',
                  {
                    class: 'menu-item' + (this.openMenuIdx == idx ? ' open' : ''),
                    href: i.link,
                    onClick: e => {
                      var _a;
                      return ((_a = i.dropdowns) === null || _a === void 0 ? void 0 : _a.length) && this.toggleMenu(idx, e);
                    },
                  },
                  i.title,
                  !((_a = i.dropdowns) === null || _a === void 0 ? void 0 : _a.length)
                    ? null
                    : [
                        hAsync('ftb-icon', { svg: ChevronIcon$1 }),
                        // <div class="dropdown">
                        //   {i.dropdowns.map(d => (
                        //     <a class="dropdown-item" href={d.link}>
                        //       {d.title}
                        //     </a>
                        //   ))}
                        // </div>,
                      ],
                );
              }),
            ),
            this.renderMenuDropdown(),
            hAsync(
              'div',
              { class: 'searchbar' + (this.searchOpen ? ' open' : ''), onClick: () => this.openSearchbar() },
              hAsync('ftb-icon', { svg: SearchIcon, class: 'search-icon' }),
              hAsync('input', {
                placeholder:
                  '\u041F\u043E\u0438\u0441\u043A (\u0438\u0433\u0440\u043E\u043A\u0438, \u043A\u043E\u043C\u0430\u043D\u0434\u044B, \u0442\u0443\u0440\u043D\u0438\u0440\u044B, \u043F\u043E\u043B\u044F)',
                onBlur: () => (this.searchOpen = false),
                ref: el => (this.searchEl = el),
                onKeyDown: e => this.onSearchKeyDown(e),
              }),
            ),
          ),
        );
      }
      renderMenuDropdown() {
        var _a;
        return hAsync(
          'div',
          { class: 'menu-dropdown' },
          hAsync(
            'div',
            { class: 'menu-dropdown__content' + (this.openMenuIdx > -1 ? ' open' : '') },
            hAsync(
              'div',
              { class: 'dropdown-column' },
              (_a = this.menuItems[this.lastOpenMenuIdx]) === null || _a === void 0
                ? void 0
                : _a.dropdowns.map(d => hAsync('a', { class: 'dropdown-item', href: d.link }, d.title)),
            ),
          ),
        );
      }
      onSearchKeyDown(e) {
        if (e.key == 'Escape') {
          this.searchOpen = false;
        }
      }
      toggleMenu(idx, e) {
        if (this.openMenuIdx == idx) {
          this.openMenuIdx = -1;
        } else if (this.openMenuIdx != -1) {
          this.openMenuIdx = -1;
          setTimeout(() => {
            this.openMenuIdx = idx;
            this.lastOpenMenuIdx = idx;
          }, 250);
        } else {
          this.openMenuIdx = idx;
          this.lastOpenMenuIdx = idx;
        }
        e.stopPropagation();
      }
      openSearchbar() {
        this.searchOpen = true;
        setTimeout(() => this.searchEl.focus(), 300);
      }
      renderMobile() {
        return hAsync(
          'ion-header',
          null,
          hAsync(
            'ion-toolbar',
            null,
            hAsync('ion-buttons', { slot: 'start' }, hAsync('img', { src: '/assets/img/ffspb-logo.png', class: 'main-logo' })),
            hAsync('ion-title', null, hAsync('span', { class: 'title' }, '\u0424\u0443\u0442\u0431\u043E\u043B \u041F\u0435\u0442\u0435\u0440\u0431\u0443\u0440\u0433\u0430')),
            hAsync('ion-buttons', { slot: 'end' }, hAsync('ion-menu-button', { slot: 'end' })),
          ),
        );
      }
      static get style() {
        return ffspbHeaderComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-header',
          $members$: {
            searchOpen: [32],
            openMenuIdx: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbHealthcheckPageComponentCss = '';

    class FfspbHealthcheckPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbHealthcheckPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-healthcheck-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbLicenseAgreementPageComponentCss = '';

    class FfspbLicenseAgreementPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbLicenseAgreementPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-license-agreement-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbNewsComponentCss = '';

    class FfspbNews {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbNewsComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-news',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbNewsPageComponentCss = '';

    class FfspbNewsPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbNewsPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-news-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbPlayerGamesPageComponentCss = '';

    class FfspbPlayerGamesPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbPlayerGamesPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-player-games-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbPlayerPageComponentCss = '';

    class FfspbPlayerPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbPlayerPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-player-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbPostPageComponentCss = '';

    class FfspbPostPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbPostPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-post-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbRefereePageComponentCss = '';

    class FfspbRefereePage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbRefereePageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-referee-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbRefereesPageComponentCss = '';

    class FfspbRefereesPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbRefereesPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-referees-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbSeasonCalendarPageComponentCss = '';

    class FfspbSeasonCalendarPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbSeasonCalendarPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-season-calendar-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbSeasonPageComponentCss = '';

    class FfspbSeasonPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbSeasonPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-season-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbSeasonPlayersPageComponentCss = '';

    class FfspbSeasonPlayersPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbSeasonPlayersPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-season-players-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbSeasonStadiumsPageComponentCss = '';

    class FfspbSeasonStadiumsPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbSeasonStadiumsPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-season-stadiums-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbSeasonStaffPageComponentCss = '';

    class FfspbSeasonStaffPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbSeasonStaffPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-season-staff-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const getName = (iconName, icon, mode, ios, md) => {
      // default to "md" if somehow the mode wasn't set
      mode = (mode && toLower(mode)) === 'ios' ? 'ios' : 'md';
      // if an icon was passed in using the ios or md attributes
      // set the iconName to whatever was passed in
      if (ios && mode === 'ios') {
        iconName = toLower(ios);
      } else if (md && mode === 'md') {
        iconName = toLower(md);
      } else {
        if (!iconName && icon && !isSrc(icon)) {
          iconName = icon;
        }
        if (isStr(iconName)) {
          iconName = toLower(iconName);
        }
      }
      if (!isStr(iconName) || iconName.trim() === '') {
        return null;
      }
      // only allow alpha characters and dash
      const invalidChars = iconName.replace(/[a-z]|-|\d/gi, '');
      if (invalidChars !== '') {
        return null;
      }
      return iconName;
    };
    const isSrc = str => str.length > 0 && /(\/|\.)/.test(str);
    const isStr = val => typeof val === 'string';
    const toLower = val => val.toLowerCase();

    const LIFECYCLE_WILL_ENTER = 'ionViewWillEnter';
    const LIFECYCLE_DID_ENTER = 'ionViewDidEnter';
    const LIFECYCLE_WILL_LEAVE = 'ionViewWillLeave';
    const LIFECYCLE_DID_LEAVE = 'ionViewDidLeave';
    const LIFECYCLE_WILL_UNLOAD = 'ionViewWillUnload';

    const iosTransitionAnimation$1 = () =>
      Promise.resolve().then(function () {
        return ios_transition;
      });
    const mdTransitionAnimation$1 = () =>
      Promise.resolve().then(function () {
        return md_transition;
      });
    const transition$4 = opts => {
      return new Promise((resolve, reject) => {
        writeTask(() => {
          beforeTransition(opts);
          runTransition(opts).then(
            result => {
              if (result.animation) {
                result.animation.destroy();
              }
              afterTransition(opts);
              resolve(result);
            },
            error => {
              afterTransition(opts);
              reject(error);
            },
          );
        });
      });
    };
    const beforeTransition = opts => {
      const enteringEl = opts.enteringEl;
      const leavingEl = opts.leavingEl;
      setZIndex(enteringEl, leavingEl, opts.direction);
      if (opts.showGoBack) {
        enteringEl.classList.add('can-go-back');
      } else {
        enteringEl.classList.remove('can-go-back');
      }
      setPageHidden(enteringEl, false);
      /**
       * When transitioning, the page should not
       * respond to click events. This resolves small
       * issues like users double tapping the ion-back-button.
       * These pointer events are removed in `afterTransition`.
       */
      enteringEl.style.setProperty('pointer-events', 'none');
      if (leavingEl) {
        setPageHidden(leavingEl, false);
        leavingEl.style.setProperty('pointer-events', 'none');
      }
    };
    const runTransition = async opts => {
      const animationBuilder = await getAnimationBuilder(opts);
      const ani = animationBuilder && Build.isBrowser ? animation(animationBuilder, opts) : noAnimation(opts); // fast path for no animation
      return ani;
    };
    const afterTransition = opts => {
      const enteringEl = opts.enteringEl;
      const leavingEl = opts.leavingEl;
      enteringEl.classList.remove('ion-page-invisible');
      enteringEl.style.removeProperty('pointer-events');
      if (leavingEl !== undefined) {
        leavingEl.classList.remove('ion-page-invisible');
        leavingEl.style.removeProperty('pointer-events');
      }
    };
    const getAnimationBuilder = async opts => {
      if (!opts.leavingEl || !opts.animated || opts.duration === 0) {
        return undefined;
      }
      if (opts.animationBuilder) {
        return opts.animationBuilder;
      }
      const getAnimation = opts.mode === 'ios' ? (await iosTransitionAnimation$1()).iosTransitionAnimation : (await mdTransitionAnimation$1()).mdTransitionAnimation;
      return getAnimation;
    };
    const animation = async (animationBuilder, opts) => {
      await waitForReady(opts, true);
      const trans = animationBuilder(opts.baseEl, opts);
      fireWillEvents(opts.enteringEl, opts.leavingEl);
      const didComplete = await playTransition(trans, opts);
      if (opts.progressCallback) {
        opts.progressCallback(undefined);
      }
      if (didComplete) {
        fireDidEvents(opts.enteringEl, opts.leavingEl);
      }
      return {
        hasCompleted: didComplete,
        animation: trans,
      };
    };
    const noAnimation = async opts => {
      const enteringEl = opts.enteringEl;
      const leavingEl = opts.leavingEl;
      await waitForReady(opts, false);
      fireWillEvents(enteringEl, leavingEl);
      fireDidEvents(enteringEl, leavingEl);
      return {
        hasCompleted: true,
      };
    };
    const waitForReady = async (opts, defaultDeep) => {
      const deep = opts.deepWait !== undefined ? opts.deepWait : defaultDeep;
      const promises = deep ? [deepReady(opts.enteringEl), deepReady(opts.leavingEl)] : [shallowReady(opts.enteringEl), shallowReady(opts.leavingEl)];
      await Promise.all(promises);
      await notifyViewReady(opts.viewIsReady, opts.enteringEl);
    };
    const notifyViewReady = async (viewIsReady, enteringEl) => {
      if (viewIsReady) {
        await viewIsReady(enteringEl);
      }
    };
    const playTransition = (trans, opts) => {
      const progressCallback = opts.progressCallback;
      const promise = new Promise(resolve => {
        trans.onFinish(currentStep => resolve(currentStep === 1));
      });
      // cool, let's do this, start the transition
      if (progressCallback) {
        // this is a swipe to go back, just get the transition progress ready
        // kick off the swipe animation start
        trans.progressStart(true);
        progressCallback(trans);
      } else {
        // only the top level transition should actually start "play"
        // kick it off and let it play through
        // ******** DOM WRITE ****************
        trans.play();
      }
      // create a callback for when the animation is done
      return promise;
    };
    const fireWillEvents = (enteringEl, leavingEl) => {
      lifecycle(leavingEl, LIFECYCLE_WILL_LEAVE);
      lifecycle(enteringEl, LIFECYCLE_WILL_ENTER);
    };
    const fireDidEvents = (enteringEl, leavingEl) => {
      lifecycle(enteringEl, LIFECYCLE_DID_ENTER);
      lifecycle(leavingEl, LIFECYCLE_DID_LEAVE);
    };
    const lifecycle = (el, eventName) => {
      if (el) {
        const ev = new CustomEvent(eventName, {
          bubbles: false,
          cancelable: false,
        });
        el.dispatchEvent(ev);
      }
    };
    const shallowReady = el => {
      if (el) {
        return new Promise(resolve => componentOnReady(el, resolve));
      }
      return Promise.resolve();
    };
    const deepReady = async el => {
      const element = el;
      if (element) {
        if (element.componentOnReady != null) {
          const stencilEl = await element.componentOnReady();
          if (stencilEl != null) {
            return;
          }
        }
        await Promise.all(Array.from(element.children).map(deepReady));
      }
    };
    const setPageHidden = (el, hidden) => {
      if (hidden) {
        el.setAttribute('aria-hidden', 'true');
        el.classList.add('ion-page-hidden');
      } else {
        el.hidden = false;
        el.removeAttribute('aria-hidden');
        el.classList.remove('ion-page-hidden');
      }
    };
    const setZIndex = (enteringEl, leavingEl, direction) => {
      if (enteringEl !== undefined) {
        enteringEl.style.zIndex = direction === 'back' ? '99' : '101';
      }
      if (leavingEl !== undefined) {
        leavingEl.style.zIndex = '100';
      }
    };
    const getIonPageElement = element => {
      if (element.classList.contains('ion-page')) {
        return element;
      }
      const ionPage = element.querySelector(':scope > .ion-page, :scope > ion-nav, :scope > ion-tabs');
      if (ionPage) {
        return ionPage;
      }
      // idk, return the original element so at least something animates and we don't have a null pointer
      return element;
    };

    const DURATION = 540;
    const getClonedElement = tagName => {
      return document.querySelector(`${tagName}.ion-cloned-element`);
    };
    const shadow = el => {
      return el.shadowRoot || el;
    };
    const getLargeTitle = refEl => {
      const tabs = refEl.tagName === 'ION-TABS' ? refEl : refEl.querySelector('ion-tabs');
      const query = 'ion-content ion-header:not(.header-collapse-condense-inactive) ion-title.title-large';
      if (tabs != null) {
        const activeTab = tabs.querySelector('ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)');
        return activeTab != null ? activeTab.querySelector(query) : null;
      }
      return refEl.querySelector(query);
    };
    const getBackButton = (refEl, backDirection) => {
      const tabs = refEl.tagName === 'ION-TABS' ? refEl : refEl.querySelector('ion-tabs');
      let buttonsList = [];
      if (tabs != null) {
        const activeTab = tabs.querySelector('ion-tab:not(.tab-hidden), .ion-page:not(.ion-page-hidden)');
        if (activeTab != null) {
          buttonsList = activeTab.querySelectorAll('ion-buttons');
        }
      } else {
        buttonsList = refEl.querySelectorAll('ion-buttons');
      }
      for (const buttons of buttonsList) {
        const parentHeader = buttons.closest('ion-header');
        const activeHeader = parentHeader && !parentHeader.classList.contains('header-collapse-condense-inactive');
        const backButton = buttons.querySelector('ion-back-button');
        const buttonsCollapse = buttons.classList.contains('buttons-collapse');
        const startSlot = buttons.slot === 'start' || buttons.slot === '';
        if (backButton !== null && startSlot && ((buttonsCollapse && activeHeader && backDirection) || !buttonsCollapse)) {
          return backButton;
        }
      }
      return null;
    };
    const createLargeTitleTransition = (rootAnimation, rtl, backDirection, enteringEl, leavingEl) => {
      const enteringBackButton = getBackButton(enteringEl, backDirection);
      const leavingLargeTitle = getLargeTitle(leavingEl);
      const enteringLargeTitle = getLargeTitle(enteringEl);
      const leavingBackButton = getBackButton(leavingEl, backDirection);
      const shouldAnimationForward = enteringBackButton !== null && leavingLargeTitle !== null && !backDirection;
      const shouldAnimationBackward = enteringLargeTitle !== null && leavingBackButton !== null && backDirection;
      if (shouldAnimationForward) {
        const leavingLargeTitleBox = leavingLargeTitle.getBoundingClientRect();
        const enteringBackButtonBox = enteringBackButton.getBoundingClientRect();
        animateLargeTitle(rootAnimation, rtl, backDirection, leavingLargeTitle, leavingLargeTitleBox, enteringBackButtonBox);
        animateBackButton(rootAnimation, rtl, backDirection, enteringBackButton, leavingLargeTitleBox, enteringBackButtonBox);
      } else if (shouldAnimationBackward) {
        const enteringLargeTitleBox = enteringLargeTitle.getBoundingClientRect();
        const leavingBackButtonBox = leavingBackButton.getBoundingClientRect();
        animateLargeTitle(rootAnimation, rtl, backDirection, enteringLargeTitle, enteringLargeTitleBox, leavingBackButtonBox);
        animateBackButton(rootAnimation, rtl, backDirection, leavingBackButton, enteringLargeTitleBox, leavingBackButtonBox);
      }
      return {
        forward: shouldAnimationForward,
        backward: shouldAnimationBackward,
      };
    };
    const animateBackButton = (rootAnimation, rtl, backDirection, backButtonEl, largeTitleBox, backButtonBox) => {
      const BACK_BUTTON_START_OFFSET = rtl ? `calc(100% - ${backButtonBox.right + 4}px)` : `${backButtonBox.left - 4}px`;
      const START_TEXT_TRANSLATE = rtl ? '7px' : '-7px';
      const END_TEXT_TRANSLATE = rtl ? '-4px' : '4px';
      const ICON_TRANSLATE = rtl ? '-4px' : '4px';
      const TEXT_ORIGIN_X = rtl ? 'right' : 'left';
      const ICON_ORIGIN_X = rtl ? 'left' : 'right';
      const FORWARD_TEXT_KEYFRAMES = [
        { offset: 0, opacity: 0, transform: `translate3d(${START_TEXT_TRANSLATE}, ${largeTitleBox.top - 40}px, 0) scale(2.1)` },
        { offset: 1, opacity: 1, transform: `translate3d(${END_TEXT_TRANSLATE}, ${backButtonBox.top - 46}px, 0) scale(1)` },
      ];
      const BACKWARD_TEXT_KEYFRAMES = [
        { offset: 0, opacity: 1, transform: `translate3d(${END_TEXT_TRANSLATE}, ${backButtonBox.top - 46}px, 0) scale(1)` },
        { offset: 0.6, opacity: 0 },
        { offset: 1, opacity: 0, transform: `translate3d(${START_TEXT_TRANSLATE}, ${largeTitleBox.top - 40}px, 0) scale(2.1)` },
      ];
      const TEXT_KEYFRAMES = backDirection ? BACKWARD_TEXT_KEYFRAMES : FORWARD_TEXT_KEYFRAMES;
      const FORWARD_ICON_KEYFRAMES = [
        { offset: 0, opacity: 0, transform: `translate3d(${ICON_TRANSLATE}, ${backButtonBox.top - 41}px, 0) scale(0.6)` },
        { offset: 1, opacity: 1, transform: `translate3d(${ICON_TRANSLATE}, ${backButtonBox.top - 46}px, 0) scale(1)` },
      ];
      const BACKWARD_ICON_KEYFRAMES = [
        { offset: 0, opacity: 1, transform: `translate3d(${ICON_TRANSLATE}, ${backButtonBox.top - 46}px, 0) scale(1)` },
        { offset: 0.2, opacity: 0, transform: `translate3d(${ICON_TRANSLATE}, ${backButtonBox.top - 41}px, 0) scale(0.6)` },
        { offset: 1, opacity: 0, transform: `translate3d(${ICON_TRANSLATE}, ${backButtonBox.top - 41}px, 0) scale(0.6)` },
      ];
      const ICON_KEYFRAMES = backDirection ? BACKWARD_ICON_KEYFRAMES : FORWARD_ICON_KEYFRAMES;
      const enteringBackButtonTextAnimation = createAnimation();
      const enteringBackButtonIconAnimation = createAnimation();
      const clonedBackButtonEl = getClonedElement('ion-back-button');
      const backButtonTextEl = shadow(clonedBackButtonEl).querySelector('.button-text');
      const backButtonIconEl = shadow(clonedBackButtonEl).querySelector('ion-icon');
      clonedBackButtonEl.text = backButtonEl.text;
      clonedBackButtonEl.mode = backButtonEl.mode;
      clonedBackButtonEl.icon = backButtonEl.icon;
      clonedBackButtonEl.color = backButtonEl.color;
      clonedBackButtonEl.disabled = backButtonEl.disabled;
      clonedBackButtonEl.style.setProperty('display', 'block');
      clonedBackButtonEl.style.setProperty('position', 'fixed');
      enteringBackButtonIconAnimation.addElement(backButtonIconEl);
      enteringBackButtonTextAnimation.addElement(backButtonTextEl);
      enteringBackButtonTextAnimation
        .beforeStyles({
          'transform-origin': `${TEXT_ORIGIN_X} center`,
        })
        .beforeAddWrite(() => {
          backButtonEl.style.setProperty('display', 'none');
          clonedBackButtonEl.style.setProperty(TEXT_ORIGIN_X, BACK_BUTTON_START_OFFSET);
        })
        .afterAddWrite(() => {
          backButtonEl.style.setProperty('display', '');
          clonedBackButtonEl.style.setProperty('display', 'none');
          clonedBackButtonEl.style.removeProperty(TEXT_ORIGIN_X);
        })
        .keyframes(TEXT_KEYFRAMES);
      enteringBackButtonIconAnimation
        .beforeStyles({
          'transform-origin': `${ICON_ORIGIN_X} center`,
        })
        .keyframes(ICON_KEYFRAMES);
      rootAnimation.addAnimation([enteringBackButtonTextAnimation, enteringBackButtonIconAnimation]);
    };
    const animateLargeTitle = (rootAnimation, rtl, backDirection, largeTitleEl, largeTitleBox, backButtonBox) => {
      const TITLE_START_OFFSET = rtl ? `calc(100% - ${largeTitleBox.right}px)` : `${largeTitleBox.left}px`;
      const START_TRANSLATE = rtl ? '-18px' : '18px';
      const ORIGIN_X = rtl ? 'right' : 'left';
      const BACKWARDS_KEYFRAMES = [
        { offset: 0, opacity: 0, transform: `translate3d(${START_TRANSLATE}, ${backButtonBox.top - 4}px, 0) scale(0.49)` },
        { offset: 0.1, opacity: 0 },
        { offset: 1, opacity: 1, transform: `translate3d(0, ${largeTitleBox.top - 2}px, 0) scale(1)` },
      ];
      const FORWARDS_KEYFRAMES = [
        { offset: 0, opacity: 0.99, transform: `translate3d(0, ${largeTitleBox.top - 2}px, 0) scale(1)` },
        { offset: 0.6, opacity: 0 },
        { offset: 1, opacity: 0, transform: `translate3d(${START_TRANSLATE}, ${backButtonBox.top - 4}px, 0) scale(0.5)` },
      ];
      const KEYFRAMES = backDirection ? BACKWARDS_KEYFRAMES : FORWARDS_KEYFRAMES;
      const clonedTitleEl = getClonedElement('ion-title');
      const clonedLargeTitleAnimation = createAnimation();
      clonedTitleEl.innerText = largeTitleEl.innerText;
      clonedTitleEl.size = largeTitleEl.size;
      clonedTitleEl.color = largeTitleEl.color;
      clonedLargeTitleAnimation.addElement(clonedTitleEl);
      clonedLargeTitleAnimation
        .beforeStyles({
          'transform-origin': `${ORIGIN_X} center`,
          'height': '46px',
          'display': '',
          'position': 'relative',
          [ORIGIN_X]: TITLE_START_OFFSET,
        })
        .beforeAddWrite(() => {
          largeTitleEl.style.setProperty('display', 'none');
        })
        .afterAddWrite(() => {
          largeTitleEl.style.setProperty('display', '');
          clonedTitleEl.style.setProperty('display', 'none');
        })
        .keyframes(KEYFRAMES);
      rootAnimation.addAnimation(clonedLargeTitleAnimation);
    };
    const iosTransitionAnimation = (navEl, opts) => {
      try {
        const EASING = 'cubic-bezier(0.32,0.72,0,1)';
        const OPACITY = 'opacity';
        const TRANSFORM = 'transform';
        const CENTER = '0%';
        const OFF_OPACITY = 0.8;
        const isRTL = navEl.ownerDocument.dir === 'rtl';
        const OFF_RIGHT = isRTL ? '-99.5%' : '99.5%';
        const OFF_LEFT = isRTL ? '33%' : '-33%';
        const enteringEl = opts.enteringEl;
        const leavingEl = opts.leavingEl;
        const backDirection = opts.direction === 'back';
        const contentEl = enteringEl.querySelector(':scope > ion-content');
        const headerEls = enteringEl.querySelectorAll(':scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *');
        const enteringToolBarEls = enteringEl.querySelectorAll(':scope > ion-header > ion-toolbar');
        const rootAnimation = createAnimation();
        const enteringContentAnimation = createAnimation();
        rootAnimation
          .addElement(enteringEl)
          .duration(opts.duration || DURATION)
          .easing(opts.easing || EASING)
          .fill('both')
          .beforeRemoveClass('ion-page-invisible');
        if (leavingEl && navEl) {
          const navDecorAnimation = createAnimation();
          navDecorAnimation.addElement(navEl);
          rootAnimation.addAnimation(navDecorAnimation);
        }
        if (!contentEl && enteringToolBarEls.length === 0 && headerEls.length === 0) {
          enteringContentAnimation.addElement(enteringEl.querySelector(':scope > .ion-page, :scope > ion-nav, :scope > ion-tabs')); // REVIEW
        } else {
          enteringContentAnimation.addElement(contentEl); // REVIEW
          enteringContentAnimation.addElement(headerEls);
        }
        rootAnimation.addAnimation(enteringContentAnimation);
        if (backDirection) {
          enteringContentAnimation.beforeClearStyles([OPACITY]).fromTo('transform', `translateX(${OFF_LEFT})`, `translateX(${CENTER})`).fromTo(OPACITY, OFF_OPACITY, 1);
        } else {
          // entering content, forward direction
          enteringContentAnimation.beforeClearStyles([OPACITY]).fromTo('transform', `translateX(${OFF_RIGHT})`, `translateX(${CENTER})`);
        }
        if (contentEl) {
          const enteringTransitionEffectEl = shadow(contentEl).querySelector('.transition-effect');
          if (enteringTransitionEffectEl) {
            const enteringTransitionCoverEl = enteringTransitionEffectEl.querySelector('.transition-cover');
            const enteringTransitionShadowEl = enteringTransitionEffectEl.querySelector('.transition-shadow');
            const enteringTransitionEffect = createAnimation();
            const enteringTransitionCover = createAnimation();
            const enteringTransitionShadow = createAnimation();
            enteringTransitionEffect.addElement(enteringTransitionEffectEl).beforeStyles({ opacity: '1', display: 'block' }).afterStyles({ opacity: '', display: '' });
            enteringTransitionCover
              .addElement(enteringTransitionCoverEl) // REVIEW
              .beforeClearStyles([OPACITY])
              .fromTo(OPACITY, 0, 0.1);
            enteringTransitionShadow
              .addElement(enteringTransitionShadowEl) // REVIEW
              .beforeClearStyles([OPACITY])
              .fromTo(OPACITY, 0.03, 0.7);
            enteringTransitionEffect.addAnimation([enteringTransitionCover, enteringTransitionShadow]);
            enteringContentAnimation.addAnimation([enteringTransitionEffect]);
          }
        }
        const enteringContentHasLargeTitle = enteringEl.querySelector('ion-header.header-collapse-condense');
        const { forward, backward } = createLargeTitleTransition(rootAnimation, isRTL, backDirection, enteringEl, leavingEl);
        enteringToolBarEls.forEach(enteringToolBarEl => {
          const enteringToolBar = createAnimation();
          enteringToolBar.addElement(enteringToolBarEl);
          rootAnimation.addAnimation(enteringToolBar);
          const enteringTitle = createAnimation();
          enteringTitle.addElement(enteringToolBarEl.querySelector('ion-title')); // REVIEW
          const enteringToolBarButtons = createAnimation();
          const buttons = Array.from(enteringToolBarEl.querySelectorAll('ion-buttons,[menuToggle]'));
          const parentHeader = enteringToolBarEl.closest('ion-header');
          const inactiveHeader = parentHeader && parentHeader.classList.contains('header-collapse-condense-inactive');
          let buttonsToAnimate;
          if (backDirection) {
            buttonsToAnimate = buttons.filter(button => {
              const isCollapseButton = button.classList.contains('buttons-collapse');
              return (isCollapseButton && !inactiveHeader) || !isCollapseButton;
            });
          } else {
            buttonsToAnimate = buttons.filter(button => !button.classList.contains('buttons-collapse'));
          }
          enteringToolBarButtons.addElement(buttonsToAnimate);
          const enteringToolBarItems = createAnimation();
          enteringToolBarItems.addElement(enteringToolBarEl.querySelectorAll(':scope > *:not(ion-title):not(ion-buttons):not([menuToggle])'));
          const enteringToolBarBg = createAnimation();
          enteringToolBarBg.addElement(shadow(enteringToolBarEl).querySelector('.toolbar-background')); // REVIEW
          const enteringBackButton = createAnimation();
          const backButtonEl = enteringToolBarEl.querySelector('ion-back-button');
          if (backButtonEl) {
            enteringBackButton.addElement(backButtonEl);
          }
          enteringToolBar.addAnimation([enteringTitle, enteringToolBarButtons, enteringToolBarItems, enteringToolBarBg, enteringBackButton]);
          enteringToolBarButtons.fromTo(OPACITY, 0.01, 1);
          enteringToolBarItems.fromTo(OPACITY, 0.01, 1);
          if (backDirection) {
            if (!inactiveHeader) {
              enteringTitle.fromTo('transform', `translateX(${OFF_LEFT})`, `translateX(${CENTER})`).fromTo(OPACITY, 0.01, 1);
            }
            enteringToolBarItems.fromTo('transform', `translateX(${OFF_LEFT})`, `translateX(${CENTER})`);
            // back direction, entering page has a back button
            enteringBackButton.fromTo(OPACITY, 0.01, 1);
          } else {
            // entering toolbar, forward direction
            if (!enteringContentHasLargeTitle) {
              enteringTitle.fromTo('transform', `translateX(${OFF_RIGHT})`, `translateX(${CENTER})`).fromTo(OPACITY, 0.01, 1);
            }
            enteringToolBarItems.fromTo('transform', `translateX(${OFF_RIGHT})`, `translateX(${CENTER})`);
            enteringToolBarBg.beforeClearStyles([OPACITY, 'transform']);
            const translucentHeader = parentHeader === null || parentHeader === void 0 ? void 0 : parentHeader.translucent;
            if (!translucentHeader) {
              enteringToolBarBg.fromTo(OPACITY, 0.01, 'var(--opacity)');
            } else {
              enteringToolBarBg.fromTo('transform', isRTL ? 'translateX(-100%)' : 'translateX(100%)', 'translateX(0px)');
            }
            // forward direction, entering page has a back button
            if (!forward) {
              enteringBackButton.fromTo(OPACITY, 0.01, 1);
            }
            if (backButtonEl && !forward) {
              const enteringBackBtnText = createAnimation();
              enteringBackBtnText
                .addElement(shadow(backButtonEl).querySelector('.button-text')) // REVIEW
                .fromTo(`transform`, isRTL ? 'translateX(-100px)' : 'translateX(100px)', 'translateX(0px)');
              enteringToolBar.addAnimation(enteringBackBtnText);
            }
          }
        });
        // setup leaving view
        if (leavingEl) {
          const leavingContent = createAnimation();
          const leavingContentEl = leavingEl.querySelector(':scope > ion-content');
          const leavingToolBarEls = leavingEl.querySelectorAll(':scope > ion-header > ion-toolbar');
          const leavingHeaderEls = leavingEl.querySelectorAll(':scope > ion-header > *:not(ion-toolbar), :scope > ion-footer > *');
          if (!leavingContentEl && leavingToolBarEls.length === 0 && leavingHeaderEls.length === 0) {
            leavingContent.addElement(leavingEl.querySelector(':scope > .ion-page, :scope > ion-nav, :scope > ion-tabs')); // REVIEW
          } else {
            leavingContent.addElement(leavingContentEl); // REVIEW
            leavingContent.addElement(leavingHeaderEls);
          }
          rootAnimation.addAnimation(leavingContent);
          if (backDirection) {
            // leaving content, back direction
            leavingContent.beforeClearStyles([OPACITY]).fromTo('transform', `translateX(${CENTER})`, isRTL ? 'translateX(-100%)' : 'translateX(100%)');
            const leavingPage = getIonPageElement(leavingEl);
            rootAnimation.afterAddWrite(() => {
              if (rootAnimation.getDirection() === 'normal') {
                leavingPage.style.setProperty('display', 'none');
              }
            });
          } else {
            // leaving content, forward direction
            leavingContent.fromTo('transform', `translateX(${CENTER})`, `translateX(${OFF_LEFT})`).fromTo(OPACITY, 1, OFF_OPACITY);
          }
          if (leavingContentEl) {
            const leavingTransitionEffectEl = shadow(leavingContentEl).querySelector('.transition-effect');
            if (leavingTransitionEffectEl) {
              const leavingTransitionCoverEl = leavingTransitionEffectEl.querySelector('.transition-cover');
              const leavingTransitionShadowEl = leavingTransitionEffectEl.querySelector('.transition-shadow');
              const leavingTransitionEffect = createAnimation();
              const leavingTransitionCover = createAnimation();
              const leavingTransitionShadow = createAnimation();
              leavingTransitionEffect.addElement(leavingTransitionEffectEl).beforeStyles({ opacity: '1', display: 'block' }).afterStyles({ opacity: '', display: '' });
              leavingTransitionCover
                .addElement(leavingTransitionCoverEl) // REVIEW
                .beforeClearStyles([OPACITY])
                .fromTo(OPACITY, 0.1, 0);
              leavingTransitionShadow
                .addElement(leavingTransitionShadowEl) // REVIEW
                .beforeClearStyles([OPACITY])
                .fromTo(OPACITY, 0.7, 0.03);
              leavingTransitionEffect.addAnimation([leavingTransitionCover, leavingTransitionShadow]);
              leavingContent.addAnimation([leavingTransitionEffect]);
            }
          }
          leavingToolBarEls.forEach(leavingToolBarEl => {
            const leavingToolBar = createAnimation();
            leavingToolBar.addElement(leavingToolBarEl);
            const leavingTitle = createAnimation();
            leavingTitle.addElement(leavingToolBarEl.querySelector('ion-title')); // REVIEW
            const leavingToolBarButtons = createAnimation();
            const buttons = leavingToolBarEl.querySelectorAll('ion-buttons,[menuToggle]');
            const parentHeader = leavingToolBarEl.closest('ion-header');
            const inactiveHeader = parentHeader && parentHeader.classList.contains('header-collapse-condense-inactive');
            const buttonsToAnimate = Array.from(buttons).filter(button => {
              const isCollapseButton = button.classList.contains('buttons-collapse');
              return (isCollapseButton && !inactiveHeader) || !isCollapseButton;
            });
            leavingToolBarButtons.addElement(buttonsToAnimate);
            const leavingToolBarItems = createAnimation();
            const leavingToolBarItemEls = leavingToolBarEl.querySelectorAll(':scope > *:not(ion-title):not(ion-buttons):not([menuToggle])');
            if (leavingToolBarItemEls.length > 0) {
              leavingToolBarItems.addElement(leavingToolBarItemEls);
            }
            const leavingToolBarBg = createAnimation();
            leavingToolBarBg.addElement(shadow(leavingToolBarEl).querySelector('.toolbar-background')); // REVIEW
            const leavingBackButton = createAnimation();
            const backButtonEl = leavingToolBarEl.querySelector('ion-back-button');
            if (backButtonEl) {
              leavingBackButton.addElement(backButtonEl);
            }
            leavingToolBar.addAnimation([leavingTitle, leavingToolBarButtons, leavingToolBarItems, leavingBackButton, leavingToolBarBg]);
            rootAnimation.addAnimation(leavingToolBar);
            // fade out leaving toolbar items
            leavingBackButton.fromTo(OPACITY, 0.99, 0);
            leavingToolBarButtons.fromTo(OPACITY, 0.99, 0);
            leavingToolBarItems.fromTo(OPACITY, 0.99, 0);
            if (backDirection) {
              if (!inactiveHeader) {
                // leaving toolbar, back direction
                leavingTitle.fromTo('transform', `translateX(${CENTER})`, isRTL ? 'translateX(-100%)' : 'translateX(100%)').fromTo(OPACITY, 0.99, 0);
              }
              leavingToolBarItems.fromTo('transform', `translateX(${CENTER})`, isRTL ? 'translateX(-100%)' : 'translateX(100%)');
              leavingToolBarBg.beforeClearStyles([OPACITY, 'transform']);
              // leaving toolbar, back direction, and there's no entering toolbar
              // should just slide out, no fading out
              const translucentHeader = parentHeader === null || parentHeader === void 0 ? void 0 : parentHeader.translucent;
              if (!translucentHeader) {
                leavingToolBarBg.fromTo(OPACITY, 'var(--opacity)', 0);
              } else {
                leavingToolBarBg.fromTo('transform', 'translateX(0px)', isRTL ? 'translateX(-100%)' : 'translateX(100%)');
              }
              if (backButtonEl && !backward) {
                const leavingBackBtnText = createAnimation();
                leavingBackBtnText
                  .addElement(shadow(backButtonEl).querySelector('.button-text')) // REVIEW
                  .fromTo('transform', `translateX(${CENTER})`, `translateX(${(isRTL ? -124 : 124) + 'px'})`);
                leavingToolBar.addAnimation(leavingBackBtnText);
              }
            } else {
              // leaving toolbar, forward direction
              if (!inactiveHeader) {
                leavingTitle.fromTo('transform', `translateX(${CENTER})`, `translateX(${OFF_LEFT})`).fromTo(OPACITY, 0.99, 0).afterClearStyles([TRANSFORM, OPACITY]);
              }
              leavingToolBarItems.fromTo('transform', `translateX(${CENTER})`, `translateX(${OFF_LEFT})`).afterClearStyles([TRANSFORM, OPACITY]);
              leavingBackButton.afterClearStyles([OPACITY]);
              leavingTitle.afterClearStyles([OPACITY]);
              leavingToolBarButtons.afterClearStyles([OPACITY]);
            }
          });
        }
        return rootAnimation;
      } catch (err) {
        throw err;
      }
    };

    var ios_transition = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      shadow: shadow,
      iosTransitionAnimation: iosTransitionAnimation,
    });

    const mdTransitionAnimation = (_, opts) => {
      const OFF_BOTTOM = '40px';
      const CENTER = '0px';
      const backDirection = opts.direction === 'back';
      const enteringEl = opts.enteringEl;
      const leavingEl = opts.leavingEl;
      const ionPageElement = getIonPageElement(enteringEl);
      const enteringToolbarEle = ionPageElement.querySelector('ion-toolbar');
      const rootTransition = createAnimation();
      rootTransition.addElement(ionPageElement).fill('both').beforeRemoveClass('ion-page-invisible');
      // animate the component itself
      if (backDirection) {
        rootTransition.duration(opts.duration || 200).easing('cubic-bezier(0.47,0,0.745,0.715)');
      } else {
        rootTransition
          .duration(opts.duration || 280)
          .easing('cubic-bezier(0.36,0.66,0.04,1)')
          .fromTo('transform', `translateY(${OFF_BOTTOM})`, `translateY(${CENTER})`)
          .fromTo('opacity', 0.01, 1);
      }
      // Animate toolbar if it's there
      if (enteringToolbarEle) {
        const enteringToolBar = createAnimation();
        enteringToolBar.addElement(enteringToolbarEle);
        rootTransition.addAnimation(enteringToolBar);
      }
      // setup leaving view
      if (leavingEl && backDirection) {
        // leaving content
        rootTransition.duration(opts.duration || 200).easing('cubic-bezier(0.47,0,0.745,0.715)');
        const leavingPage = createAnimation();
        leavingPage
          .addElement(getIonPageElement(leavingEl))
          .onFinish(currentStep => {
            if (currentStep === 1 && leavingPage.elements.length > 0) {
              leavingPage.elements[0].style.setProperty('display', 'none');
            }
          })
          .fromTo('transform', `translateY(${CENTER})`, `translateY(${OFF_BOTTOM})`)
          .fromTo('opacity', 1, 0);
        rootTransition.addAnimation(leavingPage);
      }
      return rootTransition;
    };

    var md_transition = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      mdTransitionAnimation: mdTransitionAnimation,
    });

    /**
     * Based on:
     * https://stackoverflow.com/questions/7348009/y-coordinate-for-a-given-x-cubic-bezier
     * https://math.stackexchange.com/questions/26846/is-there-an-explicit-form-for-cubic-b%C3%A9zier-curves
     * TODO: Reduce rounding error
     */
    /**
     * EXPERIMENTAL
     * Given a cubic-bezier curve, get the x value (time) given
     * the y value (progression).
     * Ex: cubic-bezier(0.32, 0.72, 0, 1);
     * P0: (0, 0)
     * P1: (0.32, 0.72)
     * P2: (0, 1)
     * P3: (1, 1)
     *
     * If you give a cubic bezier curve that never reaches the
     * provided progression, this function will return an empty array.
     */
    const getTimeGivenProgression = (p0, p1, p2, p3, progression) => {
      return solveCubicBezier(p0[1], p1[1], p2[1], p3[1], progression).map(tValue => {
        return solveCubicParametricEquation(p0[0], p1[0], p2[0], p3[0], tValue);
      });
    };
    /**
     * Solve a cubic equation in one dimension (time)
     */
    const solveCubicParametricEquation = (p0, p1, p2, p3, t) => {
      const partA = 3 * p1 * Math.pow(t - 1, 2);
      const partB = -3 * p2 * t + 3 * p2 + p3 * t;
      const partC = p0 * Math.pow(t - 1, 3);
      return t * (partA + t * partB) - partC;
    };
    /**
     * Find the `t` value for a cubic bezier using Cardano's formula
     */
    const solveCubicBezier = (p0, p1, p2, p3, refPoint) => {
      p0 -= refPoint;
      p1 -= refPoint;
      p2 -= refPoint;
      p3 -= refPoint;
      const roots = solveCubicEquation(p3 - 3 * p2 + 3 * p1 - p0, 3 * p2 - 6 * p1 + 3 * p0, 3 * p1 - 3 * p0, p0);
      return roots.filter(root => root >= 0 && root <= 1);
    };
    const solveQuadraticEquation = (a, b, c) => {
      const discriminant = b * b - 4 * a * c;
      if (discriminant < 0) {
        return [];
      } else {
        return [(-b + Math.sqrt(discriminant)) / (2 * a), (-b - Math.sqrt(discriminant)) / (2 * a)];
      }
    };
    const solveCubicEquation = (a, b, c, d) => {
      if (a === 0) {
        return solveQuadraticEquation(b, c, d);
      }
      b /= a;
      c /= a;
      d /= a;
      const p = (3 * c - b * b) / 3;
      const q = (2 * b * b * b - 9 * b * c + 27 * d) / 27;
      if (p === 0) {
        return [Math.pow(-q, 1 / 3)];
      } else if (q === 0) {
        return [Math.sqrt(-p), -Math.sqrt(-p)];
      }
      const discriminant = Math.pow(q / 2, 2) + Math.pow(p / 3, 3);
      if (discriminant === 0) {
        return [Math.pow(q / 2, 1 / 2) - b / 3];
      } else if (discriminant > 0) {
        return [Math.pow(-(q / 2) + Math.sqrt(discriminant), 1 / 3) - Math.pow(q / 2 + Math.sqrt(discriminant), 1 / 3) - b / 3];
      }
      const r = Math.sqrt(Math.pow(-(p / 3), 3));
      const phi = Math.acos(-(q / (2 * Math.sqrt(Math.pow(-(p / 3), 3)))));
      const s = 2 * Math.pow(r, 1 / 3);
      return [s * Math.cos(phi / 3) - b / 3, s * Math.cos((phi + 2 * Math.PI) / 3) - b / 3, s * Math.cos((phi + 4 * Math.PI) / 3) - b / 3];
    };

    /**
     * baseAnimation
     * Base class which is extended by the various types. Each
     * type will provide their own animations for open and close
     * and registers itself with Menu.
     */
    const baseAnimation = isIos => {
      // https://material.io/guidelines/motion/movement.html#movement-movement-in-out-of-screen-bounds
      // https://material.io/guidelines/motion/duration-easing.html#duration-easing-natural-easing-curves
      /**
       * "Apply the sharp curve to items temporarily leaving the screen that may return
       * from the same exit point. When they return, use the deceleration curve. On mobile,
       * this transition typically occurs over 300ms" -- MD Motion Guide
       */
      return createAnimation().duration(isIos ? 400 : 300);
    };

    /**
     * Menu Overlay Type
     * The menu slides over the content. The content
     * itself, which is under the menu, does not move.
     */
    const menuOverlayAnimation = menu => {
      let closedX;
      let openedX;
      const width = menu.width + 8;
      const menuAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      if (menu.isEndSide) {
        // right side
        closedX = width + 'px';
        openedX = '0px';
      } else {
        // left side
        closedX = -width + 'px';
        openedX = '0px';
      }
      menuAnimation.addElement(menu.menuInnerEl).fromTo('transform', `translateX(${closedX})`, `translateX(${openedX})`);
      const mode = getIonMode$1(menu);
      const isIos = mode === 'ios';
      const opacity = isIos ? 0.2 : 0.25;
      backdropAnimation.addElement(menu.backdropEl).fromTo('opacity', 0.01, opacity);
      return baseAnimation(isIos).addAnimation([menuAnimation, backdropAnimation]);
    };

    /**
     * Menu Push Type
     * The content slides over to reveal the menu underneath.
     * The menu itself also slides over to reveal its bad self.
     */
    const menuPushAnimation = menu => {
      let contentOpenedX;
      let menuClosedX;
      const mode = getIonMode$1(menu);
      const width = menu.width;
      if (menu.isEndSide) {
        contentOpenedX = -width + 'px';
        menuClosedX = width + 'px';
      } else {
        contentOpenedX = width + 'px';
        menuClosedX = -width + 'px';
      }
      const menuAnimation = createAnimation().addElement(menu.menuInnerEl).fromTo('transform', `translateX(${menuClosedX})`, 'translateX(0px)');
      const contentAnimation = createAnimation().addElement(menu.contentEl).fromTo('transform', 'translateX(0px)', `translateX(${contentOpenedX})`);
      const backdropAnimation = createAnimation().addElement(menu.backdropEl).fromTo('opacity', 0.01, 0.32);
      return baseAnimation(mode === 'ios').addAnimation([menuAnimation, contentAnimation, backdropAnimation]);
    };

    /**
     * Menu Reveal Type
     * The content slides over to reveal the menu underneath.
     * The menu itself, which is under the content, does not move.
     */
    const menuRevealAnimation = menu => {
      const mode = getIonMode$1(menu);
      const openedX = menu.width * (menu.isEndSide ? -1 : 1) + 'px';
      const contentOpen = createAnimation()
        .addElement(menu.contentEl) // REVIEW
        .fromTo('transform', 'translateX(0px)', `translateX(${openedX})`);
      return baseAnimation(mode === 'ios').addAnimation(contentOpen);
    };

    const createMenuController = () => {
      const menuAnimations = new Map();
      const menus = [];
      const open = async menu => {
        const menuEl = await get(menu);
        if (menuEl) {
          return menuEl.open();
        }
        return false;
      };
      const close = async menu => {
        const menuEl = await (menu !== undefined ? get(menu) : getOpen());
        if (menuEl !== undefined) {
          return menuEl.close();
        }
        return false;
      };
      const toggle = async menu => {
        const menuEl = await get(menu);
        if (menuEl) {
          return menuEl.toggle();
        }
        return false;
      };
      const enable = async (shouldEnable, menu) => {
        const menuEl = await get(menu);
        if (menuEl) {
          menuEl.disabled = !shouldEnable;
        }
        return menuEl;
      };
      const swipeGesture = async (shouldEnable, menu) => {
        const menuEl = await get(menu);
        if (menuEl) {
          menuEl.swipeGesture = shouldEnable;
        }
        return menuEl;
      };
      const isOpen = async menu => {
        if (menu != null) {
          const menuEl = await get(menu);
          return menuEl !== undefined && menuEl.isOpen();
        } else {
          const menuEl = await getOpen();
          return menuEl !== undefined;
        }
      };
      const isEnabled = async menu => {
        const menuEl = await get(menu);
        if (menuEl) {
          return !menuEl.disabled;
        }
        return false;
      };
      const get = async menu => {
        await waitUntilReady();
        if (menu === 'start' || menu === 'end') {
          // there could be more than one menu on the same side
          // so first try to get the enabled one
          const menuRef = find(m => m.side === menu && !m.disabled);
          if (menuRef) {
            return menuRef;
          }
          // didn't find a menu side that is enabled
          // so try to get the first menu side found
          return find(m => m.side === menu);
        } else if (menu != null) {
          // the menuId was not left or right
          // so try to get the menu by its "id"
          return find(m => m.menuId === menu);
        }
        // return the first enabled menu
        const menuEl = find(m => !m.disabled);
        if (menuEl) {
          return menuEl;
        }
        // get the first menu in the array, if one exists
        return menus.length > 0 ? menus[0].el : undefined;
      };
      /**
       * Get the instance of the opened menu. Returns `null` if a menu is not found.
       */
      const getOpen = async () => {
        await waitUntilReady();
        return _getOpenSync();
      };
      /**
       * Get all menu instances.
       */
      const getMenus = async () => {
        await waitUntilReady();
        return getMenusSync();
      };
      /**
       * Get whether or not a menu is animating. Returns `true` if any
       * menu is currently animating.
       */
      const isAnimating = async () => {
        await waitUntilReady();
        return isAnimatingSync();
      };
      const registerAnimation = (name, animation) => {
        menuAnimations.set(name, animation);
      };
      const _register = menu => {
        if (menus.indexOf(menu) < 0) {
          if (!menu.disabled) {
            _setActiveMenu(menu);
          }
          menus.push(menu);
        }
      };
      const _unregister = menu => {
        const index = menus.indexOf(menu);
        if (index > -1) {
          menus.splice(index, 1);
        }
      };
      const _setActiveMenu = menu => {
        // if this menu should be enabled
        // then find all the other menus on this same side
        // and automatically disable other same side menus
        const side = menu.side;
        menus.filter(m => m.side === side && m !== menu).forEach(m => (m.disabled = true));
      };
      const _setOpen = async (menu, shouldOpen, animated) => {
        if (isAnimatingSync()) {
          return false;
        }
        if (shouldOpen) {
          const openedMenu = await getOpen();
          if (openedMenu && menu.el !== openedMenu) {
            await openedMenu.setOpen(false, false);
          }
        }
        return menu._setOpen(shouldOpen, animated);
      };
      const _createAnimation = (type, menuCmp) => {
        const animationBuilder = menuAnimations.get(type);
        if (!animationBuilder) {
          throw new Error('animation not registered');
        }
        const animation = animationBuilder(menuCmp);
        return animation;
      };
      const _getOpenSync = () => {
        return find(m => m._isOpen);
      };
      const getMenusSync = () => {
        return menus.map(menu => menu.el);
      };
      const isAnimatingSync = () => {
        return menus.some(menu => menu.isAnimating);
      };
      const find = predicate => {
        const instance = menus.find(predicate);
        if (instance !== undefined) {
          return instance.el;
        }
        return undefined;
      };
      const waitUntilReady = () => {
        return Promise.all(Array.from(document.querySelectorAll('ion-menu')).map(menu => new Promise(resolve => componentOnReady(menu, resolve))));
      };
      registerAnimation('reveal', menuRevealAnimation);
      registerAnimation('push', menuPushAnimation);
      registerAnimation('overlay', menuOverlayAnimation);
      /* tslint:disable-next-line */
      if (typeof document !== 'undefined') {
        document.addEventListener('ionBackButton', ev => {
          const openMenu = _getOpenSync();
          if (openMenu) {
            ev.detail.register(MENU_BACK_BUTTON_PRIORITY, () => {
              return openMenu.close();
            });
          }
        });
      }
      return {
        registerAnimation,
        get,
        getMenus,
        getOpen,
        isEnabled,
        swipeGesture,
        isAnimating,
        isOpen,
        enable,
        toggle,
        close,
        open,
        _getOpenSync,
        _createAnimation,
        _register,
        _unregister,
        _setOpen,
        _setActiveMenu,
      };
    };
    const menuController = /*@__PURE__*/ createMenuController();

    var HeaderIcon = `<?xml version="1.0" encoding="iso-8859-1"?>
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 492 492" style="enable-background:new 0 0 492 492;" xml:space="preserve">
  <g>
    <path d="M300.188,246L484.14,62.04c5.06-5.064,7.852-11.82,7.86-19.024c0-7.208-2.792-13.972-7.86-19.028L468.02,7.872
      c-5.068-5.076-11.824-7.856-19.036-7.856c-7.2,0-13.956,2.78-19.024,7.856L246.008,191.82L62.048,7.872
      c-5.06-5.076-11.82-7.856-19.028-7.856c-7.2,0-13.96,2.78-19.02,7.856L7.872,23.988c-10.496,10.496-10.496,27.568,0,38.052
      L191.828,246L7.872,429.952c-5.064,5.072-7.852,11.828-7.852,19.032c0,7.204,2.788,13.96,7.852,19.028l16.124,16.116
      c5.06,5.072,11.824,7.856,19.02,7.856c7.208,0,13.968-2.784,19.028-7.856l183.96-183.952l183.952,183.952
      c5.068,5.072,11.824,7.856,19.024,7.856h0.008c7.204,0,13.96-2.784,19.028-7.856l16.12-16.116
      c5.06-5.064,7.852-11.824,7.852-19.028c0-7.204-2.792-13.96-7.852-19.028L300.188,246z"/>
  </g>
</svg>
`;

    var ChevronIcon = `<svg width="9" height="6" viewBox="0 0 9 6" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M9 1.2L4.5 6L-5.34045e-07 1.2L1.125 2.6522e-07L4.5 3.6L7.875 8.55324e-07L9 1.2Z"/>
</svg>
`;

    const localIp = '192.168.0.105';
    const environment = {
      versionNumber: '0.0.0',
      versionDate: '163246743',
      mode: 'dev',
      apiHost: `http://${localIp}:3001/api`,
      graphqlHost: `http://${localIp}:3004/graphql`,
      imgHost: 'https://6ff87ac8-1c01-4a5d-8145-f60a24de5ae8.selcdn.net/api/',
      ipApiKey: '1107a9b86b7aa0548a0af5f1c2007eb1',
      firebase: {
        apiKey: 'AIzaSyC3TUaAC7zYtlqWmud-Orx9qK-sfE6GPF0',
        authDomain: 'afl-sports.firebaseapp.com',
        projectId: 'afl-sports',
        storageBucket: 'afl-sports.appspot.com',
        messagingSenderId: '489582605693',
        appId: '1:489582605693:web:461b1bd4b3664b3eae0814',
        measurementId: 'G-MS7GM9REDY',
      },
    };

    const ffspbSideMenuComponentCss =
      'ffspb-side-menu .search-on ion-menu{--width:100vw}ffspb-side-menu ion-menu .title-line{display:flex;align-items:center;justify-content:space-between;padding:10px 0;color:#ffffff;text-transform:uppercase;font-size:24px;line-height:29px;font-weight:700}ffspb-side-menu ion-menu .title-line ion-button{padding:0 11px;background:transparent;height:35px;margin-right:-21px}ffspb-side-menu ion-menu .title-line ion-button ftb-icon{height:18px;width:18px;fill:#adadad}ffspb-side-menu ion-menu ion-content{--background:#2a2a2a;--padding-start:22px;--padding-end:22px}ffspb-side-menu ion-menu ion-content .content{height:100%;width:100%;display:flex;flex-direction:column}ffspb-side-menu ion-menu .searchbar{--color:#999 !important;padding:0 !important;height:60px !important;margin-left:-5px;width:calc(100% + 10px)}ffspb-side-menu ion-menu .searchbar input{padding-inline-start:50px !important}ffspb-side-menu ion-menu .searchbar ion-icon{margin-left:10px !important}ffspb-side-menu ion-menu .menu-list{flex:1}ffspb-side-menu ion-menu .menu-list .menu-line{width:100%;height:46px;display:flex;align-items:center;justify-content:space-between;text-transform:uppercase;font-size:18px;line-height:22px;color:#adadad}ffspb-side-menu ion-menu .menu-list .menu-line:not(:last-of-type){border-bottom:1px solid #555555}ffspb-side-menu ion-menu .menu-list .menu-line ftb-icon{height:9px;width:9px;transform:rotate(-90deg);fill:#adadad}ffspb-side-menu ion-menu .menu-list .back-button-line{width:100%;display:flex;align-items:center;justify-content:flex-start}ffspb-side-menu ion-menu .menu-list .back-button-line .slide-back-button{font-size:18px;line-height:22px;color:white;text-transform:uppercase;--padding-start:0;--padding-end:0}ffspb-side-menu ion-menu .menu-list .back-button-line .slide-back-button ftb-icon{height:12px;width:12px;margin-right:10px;fill:white}ffspb-side-menu ion-menu .search-list{flex:1}ffspb-side-menu ion-menu .search-list .description{color:#adadad;text-align:center;font-size:14px;padding:10px 22px}ffspb-side-menu ion-menu .bottom-info{padding:22px;text-align:center;color:#555;width:100%;font-size:14px}';

    class FfspbSideMenu {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.openMenuIdx = -1;
        this.searchMode = false;
        this.menuItems = [
          { title: 'Новости', link: '', dropdowns: [] },
          { title: 'Федерация', dropdowns: [{ title: 'О Федерации футбола', link: '' }] },
          {
            title: 'Судейство',
            dropdowns: [
              { title: 'Судьи ', link: '' },
              { title: 'Инспекторы ', link: '' },
              { title: 'Центр подготовки судей ', link: '' },
            ],
          },
          { title: 'Стадионы', link: '' },
          { title: 'Информация', dropdowns: [{ title: 'Информация', link: '' }] },
          { title: 'Документы', link: '' },
        ];
        this.lastOpenMenuIdx = -1;
      }
      componentDidLoad() {
        const menuInnerEl = this.menuEl.shadowRoot.querySelector('.menu-inner');
        if (menuInnerEl) {
          menuInnerEl['style']['transition'] = 'width 0.2s ease-in-out';
        }
        // if (!this.swiper && this.swiperRootEl) {
        //   console.log('here');
        //   this.swiper = new Swiper(this.swiperRootEl, {
        //     allowTouchMove: false,
        //   });
        // }
      }
      onMenuRowClick(menuRow, idx) {
        // if (menuRow.dropdowns) {
        //   this.openMenuIdx = idx;
        //   this.lastOpenMenuIdx = idx;
        //   this.swiper.slideTo(1);
        // }
      }
      //
      // onMenuClick() {
      //   console.log('clicked');
      //   // this.swiper.slideNext();
      //   this.swiper.slideNext();
      //   console.log('done');
      // }
      render() {
        return hAsync(
          'div',
          { class: this.searchMode ? 'search-on' : '' },
          hAsync(
            'ion-menu',
            { 'side': 'end', 'content-id': 'main-content', 'swipeGesture': false, 'ref': el => (this.menuEl = el) },
            hAsync(
              'ion-content',
              null,
              hAsync(
                'div',
                { class: 'content' },
                hAsync(
                  'div',
                  { class: 'title-line' },
                  hAsync('div', { class: 'title' }, this.searchMode ? 'ПОИСК' : 'МЕНЮ'),
                  hAsync('ion-button', { fill: 'clear', onClick: () => menuController.close() }, hAsync('ftb-icon', { svg: HeaderIcon })),
                ),
                hAsync('ion-searchbar', {
                  placeholder: '\u041F\u043E\u0438\u0441\u043A \u043F\u043E \u0441\u0430\u0439\u0442\u0443',
                  mode: 'ios',
                  class: 'searchbar',
                  onIonFocus: () => (this.searchMode = true),
                  onIonBlur: () => (this.searchMode = false),
                }),
                !this.searchMode
                  ? hAsync(
                      'div',
                      { class: 'menu-list' },
                      this.menuItems.map((i, idx) => {
                        var _a;
                        return hAsync(
                          'div',
                          { class: 'menu-line', onClick: () => this.onMenuRowClick(i, idx) },
                          i.title,
                          ((_a = i.dropdowns) === null || _a === void 0 ? void 0 : _a.length) ? hAsync('ftb-icon', { svg: ChevronIcon }) : null,
                        );
                      }),
                    )
                  : hAsync(
                      'div',
                      { class: 'search-list' },
                      hAsync(
                        'div',
                        { class: 'description' },
                        '\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0437\u0430\u043F\u0440\u043E\u0441, \u0447\u0442\u043E\u0431\u044B \u043D\u0430\u0439\u0442\u0438 \u0438\u0433\u0440\u043E\u043A\u043E\u0432, \u043A\u043E\u043C\u0430\u043D\u0434\u044B, \u0442\u0443\u0440\u043D\u0438\u0440\u044B \u0438 \u0438\u0433\u0440\u044B.',
                      ),
                    ),
                hAsync(
                  'div',
                  { class: 'bottom-info' },
                  hAsync('div', { class: 'version' }, '\u0412\u0435\u0440\u0441\u0438\u044F \u0441\u0430\u0439\u0442\u0430: ', environment.versionNumber),
                  hAsync(
                    'div',
                    { class: 'version-date' },
                    '\u041F\u043E\u0441\u043B\u0435\u0434\u043D\u0435\u0435 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0435: ',
                    dayjs_min.unix(parseInt(environment.versionDate)).format('DD.MM.YYYY'),
                  ),
                ),
              ),
            ),
          ),
        );
      }
      static get style() {
        return ffspbSideMenuComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-side-menu',
          $members$: {
            openMenuIdx: [32],
            searchMode: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbStadiumPageComponentCss = '';

    class FfspbStadiumPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbStadiumPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-stadium-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbStadiumsPageComponentCss = '';

    class FfspbStadiumsPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbStadiumsPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-stadiums-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbTeamGamesPageComponentCss = '';

    class FfspbTeamGamesPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbTeamGamesPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-team-games-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbTeamPageComponentCss = '';

    class FfspbTeamPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbTeamPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-team-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbTeamPlayersStatsPageComponentCss = '';

    class FfspbTeamPlayersStatsPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbTeamPlayersStatsPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-team-players-stats-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbTeamTransfersPageComponentCss = '';

    class FfspbTeamTransfersPage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(Host, null);
      }
      renderMobile() {
        return hAsync(Host, null);
      }
      static get style() {
        return ffspbTeamTransfersPageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-team-transfers-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbWelcomeBannerComponentCss = '';

    class FfspbWelcomeBanner {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.percentReleased = 100; // how much of an element was scrolled in for the first time. Required for appearance animation
        this.onDestroyed$ = new AsyncSubject();
      }
      componentWillLoad() {
        function getViewportSize() {
          const object = 'innerWidth' in window ? window : document.documentElement || document.body;
          const prefix = 'innerWidth' in window ? 'inner' : 'client';
          return { width: object[prefix + 'Width'], height: object[prefix + 'Height'] };
        }
        const desktopContent = this.element.closest('.ffspb-content__desktop-wrapper');
        if (desktopContent) {
          fromEvent(desktopContent, 'scroll')
            .pipe(takeUntil(this.onDestroyed$))
            .subscribe(() => {
              const { top, height: elHeight } = this.element.getBoundingClientRect();
              const { height: wpHeight } = getViewportSize();
              const visibleHeight = wpHeight - top;
              const visiblePercent = (visibleHeight / elHeight) * 100;
              this.percentReleased = Math.min(Math.max(this.percentReleased, visiblePercent), 100);
            });
        }
        const content = this.element.closest('ion-content');
        if (content) {
          content.scrollEvents = true;
          const HEADER_HEIGHT = 56;
          fromEvent(content, 'ionScrollStart')
            .pipe(takeUntil(this.onDestroyed$))
            .subscribe(() => {
              const { top } = this.element.getBoundingClientRect();
              this.scrollStartPosition = top;
            });
          fromEvent(content, 'ionScrollEnd')
            .pipe(takeUntil(this.onDestroyed$))
            .subscribe(() => {
              const { top, height } = this.element.getBoundingClientRect();
              if (top < this.scrollStartPosition) {
                const scrollThreshold = this.isFirstBanner ? height / 2 : height - HEADER_HEIGHT;
                //scrolling down
                if (top < scrollThreshold && top > HEADER_HEIGHT) {
                  content.scrollByPoint(0, top - HEADER_HEIGHT, top < height / 2 ? 200 : 300);
                } else if (top < HEADER_HEIGHT * 2 && top > -HEADER_HEIGHT && this.scrollStartPosition > HEADER_HEIGHT) {
                  content.scrollByPoint(0, top - HEADER_HEIGHT, 200);
                }
              }
            });
        }
      }
      componentDidLoad() {
        this.percentReleased = 0; // this code won't run if JS is disabled.
      }
      disconnectedCallback() {
        this.onDestroyed$.next(true);
        this.onDestroyed$.complete();
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'banner-wrapper' },
            hAsync(
              'div',
              { class: 'banner ' + this.mode, style: { opacity: this.percentReleased / 100 + '' } },
              hAsync(
                'div',
                { class: 'side' },
                hAsync(
                  'span',
                  { class: 'content' },
                  hAsync('h3', null, this.bannerTitle),
                  hAsync('div', { class: 'text' }, this.text),
                  hAsync('button', { class: this.mode == 'dark' ? 'steel' : 'black' }, '\u041F\u043E\u0434\u0440\u043E\u0431\u043D\u0435\u0435'),
                ),
              ),
              hAsync('div', { class: 'side' }, hAsync('img', { src: `/assets/demo/img/banners/${this._id}.jpg` })),
            ),
          ),
        );
      }
      renderMobile() {
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'banner ' + this.mode },
            hAsync('div', { class: 'side  img-side' }, hAsync('img', { src: `/assets/demo/img/banners/${this._id}.jpg` })),
            hAsync(
              'div',
              { class: 'side text-side' },
              hAsync(
                'span',
                { class: 'content' },
                hAsync('h3', null, this.bannerTitle),
                hAsync('div', { class: 'text' }, this.text),
                hAsync('button', { class: this.mode == 'dark' ? 'steel' : 'black' }, '\u041F\u043E\u0434\u0440\u043E\u0431\u043D\u0435\u0435'),
              ),
            ),
          ),
        );
      }
      get element() {
        return getElement(this);
      }
      static get style() {
        return ffspbWelcomeBannerComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-welcome-banner',
          $members$: {
            _id: [2],
            bannerTitle: [1, 'banner-title'],
            text: [1],
            mode: [1],
            isFirstBanner: [4, 'is-first-banner'],
            isLastBanner: [4, 'is-last-banner'],
            percentReleased: [32],
            scrollStartPosition: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbWelcomeBannersComponentCss =
      'ffspb-welcome-banners{display:block}ffspb-welcome-banners .desktop-wrapper{margin-top:80px}ffspb-welcome-banners .desktop-wrapper .banner-wrapper{width:100%;height:450px;box-sizing:border-box;position:relative}ffspb-welcome-banners .desktop-wrapper .banner-wrapper .banner{position:absolute;top:0;left:0;height:100%;width:100%;display:flex}ffspb-welcome-banners .desktop-wrapper .banner-wrapper .banner .side{width:50%;display:flex;align-items:center;justify-content:center}ffspb-welcome-banners .banner .side .content{width:75%;max-width:650px}ffspb-welcome-banners .banner .side h3{width:50%;font-weight:700;margin-bottom:0}ffspb-welcome-banners .banner .side .text{width:100%;margin-top:20px;margin-bottom:35px}ffspb-welcome-banners .banner .side img{height:100%;width:100%;object-fit:cover;object-position:center}ffspb-welcome-banners .banner.dark .side{background:linear-gradient(101.05deg, #2c2c2c 0%, #272727 0.01%, #333333 58.17%)}ffspb-welcome-banners .banner.dark h3{color:white}ffspb-welcome-banners .banner.dark .text{color:#adadad}ffspb-welcome-banners .banner.light{flex-direction:row-reverse}ffspb-welcome-banners .banner.light .side{background:linear-gradient(111.34deg, #c9c9c9 0%, #fefefe 47.19%, #c9c9c9 100%)}ffspb-welcome-banners .banner.light h3{color:#343434}ffspb-welcome-banners .banner.light .text{color:#343434}ffspb-welcome-banners .mobile-wrapper{margin-top:40px}ffspb-welcome-banners .mobile-wrapper .banner{display:flex;flex-direction:column;height:calc(var(--vh, 1vh) * 100 - 56px)}ffspb-welcome-banners .mobile-wrapper .banner .side{display:flex;flex-direction:column;justify-items:center;justify-content:center}ffspb-welcome-banners .mobile-wrapper .banner .side.img-side{flex:1}ffspb-welcome-banners .mobile-wrapper .banner .side .content{text-align:left}ffspb-welcome-banners .mobile-wrapper .banner .side img{width:100%;height:100%;object-fit:cover;object-position:center}ffspb-welcome-banners .mobile-wrapper .banner .side h3{padding:0 22px;font-weight:700;font-size:18px;line-height:22px;margin-top:40px;max-width:250px;width:100%}ffspb-welcome-banners .mobile-wrapper .banner .side .text{padding:0 22px;font-size:16px;line-height:19px;margin-top:20px}ffspb-welcome-banners .mobile-wrapper .banner .side button{margin-left:22px;margin-bottom:40px}ffspb-welcome-banners .mobile-wrapper .banner.dark .side{background:linear-gradient(95.57deg, #333333 0%, #2f2f2f 51.35%, #333333 100%)}ffspb-welcome-banners .mobile-wrapper .banner.dark h3{color:white}ffspb-welcome-banners .mobile-wrapper .banner.dark .text{color:#adadad}ffspb-welcome-banners .mobile-wrapper .banner.light .side{background:linear-gradient(111.34deg, #c9c9c9 0%, #fefefe 47.19%, #c9c9c9 100%)}ffspb-welcome-banners .mobile-wrapper .banner.light h3{color:#343434}ffspb-welcome-banners .mobile-wrapper .banner.light .text{color:#343434}';

    // import { fromEvent } from 'rxjs';
    class FfspbWelcomeBanners {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.banners = [
          {
            title: 'Отдать ребёнка в футбол',
            text:
              'Amet minim mollit non deserunt ullamco est sit aliqua dolor do amet sint. Velit officia consequat duis enim velit mollit. Exercitation veniam consequat sunt\n' +
              '                  nostrud amet.',
            _id: 1,
          },
          {
            title: 'Стать тренером по футболу',
            text:
              ' Amet minim mollit non deserunt ullamco est sit aliqua dolor do amet sint. Velit officia consequat duis enim velit mollit. Exercitation veniam consequat sunt\n' +
              '                  nostrud amet.',
            _id: 2,
          },
          {
            title: 'Стать футбольным арбитром',
            text:
              ' Amet minim mollit non deserunt ullamco est sit aliqua dolor do amet sint. Velit officia consequat duis enim velit mollit. Exercitation veniam consequat sunt\n' +
              '                  nostrud amet.',
            _id: 3,
          },
          {
            title: 'Стать лидером массового футбола',
            text:
              ' Amet minim mollit non deserunt ullamco est sit aliqua dolor do amet sint. Velit officia consequat duis enim velit mollit. Exercitation veniam consequat sunt\n' +
              '                  nostrud amet.',
            _id: 4,
          },
          {
            title: 'Играть в футбол',
            text:
              ' Amet minim mollit non deserunt ullamco est sit aliqua dolor do amet sint. Velit officia consequat duis enim velit mollit. Exercitation veniam consequat sunt\n' +
              '                  nostrud amet.',
            _id: 5,
          },
        ];
        this.onDestroyed$ = new AsyncSubject();
      }
      disconnectedCallback() {
        this.onDestroyed$.next(true);
        this.onDestroyed$.complete();
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'desktop-wrapper' },
            this.banners.map((b, idx) => hAsync('ffspb-welcome-banner', { bannerTitle: b.title, _id: b._id, text: b.text, mode: idx % 2 ? 'dark' : 'light' })),
          ),
        );
      }
      renderMobile() {
        return hAsync(
          'div',
          { class: 'mobile-wrapper' },
          this.banners.map((b, idx) =>
            hAsync(
              'div',
              { class: 'swiper-slide' },
              hAsync('ffspb-welcome-banner', {
                bannerTitle: b.title,
                _id: b._id,
                text: b.text,
                mode: idx % 2 ? 'dark' : 'light',
                isFirstBanner: idx == 0,
                isLastBanner: idx == this.banners.length - 1,
              }),
            ),
          ),
        );
      }
      get element() {
        return getElement(this);
      }
      static get style() {
        return ffspbWelcomeBannersComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-welcome-banners',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    /**
     * SSR Window 3.0.0
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: November 9, 2020
     */
    /* eslint-disable no-param-reassign */
    function isObject$2(obj) {
      return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
    }
    function extend$2(target, src) {
      if (target === void 0) {
        target = {};
      }
      if (src === void 0) {
        src = {};
      }
      Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined') target[key] = src[key];
        else if (isObject$2(src[key]) && isObject$2(target[key]) && Object.keys(src[key]).length > 0) {
          extend$2(target[key], src[key]);
        }
      });
    }

    var ssrDocument$1 = {
      body: {},
      addEventListener: function () {},
      removeEventListener: function () {},
      activeElement: {
        blur: function () {},
        nodeName: '',
      },
      querySelector: function () {
        return null;
      },
      querySelectorAll: function () {
        return [];
      },
      getElementById: function () {
        return null;
      },
      createEvent: function () {
        return {
          initEvent: function () {},
        };
      },
      createElement: function () {
        return {
          children: [],
          childNodes: [],
          style: {},
          setAttribute: function () {},
          getElementsByTagName: function () {
            return [];
          },
        };
      },
      createElementNS: function () {
        return {};
      },
      importNode: function () {
        return null;
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
      },
    };
    function getDocument() {
      var doc = typeof document !== 'undefined' ? document : {};
      extend$2(doc, ssrDocument$1);
      return doc;
    }

    var ssrWindow$1 = {
      document: ssrDocument$1,
      navigator: {
        userAgent: '',
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
      },
      history: {
        replaceState: function () {},
        pushState: function () {},
        go: function () {},
        back: function () {},
      },
      CustomEvent: function CustomEvent() {
        return this;
      },
      addEventListener: function () {},
      removeEventListener: function () {},
      getComputedStyle: function () {
        return {
          getPropertyValue: function () {
            return '';
          },
        };
      },
      Image: function () {},
      Date: function () {},
      screen: {},
      setTimeout: function () {},
      clearTimeout: function () {},
      matchMedia: function () {
        return {};
      },
      requestAnimationFrame: function (callback) {
        if (typeof setTimeout === 'undefined') {
          callback();
          return null;
        }
        return setTimeout(callback, 0);
      },
      cancelAnimationFrame: function (id) {
        if (typeof setTimeout === 'undefined') {
          return;
        }
        clearTimeout(id);
      },
    };
    function getWindow() {
      var win = typeof window !== 'undefined' ? window : {};
      extend$2(win, ssrWindow$1);
      return win;
    }

    /**
     * Dom7 3.0.0
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: November 9, 2020
     */

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function _getPrototypeOf(o) {
            return o.__proto__ || Object.getPrototypeOf(o);
          };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf =
        Object.setPrototypeOf ||
        function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === 'undefined' || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === 'function') return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }

      return _construct.apply(null, arguments);
    }

    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf('[native code]') !== -1;
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === 'function' ? new Map() : undefined;

      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;

        if (typeof Class !== 'function') {
          throw new TypeError('Super expression must either be null or a function');
        }

        if (typeof _cache !== 'undefined') {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true,
          },
        });
        return _setPrototypeOf(Wrapper, Class);
      };

      return _wrapNativeSuper(Class);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    /* eslint-disable no-proto */
    function makeReactive(obj) {
      var proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get: function get() {
          return proto;
        },
        set: function set(value) {
          proto.__proto__ = value;
        },
      });
    }

    var Dom7$1 = /*#__PURE__*/ (function (_Array) {
      _inheritsLoose(Dom7, _Array);

      function Dom7(items) {
        var _this;

        _this = _Array.call.apply(_Array, [this].concat(items)) || this;
        makeReactive(_assertThisInitialized(_this));
        return _this;
      }

      return Dom7;
    })(/*#__PURE__*/ _wrapNativeSuper(Array));

    function arrayFlat(arr) {
      if (arr === void 0) {
        arr = [];
      }

      var res = [];
      arr.forEach(function (el) {
        if (Array.isArray(el)) {
          res.push.apply(res, arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }
    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
      var uniqueArray = [];

      for (var i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }

      return uniqueArray;
    }

    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }

      var a = [];
      var res = context.querySelectorAll(selector);

      for (var i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }

      return a;
    }

    function $$1(selector, context) {
      var window = getWindow();
      var document = getDocument();
      var arr = [];

      if (!context && selector instanceof Dom7$1) {
        return selector;
      }

      if (!selector) {
        return new Dom7$1(arr);
      }

      if (typeof selector === 'string') {
        var html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          var tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (var i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);
      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7$1) return selector;
        arr = selector;
      }

      return new Dom7$1(arrayUnique(arr));
    }

    $$1.fn = Dom7$1.prototype;

    function addClass$1() {
      for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
        classes[_key] = arguments[_key];
      }

      var classNames = arrayFlat(
        classes.map(function (c) {
          return c.split(' ');
        }),
      );
      this.forEach(function (el) {
        var _el$classList;

        (_el$classList = el.classList).add.apply(_el$classList, classNames);
      });
      return this;
    }

    function removeClass$1() {
      for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        classes[_key2] = arguments[_key2];
      }

      var classNames = arrayFlat(
        classes.map(function (c) {
          return c.split(' ');
        }),
      );
      this.forEach(function (el) {
        var _el$classList2;

        (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
      });
      return this;
    }

    function toggleClass$1() {
      for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        classes[_key3] = arguments[_key3];
      }

      var classNames = arrayFlat(
        classes.map(function (c) {
          return c.split(' ');
        }),
      );
      this.forEach(function (el) {
        classNames.forEach(function (className) {
          el.classList.toggle(className);
        });
      });
    }

    function hasClass$1() {
      for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        classes[_key4] = arguments[_key4];
      }

      var classNames = arrayFlat(
        classes.map(function (c) {
          return c.split(' ');
        }),
      );
      return (
        arrayFilter(this, function (el) {
          return (
            classNames.filter(function (className) {
              return el.classList.contains(className);
            }).length > 0
          );
        }).length > 0
      );
    }

    function attr$1(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs

      for (var i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (var attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }

      return this;
    }

    function removeAttr$1(attr) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }

      return this;
    }

    function transform$1(transform) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }

      return this;
    }

    function transition$3(duration) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? duration + 'ms' : duration;
      }

      return this;
    }

    function on$1() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      var eventType = args[0],
        targetSelector = args[1],
        listener = args[2],
        capture = args[3];

      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      if (!capture) capture = false;

      function handleLiveEvent(e) {
        var target = e.target;
        if (!target) return;
        var eventData = e.target.dom7EventData || [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        if ($$1(target).is(targetSelector)) listener.apply(target, eventData);
        else {
          var _parents = $$1(target).parents(); // eslint-disable-line

          for (var k = 0; k < _parents.length; k += 1) {
            if ($$1(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
          }
        }
      }

      function handleEvent(e) {
        var eventData = e && e.target ? e.target.dom7EventData || [] : [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        listener.apply(this, eventData);
      }

      var events = eventType.split(' ');
      var j;

      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            var event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener: listener,
              proxyListener: handleEvent,
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            var _event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

            el.dom7LiveListeners[_event].push({
              listener: listener,
              proxyListener: handleLiveEvent,
            });

            el.addEventListener(_event, handleLiveEvent, capture);
          }
        }
      }

      return this;
    }

    function off$1() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      var eventType = args[0],
        targetSelector = args[1],
        listener = args[2],
        capture = args[3];

      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      if (!capture) capture = false;
      var events = eventType.split(' ');

      for (var i = 0; i < events.length; i += 1) {
        var event = events[i];

        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];
          var handlers = void 0;

          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }

          if (handlers && handlers.length) {
            for (var k = handlers.length - 1; k >= 0; k -= 1) {
              var handler = handlers[k];

              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }

      return this;
    }

    function trigger$1() {
      var window = getWindow();

      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      var events = args[0].split(' ');
      var eventData = args[1];

      for (var i = 0; i < events.length; i += 1) {
        var event = events[i];

        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];

          if (window.CustomEvent) {
            var evt = new window.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true,
            });
            el.dom7EventData = args.filter(function (data, dataIndex) {
              return dataIndex > 0;
            });
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }

      return this;
    }

    function transitionEnd$4(callback) {
      var dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }

      if (callback) {
        dom.on('transitionend', fireCallBack);
      }

      return this;
    }

    function outerWidth$1(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles = this.styles();

          return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
        }

        return this[0].offsetWidth;
      }

      return null;
    }

    function outerHeight$1(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles2 = this.styles();

          return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
        }

        return this[0].offsetHeight;
      }

      return null;
    }

    function offset$1() {
      if (this.length > 0) {
        var window = getWindow();
        var document = getDocument();
        var el = this[0];
        var box = el.getBoundingClientRect();
        var body = document.body;
        var clientTop = el.clientTop || body.clientTop || 0;
        var clientLeft = el.clientLeft || body.clientLeft || 0;
        var scrollTop = el === window ? window.scrollY : el.scrollTop;
        var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft,
        };
      }

      return null;
    }

    function styles$1() {
      var window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }

    function css$1(props, value) {
      var window = getWindow();
      var i;

      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (var _prop in props) {
              this[i].style[_prop] = props[_prop];
            }
          }

          return this;
        }
      }

      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }

        return this;
      }

      return this;
    }

    function each$1(callback) {
      if (!callback) return this;
      this.forEach(function (el, index) {
        callback.apply(el, [el, index]);
      });
      return this;
    }

    function filter$1(callback) {
      var result = arrayFilter(this, callback);
      return $$1(result);
    }

    function html$1(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }

      for (var i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }

      return this;
    }

    function text$1(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }

      for (var i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }

      return this;
    }

    function is$1(selector) {
      var window = getWindow();
      var document = getDocument();
      var el = this[0];
      var compareWith;
      var i;
      if (!el || typeof selector === 'undefined') return false;

      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $$1(selector);

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      if (selector === document) {
        return el === document;
      }

      if (selector === window) {
        return el === window;
      }

      if (selector.nodeType || selector instanceof Dom7$1) {
        compareWith = selector.nodeType ? [selector] : selector;

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      return false;
    }

    function index$1() {
      var child = this[0];
      var i;

      if (child) {
        i = 0; // eslint-disable-next-line

        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }

        return i;
      }

      return undefined;
    }

    function eq$1(index) {
      if (typeof index === 'undefined') return this;
      var length = this.length;

      if (index > length - 1) {
        return $$1([]);
      }

      if (index < 0) {
        var returnIndex = length + index;
        if (returnIndex < 0) return $$1([]);
        return $$1([this[returnIndex]]);
      }

      return $$1([this[index]]);
    }

    function append$1() {
      var newChild;
      var document = getDocument();

      for (var k = 0; k < arguments.length; k += 1) {
        newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

        for (var i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7$1) {
            for (var j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }

      return this;
    }

    function prepend$1(newChild) {
      var document = getDocument();
      var i;
      var j;

      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7$1) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    }

    function next$1(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $$1(this[0].nextElementSibling).is(selector)) {
            return $$1([this[0].nextElementSibling]);
          }

          return $$1([]);
        }

        if (this[0].nextElementSibling) return $$1([this[0].nextElementSibling]);
        return $$1([]);
      }

      return $$1([]);
    }

    function nextAll$1(selector) {
      var nextEls = [];
      var el = this[0];
      if (!el) return $$1([]);

      while (el.nextElementSibling) {
        var _next = el.nextElementSibling; // eslint-disable-line

        if (selector) {
          if ($$1(_next).is(selector)) nextEls.push(_next);
        } else nextEls.push(_next);

        el = _next;
      }

      return $$1(nextEls);
    }

    function prev$1(selector) {
      if (this.length > 0) {
        var el = this[0];

        if (selector) {
          if (el.previousElementSibling && $$1(el.previousElementSibling).is(selector)) {
            return $$1([el.previousElementSibling]);
          }

          return $$1([]);
        }

        if (el.previousElementSibling) return $$1([el.previousElementSibling]);
        return $$1([]);
      }

      return $$1([]);
    }

    function prevAll$1(selector) {
      var prevEls = [];
      var el = this[0];
      if (!el) return $$1([]);

      while (el.previousElementSibling) {
        var _prev = el.previousElementSibling; // eslint-disable-line

        if (selector) {
          if ($$1(_prev).is(selector)) prevEls.push(_prev);
        } else prevEls.push(_prev);

        el = _prev;
      }

      return $$1(prevEls);
    }

    function parent$1(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($$1(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $$1(parents);
    }

    function parents$1(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var _parent = this[i].parentNode; // eslint-disable-line

        while (_parent) {
          if (selector) {
            if ($$1(_parent).is(selector)) parents.push(_parent);
          } else {
            parents.push(_parent);
          }

          _parent = _parent.parentNode;
        }
      }

      return $$1(parents);
    }

    function closest$1(selector) {
      var closest = this; // eslint-disable-line

      if (typeof selector === 'undefined') {
        return $$1([]);
      }

      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }

      return closest;
    }

    function find$1(selector) {
      var foundElements = [];

      for (var i = 0; i < this.length; i += 1) {
        var found = this[i].querySelectorAll(selector);

        for (var j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }

      return $$1(foundElements);
    }

    function children$1(selector) {
      var children = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var childNodes = this[i].children;

        for (var j = 0; j < childNodes.length; j += 1) {
          if (!selector || $$1(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }

      return $$1(children);
    }

    function remove$1() {
      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }

      return this;
    }

    var Methods$1 = {
      addClass: addClass$1,
      removeClass: removeClass$1,
      hasClass: hasClass$1,
      toggleClass: toggleClass$1,
      attr: attr$1,
      removeAttr: removeAttr$1,
      transform: transform$1,
      transition: transition$3,
      on: on$1,
      off: off$1,
      trigger: trigger$1,
      transitionEnd: transitionEnd$4,
      outerWidth: outerWidth$1,
      outerHeight: outerHeight$1,
      styles: styles$1,
      offset: offset$1,
      css: css$1,
      each: each$1,
      html: html$1,
      text: text$1,
      is: is$1,
      index: index$1,
      eq: eq$1,
      append: append$1,
      prepend: prepend$1,
      next: next$1,
      nextAll: nextAll$1,
      prev: prev$1,
      prevAll: prevAll$1,
      parent: parent$1,
      parents: parents$1,
      closest: closest$1,
      find: find$1,
      children: children$1,
      filter: filter$1,
      remove: remove$1,
    };
    Object.keys(Methods$1).forEach(function (methodName) {
      Object.defineProperty($$1.fn, methodName, {
        value: Methods$1[methodName],
        writable: true,
      });
    });

    function deleteProps(obj) {
      var object = obj;
      Object.keys(object).forEach(function (key) {
        try {
          object[key] = null;
        } catch (e) {
          // no getter for object
        }

        try {
          delete object[key];
        } catch (e) {
          // something got wrong
        }
      });
    }

    function nextTick(callback, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return setTimeout(callback, delay);
    }

    function now() {
      return Date.now();
    }

    function getComputedStyle$1(el) {
      var window = getWindow();
      var style;

      if (window.getComputedStyle) {
        style = window.getComputedStyle(el, null);
      }

      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }

      if (!style) {
        style = el.style;
      }

      return style;
    }

    function getTranslate$1(el, axis) {
      if (axis === void 0) {
        axis = 'x';
      }

      var window = getWindow();
      var matrix;
      var curTransform;
      var transformMatrix;
      var curStyle = getComputedStyle$1(el);

      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform
            .split(', ')
            .map(function (a) {
              return a.replace(',', '.');
            })
            .join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case

        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix =
          curStyle.MozTransform ||
          curStyle.OTransform ||
          curStyle.MsTransform ||
          curStyle.msTransform ||
          curStyle.transform ||
          curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
        // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
        // Normal Browsers
        else curTransform = parseFloat(matrix[4]);
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
        // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
        // Normal Browsers
        else curTransform = parseFloat(matrix[5]);
      }

      return curTransform || 0;
    }

    function isObject$1(o) {
      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }

    function isNode(node) {
      // eslint-disable-next-line
      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
      }

      return node && (node.nodeType === 1 || node.nodeType === 11);
    }

    function extend$1() {
      var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
      var noExtend = ['__proto__', 'constructor', 'prototype'];

      for (var i = 1; i < arguments.length; i += 1) {
        var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
          var keysArray = Object.keys(Object(nextSource)).filter(function (key) {
            return noExtend.indexOf(key) < 0;
          });

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject$1(to[nextKey]) && isObject$1(nextSource[nextKey])) {
                to[nextKey] = {};

                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }

    function bindModuleMethods(instance, obj) {
      Object.keys(obj).forEach(function (key) {
        if (isObject$1(obj[key])) {
          Object.keys(obj[key]).forEach(function (subKey) {
            if (typeof obj[key][subKey] === 'function') {
              obj[key][subKey] = obj[key][subKey].bind(instance);
            }
          });
        }

        instance[key] = obj[key];
      });
    }

    function classesToSelector(classes) {
      if (classes === void 0) {
        classes = '';
      }

      return (
        '.' +
        classes
          .trim()
          .replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
          .replace(/ /g, '.')
      );
    }

    function createElementIfNotDefined($container, params, createElements, checkProps) {
      var document = getDocument();

      if (createElements) {
        Object.keys(checkProps).forEach(function (key) {
          if (!params[key] && params.auto === true) {
            var element = document.createElement('div');
            element.className = checkProps[key];
            $container.append(element);
            params[key] = element;
          }
        });
      }

      return params;
    }

    var support;

    function calcSupport() {
      var window = getWindow();
      var document = getDocument();
      return {
        touch: !!('ontouchstart' in window || (window.DocumentTouch && document instanceof window.DocumentTouch)),
        pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
        observer: (function checkObserver() {
          return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
        })(),
        passiveListener: (function checkPassiveListener() {
          var supportsPassive = false;

          try {
            var opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get: function get() {
                supportsPassive = true;
              },
            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {
            // No support
          }

          return supportsPassive;
        })(),
        gestures: (function checkGestures() {
          return 'ongesturestart' in window;
        })(),
      };
    }

    function getSupport() {
      if (!support) {
        support = calcSupport();
      }

      return support;
    }

    var device;

    function calcDevice(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
        userAgent = _ref.userAgent;

      var support = getSupport();
      var window = getWindow();
      var platform = window.navigator.platform;
      var ua = userAgent || window.navigator.userAgent;
      var device = {
        ios: false,
        android: false,
      };
      var screenWidth = window.screen.width;
      var screenHeight = window.screen.height;
      var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      var windows = platform === 'Win32';
      var macos = platform === 'MacIntel'; // iPadOs 13 fix

      var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

      if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + 'x' + screenHeight) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      } // Android

      if (android && !windows) {
        device.os = 'android';
        device.android = true;
      }

      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // Export object

      return device;
    }

    function getDevice(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }

      if (!device) {
        device = calcDevice(overrides);
      }

      return device;
    }

    var browser;

    function calcBrowser() {
      var window = getWindow();

      function isSafari() {
        var ua = window.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }

      return {
        isEdge: !!window.navigator.userAgent.match(/Edge/g),
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent),
      };
    }

    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }

      return browser;
    }

    var supportsResizeObserver = function supportsResizeObserver() {
      var window = getWindow();
      return typeof window.ResizeObserver !== 'undefined';
    };

    var Resize$1 = {
      name: 'resize',
      create: function create() {
        var swiper = this;
        extend$1(swiper, {
          resize: {
            observer: null,
            createObserver: function createObserver() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.resize.observer = new ResizeObserver(function (entries) {
                var width = swiper.width,
                  height = swiper.height;
                var newWidth = width;
                var newHeight = height;
                entries.forEach(function (_ref) {
                  var contentBoxSize = _ref.contentBoxSize,
                    contentRect = _ref.contentRect,
                    target = _ref.target;
                  if (target && target !== swiper.el) return;
                  newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                  newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                });

                if (newWidth !== width || newHeight !== height) {
                  swiper.resize.resizeHandler();
                }
              });
              swiper.resize.observer.observe(swiper.el);
            },
            removeObserver: function removeObserver() {
              if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
                swiper.resize.observer.unobserve(swiper.el);
                swiper.resize.observer = null;
              }
            },
            resizeHandler: function resizeHandler() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.emit('beforeResize');
              swiper.emit('resize');
            },
            orientationChangeHandler: function orientationChangeHandler() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.emit('orientationchange');
            },
          },
        });
      },
      on: {
        init: function init(swiper) {
          var window = getWindow();

          if (swiper.params.resizeObserver && supportsResizeObserver()) {
            swiper.resize.createObserver();
            return;
          } // Emit resize

          window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

          window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
        },
        destroy: function destroy(swiper) {
          var window = getWindow();
          swiper.resize.removeObserver();
          window.removeEventListener('resize', swiper.resize.resizeHandler);
          window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
        },
      },
    };

    function _extends$1() {
      _extends$1 =
        Object.assign ||
        function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
      return _extends$1.apply(this, arguments);
    }
    var Observer$2 = {
      attach: function attach(target, options) {
        if (options === void 0) {
          options = {};
        }

        var window = getWindow();
        var swiper = this;
        var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
        var observer = new ObserverFunc(function (mutations) {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            swiper.emit('observerUpdate', mutations[0]);
            return;
          }

          var observerUpdate = function observerUpdate() {
            swiper.emit('observerUpdate', mutations[0]);
          };

          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(observerUpdate);
          } else {
            window.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
        });
        swiper.observer.observers.push(observer);
      },
      init: function init() {
        var swiper = this;
        if (!swiper.support.observer || !swiper.params.observer) return;

        if (swiper.params.observeParents) {
          var containerParents = swiper.$el.parents();

          for (var i = 0; i < containerParents.length; i += 1) {
            swiper.observer.attach(containerParents[i]);
          }
        } // Observe container

        swiper.observer.attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren,
        }); // Observe wrapper

        swiper.observer.attach(swiper.$wrapperEl[0], {
          attributes: false,
        });
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.observer.observers.forEach(function (observer) {
          observer.disconnect();
        });
        swiper.observer.observers = [];
      },
    };
    var Observer$3 = {
      name: 'observer',
      params: {
        observer: false,
        observeParents: false,
        observeSlideChildren: false,
      },
      create: function create() {
        var swiper = this;
        bindModuleMethods(swiper, {
          observer: _extends$1({}, Observer$2, {
            observers: [],
          }),
        });
      },
      on: {
        init: function init(swiper) {
          swiper.observer.init();
        },
        destroy: function destroy(swiper) {
          swiper.observer.destroy();
        },
      },
    };

    var modular = {
      useParams: function useParams(instanceParams) {
        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName]; // Extend params

          if (module.params) {
            extend$1(instanceParams, module.params);
          }
        });
      },
      useModules: function useModules(modulesParams) {
        if (modulesParams === void 0) {
          modulesParams = {};
        }

        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName];
          var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

          if (module.on && instance.on) {
            Object.keys(module.on).forEach(function (moduleEventName) {
              instance.on(moduleEventName, module.on[moduleEventName]);
            });
          } // Module create callback

          if (module.create) {
            module.create.bind(instance)(moduleParams);
          }
        });
      },
    };

    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
      on: function on(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(function (event) {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      },
      once: function once(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;

        function onceHandler() {
          self.off(events, onceHandler);

          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          handler.apply(self, args);
        }

        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
      },
      onAny: function onAny(handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';

        if (self.eventsAnyListeners.indexOf(handler) < 0) {
          self.eventsAnyListeners[method](handler);
        }

        return self;
      },
      offAny: function offAny(handler) {
        var self = this;
        if (!self.eventsAnyListeners) return self;
        var index = self.eventsAnyListeners.indexOf(handler);

        if (index >= 0) {
          self.eventsAnyListeners.splice(index, 1);
        }

        return self;
      },
      off: function off(events, handler) {
        var self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(function (event) {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler, index) {
              if (eventHandler === handler || (eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler)) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      },
      emit: function emit() {
        var self = this;
        if (!self.eventsListeners) return self;
        var events;
        var data;
        var context;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }

        data.unshift(context);
        var eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(function (event) {
          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
            self.eventsAnyListeners.forEach(function (eventHandler) {
              eventHandler.apply(context, [event].concat(data));
            });
          }

          if (self.eventsListeners && self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler) {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      },
    };

    function updateSize$1() {
      var swiper = this;
      var width;
      var height;
      var $el = swiper.$el;

      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }

      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }

      if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
        return;
      } // Subtract paddings

      width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
      height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
      extend$1(swiper, {
        width: width,
        height: height,
        size: swiper.isHorizontal() ? width : height,
      });
    }

    function updateSlides$1() {
      var swiper = this;

      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
      return property;
    } // prettier-ignore

        return {
          'width': 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          'marginRight': 'marginBottom',
        }[property];
      }

      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }

      var params = swiper.params;
      var $wrapperEl = swiper.$wrapperEl,
        swiperSize = swiper.size,
        rtl = swiper.rtlTranslate,
        wrongRTL = swiper.wrongRTL;
      var isVirtual = swiper.virtual && params.virtual.enabled;
      var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      var slides = $wrapperEl.children('.' + swiper.params.slideClass);
      var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      var snapGrid = [];
      var slidesGrid = [];
      var slidesSizesGrid = [];
      var offsetBefore = params.slidesOffsetBefore;

      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }

      var offsetAfter = params.slidesOffsetAfter;

      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }

      var previousSnapGridLength = swiper.snapGrid.length;
      var previousSlidesGridLength = swiper.slidesGrid.length;
      var spaceBetween = params.spaceBetween;
      var slidePosition = -offsetBefore;
      var prevSlideSize = 0;
      var index = 0;

      if (typeof swiperSize === 'undefined') {
        return;
      }

      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
      }

      swiper.virtualSize = -spaceBetween; // reset margins

      if (rtl)
        slides.css({
          marginLeft: '',
          marginBottom: '',
          marginTop: '',
        });
      else
        slides.css({
          marginRight: '',
          marginBottom: '',
          marginTop: '',
        });
      var slidesNumberEvenToRows;

      if (params.slidesPerColumn > 1) {
        if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
          slidesNumberEvenToRows = slidesLength;
        } else {
          slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
        }

        if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
        }
      } // Calc slides

      var slideSize;
      var slidesPerColumn = params.slidesPerColumn;
      var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
      var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

      for (var i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        var slide = slides.eq(i);

        if (params.slidesPerColumn > 1) {
          // Set slides order
          var newSlideOrderIndex = void 0;
          var column = void 0;
          var row = void 0;

          if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
            var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
            var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
            var columnsInGroup =
              groupIndex === 0
                ? params.slidesPerGroup
                : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
            row = Math.floor(slideIndexInGroup / columnsInGroup);
            column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
            newSlideOrderIndex = column + (row * slidesNumberEvenToRows) / slidesPerColumn;
            slide.css({
              '-webkit-box-ordinal-group': newSlideOrderIndex,
              '-moz-box-ordinal-group': newSlideOrderIndex,
              '-ms-flex-order': newSlideOrderIndex,
              '-webkit-order': newSlideOrderIndex,
              'order': newSlideOrderIndex,
            });
          } else if (params.slidesPerColumnFill === 'column') {
            column = Math.floor(i / slidesPerColumn);
            row = i - column * slidesPerColumn;

            if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
              row += 1;

              if (row >= slidesPerColumn) {
                row = 0;
                column += 1;
              }
            }
          } else {
            row = Math.floor(i / slidesPerRow);
            column = i - row * slidesPerRow;
          }

          slide.css(getDirectionLabel('margin-top'), row !== 0 ? params.spaceBetween && params.spaceBetween + 'px' : '');
        }

        if (slide.css('display') === 'none') continue; // eslint-disable-line

        if (params.slidesPerView === 'auto') {
          var slideStyles = getComputedStyle(slide[0]);
          var currentTransform = slide[0].style.transform;
          var currentWebKitTransform = slide[0].style.webkitTransform;

          if (currentTransform) {
            slide[0].style.transform = 'none';
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = 'none';
          }

          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            var width = getDirectionPropertyValue(slideStyles, 'width');
            var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
            var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
            var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
            var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
            var boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              var _slide$ = slide[0],
                clientWidth = _slide$.clientWidth,
                offsetWidth = _slide$.offsetWidth;
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }

          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }

          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);

          if (slides[i]) {
            slides[i].style[getDirectionLabel('width')] = slideSize + 'px';
          }
        }

        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }

        slidesSizesGrid.push(slideSize);

        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }

        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
      }

      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
      var newSlidesGrid;

      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({
          width: swiper.virtualSize + params.spaceBetween + 'px',
        });
      }

      if (params.setWrapperSize) {
        var _$wrapperEl$css;

        $wrapperEl.css(((_$wrapperEl$css = {}), (_$wrapperEl$css[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + 'px'), _$wrapperEl$css));
      }

      if (params.slidesPerColumn > 1) {
        var _$wrapperEl$css2;

        swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
        $wrapperEl.css(((_$wrapperEl$css2 = {}), (_$wrapperEl$css2[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + 'px'), _$wrapperEl$css2));

        if (params.centeredSlides) {
          newSlidesGrid = [];

          for (var _i = 0; _i < snapGrid.length; _i += 1) {
            var slidesGridItem = snapGrid[_i];
            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
          }

          snapGrid = newSlidesGrid;
        }
      } // Remove last grid elements depending on width

      if (!params.centeredSlides) {
        newSlidesGrid = [];

        for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
          var _slidesGridItem = snapGrid[_i2];
          if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);

          if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(_slidesGridItem);
          }
        }

        snapGrid = newSlidesGrid;

        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }

      if (snapGrid.length === 0) snapGrid = [0];

      if (params.spaceBetween !== 0) {
        var _slides$filter$css;

        var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
        slides
          .filter(function (_, slideIndex) {
            if (!params.cssMode) return true;

            if (slideIndex === slides.length - 1) {
              return false;
            }

            return true;
          })
          .css(((_slides$filter$css = {}), (_slides$filter$css[key] = spaceBetween + 'px'), _slides$filter$css));
      }

      if (params.centeredSlides && params.centeredSlidesBounds) {
        var allSlidesSize = 0;
        slidesSizesGrid.forEach(function (slideSizeValue) {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        var maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(function (snap) {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }

      if (params.centerInsufficientSlides) {
        var _allSlidesSize = 0;
        slidesSizesGrid.forEach(function (slideSizeValue) {
          _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        _allSlidesSize -= params.spaceBetween;

        if (_allSlidesSize < swiperSize) {
          var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
          snapGrid.forEach(function (snap, snapIndex) {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach(function (snap, snapIndex) {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }

      extend$1(swiper, {
        slides: slides,
        snapGrid: snapGrid,
        slidesGrid: slidesGrid,
        slidesSizesGrid: slidesSizesGrid,
      });

      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }

      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }

      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }

      if (params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateSlidesOffset();
      }
    }

    function updateAutoHeight$1(speed) {
      var swiper = this;
      var activeSlides = [];
      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var newHeight = 0;
      var i;

      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }

      var getSlideByIndex = function getSlideByIndex(index) {
        if (isVirtual) {
          return swiper.slides.filter(function (el) {
            return parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index;
          })[0];
        }

        return swiper.slides.eq(index)[0];
      }; // Find slides currently in view

      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          swiper.visibleSlides.each(function (slide) {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            var index = swiper.activeIndex + i;
            if (index > swiper.slides.length && !isVirtual) break;
            activeSlides.push(getSlideByIndex(index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      } // Find new height from highest slide in view

      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          var height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      } // Update Height

      if (newHeight) swiper.$wrapperEl.css('height', newHeight + 'px');
    }

    function updateSlidesOffset$1() {
      var swiper = this;
      var slides = swiper.slides;

      for (var i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
      }
    }

    function updateSlidesProgress$1(translate) {
      if (translate === void 0) {
        translate = (this && this.translate) || 0;
      }

      var swiper = this;
      var params = swiper.params;
      var slides = swiper.slides,
        rtl = swiper.rtlTranslate;
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
      var offsetCenter = -translate;
      if (rtl) offsetCenter = translate; // Visible Slides

      slides.removeClass(params.slideVisibleClass);
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];

      for (var i = 0; i < slides.length; i += 1) {
        var slide = slides[i];
        var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

        if (params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) {
          var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
          var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
          var isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1) || (slideAfter > 1 && slideAfter <= swiper.size) || (slideBefore <= 0 && slideAfter >= swiper.size);

          if (isVisible) {
            swiper.visibleSlides.push(slide);
            swiper.visibleSlidesIndexes.push(i);
            slides.eq(i).addClass(params.slideVisibleClass);
          }
        }

        slide.progress = rtl ? -slideProgress : slideProgress;
      }

      swiper.visibleSlides = $$1(swiper.visibleSlides);
    }

    function updateProgress$1(translate) {
      var swiper = this;

      if (typeof translate === 'undefined') {
        var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

        translate = (swiper && swiper.translate && swiper.translate * multiplier) || 0;
      }

      var params = swiper.params;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      var progress = swiper.progress,
        isBeginning = swiper.isBeginning,
        isEnd = swiper.isEnd;
      var wasBeginning = isBeginning;
      var wasEnd = isEnd;

      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }

      extend$1(swiper, {
        progress: progress,
        isBeginning: isBeginning,
        isEnd: isEnd,
      });
      if (params.watchSlidesProgress || params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) swiper.updateSlidesProgress(translate);

      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }

      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }

      if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
        swiper.emit('fromEdge');
      }

      swiper.emit('progress', progress);
    }

    function updateSlidesClasses$1() {
      var swiper = this;
      var slides = swiper.slides,
        params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        activeIndex = swiper.activeIndex,
        realIndex = swiper.realIndex;
      var isVirtual = swiper.virtual && params.virtual.enabled;
      slides.removeClass(
        params.slideActiveClass +
          ' ' +
          params.slideNextClass +
          ' ' +
          params.slidePrevClass +
          ' ' +
          params.slideDuplicateActiveClass +
          ' ' +
          params.slideDuplicateNextClass +
          ' ' +
          params.slideDuplicatePrevClass,
      );
      var activeSlide;

      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find('.' + params.slideClass + '[data-swiper-slide-index="' + activeIndex + '"]');
      } else {
        activeSlide = slides.eq(activeIndex);
      } // Active classes

      activeSlide.addClass(params.slideActiveClass);

      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl
            .children('.' + params.slideClass + ':not(.' + params.slideDuplicateClass + ')[data-swiper-slide-index="' + realIndex + '"]')
            .addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl
            .children('.' + params.slideClass + '.' + params.slideDuplicateClass + '[data-swiper-slide-index="' + realIndex + '"]')
            .addClass(params.slideDuplicateActiveClass);
        }
      } // Next Slide

      var nextSlide = activeSlide
        .nextAll('.' + params.slideClass)
        .eq(0)
        .addClass(params.slideNextClass);

      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      } // Prev Slide

      var prevSlide = activeSlide
        .prevAll('.' + params.slideClass)
        .eq(0)
        .addClass(params.slidePrevClass);

      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }

      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl
            .children('.' + params.slideClass + ':not(.' + params.slideDuplicateClass + ')[data-swiper-slide-index="' + nextSlide.attr('data-swiper-slide-index') + '"]')
            .addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl
            .children('.' + params.slideClass + '.' + params.slideDuplicateClass + '[data-swiper-slide-index="' + nextSlide.attr('data-swiper-slide-index') + '"]')
            .addClass(params.slideDuplicateNextClass);
        }

        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl
            .children('.' + params.slideClass + ':not(.' + params.slideDuplicateClass + ')[data-swiper-slide-index="' + prevSlide.attr('data-swiper-slide-index') + '"]')
            .addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl
            .children('.' + params.slideClass + '.' + params.slideDuplicateClass + '[data-swiper-slide-index="' + prevSlide.attr('data-swiper-slide-index') + '"]')
            .addClass(params.slideDuplicatePrevClass);
        }
      }

      swiper.emitSlidesClasses();
    }

    function updateActiveIndex$1(newActiveIndex) {
      var swiper = this;
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      var slidesGrid = swiper.slidesGrid,
        snapGrid = swiper.snapGrid,
        params = swiper.params,
        previousIndex = swiper.activeIndex,
        previousRealIndex = swiper.realIndex,
        previousSnapIndex = swiper.snapIndex;
      var activeIndex = newActiveIndex;
      var snapIndex;

      if (typeof activeIndex === 'undefined') {
        for (var i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        } // Normalize slideIndex

        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }

      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }

      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }

        return;
      } // Get real index

      var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
      extend$1(swiper, {
        snapIndex: snapIndex,
        realIndex: realIndex,
        previousIndex: previousIndex,
        activeIndex: activeIndex,
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');

      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }

      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }

    function updateClickedSlide$1(e) {
      var swiper = this;
      var params = swiper.params;
      var slide = $$1(e.target).closest('.' + params.slideClass)[0];
      var slideFound = false;
      var slideIndex;

      if (slide) {
        for (var i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) {
            slideFound = true;
            slideIndex = i;
            break;
          }
        }
      }

      if (slide && slideFound) {
        swiper.clickedSlide = slide;

        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($$1(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }

      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }

    var update$1 = {
      updateSize: updateSize$1,
      updateSlides: updateSlides$1,
      updateAutoHeight: updateAutoHeight$1,
      updateSlidesOffset: updateSlidesOffset$1,
      updateSlidesProgress: updateSlidesProgress$1,
      updateProgress: updateProgress$1,
      updateSlidesClasses: updateSlidesClasses$1,
      updateActiveIndex: updateActiveIndex$1,
      updateClickedSlide: updateClickedSlide$1,
    };

    function getSwiperTranslate(axis) {
      if (axis === void 0) {
        axis = this.isHorizontal() ? 'x' : 'y';
      }

      var swiper = this;
      var params = swiper.params,
        rtl = swiper.rtlTranslate,
        translate = swiper.translate,
        $wrapperEl = swiper.$wrapperEl;

      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }

      if (params.cssMode) {
        return translate;
      }

      var currentTranslate = getTranslate$1($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }

    function setTranslate$1(translate, byController) {
      var swiper = this;
      var rtl = swiper.rtlTranslate,
        params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        wrapperEl = swiper.wrapperEl,
        progress = swiper.progress;
      var x = 0;
      var y = 0;
      var z = 0;

      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }

      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }

      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform('translate3d(' + x + 'px, ' + y + 'px, ' + z + 'px)');
      }

      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

      var newProgress;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }

      swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate$1() {
      return -this.snapGrid[0];
    }

    function maxTranslate$1() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }

    function translateTo$1(translate, speed, runCallbacks, translateBounds, internal) {
      if (translate === void 0) {
        translate = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (translateBounds === void 0) {
        translateBounds = true;
      }

      var swiper = this;
      var params = swiper.params,
        wrapperEl = swiper.wrapperEl;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }

      var minTranslate = swiper.minTranslate();
      var maxTranslate = swiper.maxTranslate();
      var newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
      else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
      else newTranslate = translate; // Update progress

      swiper.updateProgress(newTranslate);

      if (params.cssMode) {
        var isH = swiper.isHorizontal();

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          // eslint-disable-next-line
          if (wrapperEl.scrollTo) {
            var _wrapperEl$scrollTo;

            wrapperEl.scrollTo(
              ((_wrapperEl$scrollTo = {}), (_wrapperEl$scrollTo[isH ? 'left' : 'top'] = -newTranslate), (_wrapperEl$scrollTo.behavior = 'smooth'), _wrapperEl$scrollTo),
            );
          } else {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
          }
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;

              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
        }
      }

      return true;
    }

    var translate$1 = {
      getTranslate: getSwiperTranslate,
      setTranslate: setTranslate$1,
      minTranslate: minTranslate$1,
      maxTranslate: maxTranslate$1,
      translateTo: translateTo$1,
    };

    function setTransition$1(duration, byController) {
      var swiper = this;

      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }

      swiper.emit('setTransition', duration, byController);
    }

    function transitionStart$1(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var activeIndex = swiper.activeIndex,
        params = swiper.params,
        previousIndex = swiper.previousIndex;
      if (params.cssMode) return;

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      var dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';
        else if (activeIndex < previousIndex) dir = 'prev';
        else dir = 'reset';
      }

      swiper.emit('transitionStart');

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit('slideResetTransitionStart');
          return;
        }

        swiper.emit('slideChangeTransitionStart');

        if (dir === 'next') {
          swiper.emit('slideNextTransitionStart');
        } else {
          swiper.emit('slidePrevTransitionStart');
        }
      }
    }

    function transitionEnd$3(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var activeIndex = swiper.activeIndex,
        previousIndex = swiper.previousIndex,
        params = swiper.params;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
      var dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';
        else if (activeIndex < previousIndex) dir = 'prev';
        else dir = 'reset';
      }

      swiper.emit('transitionEnd');

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit('slideResetTransitionEnd');
          return;
        }

        swiper.emit('slideChangeTransitionEnd');

        if (dir === 'next') {
          swiper.emit('slideNextTransitionEnd');
        } else {
          swiper.emit('slidePrevTransitionEnd');
        }
      }
    }

    var transition$2 = {
      setTransition: setTransition$1,
      transitionStart: transitionStart$1,
      transitionEnd: transitionEnd$3,
    };

    function slideTo$1(index, speed, runCallbacks, internal, initial) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (typeof index !== 'number' && typeof index !== 'string') {
        throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof index + '] given.');
      }

      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        var indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        var isValidNumber = isFinite(indexAsNumber);

        if (!isValidNumber) {
          throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index + '] given.');
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.

        index = indexAsNumber;
      }

      var swiper = this;
      var slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
      var params = swiper.params,
        snapGrid = swiper.snapGrid,
        slidesGrid = swiper.slidesGrid,
        previousIndex = swiper.previousIndex,
        activeIndex = swiper.activeIndex,
        rtl = swiper.rtlTranslate,
        wrapperEl = swiper.wrapperEl,
        enabled = swiper.enabled;

      if ((swiper.animating && params.preventInteractionOnTransition) || (!enabled && !internal && !initial)) {
        return false;
      }

      var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }

      var translate = -snapGrid[snapIndex]; // Update progress

      swiper.updateProgress(translate); // Normalize slideIndex

      if (params.normalizeSlideIndex) {
        for (var i = 0; i < slidesGrid.length; i += 1) {
          var normalizedTranslate = -Math.floor(translate * 100);
          var normalizedGird = Math.floor(slidesGrid[i] * 100);
          var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
              slideIndex = i;
            } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
              slideIndex = i + 1;
            }
          } else if (normalizedTranslate >= normalizedGird) {
            slideIndex = i;
          }
        }
      } // Directions locks

      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
          return false;
        }

        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }

      var direction;
      if (slideIndex > activeIndex) direction = 'next';
      else if (slideIndex < activeIndex) direction = 'prev';
      else direction = 'reset'; // Update Index

      if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
        swiper.updateActiveIndex(slideIndex); // Update Height

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }

        swiper.updateSlidesClasses();

        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }

        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }

        return false;
      }

      if (params.cssMode) {
        var isH = swiper.isHorizontal();
        var t = -translate;

        if (rtl) {
          t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
        }

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        } else {
          // eslint-disable-next-line
          if (wrapperEl.scrollTo) {
            var _wrapperEl$scrollTo;

            wrapperEl.scrollTo(((_wrapperEl$scrollTo = {}), (_wrapperEl$scrollTo[isH ? 'left' : 'top'] = t), (_wrapperEl$scrollTo.behavior = 'smooth'), _wrapperEl$scrollTo));
          } else {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
          }
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onSlideToWrapperTransitionEnd) {
            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
              swiper.onSlideToWrapperTransitionEnd = null;
              delete swiper.onSlideToWrapperTransitionEnd;
              swiper.transitionEnd(runCallbacks, direction);
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        }
      }

      return true;
    }

    function slideToLoop$1(index, speed, runCallbacks, internal) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var newIndex = index;

      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }

      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext$1(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var params = swiper.params,
        animating = swiper.animating,
        enabled = swiper.enabled;
      if (!enabled) return swiper;
      var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev$1(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var params = swiper.params,
        animating = swiper.animating,
        snapGrid = swiper.snapGrid,
        slidesGrid = swiper.slidesGrid,
        rtlTranslate = swiper.rtlTranslate,
        enabled = swiper.enabled;
      if (!enabled) return swiper;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      var translate = rtlTranslate ? swiper.translate : -swiper.translate;

      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }

      var normalizedTranslate = normalize(translate);
      var normalizedSnapGrid = snapGrid.map(function (val) {
        return normalize(val);
      });
      var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

      if (typeof prevSnap === 'undefined' && params.cssMode) {
        snapGrid.forEach(function (snap) {
          if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
        });
      }

      var prevIndex;

      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
      }

      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset$1(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest$1(speed, runCallbacks, internal, threshold) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (threshold === void 0) {
        threshold = 0.5;
      }

      var swiper = this;
      var index = swiper.activeIndex;
      var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        var currentSnap = swiper.snapGrid[snapIndex];
        var nextSnap = swiper.snapGrid[snapIndex + 1];

        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        var prevSnap = swiper.snapGrid[snapIndex - 1];
        var _currentSnap = swiper.snapGrid[snapIndex];

        if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }

      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index, speed, runCallbacks, internal);
    }

    function slideToClickedSlide$1() {
      var swiper = this;
      var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl;
      var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      var slideToIndex = swiper.clickedIndex;
      var realIndex;

      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($$1(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl
              .children('.' + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ')')
              .eq(0)
              .index();
            nextTick(function () {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl
            .children('.' + params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]:not(.' + params.slideDuplicateClass + ')')
            .eq(0)
            .index();
          nextTick(function () {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }

    var slide$1 = {
      slideTo: slideTo$1,
      slideToLoop: slideToLoop$1,
      slideNext: slideNext$1,
      slidePrev: slidePrev$1,
      slideReset: slideReset$1,
      slideToClosest: slideToClosest$1,
      slideToClickedSlide: slideToClickedSlide$1,
    };

    function loopCreate$1() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

      $wrapperEl.children('.' + params.slideClass + '.' + params.slideDuplicateClass).remove();
      var slides = $wrapperEl.children('.' + params.slideClass);

      if (params.loopFillGroupWithBlank) {
        var blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);

        if (blankSlidesNum !== params.slidesPerGroup) {
          for (var i = 0; i < blankSlidesNum; i += 1) {
            var blankNode = $$1(document.createElement('div')).addClass(params.slideClass + ' ' + params.slideBlankClass);
            $wrapperEl.append(blankNode);
          }

          slides = $wrapperEl.children('.' + params.slideClass);
        }
      }

      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;

      if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
      }

      var prependSlides = [];
      var appendSlides = [];
      slides.each(function (el, index) {
        var slide = $$1(el);

        if (index < swiper.loopedSlides) {
          appendSlides.push(el);
        }

        if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
          prependSlides.push(el);
        }

        slide.attr('data-swiper-slide-index', index);
      });

      for (var _i = 0; _i < appendSlides.length; _i += 1) {
        $wrapperEl.append($$1(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }

      for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
        $wrapperEl.prepend($$1(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }

    function loopFix$1() {
      var swiper = this;
      swiper.emit('beforeLoopFix');
      var activeIndex = swiper.activeIndex,
        slides = swiper.slides,
        loopedSlides = swiper.loopedSlides,
        allowSlidePrev = swiper.allowSlidePrev,
        allowSlideNext = swiper.allowSlideNext,
        snapGrid = swiper.snapGrid,
        rtl = swiper.rtlTranslate;
      var newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      var snapTranslate = -snapGrid[activeIndex];
      var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        var slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;

        var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (_slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }

      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit('loopFix');
    }

    function loopDestroy$1() {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
        params = swiper.params,
        slides = swiper.slides;
      $wrapperEl.children('.' + params.slideClass + '.' + params.slideDuplicateClass + ',.' + params.slideClass + '.' + params.slideBlankClass).remove();
      slides.removeAttr('data-swiper-slide-index');
    }

    var loop$1 = {
      loopCreate: loopCreate$1,
      loopFix: loopFix$1,
      loopDestroy: loopDestroy$1,
    };

    function setGrabCursor$1(moving) {
      var swiper = this;
      if (swiper.support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
      var el = swiper.el;
      el.style.cursor = 'move';
      el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
      el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor$1() {
      var swiper = this;

      if (swiper.support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) {
        return;
      }

      swiper.el.style.cursor = '';
    }

    var grabCursor$1 = {
      setGrabCursor: setGrabCursor$1,
      unsetGrabCursor: unsetGrabCursor$1,
    };

    function appendSlide$1(slides) {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
        params = swiper.params;

      if (params.loop) {
        swiper.loopDestroy();
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }
      } else {
        $wrapperEl.append(slides);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }
    }

    function prependSlide$1(slides) {
      var swiper = this;
      var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        activeIndex = swiper.activeIndex;

      if (params.loop) {
        swiper.loopDestroy();
      }

      var newActiveIndex = activeIndex + 1;

      if (typeof slides === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.prepend(slides[i]);
        }

        newActiveIndex = activeIndex + slides.length;
      } else {
        $wrapperEl.prepend(slides);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      swiper.slideTo(newActiveIndex, 0, false);
    }

    function addSlide$1(index, slides) {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
        params = swiper.params,
        activeIndex = swiper.activeIndex;
      var activeIndexBuffer = activeIndex;

      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children('.' + params.slideClass);
      }

      var baseLength = swiper.slides.length;

      if (index <= 0) {
        swiper.prependSlide(slides);
        return;
      }

      if (index >= baseLength) {
        swiper.appendSlide(slides);
        return;
      }

      var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
      var slidesBuffer = [];

      for (var i = baseLength - 1; i >= index; i -= 1) {
        var currentSlide = swiper.slides.eq(i);
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (var _i = 0; _i < slides.length; _i += 1) {
          if (slides[_i]) $wrapperEl.append(slides[_i]);
        }

        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
      } else {
        $wrapperEl.append(slides);
      }

      for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
        $wrapperEl.append(slidesBuffer[_i2]);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeSlide$1(slidesIndexes) {
      var swiper = this;
      var params = swiper.params,
        $wrapperEl = swiper.$wrapperEl,
        activeIndex = swiper.activeIndex;
      var activeIndexBuffer = activeIndex;

      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children('.' + params.slideClass);
      }

      var newActiveIndex = activeIndexBuffer;
      var indexToRemove;

      if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
        for (var i = 0; i < slidesIndexes.length; i += 1) {
          indexToRemove = slidesIndexes[i];
          if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }

        newActiveIndex = Math.max(newActiveIndex, 0);
      } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeAllSlides$1() {
      var swiper = this;
      var slidesIndexes = [];

      for (var i = 0; i < swiper.slides.length; i += 1) {
        slidesIndexes.push(i);
      }

      swiper.removeSlide(slidesIndexes);
    }

    var manipulation$1 = {
      appendSlide: appendSlide$1,
      prependSlide: prependSlide$1,
      addSlide: addSlide$1,
      removeSlide: removeSlide$1,
      removeAllSlides: removeAllSlides$1,
    };

    function closestElement(selector, base) {
      if (base === void 0) {
        base = this;
      }

      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        var found = el.closest(selector);
        return found || __closestFrom(el.getRootNode().host);
      }

      return __closestFrom(base);
    }

    function onTouchStart$1(event) {
      var swiper = this;
      var document = getDocument();
      var window = getWindow();
      var data = swiper.touchEventsData;
      var params = swiper.params,
        touches = swiper.touches,
        enabled = swiper.enabled;
      if (!enabled) return;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }

      var e = event;
      if (e.originalEvent) e = e.originalEvent;
      var $targetEl = $$1(e.target);

      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }

      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return; // change target el for shadow root component

      var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

      if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
        $targetEl = $$1(event.path[0]);
      }

      var noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : '.' + params.noSwipingClass;
      var isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
        swiper.allowClick = true;
        return;
      }

      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }

      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      var startX = touches.currentX;
      var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

      var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === 'prevent') {
          event.preventDefault();
        } else {
          return;
        }
      }

      extend$1(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined,
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;

      if (e.type !== 'touchstart') {
        var preventDefault = true;
        if ($targetEl.is(data.focusableElements)) preventDefault = false;

        if (document.activeElement && $$1(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
          document.activeElement.blur();
        }

        var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
          e.preventDefault();
        }
      }

      swiper.emit('touchStart', e);
    }

    function onTouchMove$1(event) {
      var document = getDocument();
      var swiper = this;
      var data = swiper.touchEventsData;
      var params = swiper.params,
        touches = swiper.touches,
        rtl = swiper.rtlTranslate,
        enabled = swiper.enabled;
      if (!enabled) return;
      var e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }

        return;
      }

      if (data.isTouchEvent && e.type !== 'touchmove') return;
      var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }

      if (!swiper.allowTouchMove) {
        // isMoved = true;
        swiper.allowClick = false;

        if (data.isTouched) {
          extend$1(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY,
          });
          data.touchStartTime = now();
        }

        return;
      }

      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if ((pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if ((pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())) {
          return;
        }
      }

      if (data.isTouchEvent && document.activeElement) {
        if (e.target === document.activeElement && $$1(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }

      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }

      if (e.targetTouches && e.targetTouches.length > 1) return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      var diffX = touches.currentX - touches.startX;
      var diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;

      if (typeof data.isScrolling === 'undefined') {
        var touchAngle;

        if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }

      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }

      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }

      if (!data.startMoving) {
        return;
      }

      swiper.allowClick = false;

      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }

      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }

      if (!data.isMoved) {
        if (params.loop) {
          swiper.loopFix();
        }

        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);

        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }

        data.allowMomentumBounce = false; // Grab Cursor

        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }

        swiper.emit('sliderFirstMove', e);
      }

      swiper.emit('sliderMove', e);
      data.isMoved = true;
      var diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) diff = -diff;
      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;
      var disableParentSwiper = true;
      var resistanceRatio = params.resistanceRatio;

      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }

      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
      }

      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      } // Directions locks

      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      } // Threshold

      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }

      if (!params.followFinger || params.cssMode) return; // Update active index in free mode

      if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      if (params.freeMode) {
        // Velocity
        if (data.velocities.length === 0) {
          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
            time: data.touchStartTime,
          });
        }

        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
          time: now(),
        });
      } // Update progress

      swiper.updateProgress(data.currentTranslate); // Update translate

      swiper.setTranslate(data.currentTranslate);
    }

    function onTouchEnd$1(event) {
      var swiper = this;
      var data = swiper.touchEventsData;
      var params = swiper.params,
        touches = swiper.touches,
        rtl = swiper.rtlTranslate,
        $wrapperEl = swiper.$wrapperEl,
        slidesGrid = swiper.slidesGrid,
        snapGrid = swiper.snapGrid,
        enabled = swiper.enabled;
      if (!enabled) return;
      var e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }

      data.allowTouchCallbacks = false;

      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }

        data.isMoved = false;
        data.startMoving = false;
        return;
      } // Return Grab Cursor

      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      } // Time diff

      var touchEndTime = now();
      var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

      if (swiper.allowClick) {
        swiper.updateClickedSlide(e);
        swiper.emit('tap click', e);

        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }

      data.lastClickTime = now();
      nextTick(function () {
        if (!swiper.destroyed) swiper.allowClick = true;
      });

      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }

      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      var currentPos;

      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }

      if (params.cssMode) {
        return;
      }

      if (params.freeMode) {
        if (currentPos < -swiper.minTranslate()) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (currentPos > -swiper.maxTranslate()) {
          if (swiper.slides.length < snapGrid.length) {
            swiper.slideTo(snapGrid.length - 1);
          } else {
            swiper.slideTo(swiper.slides.length - 1);
          }

          return;
        }

        if (params.freeModeMomentum) {
          if (data.velocities.length > 1) {
            var lastMoveEvent = data.velocities.pop();
            var velocityEvent = data.velocities.pop();
            var distance = lastMoveEvent.position - velocityEvent.position;
            var time = lastMoveEvent.time - velocityEvent.time;
            swiper.velocity = distance / time;
            swiper.velocity /= 2;

            if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
              swiper.velocity = 0;
            } // this implies that the user stopped moving a finger then released.
            // There would be no events with distance zero, so the last event is stale.

            if (time > 150 || now() - lastMoveEvent.time > 300) {
              swiper.velocity = 0;
            }
          } else {
            swiper.velocity = 0;
          }

          swiper.velocity *= params.freeModeMomentumVelocityRatio;
          data.velocities.length = 0;
          var momentumDuration = 1000 * params.freeModeMomentumRatio;
          var momentumDistance = swiper.velocity * momentumDuration;
          var newPosition = swiper.translate + momentumDistance;
          if (rtl) newPosition = -newPosition;
          var doBounce = false;
          var afterBouncePosition;
          var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
          var needsLoopFix;

          if (newPosition < swiper.maxTranslate()) {
            if (params.freeModeMomentumBounce) {
              if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                newPosition = swiper.maxTranslate() - bounceAmount;
              }

              afterBouncePosition = swiper.maxTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.maxTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (newPosition > swiper.minTranslate()) {
            if (params.freeModeMomentumBounce) {
              if (newPosition - swiper.minTranslate() > bounceAmount) {
                newPosition = swiper.minTranslate() + bounceAmount;
              }

              afterBouncePosition = swiper.minTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.minTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (params.freeModeSticky) {
            var nextSlide;

            for (var j = 0; j < snapGrid.length; j += 1) {
              if (snapGrid[j] > -newPosition) {
                nextSlide = j;
                break;
              }
            }

            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
              newPosition = snapGrid[nextSlide];
            } else {
              newPosition = snapGrid[nextSlide - 1];
            }

            newPosition = -newPosition;
          }

          if (needsLoopFix) {
            swiper.once('transitionEnd', function () {
              swiper.loopFix();
            });
          } // Fix duration

          if (swiper.velocity !== 0) {
            if (rtl) {
              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
            } else {
              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
            }

            if (params.freeModeSticky) {
              // If freeModeSticky is active and the user ends a swipe with a slow-velocity
              // event, then durations can be 20+ seconds to slide one (or zero!) slides.
              // It's easy to see this when simulating touch with mouse events. To fix this,
              // limit single-slide swipes to the default slide duration. This also has the
              // nice side effect of matching slide speed if the user stopped moving before
              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
              // For faster swipes, also apply limits (albeit higher ones).
              var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
              var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

              if (moveDistance < currentSlideSize) {
                momentumDuration = params.speed;
              } else if (moveDistance < 2 * currentSlideSize) {
                momentumDuration = params.speed * 1.5;
              } else {
                momentumDuration = params.speed * 2.5;
              }
            }
          } else if (params.freeModeSticky) {
            swiper.slideToClosest();
            return;
          }

          if (params.freeModeMomentumBounce && doBounce) {
            swiper.updateProgress(afterBouncePosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            swiper.animating = true;
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
              swiper.emit('momentumBounce');
              swiper.setTransition(params.speed);
              setTimeout(function () {
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(function () {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }, 0);
            });
          } else if (swiper.velocity) {
            swiper.updateProgress(newPosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);

            if (!swiper.animating) {
              swiper.animating = true;
              $wrapperEl.transitionEnd(function () {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }
          } else {
            swiper.emit('_freeModeNoMomentumRelease');
            swiper.updateProgress(newPosition);
          }

          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        } else if (params.freeModeSticky) {
          swiper.slideToClosest();
          return;
        } else if (params.freeMode) {
          swiper.emit('_freeModeNoMomentumRelease');
        }

        if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        return;
      } // Find current slide

      var stopIndex = 0;
      var groupSize = swiper.slidesSizesGrid[0];

      for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

        if (typeof slidesGrid[i + _increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + _increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      } // Find current slide size

      var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
          else swiper.slideTo(stopIndex);
        }

        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
          else swiper.slideTo(stopIndex);
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(stopIndex + increment);
          }

          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }

    function onResize$1() {
      var swiper = this;
      var params = swiper.params,
        el = swiper.el;
      if (el && el.offsetWidth === 0) return; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      } // Save locks

      var allowSlideNext = swiper.allowSlideNext,
        allowSlidePrev = swiper.allowSlidePrev,
        snapGrid = swiper.snapGrid; // Disable locks on resize

      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();

      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      } // Return locks after resize

      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;

      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }

    function onClick$1(e) {
      var swiper = this;
      if (!swiper.enabled) return;

      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();

        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }

    function onScroll$1() {
      var swiper = this;
      var wrapperEl = swiper.wrapperEl,
        rtlTranslate = swiper.rtlTranslate,
        enabled = swiper.enabled;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;

      if (swiper.isHorizontal()) {
        if (rtlTranslate) {
          swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
        } else {
          swiper.translate = -wrapperEl.scrollLeft;
        }
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      } // eslint-disable-next-line

      if (swiper.translate === -0) swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      var newProgress;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }

      swiper.emit('setTranslate', swiper.translate, false);
    }

    var dummyEventAttached$1 = false;

    function dummyEventListener$1() {}

    function attachEvents$1() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
        touchEvents = swiper.touchEvents,
        el = swiper.el,
        wrapperEl = swiper.wrapperEl,
        device = swiper.device,
        support = swiper.support;
      swiper.onTouchStart = onTouchStart$1.bind(swiper);
      swiper.onTouchMove = onTouchMove$1.bind(swiper);
      swiper.onTouchEnd = onTouchEnd$1.bind(swiper);

      if (params.cssMode) {
        swiper.onScroll = onScroll$1.bind(swiper);
      }

      swiper.onClick = onClick$1.bind(swiper);
      var capture = !!params.nested; // Touch Events

      if (!support.touch && support.pointerEvents) {
        el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
        document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (support.touch) {
          var passiveListener =
            touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners
              ? {
                  passive: true,
                  capture: false,
                }
              : false;
          el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          el.addEventListener(
            touchEvents.move,
            swiper.onTouchMove,
            support.passiveListener
              ? {
                  passive: false,
                  capture: capture,
                }
              : capture,
          );
          el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

          if (touchEvents.cancel) {
            el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
          }

          if (!dummyEventAttached$1) {
            document.addEventListener('touchstart', dummyEventListener$1);
            dummyEventAttached$1 = true;
          }
        }

        if ((params.simulateTouch && !device.ios && !device.android) || (params.simulateTouch && !support.touch && device.ios)) {
          el.addEventListener('mousedown', swiper.onTouchStart, false);
          document.addEventListener('mousemove', swiper.onTouchMove, capture);
          document.addEventListener('mouseup', swiper.onTouchEnd, false);
        }
      } // Prevent Links Clicks

      if (params.preventClicks || params.preventClicksPropagation) {
        el.addEventListener('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl.addEventListener('scroll', swiper.onScroll);
      } // Resize handler

      if (params.updateOnWindowResize) {
        swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize$1, true);
      } else {
        swiper.on('observerUpdate', onResize$1, true);
      }
    }

    function detachEvents$1() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
        touchEvents = swiper.touchEvents,
        el = swiper.el,
        wrapperEl = swiper.wrapperEl,
        device = swiper.device,
        support = swiper.support;
      var capture = !!params.nested; // Touch Events

      if (!support.touch && support.pointerEvents) {
        el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
        document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (support.touch) {
          var passiveListener =
            touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners
              ? {
                  passive: true,
                  capture: false,
                }
              : false;
          el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
          el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

          if (touchEvents.cancel) {
            el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
          }
        }

        if ((params.simulateTouch && !device.ios && !device.android) || (params.simulateTouch && !support.touch && device.ios)) {
          el.removeEventListener('mousedown', swiper.onTouchStart, false);
          document.removeEventListener('mousemove', swiper.onTouchMove, capture);
          document.removeEventListener('mouseup', swiper.onTouchEnd, false);
        }
      } // Prevent Links Clicks

      if (params.preventClicks || params.preventClicksPropagation) {
        el.removeEventListener('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl.removeEventListener('scroll', swiper.onScroll);
      } // Resize handler

      swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize$1);
    }

    var events$1 = {
      attachEvents: attachEvents$1,
      detachEvents: detachEvents$1,
    };

    function setBreakpoint$1() {
      var swiper = this;
      var activeIndex = swiper.activeIndex,
        initialized = swiper.initialized,
        _swiper$loopedSlides = swiper.loopedSlides,
        loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
        params = swiper.params,
        $el = swiper.$el;
      var breakpoints = params.breakpoints;
      if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return; // Get breakpoint for window width and update parameters

      var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

      if (breakpointOnlyParams) {
        ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
          var paramValue = breakpointOnlyParams[param];
          if (typeof paramValue === 'undefined') return;

          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
            breakpointOnlyParams[param] = 'auto';
          } else if (param === 'slidesPerView') {
            breakpointOnlyParams[param] = parseFloat(paramValue);
          } else {
            breakpointOnlyParams[param] = parseInt(paramValue, 10);
          }
        });
      }

      var breakpointParams = breakpointOnlyParams || swiper.originalParams;
      var wasMultiRow = params.slidesPerColumn > 1;
      var isMultiRow = breakpointParams.slidesPerColumn > 1;
      var wasEnabled = params.enabled;

      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(params.containerModifierClass + 'multirow ' + params.containerModifierClass + 'multirow-column');
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(params.containerModifierClass + 'multirow');

        if (
          (breakpointParams.slidesPerColumnFill && breakpointParams.slidesPerColumnFill === 'column') ||
          (!breakpointParams.slidesPerColumnFill && params.slidesPerColumnFill === 'column')
        ) {
          $el.addClass(params.containerModifierClass + 'multirow-column');
        }

        swiper.emitContainerClasses();
      }

      var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      extend$1(swiper.params, breakpointParams);
      var isEnabled = swiper.params.enabled;
      extend$1(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
      });

      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }

      swiper.currentBreakpoint = breakpoint;
      swiper.emit('_beforeBreakpoint', breakpointParams);

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }

    function getBreakpoint$1(breakpoints, base, containerEl) {
      if (base === void 0) {
        base = 'window';
      }

      if (!breakpoints || (base === 'container' && !containerEl)) return undefined;
      var breakpoint = false;
      var window = getWindow();
      var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
      var points = Object.keys(breakpoints).map(function (point) {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          var minRatio = parseFloat(point.substr(1));
          var value = currentHeight * minRatio;
          return {
            value: value,
            point: point,
          };
        }

        return {
          value: point,
          point: point,
        };
      });
      points.sort(function (a, b) {
        return parseInt(a.value, 10) - parseInt(b.value, 10);
      });

      for (var i = 0; i < points.length; i += 1) {
        var _points$i = points[i],
          point = _points$i.point,
          value = _points$i.value;

        if (base === 'window') {
          if (window.matchMedia('(min-width: ' + value + 'px)').matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }

      return breakpoint || 'max';
    }

    var breakpoints$1 = {
      setBreakpoint: setBreakpoint$1,
      getBreakpoint: getBreakpoint$1,
    };

    function prepareClasses(entries, prefix) {
      var resultClasses = [];
      entries.forEach(function (item) {
        if (typeof item === 'object') {
          Object.keys(item).forEach(function (classNames) {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === 'string') {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }

    function addClasses$1() {
      var swiper = this;
      var classNames = swiper.classNames,
      params = swiper.params,
      rtl = swiper.rtl,
      $el = swiper.$el,
      device = swiper.device,
      support = swiper.support; // prettier-ignore

      var suffixes = prepareClasses(
        [
          'initialized',
          params.direction,
          {
            'pointer-events': support.pointerEvents && !support.touch,
          },
          {
            'free-mode': params.freeMode,
          },
          {
            autoheight: params.autoHeight,
          },
          {
            rtl: rtl,
          },
          {
            multirow: params.slidesPerColumn > 1,
          },
          {
            'multirow-column': params.slidesPerColumn > 1 && params.slidesPerColumnFill === 'column',
          },
          {
            android: device.android,
          },
          {
            ios: device.ios,
          },
          {
            'css-mode': params.cssMode,
          },
        ],
        params.containerModifierClass,
      );
      classNames.push.apply(classNames, suffixes);
      $el.addClass([].concat(classNames).join(' '));
      swiper.emitContainerClasses();
    }

    function removeClasses$1() {
      var swiper = this;
      var $el = swiper.$el,
        classNames = swiper.classNames;
      $el.removeClass(classNames.join(' '));
      swiper.emitContainerClasses();
    }

    var classes$1 = {
      addClasses: addClasses$1,
      removeClasses: removeClasses$1,
    };

    function loadImage$1(imageEl, src, srcset, sizes, checkForComplete, callback) {
      var window = getWindow();
      var image;

      function onReady() {
        if (callback) callback();
      }

      var isPicture = $$1(imageEl).parent('picture')[0];

      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new window.Image();
          image.onload = onReady;
          image.onerror = onReady;

          if (sizes) {
            image.sizes = sizes;
          }

          if (srcset) {
            image.srcset = srcset;
          }

          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }

    function preloadImages$1() {
      var swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');

      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }

      for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
        var imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(
          imageEl,
          imageEl.currentSrc || imageEl.getAttribute('src'),
          imageEl.srcset || imageEl.getAttribute('srcset'),
          imageEl.sizes || imageEl.getAttribute('sizes'),
          true,
          onReady,
        );
      }
    }

    var images$1 = {
      loadImage: loadImage$1,
      preloadImages: preloadImages$1,
    };

    function checkOverflow$2() {
      var swiper = this;
      var params = swiper.params;
      var wasLocked = swiper.isLocked;
      var lastSlidePosition =
        swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

      if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
        swiper.isLocked = lastSlidePosition <= swiper.size;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }

      swiper.allowSlideNext = !swiper.isLocked;
      swiper.allowSlidePrev = !swiper.isLocked; // events

      if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
        if (swiper.navigation) swiper.navigation.update();
      }
    }

    var checkOverflow$3 = {
      checkOverflow: checkOverflow$2,
    };

    var defaults$1 = {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'container',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: false,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: 'input, select, option, textarea, button, video, label',
      // Overrides
      width: null,
      height: null,
      //
      preventInteractionOnTransition: false,
      // ssr
      userAgent: null,
      url: null,
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      // Free mode
      freeMode: false,
      freeModeMomentum: true,
      freeModeMomentumRatio: 1,
      freeModeMomentumBounce: true,
      freeModeMomentumBounceRatio: 1,
      freeModeMomentumVelocityRatio: 1,
      freeModeSticky: false,
      freeModeMinimumVelocity: 0.02,
      // Autoheight
      autoHeight: false,
      // Set wrapper width
      setWrapperSize: false,
      // Virtual Translate
      virtualTranslate: false,
      // Effects
      effect: 'slide',
      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
      // Breakpoints
      breakpoints: undefined,
      breakpointsBase: 'window',
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerColumn: 1,
      slidesPerColumnFill: 'column',
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      // in px
      slidesOffsetAfter: 0,
      // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: false,
      // Round length
      roundLengths: false,
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      // Unique Navigation Elements
      uniqueNavElements: true,
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
      // Progress
      watchSlidesProgress: false,
      watchSlidesVisibility: false,
      // Cursor
      grabCursor: false,
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      // Images
      preloadImages: true,
      updateOnImagesReady: true,
      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,
      // Passive Listeners
      passiveListeners: true,
      // NS
      containerModifierClass: 'swiper-container-',
      // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',
      // Callbacks
      runCallbacksOnInit: true,
      // Internals
      _emitClasses: false,
    };

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var prototypes$1 = {
      modular: modular,
      eventsEmitter: eventsEmitter,
      update: update$1,
      translate: translate$1,
      transition: transition$2,
      slide: slide$1,
      loop: loop$1,
      grabCursor: grabCursor$1,
      manipulation: manipulation$1,
      events: events$1,
      breakpoints: breakpoints$1,
      checkOverflow: checkOverflow$3,
      classes: classes$1,
      images: images$1,
    };
    var extendedDefaults$1 = {};

    var Swiper$1 = /*#__PURE__*/ (function () {
      function Swiper() {
        var el;
        var params;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
          params = args[0];
        } else {
          el = args[0];
          params = args[1];
        }

        if (!params) params = {};
        params = extend$1({}, params);
        if (el && !params.el) params.el = el;

        if (params.el && $$1(params.el).length > 1) {
          var swipers = [];
          $$1(params.el).each(function (containerEl) {
            var newParams = extend$1({}, params, {
              el: containerEl,
            });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        } // Swiper Instance

        var swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
          userAgent: params.userAgent,
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];

        if (typeof swiper.modules === 'undefined') {
          swiper.modules = {};
        }

        Object.keys(swiper.modules).forEach(function (moduleName) {
          var module = swiper.modules[moduleName];

          if (module.params) {
            var moduleParamName = Object.keys(module.params)[0];
            var moduleParams = module.params[moduleParamName];
            if (typeof moduleParams !== 'object' || moduleParams === null) return;

            if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
              params[moduleParamName] = {
                auto: true,
              };
            }

            if (!(moduleParamName in params && 'enabled' in moduleParams)) return;

            if (params[moduleParamName] === true) {
              params[moduleParamName] = {
                enabled: true,
              };
            }

            if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
              params[moduleParamName].enabled = true;
            }

            if (!params[moduleParamName])
              params[moduleParamName] = {
                enabled: false,
              };
          }
        }); // Extend defaults with modules params

        var swiperParams = extend$1({}, defaults$1);
        swiper.useParams(swiperParams); // Extend defaults with passed params

        swiper.params = extend$1({}, swiperParams, extendedDefaults$1, params);
        swiper.originalParams = extend$1({}, swiper.params);
        swiper.passedParams = extend$1({}, params); // add event listeners

        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach(function (eventName) {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }

        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        } // Save Dom lib

        swiper.$ = $$1; // Extend Swiper

        extend$1(swiper, {
          enabled: swiper.params.enabled,
          el: el,
          // Classes
          classNames: [],
          // Slides
          slides: $$1(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
          // isDirection
          isHorizontal: function isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },
          isVertical: function isVertical() {
            return swiper.params.direction === 'vertical';
          },
          // Indexes
          activeIndex: 0,
          realIndex: 0,
          //
          isBeginning: true,
          isEnd: false,
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
          // Touch Events
          touchEvents: (function touchEvents() {
            var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            var desktop = ['mousedown', 'mousemove', 'mouseup'];

            if (swiper.support.pointerEvents) {
              desktop = ['pointerdown', 'pointermove', 'pointerup'];
            }

            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3],
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2],
            };
            return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          })(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            focusableElements: swiper.params.focusableElements,
            // Last click time
            lastClickTime: now(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined,
          },
          // Clicks
          allowClick: true,
          // Touches
          allowTouchMove: swiper.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0,
          },
          // Images
          imagesToLoad: [],
          imagesLoaded: 0,
        }); // Install Modules

        swiper.useModules();
        swiper.emit('_swiper'); // Init

        if (swiper.params.init) {
          swiper.init();
        } // Return app instance

        return swiper;
      }

      var _proto = Swiper.prototype;

      _proto.enable = function enable() {
        var swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;

        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }

        swiper.emit('enable');
      };

      _proto.disable = function disable() {
        var swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;

        if (swiper.params.grabCursor) {
          swiper.unsetGrabCursor();
        }

        swiper.emit('disable');
      };

      _proto.setProgress = function setProgress(progress, speed) {
        var swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        var min = swiper.minTranslate();
        var max = swiper.maxTranslate();
        var current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      };

      _proto.emitContainerClasses = function emitContainerClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var classes = swiper.el.className.split(' ').filter(function (className) {
          return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit('_containerClasses', classes.join(' '));
      };

      _proto.getSlideClasses = function getSlideClasses(slideEl) {
        var swiper = this;
        return slideEl.className
          .split(' ')
          .filter(function (className) {
            return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
          })
          .join(' ');
      };

      _proto.emitSlidesClasses = function emitSlidesClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var updates = [];
        swiper.slides.each(function (slideEl) {
          var classNames = swiper.getSlideClasses(slideEl);
          updates.push({
            slideEl: slideEl,
            classNames: classNames,
          });
          swiper.emit('_slideClass', slideEl, classNames);
        });
        swiper.emit('_slideClasses', updates);
      };

      _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
        var swiper = this;
        var params = swiper.params,
          slides = swiper.slides,
          slidesGrid = swiper.slidesGrid,
          swiperSize = swiper.size,
          activeIndex = swiper.activeIndex;
        var spv = 1;

        if (params.centeredSlides) {
          var slideSize = slides[activeIndex].swiperSlideSize;
          var breakLoop;

          for (var i = activeIndex + 1; i < slides.length; i += 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }

          for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
            if (slides[_i] && !breakLoop) {
              slideSize += slides[_i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
        } else {
          for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
            if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
              spv += 1;
            }
          }
        }

        return spv;
      };

      _proto.update = function update() {
        var swiper = this;
        if (!swiper || swiper.destroyed) return;
        var snapGrid = swiper.snapGrid,
          params = swiper.params; // Breakpoints

        if (params.breakpoints) {
          swiper.setBreakpoint();
        }

        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        function setTranslate() {
          var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        var translated;

        if (swiper.params.freeMode) {
          setTranslate();

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }

          if (!translated) {
            setTranslate();
          }
        }

        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }

        swiper.emit('update');
      };

      _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
          needUpdate = true;
        }

        var swiper = this;
        var currentDirection = swiper.params.direction;

        if (!newDirection) {
          // eslint-disable-next-line
          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }

        if (newDirection === currentDirection || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
          return swiper;
        }

        swiper.$el.removeClass('' + swiper.params.containerModifierClass + currentDirection).addClass('' + swiper.params.containerModifierClass + newDirection);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each(function (slideEl) {
          if (newDirection === 'vertical') {
            slideEl.style.width = '';
          } else {
            slideEl.style.height = '';
          }
        });
        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();
        return swiper;
      };

      _proto.mount = function mount(el) {
        var swiper = this;
        if (swiper.mounted) return true; // Find el

        var $el = $$1(el || swiper.params.el);
        el = $el[0];

        if (!el) {
          return false;
        }

        el.swiper = swiper;

        var getWrapperSelector = function getWrapperSelector() {
          return '.' + (swiper.params.wrapperClass || '').trim().split(' ').join('.');
        };

        var getWrapper = function getWrapper() {
          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            var res = $$1(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

            res.children = function (options) {
              return $el.children(options);
            };

            return res;
          }

          return $el.children(getWrapperSelector());
        }; // Find Wrapper

        var $wrapperEl = getWrapper();

        if ($wrapperEl.length === 0 && swiper.params.createElements) {
          var document = getDocument();
          var wrapper = document.createElement('div');
          $wrapperEl = $$1(wrapper);
          wrapper.className = swiper.params.wrapperClass;
          $el.append(wrapper);
          $el.children('.' + swiper.params.slideClass).each(function (slideEl) {
            $wrapperEl.append(slideEl);
          });
        }

        extend$1(swiper, {
          $el: $el,
          el: el,
          $wrapperEl: $wrapperEl,
          wrapperEl: $wrapperEl[0],
          mounted: true,
          // RTL
          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
          wrongRTL: $wrapperEl.css('display') === '-webkit-box',
        });
        return true;
      };

      _proto.init = function init(el) {
        var swiper = this;
        if (swiper.initialized) return swiper;
        var mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit('beforeInit'); // Set breakpoint

        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        } // Add Classes

        swiper.addClasses(); // Create loop

        if (swiper.params.loop) {
          swiper.loopCreate();
        } // Update size

        swiper.updateSize(); // Update slides

        swiper.updateSlides();

        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        } // Set Grab Cursor

        if (swiper.params.grabCursor && swiper.enabled) {
          swiper.setGrabCursor();
        }

        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        } // Slide To Initial Slide

        if (swiper.params.loop) {
          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        } // Attach events

        swiper.attachEvents(); // Init Flag

        swiper.initialized = true; // Emit

        swiper.emit('init');
        swiper.emit('afterInit');
        return swiper;
      };

      _proto.destroy = function destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
          deleteInstance = true;
        }

        if (cleanStyles === void 0) {
          cleanStyles = true;
        }

        var swiper = this;
        var params = swiper.params,
          $el = swiper.$el,
          $wrapperEl = swiper.$wrapperEl,
          slides = swiper.slides;

        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
          return null;
        }

        swiper.emit('beforeDestroy'); // Init Flag

        swiper.initialized = false; // Detach events

        swiper.detachEvents(); // Destroy loop

        if (params.loop) {
          swiper.loopDestroy();
        } // Cleanup styles

        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr('style');
          $wrapperEl.removeAttr('style');

          if (slides && slides.length) {
            slides
              .removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' '))
              .removeAttr('style')
              .removeAttr('data-swiper-slide-index');
          }
        }

        swiper.emit('destroy'); // Detach emitter events

        Object.keys(swiper.eventsListeners).forEach(function (eventName) {
          swiper.off(eventName);
        });

        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          deleteProps(swiper);
        }

        swiper.destroyed = true;
        return null;
      };

      Swiper.extendDefaults = function extendDefaults(newDefaults) {
        extend$1(extendedDefaults$1, newDefaults);
      };

      Swiper.installModule = function installModule(module) {
        if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
        var name = module.name || Object.keys(Swiper.prototype.modules).length + '_' + now();
        Swiper.prototype.modules[name] = module;
      };

      Swiper.use = function use(module) {
        if (Array.isArray(module)) {
          module.forEach(function (m) {
            return Swiper.installModule(m);
          });
          return Swiper;
        }

        Swiper.installModule(module);
        return Swiper;
      };

      _createClass(Swiper, null, [
        {
          key: 'extendedDefaults',
          get: function get() {
            return extendedDefaults$1;
          },
        },
        {
          key: 'defaults',
          get: function get() {
            return defaults$1;
          },
        },
      ]);

      return Swiper;
    })();

    Object.keys(prototypes$1).forEach(function (prototypeGroup) {
      Object.keys(prototypes$1[prototypeGroup]).forEach(function (protoMethod) {
        Swiper$1.prototype[protoMethod] = prototypes$1[prototypeGroup][protoMethod];
      });
    });
    Swiper$1.use([Resize$1, Observer$3]);

    function _extends() {
      _extends =
        Object.assign ||
        function (target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
      return _extends.apply(this, arguments);
    }
    var Pagination$1 = {
      update: function update() {
        // Render || Update Pagination bullets/items
        var swiper = this;
        var rtl = swiper.rtl;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el; // Current/Total

        var current;
        var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        if (swiper.params.loop) {
          current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

          if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
            current -= slidesLength - swiper.loopedSlides * 2;
          }

          if (current > total - 1) current -= total;
          if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
        } else if (typeof swiper.snapIndex !== 'undefined') {
          current = swiper.snapIndex;
        } else {
          current = swiper.activeIndex || 0;
        } // Types

        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
          var bullets = swiper.pagination.bullets;
          var firstIndex;
          var lastIndex;
          var midIndex;

          if (params.dynamicBullets) {
            swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
            $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + 'px');

            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
              swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

              if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
                swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (swiper.pagination.dynamicBulletIndex < 0) {
                swiper.pagination.dynamicBulletIndex = 0;
              }
            }

            firstIndex = current - swiper.pagination.dynamicBulletIndex;
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }

          bullets.removeClass(
            params.bulletActiveClass +
              ' ' +
              params.bulletActiveClass +
              '-next ' +
              params.bulletActiveClass +
              '-next-next ' +
              params.bulletActiveClass +
              '-prev ' +
              params.bulletActiveClass +
              '-prev-prev ' +
              params.bulletActiveClass +
              '-main',
          );

          if ($el.length > 1) {
            bullets.each(function (bullet) {
              var $bullet = $$1(bullet);
              var bulletIndex = $bullet.index();

              if (bulletIndex === current) {
                $bullet.addClass(params.bulletActiveClass);
              }

              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  $bullet.addClass(params.bulletActiveClass + '-main');
                }

                if (bulletIndex === firstIndex) {
                  $bullet
                    .prev()
                    .addClass(params.bulletActiveClass + '-prev')
                    .prev()
                    .addClass(params.bulletActiveClass + '-prev-prev');
                }

                if (bulletIndex === lastIndex) {
                  $bullet
                    .next()
                    .addClass(params.bulletActiveClass + '-next')
                    .next()
                    .addClass(params.bulletActiveClass + '-next-next');
                }
              }
            });
          } else {
            var $bullet = bullets.eq(current);
            var bulletIndex = $bullet.index();
            $bullet.addClass(params.bulletActiveClass);

            if (params.dynamicBullets) {
              var $firstDisplayedBullet = bullets.eq(firstIndex);
              var $lastDisplayedBullet = bullets.eq(lastIndex);

              for (var i = firstIndex; i <= lastIndex; i += 1) {
                bullets.eq(i).addClass(params.bulletActiveClass + '-main');
              }

              if (swiper.params.loop) {
                if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                  for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {
                    bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + '-main');
                  }

                  bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + '-prev');
                } else {
                  $firstDisplayedBullet
                    .prev()
                    .addClass(params.bulletActiveClass + '-prev')
                    .prev()
                    .addClass(params.bulletActiveClass + '-prev-prev');
                  $lastDisplayedBullet
                    .next()
                    .addClass(params.bulletActiveClass + '-next')
                    .next()
                    .addClass(params.bulletActiveClass + '-next-next');
                }
              } else {
                $firstDisplayedBullet
                  .prev()
                  .addClass(params.bulletActiveClass + '-prev')
                  .prev()
                  .addClass(params.bulletActiveClass + '-prev-prev');
                $lastDisplayedBullet
                  .next()
                  .addClass(params.bulletActiveClass + '-next')
                  .next()
                  .addClass(params.bulletActiveClass + '-next-next');
              }
            }
          }

          if (params.dynamicBullets) {
            var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
            var offsetProp = rtl ? 'right' : 'left';
            bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + 'px');
          }
        }

        if (params.type === 'fraction') {
          $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
          $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }

        if (params.type === 'progressbar') {
          var progressbarDirection;

          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }

          var scale = (current + 1) / total;
          var scaleX = 1;
          var scaleY = 1;

          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }

          $el
            .find(classesToSelector(params.progressbarFillClass))
            .transform('translate3d(0,0,0) scaleX(' + scaleX + ') scaleY(' + scaleY + ')')
            .transition(swiper.params.speed);
        }

        if (params.type === 'custom' && params.renderCustom) {
          $el.html(params.renderCustom(swiper, current + 1, total));
          swiper.emit('paginationRender', $el[0]);
        } else {
          swiper.emit('paginationUpdate', $el[0]);
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      },
      render: function render() {
        // Render Container
        var swiper = this;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el;
        var paginationHTML = '';

        if (params.type === 'bullets') {
          var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

          if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {
            numberOfBullets = slidesLength;
          }

          for (var i = 0; i < numberOfBullets; i += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
            } else {
              paginationHTML += '<' + params.bulletElement + ' class="' + params.bulletClass + '"></' + params.bulletElement + '>';
            }
          }

          $el.html(paginationHTML);
          swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }

        if (params.type === 'fraction') {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
          } else {
            paginationHTML = '<span class="' + params.currentClass + '"></span>' + ' / ' + ('<span class="' + params.totalClass + '"></span>');
          }

          $el.html(paginationHTML);
        }

        if (params.type === 'progressbar') {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
          } else {
            paginationHTML = '<span class="' + params.progressbarFillClass + '"></span>';
          }

          $el.html(paginationHTML);
        }

        if (params.type !== 'custom') {
          swiper.emit('paginationRender', swiper.pagination.$el[0]);
        }
      },
      init: function init() {
        var swiper = this;
        swiper.params.pagination = createElementIfNotDefined(swiper.$el, swiper.params.pagination, swiper.params.createElements, {
          el: 'swiper-pagination',
        });
        var params = swiper.params.pagination;
        if (!params.el) return;
        var $el = $$1(params.el);
        if ($el.length === 0) return;

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
          $el = swiper.$el.find(params.el);
        }

        if (params.type === 'bullets' && params.clickable) {
          $el.addClass(params.clickableClass);
        }

        $el.addClass(params.modifierClass + params.type);

        if (params.type === 'bullets' && params.dynamicBullets) {
          $el.addClass('' + params.modifierClass + params.type + '-dynamic');
          swiper.pagination.dynamicBulletIndex = 0;

          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }

        if (params.type === 'progressbar' && params.progressbarOpposite) {
          $el.addClass(params.progressbarOppositeClass);
        }

        if (params.clickable) {
          $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
            e.preventDefault();
            var index = $$1(this).index() * swiper.params.slidesPerGroup;
            if (swiper.params.loop) index += swiper.loopedSlides;
            swiper.slideTo(index);
          });
        }

        extend$1(swiper.pagination, {
          $el: $el,
          el: $el[0],
        });

        if (!swiper.enabled) {
          $el.addClass(params.lockClass);
        }
      },
      destroy: function destroy() {
        var swiper = this;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var $el = swiper.pagination.$el;
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

        if (params.clickable) {
          $el.off('click', classesToSelector(params.bulletClass));
        }
      },
    };
    var Pagination$2 = {
      name: 'pagination',
      params: {
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: 'bullets',
          // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: function formatFractionCurrent(number) {
            return number;
          },
          formatFractionTotal: function formatFractionTotal(number) {
            return number;
          },
          bulletClass: 'swiper-pagination-bullet',
          bulletActiveClass: 'swiper-pagination-bullet-active',
          modifierClass: 'swiper-pagination-',
          // NEW
          currentClass: 'swiper-pagination-current',
          totalClass: 'swiper-pagination-total',
          hiddenClass: 'swiper-pagination-hidden',
          progressbarFillClass: 'swiper-pagination-progressbar-fill',
          progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
          clickableClass: 'swiper-pagination-clickable',
          // NEW
          lockClass: 'swiper-pagination-lock',
        },
      },
      create: function create() {
        var swiper = this;
        bindModuleMethods(swiper, {
          pagination: _extends(
            {
              dynamicBulletIndex: 0,
            },
            Pagination$1,
          ),
        });
      },
      on: {
        'init': function init(swiper) {
          swiper.pagination.init();
          swiper.pagination.render();
          swiper.pagination.update();
        },
        'activeIndexChange': function activeIndexChange(swiper) {
          if (swiper.params.loop) {
            swiper.pagination.update();
          } else if (typeof swiper.snapIndex === 'undefined') {
            swiper.pagination.update();
          }
        },
        'snapIndexChange': function snapIndexChange(swiper) {
          if (!swiper.params.loop) {
            swiper.pagination.update();
          }
        },
        'slidesLengthChange': function slidesLengthChange(swiper) {
          if (swiper.params.loop) {
            swiper.pagination.render();
            swiper.pagination.update();
          }
        },
        'snapGridLengthChange': function snapGridLengthChange(swiper) {
          if (!swiper.params.loop) {
            swiper.pagination.render();
            swiper.pagination.update();
          }
        },
        'destroy': function destroy(swiper) {
          swiper.pagination.destroy();
        },
        'enable disable': function enableDisable(swiper) {
          var $el = swiper.pagination.$el;

          if ($el) {
            $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
          }
        },
        'click': function click(swiper, e) {
          var targetEl = e.target;

          if (
            swiper.params.pagination.el &&
            swiper.params.pagination.hideOnClick &&
            swiper.pagination.$el.length > 0 &&
            !$$1(targetEl).hasClass(swiper.params.pagination.bulletClass)
          ) {
            if (swiper.navigation && ((swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl) || (swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)))
              return;
            var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);

            if (isHidden === true) {
              swiper.emit('paginationShow');
            } else {
              swiper.emit('paginationHide');
            }

            swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
          }
        },
      },
    };

    const ffspbWelcomeMaterialsComponentCss =
      'ffspb-welcome-materials{display:block}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper{margin-top:40px}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .materials-swiper-container{width:100%;padding:22%;position:relative}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .materials-swiper-container .materials-swiper{position:absolute;top:0;left:0;height:100%;width:100%;display:flex}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part{flex:0.1;height:100%;box-sizing:border-box;transition:flex 0.3s ease-in-out, transform 0.3s ease-in-out;background:linear-gradient(180deg, rgba(0, 0, 0, 0) 53.52%, rgba(0, 0, 0, 0.8) 100%);box-shadow:0px 0px 10px 10px rgba(0, 0, 0, 0.15);border-radius:5px;user-select:none}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part:not(:last-of-type){margin-right:10px}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part.selected{flex:1}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part.selected .text{transition:opacity 0.3s ease-in-out 0.4s}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part.selected img{transition:transform 0.1s ease-in-out 0.3s}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part:not(.selected) .text{opacity:0}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part:hover:not(.selected){transform:scaleX(1.05)}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part:after{display:block;content:" ";height:6px;width:100%;background:linear-gradient(180deg, #d4d4d4 -0.02%, #696969 220%);border-radius:0px 0px 5px 5px;margin-top:-3px}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner{width:100%;height:100%;box-sizing:border-box;position:relative;border-radius:5px;cursor:pointer}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner ftb-improving-img{display:block;position:absolute;height:100%;width:100%;top:0;left:0;overflow:hidden}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner ftb-improving-img img{height:100%;width:100%;object-fit:cover;object-position:center;border-radius:5px 5px 0 0;position:absolute;top:0;left:0}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner .title{height:100%;width:100%;background:linear-gradient(180deg, rgba(0, 0, 0, 0) 30%, rgba(0, 0, 0, 0.8) 100%);position:absolute;top:0;left:0;overflow:hidden}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner .title .text{position:absolute;left:30px;bottom:40px;width:calc(100% - 60px)}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner .title .text h3{font-size:30px;color:white;line-height:36px;text-transform:uppercase;font-weight:700;max-width:360px}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner .title .text .description{font-size:16px;line-height:19px;color:#adadad;max-width:360px;transition:transform 0.3s ease-in-out}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner .title .text button{position:absolute;bottom:0;right:0}@media only screen and (max-width: 1200px){ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner .title h3{font-size:28px}}@media only screen and (max-width: 1100px){ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner .title h3{font-size:26px}}@media only screen and (max-width: 1000px){ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner .title h3{font-size:24px}ffspb-welcome-materials .ffspb-welcome-materials__desktop-wrapper .block-inner .part .part-inner .title .description{font-size:14px}}ffspb-welcome-materials .mobile-wrapper button.control{position:absolute;top:74px;z-index:10000;background:transparent}ffspb-welcome-materials .mobile-wrapper button.control ftb-icon{height:15px;fill:white}ffspb-welcome-materials .mobile-wrapper button.control.left{left:-30px;transform:rotate(90deg)}ffspb-welcome-materials .mobile-wrapper button.control.right{right:-30px;transform:rotate(-90deg)}ffspb-welcome-materials .mobile-wrapper .carousel{display:flex}ffspb-welcome-materials .mobile-wrapper .swiper-container .swiper-slide{position:relative;height:227px !important}ffspb-welcome-materials .mobile-wrapper .swiper-container .swiper-slide img{position:absolute;top:0;left:0;width:100vw !important;height:227px !important;object-fit:cover;object-position:center}ffspb-welcome-materials .mobile-wrapper .swiper-container .swiper-slide .title{height:100%;width:100%;background:linear-gradient(to bottom, transparent, black);padding-top:50px;position:absolute;top:0;left:0;overflow:hidden}ffspb-welcome-materials .mobile-wrapper .swiper-container .swiper-slide .title h3{font-size:16px;line-height:19px;text-transform:uppercase;color:#ffffff;text-align:center;width:100%;position:absolute;left:0;bottom:5px;font-weight:700}ffspb-welcome-materials .mobile-wrapper .description{background:linear-gradient(95.57deg, #333333 0%, #2f2f2f 51.35%, #333333 100%);padding:40px 22px}ffspb-welcome-materials .mobile-wrapper .description h3{margin:0;padding:0;width:100%;text-align:left !important;font-size:16px;line-height:19px;text-transform:uppercase;color:white;font-weight:700}ffspb-welcome-materials .mobile-wrapper .description p{padding:10px 0;font-size:16px;line-height:19px;color:#adadad;text-align:left;height:57px}ffspb-welcome-materials .mobile-wrapper .description button{margin-top:25px}ffspb-welcome-materials .mobile-wrapper .swiper-pagination{bottom:0;height:50px;text-align:right;padding-right:22px}ffspb-welcome-materials .mobile-wrapper .swiper-pagination .swiper-pagination-bullet{width:40px;padding:0 !important;height:40px;margin-left:10px;background:transparent !important;border:none;box-shadow:none}ffspb-welcome-materials .mobile-wrapper .swiper-pagination .swiper-pagination-bullet .underscore{height:3px;margin-top:3px;background:#4e4e4e;border-radius:15px;width:100%}ffspb-welcome-materials .mobile-wrapper .swiper-pagination .swiper-pagination-bullet.swiper-pagination-bullet-active .underscore{background:linear-gradient(to bottom, #d4d4d4, #696969 200%)}';

    Swiper$1.use([Pagination$2]);
    class FfspbWelcomeMaterials {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.selectedIdx = 0;
        this.autoSlideDisabled$ = new AsyncSubject();
        this.materials = [
          {
            _id: 1,
            title: 'Приём заявок на участие в соревнованиях по футболу',
            description: 'Заявки принимаются на Зимнее Первенство среди мужских и молодежных команд, а также на Зимние Первенства среди юношеских команд 2006, 2007 и 2008 г.р.',
          },
          { _id: 2, title: 'Второй заголовок', description: 'Второй подзаголовок' },
          { _id: 3, title: 'Третий заголовок', description: 'Третий подзаголовок' },
          { _id: 4, title: 'Четвёртый заголовок', description: 'Четвёртый подзаголовок' },
        ];
      }
      componentWillLoad() {
        interval(10000)
          .pipe(takeUntil(this.autoSlideDisabled$))
          .subscribe(() => {
            this.selectedIdx = this.selectedIdx == this.materials.length - 1 ? 0 : this.selectedIdx + 1;
          });
      }
      componentDidRender() {
        var _a;
        if (!this.swiper && this.swiperRootEl) {
          const autoSlideDisabled$ = this.autoSlideDisabled$;
          (_a = this.swiper) !== null && _a !== void 0
            ? _a
            : (this.swiper = new Swiper$1(this.swiperRootEl, {
                pagination: {
                  el: '.swiper-pagination',
                  clickable: true,
                  renderBullet: (_, className) => `<button class="${className}"><div class="underscore"/></button>`,
                },
                onAny(eventName) {
                  if ('slideChange' == eventName + '') {
                    autoSlideDisabled$.next(true);
                    autoSlideDisabled$.complete();
                  }
                },
                loop: true,
              }));
        }
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      selectPart(idx) {
        this.autoSlideDisabled$.next(true);
        this.autoSlideDisabled$.complete();
        this.selectedIdx = idx;
      }
      renderDesktop() {
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'ffspb-welcome-materials__desktop-wrapper' },
            hAsync(
              'div',
              { class: 'block' },
              hAsync(
                'div',
                { class: 'block-inner' },
                hAsync(
                  'div',
                  { class: 'materials-swiper-container' },
                  hAsync(
                    'div',
                    { class: 'materials-swiper' },
                    this.materials.map((m, idx) =>
                      hAsync(
                        'div',
                        { class: 'part ' + (idx == this.selectedIdx ? ' selected' : ''), onClick: () => this.selectPart(idx) },
                        hAsync(
                          'div',
                          { class: 'part-inner' },
                          hAsync('ftb-improving-img', {
                            sources: [`/assets/demo/img/materials/${idx}-micro.jpg`, `/assets/demo/img/materials/${idx}-min.jpg`, `/assets/demo/img/materials/${idx}-big.jpg`],
                          }),
                          hAsync(
                            'div',
                            { class: 'title' },
                            hAsync(
                              'div',
                              { class: 'text' },
                              hAsync('h3', null, m.title),
                              hAsync('div', { class: 'description' }, m.description),
                              hAsync('button', { class: 'outline' }, '\u041F\u043E\u0434\u0440\u043E\u0431\u043D\u0435\u0435'),
                            ),
                          ),
                        ),
                      ),
                    ),
                  ),
                ),
              ),
            ),
          ),
        );
      }
      renderMobile() {
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'mobile-wrapper' },
            hAsync(
              'div',
              { class: 'swiper-container', ref: el => (this.swiperRootEl = el) },
              hAsync(
                'div',
                { class: 'swiper-wrapper' },
                this.materials.map((m, idx) =>
                  hAsync(
                    'div',
                    { class: 'swiper-slide' },
                    hAsync('img', { src: `/assets/demo/img/materials/${idx}-micro.jpg` }),
                    hAsync('div', { class: 'title' }, hAsync('h3', null, m.title)),
                  ),
                ),
              ),
              hAsync('div', { class: 'swiper-pagination' }),
            ),
          ),
        );
      }
      slideLeft() {
        this.selectedIdx = this.selectedIdx == 0 ? this.materials.length - 1 : this.selectedIdx - 1;
        this.autoSlideDisabled$.next(true);
        this.autoSlideDisabled$.complete();
      }
      slideRight() {
        this.selectedIdx = this.selectedIdx == this.materials.length - 1 ? 0 : this.selectedIdx + 1;
        this.autoSlideDisabled$.next(true);
        this.autoSlideDisabled$.complete();
      }
      static get style() {
        return ffspbWelcomeMaterialsComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-welcome-materials',
          $members$: {
            selectedIdx: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbWelcomeNewsComponentCss =
      'ffspb-welcome-news{display:block}ffspb-welcome-news .desktop-wrapper{margin-top:80px;text-align:center}ffspb-welcome-news .desktop-wrapper h2{text-align:left;margin-bottom:0}ffspb-welcome-news .desktop-wrapper .news-lines{width:100%;display:flex;justify-content:space-between;margin-top:40px}ffspb-welcome-news .desktop-wrapper .news-lines .post-content{flex:1;display:flex;flex-direction:column;cursor:pointer;box-shadow:0 0 3px 3px rgba(0, 0, 0, 0.1);border-radius:15px}ffspb-welcome-news .desktop-wrapper .news-lines .post-content:nth-of-type(2){margin:0 15px}ffspb-welcome-news .desktop-wrapper .news-lines .post-content .img-container{width:100%;padding:24.4%;position:relative}ffspb-welcome-news .desktop-wrapper .news-lines .post-content .img-container ftb-improving-img{position:absolute;top:0;left:0;height:100%;width:100%;object-fit:cover;object-position:center;border-radius:15px 15px 0 0;overflow:hidden}ffspb-welcome-news .desktop-wrapper .news-lines .post-content .img-container ftb-improving-img img{border-radius:15px 15px 0 0;object-fit:cover;object-position:center;transition:all 0.3s ease-in-out}ffspb-welcome-news .desktop-wrapper .news-lines .post-content .delimiter{background:linear-gradient(180deg, #d4d4d4 -0.02%, #696969 220%);height:3px;width:100%}ffspb-welcome-news .desktop-wrapper .news-lines .post-content .post-text{display:flex;align-items:center;justify-content:stretch;flex-direction:column;height:min-content;background:#2e2e2e;border-radius:0 0 15px 15px;padding:0 25px;flex:1}ffspb-welcome-news .desktop-wrapper .news-lines .post-content .post-text .date{color:#adadad;font-size:14px;line-height:17px;font-weight:700;width:100%;margin-top:25px;display:flex;align-items:center;justify-content:space-between}ffspb-welcome-news .desktop-wrapper .news-lines .post-content .post-text .title{margin-top:20px;font-weight:700;color:white;font-size:18px;line-height:22px;text-align:left;width:100%}ffspb-welcome-news .desktop-wrapper .news-lines .post-content .post-text .description{margin-top:15px;font-size:16px;line-height:19px;color:#adadad;text-align:left;margin-bottom:44px}@media only screen and (max-width: 1200px){ffspb-welcome-news .desktop-wrapper .news-lines .post-content .title{font-size:17px}}@media only screen and (max-width: 1100px){ffspb-welcome-news .desktop-wrapper .news-lines .post-content .title{font-size:16px}}ffspb-welcome-news .desktop-wrapper .news-lines .post-content:hover img{transform:scale(1.03)}@media only screen and (max-width: 1000px){ffspb-welcome-news .desktop-wrapper .post-content{box-shadow:none !important}ffspb-welcome-news .desktop-wrapper .post-content:hover .title{text-decoration:underline}ffspb-welcome-news .desktop-wrapper .delimiter{display:none}ffspb-welcome-news .desktop-wrapper .img-container{padding:27% !important}ffspb-welcome-news .desktop-wrapper ftb-improving-img{border-radius:15px !important}ffspb-welcome-news .desktop-wrapper ftb-improving-img img{border-radius:15px !important}ffspb-welcome-news .desktop-wrapper .post-text{background:transparent !important;padding:0 !important}ffspb-welcome-news .desktop-wrapper .post-text .title{font-size:15px}ffspb-welcome-news .desktop-wrapper .post-text .description{display:none}}ffspb-welcome-news .desktop-wrapper .button-line{max-width:var(--content-width);text-align:right;margin:0 auto;margin-top:40px}ffspb-welcome-news .mobile-wrapper{margin-top:10px}ffspb-welcome-news .mobile-wrapper h2{margin-top:20px;margin-left:22px}ffspb-welcome-news .mobile-wrapper .news-list{margin-top:20px}ffspb-welcome-news .mobile-wrapper .news-list .post{display:flex;align-items:center;margin-bottom:30px;padding:0 22px;position:relative}ffspb-welcome-news .mobile-wrapper .news-list .post ftb-improving-img{margin-right:20px;filter:drop-shadow(0px 0px 10px rgba(0, 0, 0, 0.15));height:80px;min-width:110px;width:110px;position:relative}ffspb-welcome-news .mobile-wrapper .news-list .post img{position:absolute;top:0;left:0;height:80px;width:110px;border-radius:5px;object-position:center;object-fit:cover}ffspb-welcome-news .mobile-wrapper .news-list .post .info{height:min-content}ffspb-welcome-news .mobile-wrapper .news-list .post .info .date{color:#adadad;font-size:14px;line-height:17px;flex:1;display:flex;align-items:center}ffspb-welcome-news .mobile-wrapper .news-list .post .info .title{flex:1;font-weight:700;color:white;font-size:15px;line-height:19px}ffspb-welcome-news .mobile-wrapper .news-list .post:not(:last-of-type):after{display:block;content:" ";height:1px;background:#616161;width:calc(100% - 44px);margin-left:22px;position:absolute;bottom:-15px;left:0}ffspb-welcome-news .mobile-wrapper .button-line{padding:0 22px;margin-top:-20px}ffspb-welcome-news .mobile-wrapper .button-line button{margin-top:20px;width:100%}';

    class FfspbWelcomeNews {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.news = [
          {
            _id: 1,
            date: 123456,
            title: 'Спортсмен и депутат Николай Валуев посетил матчи Премиум Бизнес Лиги',
            // description: 'Чемпион мира по боксу поделился впечатлениями о новом турнире ФФСПб, а также рассказал о важности развития корпоративного спорта',
            description: 'Чемпион мира по боксу поделился впечатлениями о новом турнире ФФСПб...',
          },
          {
            _id: 2,
            date: 123456,
            title: 'Петербургский "Кристалл" завоевал Кубок России по пляжному футболу 2021',
            description: 'Это уже 6-я победа команды из Северной столицы в турнире',
          },
          {
            _id: 3,
            date: 123456,
            title: 'Федерация Футбола Санкт-Петербурга поздравляет Юрия Павловича Лукосяка с юбилеем!',
            description: 'Известный спортивный журналист отмечает сегодня 75-летие',
          },
        ];
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'desktop-wrapper' },
            hAsync(
              'div',
              { class: 'block' },
              hAsync(
                'div',
                { class: 'block-inner' },
                hAsync('h2', null, '\u041D\u043E\u0432\u043E\u0441\u0442\u0438'),
                hAsync(
                  'div',
                  { class: 'news-lines' },
                  this.news.map(p =>
                    hAsync(
                      'ion-router-link',
                      { href: dist.buildRoute(routes.post, { postId: p._id, postTitle: p.title }) },
                      hAsync(
                        'div',
                        { class: 'post-content' },
                        hAsync('div', { class: 'img-container' }, hAsync('ftb-improving-img', { sources: [`/assets/demo/img/news/${p._id}.png`] })),
                        hAsync('div', { class: 'delimiter' }),
                        hAsync(
                          'div',
                          { class: 'post-text' },
                          hAsync('div', { class: 'date' }, '30 \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F 2021'),
                          hAsync('div', { class: 'title' }, p.title),
                          hAsync('div', { class: 'description' }, p.description),
                        ),
                      ),
                    ),
                  ),
                ),
                hAsync('div', { class: 'button-line' }, hAsync('button', { class: 'steel' }, '\u0412\u0441\u0435 \u043D\u043E\u0432\u043E\u0441\u0442\u0438')),
              ),
            ),
          ),
        );
      }
      renderMobile() {
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'mobile-wrapper' },
            hAsync('h2', null, '\u041D\u043E\u0432\u043E\u0441\u0442\u0438'),
            hAsync(
              'div',
              { class: 'news-list' },
              this.news
                .slice(0, 3)
                .map(p =>
                  hAsync(
                    'div',
                    { class: 'post' },
                    hAsync('ftb-improving-img', { sources: [`/assets/demo/img/news/${p._id}.png`] }),
                    hAsync(
                      'div',
                      { class: 'info' },
                      hAsync('div', { class: 'date' }, '30 \u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F 2021'),
                      hAsync('div', { class: 'title' }, p.title),
                    ),
                  ),
                ),
            ),
            hAsync('div', { class: 'button-line' }, hAsync('button', { class: 'steel' }, '\u0412\u0441\u0435 \u043D\u043E\u0432\u043E\u0441\u0442\u0438')),
          ),
        );
      }
      static get style() {
        return ffspbWelcomeNewsComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-welcome-news',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbWelcomePageComponentCss =
      'ffspb-welcome-page {\n  /* Auto Height */\n  /* 3D Effects */\n  /* CSS Mode */\n  display: block;\n}\n@font-face {\n  ffspb-welcome-page {\n    font-family: "swiper-icons";\n    src: url("data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA") format("woff");\n    font-weight: 400;\n    font-style: normal;\n  }\n}\nffspb-welcome-page :root {\n  --swiper-theme-color: #007aff;\n}\nffspb-welcome-page .swiper-container {\n  margin-left: auto;\n  margin-right: auto;\n  position: relative;\n  overflow: hidden;\n  list-style: none;\n  padding: 0;\n  /* Fix of Webkit flickering */\n  z-index: 1;\n}\nffspb-welcome-page .swiper-container-vertical > .swiper-wrapper {\n  flex-direction: column;\n}\nffspb-welcome-page .swiper-wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  display: flex;\n  transition-property: transform;\n  box-sizing: content-box;\n}\nffspb-welcome-page .swiper-container-android .swiper-slide,\nffspb-welcome-page .swiper-wrapper {\n  transform: translate3d(0px, 0, 0);\n}\nffspb-welcome-page .swiper-container-multirow > .swiper-wrapper {\n  flex-wrap: wrap;\n}\nffspb-welcome-page .swiper-container-multirow-column > .swiper-wrapper {\n  flex-wrap: wrap;\n  flex-direction: column;\n}\nffspb-welcome-page .swiper-container-free-mode > .swiper-wrapper {\n  transition-timing-function: ease-out;\n  margin: 0 auto;\n}\nffspb-welcome-page .swiper-container-pointer-events {\n  touch-action: pan-y;\n}\nffspb-welcome-page .swiper-container-pointer-events.swiper-container-vertical {\n  touch-action: pan-x;\n}\nffspb-welcome-page .swiper-slide {\n  flex-shrink: 0;\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transition-property: transform;\n}\nffspb-welcome-page .swiper-slide-invisible-blank {\n  visibility: hidden;\n}\nffspb-welcome-page .swiper-container-autoheight,\nffspb-welcome-page .swiper-container-autoheight .swiper-slide {\n  height: auto;\n}\nffspb-welcome-page .swiper-container-autoheight .swiper-wrapper {\n  align-items: flex-start;\n  transition-property: transform, height;\n}\nffspb-welcome-page .swiper-container-3d {\n  perspective: 1200px;\n}\nffspb-welcome-page .swiper-container-3d .swiper-wrapper,\nffspb-welcome-page .swiper-container-3d .swiper-slide,\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-left,\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-right,\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-top,\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-bottom,\nffspb-welcome-page .swiper-container-3d .swiper-cube-shadow {\n  transform-style: preserve-3d;\n}\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-left,\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-right,\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-top,\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-bottom {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 10;\n}\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-left {\n  background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-right {\n  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-top {\n  background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\nffspb-welcome-page .swiper-container-3d .swiper-slide-shadow-bottom {\n  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\nffspb-welcome-page .swiper-container-css-mode > .swiper-wrapper {\n  overflow: auto;\n  scrollbar-width: none;\n  /* For Firefox */\n  -ms-overflow-style: none;\n  /* For Internet Explorer and Edge */\n}\nffspb-welcome-page .swiper-container-css-mode > .swiper-wrapper::-webkit-scrollbar {\n  display: none;\n}\nffspb-welcome-page .swiper-container-css-mode > .swiper-wrapper > .swiper-slide {\n  scroll-snap-align: start start;\n}\nffspb-welcome-page .swiper-container-horizontal.swiper-container-css-mode > .swiper-wrapper {\n  scroll-snap-type: x mandatory;\n}\nffspb-welcome-page .swiper-container-vertical.swiper-container-css-mode > .swiper-wrapper {\n  scroll-snap-type: y mandatory;\n}\nffspb-welcome-page ffspb-content {\n  background: #414141;\n  min-height: 100%;\n}\nffspb-welcome-page .block {\n  width: 100%;\n  max-width: calc(var(--content-width) + 80px);\n  min-width: 800px;\n  margin: 0 auto;\n  padding: 0 40px;\n}\nffspb-welcome-page .block .block-inner {\n  width: 100%;\n  max-width: calc(var(--content-width));\n}';

    class FfspbWelcomePage {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(
          Host,
          null,
          hAsync('ffspb-header', null),
          hAsync(
            'ffspb-content',
            null,
            hAsync('ffspb-welcome-materials', null),
            hAsync('ffspb-welcome-news', null),
            hAsync('ffspb-welcome-tournaments', null),
            hAsync('ffspb-welcome-banners', null),
            hAsync('ffspb-welcome-partners', null),
            hAsync('ffspb-footer', null),
          ),
        );
      }
      renderMobile() {
        return [
          hAsync('ffspb-header', null),
          hAsync(
            'ion-content',
            null,
            hAsync('ffspb-welcome-materials', null),
            hAsync('ffspb-welcome-news', null),
            hAsync('ffspb-welcome-tournaments', null),
            hAsync('ffspb-welcome-banners', null),
            hAsync('ffspb-welcome-partners', null),
            hAsync('ffspb-footer', null),
          ),
        ];
      }
      static get style() {
        return ffspbWelcomePageComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-welcome-page',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbWelcomePartnersComponentCss =
      'ffspb-welcome-partners .desktop-wrapper{display:block;margin-top:60px}ffspb-welcome-partners .desktop-wrapper .swiper-slide{text-align:center;display:-webkit-box;display:-ms-flexbox;display:-webkit-flex;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-justify-content:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;-webkit-align-items:center;align-items:center}ffspb-welcome-partners .desktop-wrapper .partners-line{margin-top:40px;height:166px;background:#515151;box-shadow:inset 0px 0px 15px rgba(0, 0, 0, 0.15);text-align:center}ffspb-welcome-partners .desktop-wrapper .partners-line .partner{display:block;opacity:0.8;margin-top:38px;width:fit-content}ffspb-welcome-partners .desktop-wrapper .partners-line .partner:hover{opacity:1}ffspb-welcome-partners .desktop-wrapper .partners-line .partner img{height:90px;margin:0 40px}@media only screen and (max-width: 1200px){ffspb-welcome-partners .desktop-wrapper .partners-line{height:146px}ffspb-welcome-partners .desktop-wrapper .partner{margin-top:33px !important}ffspb-welcome-partners .desktop-wrapper img{height:80px !important;margin:0 30px !important}}@media only screen and (max-width: 1000px){ffspb-welcome-partners .desktop-wrapper .partners-line{height:126px}ffspb-welcome-partners .desktop-wrapper .partner{margin-top:28px !important}ffspb-welcome-partners .desktop-wrapper img{height:70px !important;margin:0 20px !important}}ffspb-welcome-partners .mobile-wrapper{margin-top:40px}ffspb-welcome-partners .mobile-wrapper h2{text-align:left;margin-bottom:0}ffspb-welcome-partners .mobile-wrapper .partners-line{margin-top:20px;background:#515151;box-shadow:inset 0px 0px 15px rgba(0, 0, 0, 0.15);text-align:center;display:flex;align-items:center;flex-wrap:wrap;justify-content:center}ffspb-welcome-partners .mobile-wrapper .partners-line .partner{display:inline-block;height:60px;margin:20px 0}ffspb-welcome-partners .mobile-wrapper .partners-line .partner img{height:60px;margin:0 20px}';

    class FfspbWelcomePartners {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.partners = [
          { link: 'https://kfis.gov.spb.ru/', _id: 1, title: 'Комитет по физической культуре и спорту' },
          { link: 'https://www.radiozenit.ru/', _id: 2, title: 'Радио Зенит' },
          { link: 'https://rfs.ru/', _id: 3, title: 'Российский футбольный союз' },
        ];
      }
      componentDidRender() {
        var _a;
        if (!this.swiper && this.swiperRootEl) {
          (_a = this.swiper) !== null && _a !== void 0
            ? _a
            : (this.swiper = new Swiper$1(this.swiperRootEl, {
                slidesPerView: 'auto',
                spaceBetween: 30,
                loop: true,
              }));
          setInterval(() => {
            this.swiper.slideNext();
          }, 3000);
        }
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        const partners = [];
        while (partners.length < 24) {
          partners.push(...this.partners);
        }
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'desktop-wrapper' },
            hAsync('div', { class: 'block' }, hAsync('div', { class: 'block-inner' }, hAsync('h2', null, '\u041F\u0430\u0440\u0442\u043D\u0451\u0440\u044B'))),
            hAsync(
              'div',
              { class: 'partners-line swiper-container', ref: el => (this.swiperRootEl = el) },
              hAsync(
                'div',
                { class: 'swiper-wrapper' },
                partners.map(p => hAsync('a', { href: p.link, title: p.title, class: 'partner swiper-slide' }, hAsync('img', { src: `/assets/demo/img/partners/${p._id}.png` }))),
              ),
            ),
          ),
        );
      }
      renderMobile() {
        const partners = this.partners;
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'mobile-wrapper' },
            hAsync('h2', null, '\u041F\u0430\u0440\u0442\u043D\u0451\u0440\u044B'),
            hAsync(
              'div',
              { class: 'partners-line' },
              partners.map(p => hAsync('a', { href: p.link, title: p.title, class: 'partner' }, hAsync('img', { src: `/assets/demo/img/partners/${p._id}.png` }))),
            ),
          ),
        );
      }
      static get style() {
        return ffspbWelcomePartnersComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-welcome-partners',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ffspbWelcomeTournamentsComponentCss =
      'ffspb-welcome-tournaments .card{width:100%;max-width:1540px;min-width:800px;margin:0 auto;padding:0 40px;margin-top:60px}ffspb-welcome-tournaments .card .card-inner{width:100%;box-sizing:border-box;padding:13.3%;border-radius:15px;display:flex;position:relative}ffspb-welcome-tournaments .card .card-inner .card-contents{position:absolute;top:0;left:0;height:100%;width:100%;display:flex;border-radius:15px;box-shadow:0px 0px 10px 10px rgba(0, 0, 0, 0.15)}ffspb-welcome-tournaments .card .card-inner .card-contents .left{border-radius:15px 0 0 15px;flex:0.5}ffspb-welcome-tournaments .card .card-inner .card-contents .center{flex:1;background:linear-gradient(123.57deg, #272727 2.34%, #474747 50.65%, #272727 100%);padding:3%;display:flex;flex-direction:column}ffspb-welcome-tournaments .card .card-inner .card-contents .center .text{flex:1}ffspb-welcome-tournaments .card .card-inner .card-contents .center .text h3{color:white;font-weight:700;font-size:30px;line-height:36px;text-transform:uppercase;margin-bottom:10px;margin-top:0;width:250px}ffspb-welcome-tournaments .card .card-inner .card-contents .center .text .description{font-weight:normal;font-size:16px;line-height:19px;color:#adadad;width:250px}@media only screen and (max-width: 1150px){ffspb-welcome-tournaments .card .card-inner .card-contents .center h3{font-size:26px !important}ffspb-welcome-tournaments .card .card-inner .card-contents .center .description{font-size:14px !important}}ffspb-welcome-tournaments .card .card-inner .card-contents .center .button-row{text-align:right}ffspb-welcome-tournaments .card .card-inner .card-contents .right{border-radius:0 15px 15px 0;flex:0.5}ffspb-welcome-tournaments .mobile-wrapper{margin-top:40px;padding:0 22px}ffspb-welcome-tournaments .mobile-wrapper .tournaments-card{box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);position:relative;display:flex;flex-direction:column}ffspb-welcome-tournaments .mobile-wrapper .tournaments-card:before{display:block;content:" ";background:linear-gradient(180deg, #d4d4d4 -0.02%, #696969 220%);border-radius:0px 0px 5px 5px;transform:matrix(1, 0, 0, -1, 0, 0);width:100%;height:5px;position:absolute;top:0;left:0}ffspb-welcome-tournaments .mobile-wrapper .tournaments-card:after{display:block;content:" ";background:linear-gradient(180deg, #d4d4d4 -0.02%, #696969 220%);border-radius:0px 0px 5px 5px;width:100%;height:5px;position:absolute;bottom:0;left:0}ffspb-welcome-tournaments .mobile-wrapper .tournaments-card img{width:100%;height:250px;object-fit:cover;object-position:center}ffspb-welcome-tournaments .mobile-wrapper .tournaments-card .center{display:block;background:linear-gradient(123.57deg, #272727 2.34%, #474747 50.65%, #272727 100%);text-align:center;padding-top:38px;padding-bottom:43px}ffspb-welcome-tournaments .mobile-wrapper .tournaments-card .center h3{color:white;font-weight:700;font-size:18px;line-height:22px;text-transform:uppercase;margin-bottom:20px}ffspb-welcome-tournaments .mobile-wrapper .tournaments-card .center .description{font-weight:normal;font-size:16px;line-height:19px;color:#adadad;margin-bottom:28px}';

    class FfspbWelcomeTournaments {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return dist.envState.platform == 'web' ? this.renderDesktop() : this.renderMobile();
      }
      renderDesktop() {
        return hAsync(
          Host,
          null,
          hAsync(
            'div',
            { class: 'card' },
            hAsync(
              'div',
              { class: 'card-inner' },
              hAsync(
                'div',
                { class: 'card-contents' },
                hAsync('img', { class: 'left', src: '/assets/demo/img/tournaments/0.jpg' }),
                hAsync(
                  'div',
                  { class: 'center' },
                  hAsync(
                    'div',
                    { class: 'text' },
                    hAsync('h3', null, '\u0422\u0443\u0440\u043D\u0438\u0440\u043D\u0430\u044F \u0441\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0430'),
                    hAsync(
                      'div',
                      { class: 'description' },
                      '\u0414\u043B\u044F \u0442\u0435\u0445, \u043A\u0442\u043E \u0445\u043E\u0447\u0435\u0442 \u043E\u0431\u043B\u0430\u0434\u0430\u0442\u044C \u0432\u0441\u0435\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0435\u0439 \u043E \u043F\u0440\u043E\u0448\u0435\u0434\u0448\u0438\u0445 \u0438 \u043F\u0440\u0435\u0434\u0441\u0442\u043E\u044F\u0448\u0438\u0445 \u0442\u0443\u0440\u043D\u0438\u0440\u0430\u0445',
                    ),
                  ),
                  hAsync('div', { class: 'button-row' }, hAsync('button', { class: 'outline' }, '\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C')),
                ),
                hAsync('img', { class: 'right', src: '/assets/demo/img/tournaments/1.jpg' }),
              ),
            ),
          ),
        );
      }
      renderMobile() {
        return hAsync(
          'div',
          { class: 'mobile-wrapper' },
          hAsync(
            'div',
            { class: 'tournaments-card' },
            hAsync('img', { src: '/assets/demo/img/tournaments/2.jpg' }),
            hAsync(
              'div',
              { class: 'center' },
              hAsync('h3', null, '\u0422\u0443\u0440\u043D\u0438\u0440\u043D\u0430\u044F \u0441\u0442\u0430\u0442\u0438\u0441\u0442\u0438\u043A\u0430'),
              hAsync(
                'div',
                { class: 'description' },
                '\u0414\u043B\u044F \u0442\u0435\u0445, \u043A\u0442\u043E \u0445\u043E\u0447\u0435\u0442 \u043E\u0431\u043B\u0430\u0434\u0430\u0442\u044C \u0432\u0441\u0435\u0439 \u0438\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u0435\u0439 \u043E \u043F\u0440\u043E\u0448\u0435\u0434\u0448\u0438\u0445 \u0438 \u043F\u0440\u0435\u0434\u0441\u0442\u043E\u044F\u0448\u0438\u0445 \u0442\u0443\u0440\u043D\u0438\u0440\u0430\u0445',
              ),
              hAsync('div', { class: 'button-row' }, hAsync('button', { class: 'outline' }, '\u041F\u043E\u0441\u043C\u043E\u0442\u0440\u0435\u0442\u044C')),
            ),
          ),
        );
      }
      static get style() {
        return ffspbWelcomeTournamentsComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-welcome-tournaments',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const footerIosCss =
      'ion-footer{display:block;position:relative;order:1;width:100%;z-index:10}ion-footer ion-toolbar:last-of-type{padding-bottom:var(--ion-safe-area-bottom, 0)}.footer-ios ion-toolbar:first-of-type{--border-width:0.55px 0 0}@supports (backdrop-filter: blur(0)){.footer-background{left:0;right:0;top:0;bottom:0;position:absolute;backdrop-filter:saturate(180%) blur(20px)}.footer-translucent-ios ion-toolbar{--opacity:.8}}.footer-ios.ion-no-border ion-toolbar:first-of-type{--border-width:0}';

    const footerMdCss =
      'ion-footer{display:block;position:relative;order:1;width:100%;z-index:10}ion-footer ion-toolbar:last-of-type{padding-bottom:var(--ion-safe-area-bottom, 0)}.footer-md::before{left:0;top:-2px;bottom:auto;background-position:left 0 top 0;position:absolute;width:100%;height:2px;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAHBAMAAADzDtBxAAAAD1BMVEUAAAAAAAAAAAAAAAAAAABPDueNAAAABXRSTlMUCS0gBIh/TXEAAAAaSURBVAjXYxCEAgY4UIICBmMogMsgFLtAAQCNSwXZKOdPxgAAAABJRU5ErkJggg==");background-repeat:repeat-x;content:""}[dir=rtl] .footer-md::before,:host-context([dir=rtl]) .footer-md::before{left:unset;right:unset;right:0}[dir=rtl] .footer-md::before,:host-context([dir=rtl]) .footer-md::before{background-position:right 0 top 0}.footer-md.ion-no-border::before{display:none}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Footer {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If `true`, the footer will be translucent.
         * Only applies when the mode is `"ios"` and the device supports
         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
         *
         * Note: In order to scroll content behind the footer, the `fullscreen`
         * attribute needs to be set on the content.
         */
        this.translucent = false;
      }
      render() {
        const mode = getIonMode$1(this);
        const translucent = this.translucent;
        return hAsync(
          Host,
          {
            role: 'contentinfo',
            class: {
              [mode]: true,
              // Used internally for styling
              [`footer-${mode}`]: true,
              [`footer-translucent`]: translucent,
              [`footer-translucent-${mode}`]: translucent,
            },
          },
          mode === 'ios' && translucent && hAsync('div', { class: 'footer-background' }),
          hAsync('slot', null),
        );
      }
      static get style() {
        return {
          ios: footerIosCss,
          md: footerMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 36,
          $tagName$: 'ion-footer',
          $members$: {
            translucent: [4],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const gridCss =
      '/*!@:host*/.sc-ion-grid-h{padding-left:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-right:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));margin-left:auto;margin-right:auto;display:block;flex:1}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-grid-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-xs, var(--ion-grid-padding, 5px))}}@media (min-width: 576px){/*!@:host*/.sc-ion-grid-h{padding-left:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-right:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px))}/*!@@supports (margin-inline-start: 0) or (-webkit-margin-start: 0)*/@supports .sc-ion-grid (margin-inline-start.sc-ion-grid: 0).sc-ion-grid or.sc-ion-grid (-webkit-margin-start.sc-ion-grid: 0).sc-ion-grid{.sc-ion-grid-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-sm, var(--ion-grid-padding, 5px))}}}@media (min-width: 768px){/*!@:host*/.sc-ion-grid-h{padding-left:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-right:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px))}/*!@@supports (margin-inline-start: 0) or (-webkit-margin-start: 0)*/@supports .sc-ion-grid (margin-inline-start.sc-ion-grid: 0).sc-ion-grid or.sc-ion-grid (-webkit-margin-start.sc-ion-grid: 0).sc-ion-grid{.sc-ion-grid-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-md, var(--ion-grid-padding, 5px))}}}@media (min-width: 992px){/*!@:host*/.sc-ion-grid-h{padding-left:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-right:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px))}/*!@@supports (margin-inline-start: 0) or (-webkit-margin-start: 0)*/@supports .sc-ion-grid (margin-inline-start.sc-ion-grid: 0).sc-ion-grid or.sc-ion-grid (-webkit-margin-start.sc-ion-grid: 0).sc-ion-grid{.sc-ion-grid-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-lg, var(--ion-grid-padding, 5px))}}}@media (min-width: 1200px){/*!@:host*/.sc-ion-grid-h{padding-left:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-right:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-top:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-bottom:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px))}/*!@@supports (margin-inline-start: 0) or (-webkit-margin-start: 0)*/@supports .sc-ion-grid (margin-inline-start.sc-ion-grid: 0).sc-ion-grid or.sc-ion-grid (-webkit-margin-start.sc-ion-grid: 0).sc-ion-grid{.sc-ion-grid-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-inline-start:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));-webkit-padding-end:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px));padding-inline-end:var(--ion-grid-padding-xl, var(--ion-grid-padding, 5px))}}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-grid-h{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}/*!@:host(.grid-fixed)*/.grid-fixed.sc-ion-grid-h{width:var(--ion-grid-width-xs, var(--ion-grid-width, 100%));max-width:100%}@media (min-width: 576px){/*!@:host(.grid-fixed)*/.grid-fixed.sc-ion-grid-h{width:var(--ion-grid-width-sm, var(--ion-grid-width, 540px))}}@media (min-width: 768px){/*!@:host(.grid-fixed)*/.grid-fixed.sc-ion-grid-h{width:var(--ion-grid-width-md, var(--ion-grid-width, 720px))}}@media (min-width: 992px){/*!@:host(.grid-fixed)*/.grid-fixed.sc-ion-grid-h{width:var(--ion-grid-width-lg, var(--ion-grid-width, 960px))}}@media (min-width: 1200px){/*!@:host(.grid-fixed)*/.grid-fixed.sc-ion-grid-h{width:var(--ion-grid-width-xl, var(--ion-grid-width, 1140px))}}/*!@:host(.ion-no-padding)*/.ion-no-padding.sc-ion-grid-h{--ion-grid-column-padding:0;--ion-grid-column-padding-xs:0;--ion-grid-column-padding-sm:0;--ion-grid-column-padding-md:0;--ion-grid-column-padding-lg:0;--ion-grid-column-padding-xl:0}';

    class Grid {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If `true`, the grid will have a fixed width based on the screen size.
         */
        this.fixed = false;
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: {
              [mode]: true,
              'grid-fixed': this.fixed,
            },
          },
          hAsync('slot', null),
        );
      }
      static get style() {
        return gridCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-grid',
          $members$: {
            fixed: [4],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const TRANSITION = 'all 0.2s ease-in-out';
    const cloneElement = tagName => {
      const getCachedEl = document.querySelector(`${tagName}.ion-cloned-element`);
      if (getCachedEl !== null) {
        return getCachedEl;
      }
      const clonedEl = document.createElement(tagName);
      clonedEl.classList.add('ion-cloned-element');
      clonedEl.style.setProperty('display', 'none');
      document.body.appendChild(clonedEl);
      return clonedEl;
    };
    const createHeaderIndex = headerEl => {
      if (!headerEl) {
        return;
      }
      const toolbars = headerEl.querySelectorAll('ion-toolbar');
      return {
        el: headerEl,
        toolbars:
          Array.from(toolbars).map(toolbar => {
            const ionTitleEl = toolbar.querySelector('ion-title');
            return {
              el: toolbar,
              background: toolbar.shadowRoot.querySelector('.toolbar-background'),
              ionTitleEl,
              innerTitleEl: ionTitleEl ? ionTitleEl.shadowRoot.querySelector('.toolbar-title') : null,
              ionButtonsEl: Array.from(toolbar.querySelectorAll('ion-buttons')) || [],
            };
          }) || [],
      };
    };
    const handleContentScroll = (scrollEl, scrollHeaderIndex, contentEl) => {
      readTask(() => {
        const scrollTop = scrollEl.scrollTop;
        const scale = clamp(1, 1 + -scrollTop / 500, 1.1);
        // Native refresher should not cause titles to scale
        const nativeRefresher = contentEl.querySelector('ion-refresher.refresher-native');
        if (nativeRefresher === null) {
          writeTask(() => {
            scaleLargeTitles(scrollHeaderIndex.toolbars, scale);
          });
        }
      });
    };
    const setToolbarBackgroundOpacity = (toolbar, opacity) => {
      if (opacity === undefined) {
        toolbar.background.style.removeProperty('--opacity');
      } else {
        toolbar.background.style.setProperty('--opacity', opacity.toString());
      }
    };
    const handleToolbarBorderIntersection = (ev, mainHeaderIndex, scrollTop) => {
      if (!ev[0].isIntersecting) {
        return;
      }
      /**
       * There is a bug in Safari where overflow scrolling on a non-body element
       * does not always reset the scrollTop position to 0 when letting go. It will
       * set to 1 once the rubber band effect has ended. This causes the background to
       * appear slightly on certain app setups.
       *
       * Additionally, we check if user is rubber banding (scrolling is negative)
       * as this can mean they are using pull to refresh. Once the refresher starts,
       * the content is transformed which can cause the intersection observer to erroneously
       * fire here as well.
       */
      const scale = ev[0].intersectionRatio > 0.9 || scrollTop <= 0 ? 0 : ((1 - ev[0].intersectionRatio) * 100) / 75;
      mainHeaderIndex.toolbars.forEach(toolbar => {
        setToolbarBackgroundOpacity(toolbar, scale === 1 ? undefined : scale);
      });
    };
    /**
     * If toolbars are intersecting, hide the scrollable toolbar content
     * and show the primary toolbar content. If the toolbars are not intersecting,
     * hide the primary toolbar content and show the scrollable toolbar content
     */
    const handleToolbarIntersection = (ev, mainHeaderIndex, scrollHeaderIndex, scrollEl) => {
      writeTask(() => {
        const scrollTop = scrollEl.scrollTop;
        handleToolbarBorderIntersection(ev, mainHeaderIndex, scrollTop);
        const event = ev[0];
        const intersection = event.intersectionRect;
        const intersectionArea = intersection.width * intersection.height;
        const rootArea = event.rootBounds.width * event.rootBounds.height;
        const isPageHidden = intersectionArea === 0 && rootArea === 0;
        const leftDiff = Math.abs(intersection.left - event.boundingClientRect.left);
        const rightDiff = Math.abs(intersection.right - event.boundingClientRect.right);
        const isPageTransitioning = intersectionArea > 0 && (leftDiff >= 5 || rightDiff >= 5);
        if (isPageHidden || isPageTransitioning) {
          return;
        }
        if (event.isIntersecting) {
          setHeaderActive(mainHeaderIndex, false);
          setHeaderActive(scrollHeaderIndex);
        } else {
          /**
           * There is a bug with IntersectionObserver on Safari
           * where `event.isIntersecting === false` when cancelling
           * a swipe to go back gesture. Checking the intersection
           * x, y, width, and height provides a workaround. This bug
           * does not happen when using Safari + Web Animations,
           * only Safari + CSS Animations.
           */
          const hasValidIntersection = (intersection.x === 0 && intersection.y === 0) || (intersection.width !== 0 && intersection.height !== 0);
          if (hasValidIntersection && scrollTop > 0) {
            setHeaderActive(mainHeaderIndex);
            setHeaderActive(scrollHeaderIndex, false);
            setToolbarBackgroundOpacity(mainHeaderIndex.toolbars[0]);
          }
        }
      });
    };
    const setHeaderActive = (headerIndex, active = true) => {
      if (active) {
        headerIndex.el.classList.remove('header-collapse-condense-inactive');
      } else {
        headerIndex.el.classList.add('header-collapse-condense-inactive');
      }
    };
    const scaleLargeTitles = (toolbars = [], scale = 1, transition = false) => {
      toolbars.forEach(toolbar => {
        const ionTitle = toolbar.ionTitleEl;
        const titleDiv = toolbar.innerTitleEl;
        if (!ionTitle || ionTitle.size !== 'large') {
          return;
        }
        titleDiv.style.transition = transition ? TRANSITION : '';
        titleDiv.style.transform = `scale3d(${scale}, ${scale}, 1)`;
      });
    };

    const headerIosCss =
      'ion-header{display:block;position:relative;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-ios ion-toolbar:last-of-type{--border-width:0 0 0.55px}@supports (backdrop-filter: blur(0)){.header-background{left:0;right:0;top:0;bottom:0;position:absolute;backdrop-filter:saturate(180%) blur(20px)}.header-translucent-ios ion-toolbar{--opacity:.8}.header-collapse-condense-inactive .header-background{backdrop-filter:blur(20px)}}.header-ios.ion-no-border ion-toolbar:last-of-type{--border-width:0}.header-collapse-condense{z-index:9}.header-collapse-condense ion-toolbar{position:sticky;top:0}.header-collapse-condense ion-toolbar:first-of-type{padding-top:7px;z-index:1}.header-collapse-condense ion-toolbar{--background:var(--ion-background-color, #fff);z-index:0}.header-collapse-condense ion-toolbar ion-searchbar{height:48px;padding-top:0px;padding-bottom:13px}.header-collapse-main ion-toolbar.in-toolbar ion-title,.header-collapse-main ion-toolbar.in-toolbar ion-buttons{transition:all 0.2s ease-in-out}.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive:not(.header-collapse-condense) ion-toolbar.in-toolbar ion-buttons.buttons-collapse{opacity:0;pointer-events:none}.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-title,.header-collapse-condense-inactive.header-collapse-condense ion-toolbar.in-toolbar ion-buttons.buttons-collapse{visibility:hidden}';

    const headerMdCss =
      'ion-header{display:block;position:relative;order:-1;width:100%;z-index:10}ion-header ion-toolbar:first-of-type{padding-top:var(--ion-safe-area-top, 0)}.header-md::after{left:0;bottom:-5px;background-position:left 0 top -2px;position:absolute;width:100%;height:5px;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAHBAMAAADzDtBxAAAAD1BMVEUAAAAAAAAAAAAAAAAAAABPDueNAAAABXRSTlMUCS0gBIh/TXEAAAAaSURBVAjXYxCEAgY4UIICBmMogMsgFLtAAQCNSwXZKOdPxgAAAABJRU5ErkJggg==);background-repeat:repeat-x;content:""}[dir=rtl] .header-md::after,:host-context([dir=rtl]) .header-md::after{left:unset;right:unset;right:0}[dir=rtl] .header-md::after,:host-context([dir=rtl]) .header-md::after{background-position:right 0 top -2px}.header-collapse-condense{display:none}.header-md.ion-no-border::after{display:none}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Header {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.collapsibleHeaderInitialized = false;
        this.inheritedAttributes = {};
        /**
         * If `true`, the header will be translucent.
         * Only applies when the mode is `"ios"` and the device supports
         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
         *
         * Note: In order to scroll content behind the header, the `fullscreen`
         * attribute needs to be set on the content.
         */
        this.translucent = false;
      }
      componentWillLoad() {
        this.inheritedAttributes = inheritAttributes(this.el, ['role']);
      }
      async componentDidLoad() {
        await this.checkCollapsibleHeader();
      }
      async componentDidUpdate() {
        await this.checkCollapsibleHeader();
      }
      disconnectedCallback() {
        this.destroyCollapsibleHeader();
      }
      async checkCollapsibleHeader() {
        // Determine if the header can collapse
        const hasCollapse = this.collapse === 'condense';
        const canCollapse = hasCollapse && getIonMode$1(this) === 'ios' ? hasCollapse : false;
        if (!canCollapse && this.collapsibleHeaderInitialized) {
          this.destroyCollapsibleHeader();
        } else if (canCollapse && !this.collapsibleHeaderInitialized) {
          const pageEl = this.el.closest('ion-app,ion-page,.ion-page,page-inner');
          const contentEl = pageEl ? pageEl.querySelector('ion-content') : null;
          // Cloned elements are always needed in iOS transition
          writeTask(() => {
            const title = cloneElement('ion-title');
            title.size = 'large';
            cloneElement('ion-back-button');
          });
          await this.setupCollapsibleHeader(contentEl, pageEl);
        }
      }
      destroyCollapsibleHeader() {
        if (this.intersectionObserver) {
          this.intersectionObserver.disconnect();
          this.intersectionObserver = undefined;
        }
        if (this.scrollEl && this.contentScrollCallback) {
          this.scrollEl.removeEventListener('scroll', this.contentScrollCallback);
          this.contentScrollCallback = undefined;
        }
        if (this.collapsibleMainHeader) {
          this.collapsibleMainHeader.classList.remove('header-collapse-main');
          this.collapsibleMainHeader = undefined;
        }
      }
      async setupCollapsibleHeader(contentEl, pageEl) {
        if (!contentEl || !pageEl) {
          console.error('ion-header requires a content to collapse, make sure there is an ion-content.');
          return;
        }
        if (typeof IntersectionObserver === 'undefined') {
          return;
        }
        this.scrollEl = await contentEl.getScrollElement();
        const headers = pageEl.querySelectorAll('ion-header');
        this.collapsibleMainHeader = Array.from(headers).find(header => header.collapse !== 'condense');
        if (!this.collapsibleMainHeader) {
          return;
        }
        const mainHeaderIndex = createHeaderIndex(this.collapsibleMainHeader);
        const scrollHeaderIndex = createHeaderIndex(this.el);
        if (!mainHeaderIndex || !scrollHeaderIndex) {
          return;
        }
        setHeaderActive(mainHeaderIndex, false);
        mainHeaderIndex.toolbars.forEach(toolbar => {
          setToolbarBackgroundOpacity(toolbar, 0);
        });
        /**
         * Handle interaction between toolbar collapse and
         * showing/hiding content in the primary ion-header
         * as well as progressively showing/hiding the main header
         * border as the top-most toolbar collapses or expands.
         */
        const toolbarIntersection = ev => {
          handleToolbarIntersection(ev, mainHeaderIndex, scrollHeaderIndex, this.scrollEl);
        };
        this.intersectionObserver = new IntersectionObserver(toolbarIntersection, { root: contentEl, threshold: [0.25, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1] });
        this.intersectionObserver.observe(scrollHeaderIndex.toolbars[scrollHeaderIndex.toolbars.length - 1].el);
        /**
         * Handle scaling of large iOS titles and
         * showing/hiding border on last toolbar
         * in primary header
         */
        this.contentScrollCallback = () => {
          handleContentScroll(this.scrollEl, scrollHeaderIndex, contentEl);
        };
        this.scrollEl.addEventListener('scroll', this.contentScrollCallback);
        writeTask(() => {
          if (this.collapsibleMainHeader !== undefined) {
            this.collapsibleMainHeader.classList.add('header-collapse-main');
          }
        });
        this.collapsibleHeaderInitialized = true;
      }
      render() {
        const { translucent, inheritedAttributes } = this;
        const mode = getIonMode$1(this);
        const collapse = this.collapse || 'none';
        return hAsync(
          Host,
          Object.assign(
            {
              role: 'banner',
              class: {
                [mode]: true,
                // Used internally for styling
                [`header-${mode}`]: true,
                [`header-translucent`]: this.translucent,
                [`header-collapse-${collapse}`]: true,
                [`header-translucent-${mode}`]: this.translucent,
              },
            },
            inheritedAttributes,
          ),
          mode === 'ios' && translucent && hAsync('div', { class: 'header-background' }),
          hAsync('slot', null),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: headerIosCss,
          md: headerMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 36,
          $tagName$: 'ion-header',
          $members$: {
            collapse: [1],
            translucent: [4],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const iconCss =
      '/*!@:host*/.sc-ion-icon-h{display:inline-block;width:1em;height:1em;contain:strict;fill:currentColor;box-sizing:content-box !important}/*!@:host .ionicon*/.sc-ion-icon-h .ionicon.sc-ion-icon{stroke:currentColor}/*!@.ionicon-fill-none*/.ionicon-fill-none.sc-ion-icon{fill:none}/*!@.ionicon-stroke-width*/.ionicon-stroke-width.sc-ion-icon{stroke-width:32px;stroke-width:var(--ionicon-stroke-width, 32px)}/*!@.icon-inner,\n.ionicon,\nsvg*/.icon-inner.sc-ion-icon,.ionicon.sc-ion-icon,svg.sc-ion-icon{display:block;height:100%;width:100%}/*!@:host(.flip-rtl) .icon-inner*/.flip-rtl.sc-ion-icon-h .icon-inner.sc-ion-icon{transform:scaleX(-1)}/*!@:host(.icon-small)*/.icon-small.sc-ion-icon-h{font-size:18px !important}/*!@:host(.icon-large)*/.icon-large.sc-ion-icon-h{font-size:32px !important}/*!@:host(.ion-color)*/.ion-color.sc-ion-icon-h{color:var(--ion-color-base) !important}/*!@:host(.ion-color-primary)*/.ion-color-primary.sc-ion-icon-h{--ion-color-base:var(--ion-color-primary, #3880ff)}/*!@:host(.ion-color-secondary)*/.ion-color-secondary.sc-ion-icon-h{--ion-color-base:var(--ion-color-secondary, #0cd1e8)}/*!@:host(.ion-color-tertiary)*/.ion-color-tertiary.sc-ion-icon-h{--ion-color-base:var(--ion-color-tertiary, #f4a942)}/*!@:host(.ion-color-success)*/.ion-color-success.sc-ion-icon-h{--ion-color-base:var(--ion-color-success, #10dc60)}/*!@:host(.ion-color-warning)*/.ion-color-warning.sc-ion-icon-h{--ion-color-base:var(--ion-color-warning, #ffce00)}/*!@:host(.ion-color-danger)*/.ion-color-danger.sc-ion-icon-h{--ion-color-base:var(--ion-color-danger, #f14141)}/*!@:host(.ion-color-light)*/.ion-color-light.sc-ion-icon-h{--ion-color-base:var(--ion-color-light, #f4f5f8)}/*!@:host(.ion-color-medium)*/.ion-color-medium.sc-ion-icon-h{--ion-color-base:var(--ion-color-medium, #989aa2)}/*!@:host(.ion-color-dark)*/.ion-color-dark.sc-ion-icon-h{--ion-color-base:var(--ion-color-dark, #222428)}';

    class Icon {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.iconName = null;
        this.isVisible = false;
        /**
         * The mode determines which platform styles to use.
         */
        this.mode = getIonMode();
        /**
         * If enabled, ion-icon will be loaded lazily when it's visible in the viewport.
         * Default, `false`.
         */
        this.lazy = false;
        /**
         * When set to `false`, SVG content that is HTTP fetched will not be checked
         * if the response SVG content has any `<script>` elements, or any attributes
         * that start with `on`, such as `onclick`.
         * @default true
         */
        this.sanitize = true;
      }
      connectedCallback() {
        // purposely do not return the promise here because loading
        // the svg file should not hold up loading the app
        // only load the svg if it's visible
        this.waitUntilVisible(this.el, '50px', () => {
          this.isVisible = true;
          this.loadIcon();
        });
      }
      disconnectedCallback() {
        if (this.io) {
          this.io.disconnect();
          this.io = undefined;
        }
      }
      waitUntilVisible(el, rootMargin, cb) {
        {
          // browser doesn't support IntersectionObserver
          // so just fallback to always show it
          cb();
        }
      }
      loadIcon() {
        const label = (this.iconName = getName(this.name, this.icon, this.mode, this.ios, this.md));
        if (!this.ariaLabel && this.ariaHidden !== 'true') {
          // user did not provide a label
          // come up with the label based on the icon name
          if (label) {
            this.ariaLabel = label.replace(/\-/g, ' ');
          }
        }
      }
      render() {
        const { iconName } = this;
        const mode = this.mode || 'md';
        const flipRtl = this.flipRtl || (iconName && (iconName.indexOf('arrow') > -1 || iconName.indexOf('chevron') > -1) && this.flipRtl !== false);
        return hAsync(
          Host,
          {
            role: 'img',
            class: Object.assign(Object.assign({ [mode]: true }, createColorClasses(this.color)), {
              [`icon-${this.size}`]: !!this.size,
              'flip-rtl': !!flipRtl && this.el.ownerDocument.dir === 'rtl',
            }),
          },
          hAsync('div', { class: 'icon-inner' }),
        );
      }
      static get assetsDirs() {
        return ['svg'];
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          name: ['loadIcon'],
          src: ['loadIcon'],
          icon: ['loadIcon'],
        };
      }
      static get style() {
        return iconCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-icon',
          $members$: {
            mode: [1025],
            color: [1],
            ariaLabel: [1537, 'aria-label'],
            ariaHidden: [513, 'aria-hidden'],
            ios: [1],
            md: [1],
            flipRtl: [4, 'flip-rtl'],
            name: [513],
            src: [1],
            icon: [8],
            size: [1],
            lazy: [4],
            sanitize: [4],
            svgContent: [32],
            isVisible: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [
            ['ariaLabel', 'aria-label'],
            ['ariaHidden', 'aria-hidden'],
            ['name', 'name'],
          ],
        };
      }
    }
    const getIonMode = () => 'md';
    const createColorClasses = color => {
      return color
        ? {
            'ion-color': true,
            [`ion-color-${color}`]: true,
          }
        : null;
    };

    const imgCss =
      '/*!@:host*/.sc-ion-img-h{display:block;object-fit:contain}/*!@img*/img.sc-ion-img{display:block;width:100%;height:100%;object-fit:inherit;object-position:inherit}';

    /**
     * @part image - The inner `img` element.
     */
    class Img {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionImgWillLoad = createEvent(this, 'ionImgWillLoad', 7);
        this.ionImgDidLoad = createEvent(this, 'ionImgDidLoad', 7);
        this.ionError = createEvent(this, 'ionError', 7);
        this.onLoad = () => {
          this.ionImgDidLoad.emit();
        };
        this.onError = () => {
          this.ionError.emit();
        };
      }
      srcChanged() {
        this.addIO();
      }
      componentDidLoad() {
        this.addIO();
      }
      addIO() {
        if (this.src === undefined) {
          return;
        }
        if (
          typeof window !== 'undefined' &&
          'IntersectionObserver' in window &&
          'IntersectionObserverEntry' in window &&
          'isIntersecting' in window.IntersectionObserverEntry.prototype
        ) {
          this.removeIO();
          this.io = new IntersectionObserver(data => {
            /**
             * On slower devices, it is possible for an intersection observer entry to contain multiple
             * objects in the array. This happens when quickly scrolling an image into view and then out of
             * view. In this case, the last object represents the current state of the component.
             */
            if (data[data.length - 1].isIntersecting) {
              this.load();
              this.removeIO();
            }
          });
          this.io.observe(this.el);
        } else {
          // fall back to setTimeout for Safari and IE
          setTimeout(() => this.load(), 200);
        }
      }
      load() {
        this.loadError = this.onError;
        this.loadSrc = this.src;
        this.ionImgWillLoad.emit();
      }
      removeIO() {
        if (this.io) {
          this.io.disconnect();
          this.io = undefined;
        }
      }
      render() {
        return hAsync(
          Host,
          { class: getIonMode$1(this) },
          hAsync('img', { decoding: 'async', src: this.loadSrc, alt: this.alt, onLoad: this.onLoad, onError: this.loadError, part: 'image' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          src: ['srcChanged'],
        };
      }
      static get style() {
        return imgCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-img',
          $members$: {
            alt: [1],
            src: [1],
            loadSrc: [32],
            loadError: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const infiniteScrollCss = 'ion-infinite-scroll{display:none;width:100%}.infinite-scroll-enabled{display:block}';

    class InfiniteScroll {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionInfinite = createEvent(this, 'ionInfinite', 7);
        this.thrPx = 0;
        this.thrPc = 0;
        this.didFire = false;
        this.isBusy = false;
        this.isLoading = false;
        /**
         * The threshold distance from the bottom
         * of the content to call the `infinite` output event when scrolled.
         * The threshold value can be either a percent, or
         * in pixels. For example, use the value of `10%` for the `infinite`
         * output event to get called when the user has scrolled 10%
         * from the bottom of the page. Use the value `100px` when the
         * scroll is within 100 pixels from the bottom of the page.
         */
        this.threshold = '15%';
        /**
         * If `true`, the infinite scroll will be hidden and scroll event listeners
         * will be removed.
         *
         * Set this to true to disable the infinite scroll from actively
         * trying to receive new data while scrolling. This is useful
         * when it is known that there is no more data that can be added, and
         * the infinite scroll is no longer needed.
         */
        this.disabled = false;
        /**
         * The position of the infinite scroll element.
         * The value can be either `top` or `bottom`.
         */
        this.position = 'bottom';
        this.onScroll = () => {
          const scrollEl = this.scrollEl;
          if (!scrollEl || !this.canStart()) {
            return 1;
          }
          const infiniteHeight = this.el.offsetHeight;
          if (infiniteHeight === 0) {
            // if there is no height of this element then do nothing
            return 2;
          }
          const scrollTop = scrollEl.scrollTop;
          const scrollHeight = scrollEl.scrollHeight;
          const height = scrollEl.offsetHeight;
          const threshold = this.thrPc !== 0 ? height * this.thrPc : this.thrPx;
          const distanceFromInfinite = this.position === 'bottom' ? scrollHeight - infiniteHeight - scrollTop - threshold - height : scrollTop - infiniteHeight - threshold;
          if (distanceFromInfinite < 0) {
            if (!this.didFire) {
              this.isLoading = true;
              this.didFire = true;
              this.ionInfinite.emit();
              return 3;
            }
          } else {
            this.didFire = false;
          }
          return 4;
        };
      }
      thresholdChanged() {
        const val = this.threshold;
        if (val.lastIndexOf('%') > -1) {
          this.thrPx = 0;
          this.thrPc = parseFloat(val) / 100;
        } else {
          this.thrPx = parseFloat(val);
          this.thrPc = 0;
        }
      }
      disabledChanged() {
        const disabled = this.disabled;
        if (disabled) {
          this.isLoading = false;
          this.isBusy = false;
        }
        this.enableScrollEvents(!disabled);
      }
      async connectedCallback() {
        const contentEl = this.el.closest('ion-content');
        if (!contentEl) {
          console.error('<ion-infinite-scroll> must be used inside an <ion-content>');
          return;
        }
        this.scrollEl = await contentEl.getScrollElement();
        this.thresholdChanged();
        this.disabledChanged();
        if (this.position === 'top') {
          writeTask(() => {
            if (this.scrollEl) {
              this.scrollEl.scrollTop = this.scrollEl.scrollHeight - this.scrollEl.clientHeight;
            }
          });
        }
      }
      disconnectedCallback() {
        this.enableScrollEvents(false);
        this.scrollEl = undefined;
      }
      /**
       * Call `complete()` within the `ionInfinite` output event handler when
       * your async operation has completed. For example, the `loading`
       * state is while the app is performing an asynchronous operation,
       * such as receiving more data from an AJAX request to add more items
       * to a data list. Once the data has been received and UI updated, you
       * then call this method to signify that the loading has completed.
       * This method will change the infinite scroll's state from `loading`
       * to `enabled`.
       */
      async complete() {
        const scrollEl = this.scrollEl;
        if (!this.isLoading || !scrollEl) {
          return;
        }
        this.isLoading = false;
        if (this.position === 'top') {
          /**
           * New content is being added at the top, but the scrollTop position stays the same,
           * which causes a scroll jump visually. This algorithm makes sure to prevent this.
           * (Frame 1)
           *    - complete() is called, but the UI hasn't had time to update yet.
           *    - Save the current content dimensions.
           *    - Wait for the next frame using _dom.read, so the UI will be updated.
           * (Frame 2)
           *    - Read the new content dimensions.
           *    - Calculate the height difference and the new scroll position.
           *    - Delay the scroll position change until other possible dom reads are done using _dom.write to be performant.
           * (Still frame 2, if I'm correct)
           *    - Change the scroll position (= visually maintain the scroll position).
           *    - Change the state to re-enable the InfiniteScroll.
           *    - This should be after changing the scroll position, or it could
           *    cause the InfiniteScroll to be triggered again immediately.
           * (Frame 3)
           *    Done.
           */
          this.isBusy = true;
          // ******** DOM READ ****************
          // Save the current content dimensions before the UI updates
          const prev = scrollEl.scrollHeight - scrollEl.scrollTop;
          // ******** DOM READ ****************
          requestAnimationFrame(() => {
            readTask(() => {
              // UI has updated, save the new content dimensions
              const scrollHeight = scrollEl.scrollHeight;
              // New content was added on top, so the scroll position should be changed immediately to prevent it from jumping around
              const newScrollTop = scrollHeight - prev;
              // ******** DOM WRITE ****************
              requestAnimationFrame(() => {
                writeTask(() => {
                  scrollEl.scrollTop = newScrollTop;
                  this.isBusy = false;
                });
              });
            });
          });
        }
      }
      canStart() {
        return !this.disabled && !this.isBusy && !!this.scrollEl && !this.isLoading;
      }
      enableScrollEvents(shouldListen) {
        if (this.scrollEl) {
          if (shouldListen) {
            this.scrollEl.addEventListener('scroll', this.onScroll);
          } else {
            this.scrollEl.removeEventListener('scroll', this.onScroll);
          }
        }
      }
      render() {
        const mode = getIonMode$1(this);
        const disabled = this.disabled;
        return hAsync(Host, {
          class: {
            [mode]: true,
            'infinite-scroll-loading': this.isLoading,
            'infinite-scroll-enabled': !disabled,
          },
        });
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          threshold: ['thresholdChanged'],
          disabled: ['disabledChanged'],
        };
      }
      static get style() {
        return infiniteScrollCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-infinite-scroll',
          $members$: {
            threshold: [1],
            disabled: [4],
            position: [1],
            isLoading: [32],
            complete: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const infiniteScrollContentIosCss =
      'ion-infinite-scroll-content{display:flex;flex-direction:column;justify-content:center;min-height:84px;text-align:center;user-select:none}.infinite-loading{margin-left:0;margin-right:0;margin-top:0;margin-bottom:32px;display:none;width:100%}.infinite-loading-text{margin-left:32px;margin-right:32px;margin-top:4px;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.infinite-loading-text{margin-left:unset;margin-right:unset;-webkit-margin-start:32px;margin-inline-start:32px;-webkit-margin-end:32px;margin-inline-end:32px}}.infinite-scroll-loading ion-infinite-scroll-content>.infinite-loading{display:block}.infinite-scroll-content-ios .infinite-loading-text{color:var(--ion-color-step-600, #666666)}.infinite-scroll-content-ios .infinite-loading-spinner .spinner-lines-ios line,.infinite-scroll-content-ios .infinite-loading-spinner .spinner-lines-small-ios line,.infinite-scroll-content-ios .infinite-loading-spinner .spinner-crescent circle{stroke:var(--ion-color-step-600, #666666)}.infinite-scroll-content-ios .infinite-loading-spinner .spinner-bubbles circle,.infinite-scroll-content-ios .infinite-loading-spinner .spinner-circles circle,.infinite-scroll-content-ios .infinite-loading-spinner .spinner-dots circle{fill:var(--ion-color-step-600, #666666)}';

    const infiniteScrollContentMdCss =
      'ion-infinite-scroll-content{display:flex;flex-direction:column;justify-content:center;min-height:84px;text-align:center;user-select:none}.infinite-loading{margin-left:0;margin-right:0;margin-top:0;margin-bottom:32px;display:none;width:100%}.infinite-loading-text{margin-left:32px;margin-right:32px;margin-top:4px;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.infinite-loading-text{margin-left:unset;margin-right:unset;-webkit-margin-start:32px;margin-inline-start:32px;-webkit-margin-end:32px;margin-inline-end:32px}}.infinite-scroll-loading ion-infinite-scroll-content>.infinite-loading{display:block}.infinite-scroll-content-md .infinite-loading-text{color:var(--ion-color-step-600, #666666)}.infinite-scroll-content-md .infinite-loading-spinner .spinner-lines-md line,.infinite-scroll-content-md .infinite-loading-spinner .spinner-lines-small-md line,.infinite-scroll-content-md .infinite-loading-spinner .spinner-crescent circle{stroke:var(--ion-color-step-600, #666666)}.infinite-scroll-content-md .infinite-loading-spinner .spinner-bubbles circle,.infinite-scroll-content-md .infinite-loading-spinner .spinner-circles circle,.infinite-scroll-content-md .infinite-loading-spinner .spinner-dots circle{fill:var(--ion-color-step-600, #666666)}';

    class InfiniteScrollContent {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      componentDidLoad() {
        if (this.loadingSpinner === undefined) {
          const mode = getIonMode$1(this);
          this.loadingSpinner = config$2.get('infiniteLoadingSpinner', config$2.get('spinner', mode === 'ios' ? 'lines' : 'crescent'));
        }
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: {
              [mode]: true,
              // Used internally for styling
              [`infinite-scroll-content-${mode}`]: true,
            },
          },
          hAsync(
            'div',
            { class: 'infinite-loading' },
            this.loadingSpinner && hAsync('div', { class: 'infinite-loading-spinner' }, hAsync('ion-spinner', { name: this.loadingSpinner })),
            this.loadingText && hAsync('div', { class: 'infinite-loading-text', innerHTML: sanitizeDOMString(this.loadingText) }),
          ),
        );
      }
      static get style() {
        return {
          ios: infiniteScrollContentIosCss,
          md: infiniteScrollContentMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 32,
          $tagName$: 'ion-infinite-scroll-content',
          $members$: {
            loadingSpinner: [1025, 'loading-spinner'],
            loadingText: [1, 'loading-text'],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const inputIosCss =
      ".sc-ion-input-ios-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:.5;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--background:transparent;--color:initial;display:flex;position:relative;flex:1;align-items:center;width:100%;padding:0 !important;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);z-index:2}ion-item.sc-ion-input-ios-h:not(.item-label),ion-item:not(.item-label) .sc-ion-input-ios-h{--padding-start:0}.ion-color.sc-ion-input-ios-h{color:var(--ion-color-base)}.native-input.sc-ion-input-ios{border-radius:var(--border-radius);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:inline-block;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;box-sizing:border-box;appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.native-input.sc-ion-input-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.native-input.sc-ion-input-ios::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-ios:-webkit-autofill{background-color:transparent}.native-input.sc-ion-input-ios:invalid{box-shadow:none}.native-input.sc-ion-input-ios::-ms-clear{display:none}.native-input[disabled].sc-ion-input-ios{opacity:0.4}.cloned-input.sc-ion-input-ios{left:0;top:0;position:absolute;pointer-events:none}[dir=rtl].sc-ion-input-ios .cloned-input.sc-ion-input-ios,[dir=rtl].sc-ion-input-ios-h .cloned-input.sc-ion-input-ios,[dir=rtl] .sc-ion-input-ios-h .cloned-input.sc-ion-input-ios{left:unset;right:unset;right:0}.input-clear-icon.sc-ion-input-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;background-position:center;border:0;outline:none;background-color:transparent;background-repeat:no-repeat;visibility:hidden;appearance:none}.input-clear-icon.sc-ion-input-ios:focus{opacity:0.5}.has-value.sc-ion-input-ios-h .input-clear-icon.sc-ion-input-ios{visibility:visible}.has-focus.sc-ion-input-ios-h{pointer-events:none}.has-focus.sc-ion-input-ios-h input.sc-ion-input-ios,.has-focus.sc-ion-input-ios-h a.sc-ion-input-ios,.has-focus.sc-ion-input-ios-h button.sc-ion-input-ios{pointer-events:auto}.item-label-floating.item-has-placeholder.sc-ion-input-ios-h:not(.item-has-value),.item-label-floating.item-has-placeholder:not(.item-has-value) .sc-ion-input-ios-h{opacity:0}.item-label-floating.item-has-placeholder.sc-ion-input-ios-h:not(.item-has-value).item-has-focus,.item-label-floating.item-has-placeholder:not(.item-has-value).item-has-focus .sc-ion-input-ios-h{transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);opacity:1}.sc-ion-input-ios-h{--padding-top:10px;--padding-end:10px;--padding-bottom:10px;--padding-start:0;font-size:inherit}.item-label-stacked.sc-ion-input-ios-h,.item-label-stacked .sc-ion-input-ios-h,.item-label-floating.sc-ion-input-ios-h,.item-label-floating .sc-ion-input-ios-h{--padding-top:8px;--padding-bottom:8px;--padding-start:0px}.input-clear-icon.sc-ion-input-ios{background-image:url(\"data:image/svg+xml;charset=utf-8,<svg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'><path%20fill='var(--ion-color-step-600,%20%23666666)'%20d='M403.1,108.9c-81.2-81.2-212.9-81.2-294.2,0s-81.2,212.9,0,294.2c81.2,81.2,212.9,81.2,294.2,0S484.3,190.1,403.1,108.9z%20M352,340.2L340.2,352l-84.4-84.2l-84,83.8L160,339.8l84-83.8l-84-83.8l11.8-11.8l84,83.8l84.4-84.2l11.8,11.8L267.6,256L352,340.2z'/></svg>\");width:30px;height:30px;background-size:18px}";

    const inputMdCss =
      ".sc-ion-input-md-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:.5;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--background:transparent;--color:initial;display:flex;position:relative;flex:1;align-items:center;width:100%;padding:0 !important;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);z-index:2}ion-item.sc-ion-input-md-h:not(.item-label),ion-item:not(.item-label) .sc-ion-input-md-h{--padding-start:0}.ion-color.sc-ion-input-md-h{color:var(--ion-color-base)}.native-input.sc-ion-input-md{border-radius:var(--border-radius);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:inline-block;flex:1;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;box-sizing:border-box;appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.native-input.sc-ion-input-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.native-input.sc-ion-input-md::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-input.sc-ion-input-md:-webkit-autofill{background-color:transparent}.native-input.sc-ion-input-md:invalid{box-shadow:none}.native-input.sc-ion-input-md::-ms-clear{display:none}.native-input[disabled].sc-ion-input-md{opacity:0.4}.cloned-input.sc-ion-input-md{left:0;top:0;position:absolute;pointer-events:none}[dir=rtl].sc-ion-input-md .cloned-input.sc-ion-input-md,[dir=rtl].sc-ion-input-md-h .cloned-input.sc-ion-input-md,[dir=rtl] .sc-ion-input-md-h .cloned-input.sc-ion-input-md{left:unset;right:unset;right:0}.input-clear-icon.sc-ion-input-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;background-position:center;border:0;outline:none;background-color:transparent;background-repeat:no-repeat;visibility:hidden;appearance:none}.input-clear-icon.sc-ion-input-md:focus{opacity:0.5}.has-value.sc-ion-input-md-h .input-clear-icon.sc-ion-input-md{visibility:visible}.has-focus.sc-ion-input-md-h{pointer-events:none}.has-focus.sc-ion-input-md-h input.sc-ion-input-md,.has-focus.sc-ion-input-md-h a.sc-ion-input-md,.has-focus.sc-ion-input-md-h button.sc-ion-input-md{pointer-events:auto}.item-label-floating.item-has-placeholder.sc-ion-input-md-h:not(.item-has-value),.item-label-floating.item-has-placeholder:not(.item-has-value) .sc-ion-input-md-h{opacity:0}.item-label-floating.item-has-placeholder.sc-ion-input-md-h:not(.item-has-value).item-has-focus,.item-label-floating.item-has-placeholder:not(.item-has-value).item-has-focus .sc-ion-input-md-h{transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);opacity:1}.sc-ion-input-md-h{--padding-top:10px;--padding-end:0;--padding-bottom:10px;--padding-start:8px;font-size:inherit}.item-label-stacked.sc-ion-input-md-h,.item-label-stacked .sc-ion-input-md-h,.item-label-floating.sc-ion-input-md-h,.item-label-floating .sc-ion-input-md-h{--padding-top:8px;--padding-bottom:8px;--padding-start:0}.input-clear-icon.sc-ion-input-md{background-image:url(\"data:image/svg+xml;charset=utf-8,<svg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20512%20512'><polygon%20fill='var(--ion-color-step-600,%20%23666666)'%20points='405,136.798%20375.202,107%20256,226.202%20136.798,107%20107,136.798%20226.202,256%20107,375.202%20136.798,405%20256,285.798%20375.202,405%20405,375.202%20285.798,256'/></svg>\");width:30px;height:30px;background-size:22px}";

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Input {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionInput = createEvent(this, 'ionInput', 7);
        this.ionChange = createEvent(this, 'ionChange', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.inputId = `ion-input-${inputIds++}`;
        this.didBlurAfterEdit = false;
        this.inheritedAttributes = {};
        /**
         * This is required for a WebKit bug which requires us to
         * blur and focus an input to properly focus the input in
         * an item with delegatesFocus. It will no longer be needed
         * with iOS 14.
         *
         * @internal
         */
        this.fireFocusEvents = true;
        this.hasFocus = false;
        /**
         * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.
         * Available options: `"off"`, `"none"`, `"on"`, `"sentences"`, `"words"`, `"characters"`.
         */
        this.autocapitalize = 'off';
        /**
         * Indicates whether the value of the control can be automatically completed by the browser.
         */
        this.autocomplete = 'off';
        /**
         * Whether auto correction should be enabled when the user is entering/editing the text value.
         */
        this.autocorrect = 'off';
        /**
         * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        this.autofocus = false;
        /**
         * If `true`, a clear icon will appear in the input when there is a value. Clicking it clears the input.
         */
        this.clearInput = false;
        /**
         * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        this.debounce = 0;
        /**
         * If `true`, the user cannot interact with the input.
         */
        this.disabled = false;
        /**
         * The name of the control, which is submitted with the form data.
         */
        this.name = this.inputId;
        /**
         * If `true`, the user cannot modify the value.
         */
        this.readonly = false;
        /**
         * If `true`, the user must fill in a value before submitting a form.
         */
        this.required = false;
        /**
         * If `true`, the element will have its spelling and grammar checked.
         */
        this.spellcheck = false;
        /**
         * The type of control to display. The default type is text.
         */
        this.type = 'text';
        /**
         * The value of the input.
         */
        this.value = '';
        this.onInput = ev => {
          const input = ev.target;
          if (input) {
            this.value = input.value || '';
          }
          this.ionInput.emit(ev);
        };
        this.onBlur = ev => {
          this.hasFocus = false;
          this.focusChanged();
          this.emitStyle();
          if (this.fireFocusEvents) {
            this.ionBlur.emit(ev);
          }
        };
        this.onFocus = ev => {
          this.hasFocus = true;
          this.focusChanged();
          this.emitStyle();
          if (this.fireFocusEvents) {
            this.ionFocus.emit(ev);
          }
        };
        this.onKeydown = ev => {
          if (this.shouldClearOnEdit()) {
            // Did the input value change after it was blurred and edited?
            // Do not clear if user is hitting Enter to submit form
            if (this.didBlurAfterEdit && this.hasValue() && ev.key !== 'Enter') {
              // Clear the input
              this.clearTextInput();
            }
            // Reset the flag
            this.didBlurAfterEdit = false;
          }
        };
        this.clearTextOnEnter = ev => {
          if (ev.key === 'Enter') {
            this.clearTextInput(ev);
          }
        };
        this.clearTextInput = ev => {
          if (this.clearInput && !this.readonly && !this.disabled && ev) {
            ev.preventDefault();
            ev.stopPropagation();
            // Attempt to focus input again after pressing clear button
            this.setFocus();
          }
          this.value = '';
          /**
           * This is needed for clearOnEdit
           * Otherwise the value will not be cleared
           * if user is inside the input
           */
          if (this.nativeInput) {
            this.nativeInput.value = '';
          }
        };
      }
      debounceChanged() {
        this.ionChange = debounceEvent(this.ionChange, this.debounce);
      }
      disabledChanged() {
        this.emitStyle();
      }
      /**
       * Update the item classes when the placeholder changes
       */
      placeholderChanged() {
        this.emitStyle();
      }
      /**
       * Update the native input element when the value changes
       */
      valueChanged() {
        this.emitStyle();
        this.ionChange.emit({ value: this.value == null ? this.value : this.value.toString() });
      }
      componentWillLoad() {
        this.inheritedAttributes = inheritAttributes(this.el, ['aria-label', 'tabindex', 'title']);
      }
      connectedCallback() {
        this.emitStyle();
        this.debounceChanged();
      }
      disconnectedCallback() {}
      /**
       * Sets focus on the native `input` in `ion-input`. Use this method instead of the global
       * `input.focus()`.
       */
      async setFocus() {
        if (this.nativeInput) {
          this.nativeInput.focus();
        }
      }
      /**
       * Sets blur on the native `input` in `ion-input`. Use this method instead of the global
       * `input.blur()`.
       * @internal
       */
      async setBlur() {
        if (this.nativeInput) {
          this.nativeInput.blur();
        }
      }
      /**
       * Returns the native `<input>` element used under the hood.
       */
      getInputElement() {
        return Promise.resolve(this.nativeInput);
      }
      shouldClearOnEdit() {
        const { type, clearOnEdit } = this;
        return clearOnEdit === undefined ? type === 'password' : clearOnEdit;
      }
      getValue() {
        return typeof this.value === 'number' ? this.value.toString() : (this.value || '').toString();
      }
      emitStyle() {
        this.ionStyle.emit({
          'interactive': true,
          'input': true,
          'has-placeholder': this.placeholder != null,
          'has-value': this.hasValue(),
          'has-focus': this.hasFocus,
          'interactive-disabled': this.disabled,
        });
      }
      focusChanged() {
        // If clearOnEdit is enabled and the input blurred but has a value, set a flag
        if (!this.hasFocus && this.shouldClearOnEdit() && this.hasValue()) {
          this.didBlurAfterEdit = true;
        }
      }
      hasValue() {
        return this.getValue().length > 0;
      }
      render() {
        const mode = getIonMode$1(this);
        const value = this.getValue();
        const labelId = this.inputId + '-lbl';
        const label = findItemLabel(this.el);
        if (label) {
          label.id = labelId;
        }
        return hAsync(
          Host,
          {
            'aria-disabled': this.disabled ? 'true' : null,
            'class': createColorClasses$1(this.color, {
              [mode]: true,
              'has-value': this.hasValue(),
              'has-focus': this.hasFocus,
            }),
          },
          hAsync(
            'input',
            Object.assign(
              {
                'class': 'native-input',
                'ref': input => (this.nativeInput = input),
                'aria-labelledby': label ? labelId : null,
                'disabled': this.disabled,
                'accept': this.accept,
                'autoCapitalize': this.autocapitalize,
                'autoComplete': this.autocomplete,
                'autoCorrect': this.autocorrect,
                'autoFocus': this.autofocus,
                'enterKeyHint': this.enterkeyhint,
                'inputMode': this.inputmode,
                'min': this.min,
                'max': this.max,
                'minLength': this.minlength,
                'maxLength': this.maxlength,
                'multiple': this.multiple,
                'name': this.name,
                'pattern': this.pattern,
                'placeholder': this.placeholder || '',
                'readOnly': this.readonly,
                'required': this.required,
                'spellcheck': this.spellcheck,
                'step': this.step,
                'size': this.size,
                'type': this.type,
                'value': value,
                'onInput': this.onInput,
                'onBlur': this.onBlur,
                'onFocus': this.onFocus,
                'onKeyDown': this.onKeydown,
              },
              this.inheritedAttributes,
            ),
          ),
          this.clearInput &&
            !this.readonly &&
            !this.disabled &&
            hAsync('button', {
              'aria-label': 'reset',
              'type': 'button',
              'class': 'input-clear-icon',
              'onTouchStart': this.clearTextInput,
              'onMouseDown': this.clearTextInput,
              'onKeyDown': this.clearTextOnEnter,
            }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          debounce: ['debounceChanged'],
          disabled: ['disabledChanged'],
          placeholder: ['placeholderChanged'],
          value: ['valueChanged'],
        };
      }
      static get style() {
        return {
          ios: inputIosCss,
          md: inputMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-input',
          $members$: {
            fireFocusEvents: [4, 'fire-focus-events'],
            color: [513],
            accept: [1],
            autocapitalize: [1],
            autocomplete: [1],
            autocorrect: [1],
            autofocus: [4],
            clearInput: [4, 'clear-input'],
            clearOnEdit: [4, 'clear-on-edit'],
            debounce: [2],
            disabled: [4],
            enterkeyhint: [1],
            inputmode: [1],
            max: [1],
            maxlength: [2],
            min: [1],
            minlength: [2],
            multiple: [4],
            name: [1],
            pattern: [1],
            placeholder: [1],
            readonly: [4],
            required: [4],
            spellcheck: [4],
            step: [1],
            size: [2],
            type: [1],
            value: [1032],
            hasFocus: [32],
            setFocus: [64],
            setBlur: [64],
            getInputElement: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }
    let inputIds = 0;

    const itemIosCss =
      '/*!@:host*/.sc-ion-item-ios-h{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--show-full-highlight:0;--show-inset-highlight:0;--detail-icon-color:initial;--detail-icon-font-size:20px;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;align-items:center;justify-content:space-between;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:initial;text-decoration:none;overflow:hidden;box-sizing:border-box}/*!@:host(.ion-color) .item-native*/.ion-color.sc-ion-item-ios-h .item-native.sc-ion-item-ios{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(.ion-color) .item-native,\n:host(.ion-color) .item-inner*/.ion-color.sc-ion-item-ios-h .item-native.sc-ion-item-ios,.ion-color.sc-ion-item-ios-h .item-inner.sc-ion-item-ios{border-color:var(--ion-color-shade)}/*!@:host(.ion-activated) .item-native*/.ion-activated.sc-ion-item-ios-h .item-native.sc-ion-item-ios{color:var(--color-activated)}/*!@:host(.ion-activated) .item-native::after*/.ion-activated.sc-ion-item-ios-h .item-native.sc-ion-item-ios::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}/*!@:host(.ion-color.ion-activated) .item-native*/.ion-color.ion-activated.sc-ion-item-ios-h .item-native.sc-ion-item-ios{color:var(--ion-color-contrast)}/*!@:host(.ion-focused) .item-native*/.ion-focused.sc-ion-item-ios-h .item-native.sc-ion-item-ios{color:var(--color-focused)}/*!@:host(.ion-focused) .item-native::after*/.ion-focused.sc-ion-item-ios-h .item-native.sc-ion-item-ios::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}/*!@:host(.ion-color.ion-focused) .item-native*/.ion-color.ion-focused.sc-ion-item-ios-h .item-native.sc-ion-item-ios{color:var(--ion-color-contrast)}/*!@:host(.ion-color.ion-focused) .item-native::after*/.ion-color.ion-focused.sc-ion-item-ios-h .item-native.sc-ion-item-ios::after{background:var(--ion-color-contrast)}@media (any-hover: hover){/*!@:host(.ion-activatable:hover) .item-native*/.ion-activatable.sc-ion-item-ios-h:hover .item-native.sc-ion-item-ios{color:var(--color-hover)}/*!@:host(.ion-activatable:hover) .item-native::after*/.ion-activatable.sc-ion-item-ios-h:hover .item-native.sc-ion-item-ios::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}/*!@:host(.ion-color.ion-activatable:hover) .item-native*/.ion-color.ion-activatable.sc-ion-item-ios-h:hover .item-native.sc-ion-item-ios{color:var(--ion-color-contrast)}/*!@:host(.ion-color.ion-activatable:hover) .item-native::after*/.ion-color.ion-activatable.sc-ion-item-ios-h:hover .item-native.sc-ion-item-ios::after{background:var(--ion-color-contrast)}}/*!@:host(.item-interactive-disabled:not(.item-multiple-inputs))*/.item-interactive-disabled.sc-ion-item-ios-h:not(.item-multiple-inputs){cursor:default;pointer-events:none}/*!@:host(.item-disabled)*/.item-disabled.sc-ion-item-ios-h{cursor:default;opacity:0.3;pointer-events:none}/*!@.item-native*/.item-native.sc-ion-item-ios{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:flex;position:relative;align-items:inherit;justify-content:inherit;width:100%;min-height:var(--min-height);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);overflow:inherit;box-sizing:border-box;z-index:1}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.item-native*/.item-native.sc-ion-item-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.item-native::-moz-focus-inner*/.item-native.sc-ion-item-ios::-moz-focus-inner{border:0}/*!@.item-native::after*/.item-native.sc-ion-item-ios::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0;transition:var(--transition);z-index:-1}/*!@button, a*/button.sc-ion-item-ios,a.sc-ion-item-ios{cursor:pointer;user-select:none;-webkit-user-drag:none}/*!@.item-inner*/.item-inner.sc-ion-item-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--inner-padding-start);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:flex;position:relative;flex:1;flex-direction:inherit;align-items:inherit;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);box-shadow:var(--inner-box-shadow);overflow:inherit;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.item-inner*/.item-inner.sc-ion-item-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end))}}/*!@.item-detail-icon*/.item-detail-icon.sc-ion-item-ios{color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}/*!@::slotted(ion-icon)*/.sc-ion-item-ios-s>ion-icon{font-size:1.6em}/*!@::slotted(ion-button)*/.sc-ion-item-ios-s>ion-button{--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}/*!@::slotted(ion-label:not([slot=end]))*/.sc-ion-item-ios-s>ion-label:not([slot=end]){flex:1}/*!@:host(.item-input)*/.item-input.sc-ion-item-ios-h{align-items:center}/*!@.input-wrapper*/.input-wrapper.sc-ion-item-ios{display:flex;flex:1;flex-direction:inherit;align-items:inherit;align-self:stretch;text-overflow:ellipsis;overflow:inherit;box-sizing:border-box}/*!@:host(.item-label-stacked),\n:host(.item-label-floating)*/.item-label-stacked.sc-ion-item-ios-h,.item-label-floating.sc-ion-item-ios-h{align-items:start}/*!@:host(.item-label-stacked) .input-wrapper,\n:host(.item-label-floating) .input-wrapper*/.item-label-stacked.sc-ion-item-ios-h .input-wrapper.sc-ion-item-ios,.item-label-floating.sc-ion-item-ios-h .input-wrapper.sc-ion-item-ios{flex:1;flex-direction:column}/*!@.item-highlight,\n.item-inner-highlight*/.item-highlight.sc-ion-item-ios,.item-inner-highlight.sc-ion-item-ios{left:0;right:0;bottom:0;position:absolute;background:var(--highlight-background);z-index:1}/*!@.item-highlight*/.item-highlight.sc-ion-item-ios{height:var(--full-highlight-height)}/*!@.item-inner-highlight*/.item-inner-highlight.sc-ion-item-ios{height:var(--inset-highlight-height)}/*!@:host(.item-interactive.item-has-focus),\n:host(.item-interactive.ion-touched.ion-invalid)*/.item-interactive.item-has-focus.sc-ion-item-ios-h,.item-interactive.ion-touched.ion-invalid.sc-ion-item-ios-h{--full-highlight-height:calc(var(--highlight-height) * var(--show-full-highlight));--inset-highlight-height:calc(var(--highlight-height) * var(--show-inset-highlight))}/*!@:host(.item-interactive.item-has-focus)*/.item-interactive.item-has-focus.sc-ion-item-ios-h{--highlight-background:var(--highlight-color-focused)}/*!@:host(.item-interactive.ion-valid)*/.item-interactive.ion-valid.sc-ion-item-ios-h{--highlight-background:var(--highlight-color-valid)}/*!@:host(.item-interactive.ion-invalid)*/.item-interactive.ion-invalid.sc-ion-item-ios-h{--highlight-background:var(--highlight-color-invalid)}/*!@:host(:not(.item-label)) ::slotted(ion-select)*/.sc-ion-item-ios-h:not(.item-label) .sc-ion-item-ios-s>ion-select{--padding-start:0;max-width:none}/*!@:host(.item-label-stacked) ::slotted(ion-select),\n:host(.item-label-floating) ::slotted(ion-select)*/.sc-ion-item-ios-h.item-label-stacked .sc-ion-item-ios-s>ion-select,.sc-ion-item-ios-h.item-label-floating .sc-ion-item-ios-s>ion-select{--padding-top:8px;--padding-bottom:8px;--padding-start:0;align-self:stretch;width:100%;max-width:100%}/*!@:host(:not(.item-label)) ::slotted(ion-datetime)*/.sc-ion-item-ios-h:not(.item-label) .sc-ion-item-ios-s>ion-datetime{--padding-start:0}/*!@:host(.item-label-stacked) ::slotted(ion-datetime),\n:host(.item-label-floating) ::slotted(ion-datetime)*/.sc-ion-item-ios-h.item-label-stacked .sc-ion-item-ios-s>ion-datetime,.sc-ion-item-ios-h.item-label-floating .sc-ion-item-ios-s>ion-datetime{--padding-start:0;width:100%}/*!@:host(.item-multiple-inputs) ::slotted(ion-checkbox),\n:host(.item-multiple-inputs) ::slotted(ion-datetime),\n:host(.item-multiple-inputs) ::slotted(ion-radio),\n:host(.item-multiple-inputs) ::slotted(ion-select)*/.sc-ion-item-ios-h.item-multiple-inputs .sc-ion-item-ios-s>ion-checkbox,.sc-ion-item-ios-h.item-multiple-inputs .sc-ion-item-ios-s>ion-datetime,.sc-ion-item-ios-h.item-multiple-inputs .sc-ion-item-ios-s>ion-radio,.sc-ion-item-ios-h.item-multiple-inputs .sc-ion-item-ios-s>ion-select{position:relative}/*!@:host(.item-textarea)*/.item-textarea.sc-ion-item-ios-h{align-items:stretch}/*!@::slotted(ion-reorder[slot])*/.sc-ion-item-ios-s>ion-reorder[slot]{margin-top:0;margin-bottom:0}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-item-ios{color:var(--ripple-color)}/*!@:host*/.sc-ion-item-ios-h{--min-height:44px;--transition:background-color 200ms linear, opacity 200ms linear;--padding-start:20px;--inner-padding-end:10px;--inner-border-width:0px 0px 0.55px 0px;--background:var(--ion-item-background, var(--ion-background-color, #fff));--background-activated:#000;--background-focused:#000;--background-hover:currentColor;--background-activated-opacity:.12;--background-focused-opacity:.15;--background-hover-opacity:.04;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));--color:var(--ion-item-color, var(--ion-text-color, #000));--highlight-height:0;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);font-size:17px}/*!@:host(.ion-activated)*/.ion-activated.sc-ion-item-ios-h{--transition:none}/*!@:host(.ion-color.ion-focused) .item-native::after*/.ion-color.ion-focused.sc-ion-item-ios-h .item-native.sc-ion-item-ios::after{background:#000;opacity:0.15}/*!@:host(.ion-color.ion-activated) .item-native::after*/.ion-color.ion-activated.sc-ion-item-ios-h .item-native.sc-ion-item-ios::after{background:#000;opacity:0.12}/*!@:host(.item-interactive)*/.item-interactive.sc-ion-item-ios-h{--show-full-highlight:0;--show-inset-highlight:1}/*!@:host(.item-lines-full)*/.item-lines-full.sc-ion-item-ios-h{--border-width:0px 0px 0.55px 0px;--show-full-highlight:1;--show-inset-highlight:0}/*!@:host(.item-lines-inset)*/.item-lines-inset.sc-ion-item-ios-h{--inner-border-width:0px 0px 0.55px 0px;--show-full-highlight:0;--show-inset-highlight:1}/*!@:host(.item-lines-inset),\n:host(.item-lines-none)*/.item-lines-inset.sc-ion-item-ios-h,.item-lines-none.sc-ion-item-ios-h{--border-width:0px;--show-full-highlight:0}/*!@:host(.item-lines-full),\n:host(.item-lines-none)*/.item-lines-full.sc-ion-item-ios-h,.item-lines-none.sc-ion-item-ios-h{--inner-border-width:0px;--show-inset-highlight:0}/*!@::slotted([slot=start])*/.sc-ion-item-ios-s>[slot=start]{margin-left:0;margin-right:20px;margin-top:2px;margin-bottom:2px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=start])*/.sc-ion-item-ios-s>[slot=start]{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:20px;margin-inline-end:20px}}/*!@::slotted([slot=end])*/.sc-ion-item-ios-s>[slot=end]{margin-left:10px;margin-right:10px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=end])*/.sc-ion-item-ios-s>[slot=end]{margin-left:unset;margin-right:unset;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px}}/*!@::slotted(ion-icon[slot=start]),\n::slotted(ion-icon[slot=end])*/.sc-ion-item-ios-s>ion-icon[slot=start],.sc-ion-item-ios-s>ion-icon[slot=end]{margin-top:7px;margin-bottom:7px}/*!@::slotted(ion-toggle[slot=start]),\n::slotted(ion-toggle[slot=end])*/.sc-ion-item-ios-s>ion-toggle[slot=start],.sc-ion-item-ios-s>ion-toggle[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}/*!@:host(.item-label-stacked) ::slotted([slot=end]),\n:host(.item-label-floating) ::slotted([slot=end])*/.sc-ion-item-ios-h.item-label-stacked .sc-ion-item-ios-s>[slot=end],.sc-ion-item-ios-h.item-label-floating .sc-ion-item-ios-s>[slot=end]{margin-top:7px;margin-bottom:7px}/*!@::slotted(.button-small)*/.sc-ion-item-ios-s>.button-small{--padding-top:0px;--padding-bottom:0px;--padding-start:.5em;--padding-end:.5em;height:24px;font-size:13px}/*!@::slotted(ion-avatar)*/.sc-ion-item-ios-s>ion-avatar{width:36px;height:36px}/*!@::slotted(ion-thumbnail)*/.sc-ion-item-ios-s>ion-thumbnail{width:56px;height:56px}/*!@::slotted(ion-avatar[slot=end]),\n::slotted(ion-thumbnail[slot=end])*/.sc-ion-item-ios-s>ion-avatar[slot=end],.sc-ion-item-ios-s>ion-thumbnail[slot=end]{margin-left:10px;margin-right:10px;margin-top:10px;margin-bottom:10px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-avatar[slot=end]),\n::slotted(ion-thumbnail[slot=end])*/.sc-ion-item-ios-s>ion-avatar[slot=end],.sc-ion-item-ios-s>ion-thumbnail[slot=end]{margin-left:unset;margin-right:unset;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px}}/*!@:host(.item-radio) ::slotted(ion-label),\n:host(.item-toggle) ::slotted(ion-label)*/.sc-ion-item-ios-h.item-radio .sc-ion-item-ios-s>ion-label,.sc-ion-item-ios-h.item-toggle .sc-ion-item-ios-s>ion-label{margin-left:0px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.item-radio) ::slotted(ion-label),\n:host(.item-toggle) ::slotted(ion-label)*/.sc-ion-item-ios-h.item-radio .sc-ion-item-ios-s>ion-label,.sc-ion-item-ios-h.item-toggle .sc-ion-item-ios-s>ion-label{margin-left:unset;-webkit-margin-start:0px;margin-inline-start:0px}}/*!@::slotted(ion-label)*/.sc-ion-item-ios-s>ion-label{margin-left:0;margin-right:8px;margin-top:10px;margin-bottom:10px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-label)*/.sc-ion-item-ios-s>ion-label{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px}}/*!@:host(.item-label-floating),\n:host(.item-label-stacked)*/.item-label-floating.sc-ion-item-ios-h,.item-label-stacked.sc-ion-item-ios-h{--min-height:68px}/*!@:host(.item-label-stacked) ::slotted(ion-select),\n:host(.item-label-floating) ::slotted(ion-select)*/.sc-ion-item-ios-h.item-label-stacked .sc-ion-item-ios-s>ion-select,.sc-ion-item-ios-h.item-label-floating .sc-ion-item-ios-s>ion-select{--padding-top:8px;--padding-bottom:8px;--padding-start:0px}/*!@:host(.item-label-fixed) ::slotted(ion-select),\n:host(.item-label-fixed) ::slotted(ion-datetime)*/.sc-ion-item-ios-h.item-label-fixed .sc-ion-item-ios-s>ion-select,.sc-ion-item-ios-h.item-label-fixed .sc-ion-item-ios-s>ion-datetime{--padding-start:0}';

    const itemMdCss =
      '/*!@:host*/.sc-ion-item-md-h{--border-radius:0px;--border-width:0px;--border-style:solid;--padding-top:0px;--padding-bottom:0px;--padding-end:0px;--padding-start:0px;--inner-border-width:0px;--inner-padding-top:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;--inner-padding-end:0px;--inner-box-shadow:none;--show-full-highlight:0;--show-inset-highlight:0;--detail-icon-color:initial;--detail-icon-font-size:20px;--detail-icon-opacity:0.25;--color-activated:var(--color);--color-focused:var(--color);--color-hover:var(--color);--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:block;position:relative;align-items:center;justify-content:space-between;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);text-align:initial;text-decoration:none;overflow:hidden;box-sizing:border-box}/*!@:host(.ion-color) .item-native*/.ion-color.sc-ion-item-md-h .item-native.sc-ion-item-md{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(.ion-color) .item-native,\n:host(.ion-color) .item-inner*/.ion-color.sc-ion-item-md-h .item-native.sc-ion-item-md,.ion-color.sc-ion-item-md-h .item-inner.sc-ion-item-md{border-color:var(--ion-color-shade)}/*!@:host(.ion-activated) .item-native*/.ion-activated.sc-ion-item-md-h .item-native.sc-ion-item-md{color:var(--color-activated)}/*!@:host(.ion-activated) .item-native::after*/.ion-activated.sc-ion-item-md-h .item-native.sc-ion-item-md::after{background:var(--background-activated);opacity:var(--background-activated-opacity)}/*!@:host(.ion-color.ion-activated) .item-native*/.ion-color.ion-activated.sc-ion-item-md-h .item-native.sc-ion-item-md{color:var(--ion-color-contrast)}/*!@:host(.ion-focused) .item-native*/.ion-focused.sc-ion-item-md-h .item-native.sc-ion-item-md{color:var(--color-focused)}/*!@:host(.ion-focused) .item-native::after*/.ion-focused.sc-ion-item-md-h .item-native.sc-ion-item-md::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}/*!@:host(.ion-color.ion-focused) .item-native*/.ion-color.ion-focused.sc-ion-item-md-h .item-native.sc-ion-item-md{color:var(--ion-color-contrast)}/*!@:host(.ion-color.ion-focused) .item-native::after*/.ion-color.ion-focused.sc-ion-item-md-h .item-native.sc-ion-item-md::after{background:var(--ion-color-contrast)}@media (any-hover: hover){/*!@:host(.ion-activatable:hover) .item-native*/.ion-activatable.sc-ion-item-md-h:hover .item-native.sc-ion-item-md{color:var(--color-hover)}/*!@:host(.ion-activatable:hover) .item-native::after*/.ion-activatable.sc-ion-item-md-h:hover .item-native.sc-ion-item-md::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}/*!@:host(.ion-color.ion-activatable:hover) .item-native*/.ion-color.ion-activatable.sc-ion-item-md-h:hover .item-native.sc-ion-item-md{color:var(--ion-color-contrast)}/*!@:host(.ion-color.ion-activatable:hover) .item-native::after*/.ion-color.ion-activatable.sc-ion-item-md-h:hover .item-native.sc-ion-item-md::after{background:var(--ion-color-contrast)}}/*!@:host(.item-interactive-disabled:not(.item-multiple-inputs))*/.item-interactive-disabled.sc-ion-item-md-h:not(.item-multiple-inputs){cursor:default;pointer-events:none}/*!@:host(.item-disabled)*/.item-disabled.sc-ion-item-md-h{cursor:default;opacity:0.3;pointer-events:none}/*!@.item-native*/.item-native.sc-ion-item-md{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:flex;position:relative;align-items:inherit;justify-content:inherit;width:100%;min-height:var(--min-height);transition:var(--transition);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);outline:none;background:var(--background);overflow:inherit;box-sizing:border-box;z-index:1}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.item-native*/.item-native.sc-ion-item-md{padding-left:unset;padding-right:unset;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.item-native::-moz-focus-inner*/.item-native.sc-ion-item-md::-moz-focus-inner{border:0}/*!@.item-native::after*/.item-native.sc-ion-item-md::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0;transition:var(--transition);z-index:-1}/*!@button, a*/button.sc-ion-item-md,a.sc-ion-item-md{cursor:pointer;user-select:none;-webkit-user-drag:none}/*!@.item-inner*/.item-inner.sc-ion-item-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--inner-padding-start);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:flex;position:relative;flex:1;flex-direction:inherit;align-items:inherit;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);box-shadow:var(--inner-box-shadow);overflow:inherit;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.item-inner*/.item-inner.sc-ion-item-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end))}}/*!@.item-detail-icon*/.item-detail-icon.sc-ion-item-md{color:var(--detail-icon-color);font-size:var(--detail-icon-font-size);opacity:var(--detail-icon-opacity)}/*!@::slotted(ion-icon)*/.sc-ion-item-md-s>ion-icon{font-size:1.6em}/*!@::slotted(ion-button)*/.sc-ion-item-md-s>ion-button{--margin-top:0;--margin-bottom:0;--margin-start:0;--margin-end:0;z-index:1}/*!@::slotted(ion-label:not([slot=end]))*/.sc-ion-item-md-s>ion-label:not([slot=end]){flex:1}/*!@:host(.item-input)*/.item-input.sc-ion-item-md-h{align-items:center}/*!@.input-wrapper*/.input-wrapper.sc-ion-item-md{display:flex;flex:1;flex-direction:inherit;align-items:inherit;align-self:stretch;text-overflow:ellipsis;overflow:inherit;box-sizing:border-box}/*!@:host(.item-label-stacked),\n:host(.item-label-floating)*/.item-label-stacked.sc-ion-item-md-h,.item-label-floating.sc-ion-item-md-h{align-items:start}/*!@:host(.item-label-stacked) .input-wrapper,\n:host(.item-label-floating) .input-wrapper*/.item-label-stacked.sc-ion-item-md-h .input-wrapper.sc-ion-item-md,.item-label-floating.sc-ion-item-md-h .input-wrapper.sc-ion-item-md{flex:1;flex-direction:column}/*!@.item-highlight,\n.item-inner-highlight*/.item-highlight.sc-ion-item-md,.item-inner-highlight.sc-ion-item-md{left:0;right:0;bottom:0;position:absolute;background:var(--highlight-background);z-index:1}/*!@.item-highlight*/.item-highlight.sc-ion-item-md{height:var(--full-highlight-height)}/*!@.item-inner-highlight*/.item-inner-highlight.sc-ion-item-md{height:var(--inset-highlight-height)}/*!@:host(.item-interactive.item-has-focus),\n:host(.item-interactive.ion-touched.ion-invalid)*/.item-interactive.item-has-focus.sc-ion-item-md-h,.item-interactive.ion-touched.ion-invalid.sc-ion-item-md-h{--full-highlight-height:calc(var(--highlight-height) * var(--show-full-highlight));--inset-highlight-height:calc(var(--highlight-height) * var(--show-inset-highlight))}/*!@:host(.item-interactive.item-has-focus)*/.item-interactive.item-has-focus.sc-ion-item-md-h{--highlight-background:var(--highlight-color-focused)}/*!@:host(.item-interactive.ion-valid)*/.item-interactive.ion-valid.sc-ion-item-md-h{--highlight-background:var(--highlight-color-valid)}/*!@:host(.item-interactive.ion-invalid)*/.item-interactive.ion-invalid.sc-ion-item-md-h{--highlight-background:var(--highlight-color-invalid)}/*!@:host(:not(.item-label)) ::slotted(ion-select)*/.sc-ion-item-md-h:not(.item-label) .sc-ion-item-md-s>ion-select{--padding-start:0;max-width:none}/*!@:host(.item-label-stacked) ::slotted(ion-select),\n:host(.item-label-floating) ::slotted(ion-select)*/.sc-ion-item-md-h.item-label-stacked .sc-ion-item-md-s>ion-select,.sc-ion-item-md-h.item-label-floating .sc-ion-item-md-s>ion-select{--padding-top:8px;--padding-bottom:8px;--padding-start:0;align-self:stretch;width:100%;max-width:100%}/*!@:host(:not(.item-label)) ::slotted(ion-datetime)*/.sc-ion-item-md-h:not(.item-label) .sc-ion-item-md-s>ion-datetime{--padding-start:0}/*!@:host(.item-label-stacked) ::slotted(ion-datetime),\n:host(.item-label-floating) ::slotted(ion-datetime)*/.sc-ion-item-md-h.item-label-stacked .sc-ion-item-md-s>ion-datetime,.sc-ion-item-md-h.item-label-floating .sc-ion-item-md-s>ion-datetime{--padding-start:0;width:100%}/*!@:host(.item-multiple-inputs) ::slotted(ion-checkbox),\n:host(.item-multiple-inputs) ::slotted(ion-datetime),\n:host(.item-multiple-inputs) ::slotted(ion-radio),\n:host(.item-multiple-inputs) ::slotted(ion-select)*/.sc-ion-item-md-h.item-multiple-inputs .sc-ion-item-md-s>ion-checkbox,.sc-ion-item-md-h.item-multiple-inputs .sc-ion-item-md-s>ion-datetime,.sc-ion-item-md-h.item-multiple-inputs .sc-ion-item-md-s>ion-radio,.sc-ion-item-md-h.item-multiple-inputs .sc-ion-item-md-s>ion-select{position:relative}/*!@:host(.item-textarea)*/.item-textarea.sc-ion-item-md-h{align-items:stretch}/*!@::slotted(ion-reorder[slot])*/.sc-ion-item-md-s>ion-reorder[slot]{margin-top:0;margin-bottom:0}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-item-md{color:var(--ripple-color)}/*!@:host*/.sc-ion-item-md-h{--min-height:48px;--background:var(--ion-item-background, var(--ion-background-color, #fff));--background-activated:transparent;--background-focused:currentColor;--background-hover:currentColor;--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));--color:var(--ion-item-color, var(--ion-text-color, #000));--transition:opacity 15ms linear, background-color 15ms linear;--padding-start:16px;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));--inner-padding-end:16px;--inner-border-width:0 0 1px 0;--highlight-height:2px;--highlight-color-focused:var(--ion-color-primary, #3880ff);--highlight-color-valid:var(--ion-color-success, #2dd36f);--highlight-color-invalid:var(--ion-color-danger, #eb445a);font-size:16px;font-weight:normal;text-transform:none}/*!@:host(.ion-color.ion-activated) .item-native::after*/.ion-color.ion-activated.sc-ion-item-md-h .item-native.sc-ion-item-md::after{background:transparent}/*!@:host(.item-interactive)*/.item-interactive.sc-ion-item-md-h{--border-width:0 0 1px 0;--inner-border-width:0;--show-full-highlight:1;--show-inset-highlight:0}/*!@:host(.item-lines-full)*/.item-lines-full.sc-ion-item-md-h{--border-width:0 0 1px 0;--show-full-highlight:1;--show-inset-highlight:0}/*!@:host(.item-lines-inset)*/.item-lines-inset.sc-ion-item-md-h{--inner-border-width:0 0 1px 0;--show-full-highlight:0;--show-inset-highlight:1}/*!@:host(.item-lines-inset),\n:host(.item-lines-none)*/.item-lines-inset.sc-ion-item-md-h,.item-lines-none.sc-ion-item-md-h{--border-width:0;--show-full-highlight:0}/*!@:host(.item-lines-full),\n:host(.item-lines-none)*/.item-lines-full.sc-ion-item-md-h,.item-lines-none.sc-ion-item-md-h{--inner-border-width:0;--show-inset-highlight:0}/*!@:host(.item-multi-line) ::slotted([slot=start]),\n:host(.item-multi-line) ::slotted([slot=end])*/.sc-ion-item-md-h.item-multi-line .sc-ion-item-md-s>[slot=start],.sc-ion-item-md-h.item-multi-line .sc-ion-item-md-s>[slot=end]{margin-top:16px;margin-bottom:16px;align-self:flex-start}/*!@::slotted([slot=start])*/.sc-ion-item-md-s>[slot=start]{margin-right:32px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=start])*/.sc-ion-item-md-s>[slot=start]{margin-right:unset;-webkit-margin-end:32px;margin-inline-end:32px}}/*!@::slotted([slot=end])*/.sc-ion-item-md-s>[slot=end]{margin-left:32px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=end])*/.sc-ion-item-md-s>[slot=end]{margin-left:unset;-webkit-margin-start:32px;margin-inline-start:32px}}/*!@::slotted(ion-icon)*/.sc-ion-item-md-s>ion-icon{color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);font-size:24px}/*!@:host(.ion-color) ::slotted(ion-icon)*/.sc-ion-item-md-h.ion-color .sc-ion-item-md-s>ion-icon{color:var(--ion-color-contrast)}/*!@::slotted(ion-icon[slot])*/.sc-ion-item-md-s>ion-icon[slot]{margin-top:12px;margin-bottom:12px}/*!@::slotted(ion-icon[slot=start])*/.sc-ion-item-md-s>ion-icon[slot=start]{margin-right:32px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon[slot=start])*/.sc-ion-item-md-s>ion-icon[slot=start]{margin-right:unset;-webkit-margin-end:32px;margin-inline-end:32px}}/*!@::slotted(ion-icon[slot=end])*/.sc-ion-item-md-s>ion-icon[slot=end]{margin-left:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon[slot=end])*/.sc-ion-item-md-s>ion-icon[slot=end]{margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}/*!@::slotted(ion-toggle[slot=start]),\n::slotted(ion-toggle[slot=end])*/.sc-ion-item-md-s>ion-toggle[slot=start],.sc-ion-item-md-s>ion-toggle[slot=end]{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}/*!@::slotted(ion-note)*/.sc-ion-item-md-s>ion-note{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;align-self:flex-start;font-size:11px}/*!@::slotted(ion-note[slot])*/.sc-ion-item-md-s>ion-note[slot]{padding-left:0;padding-right:0;padding-top:18px;padding-bottom:10px}/*!@::slotted(ion-note[slot=start])*/.sc-ion-item-md-s>ion-note[slot=start]{padding-right:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-note[slot=start])*/.sc-ion-item-md-s>ion-note[slot=start]{padding-right:unset;-webkit-padding-end:16px;padding-inline-end:16px}}/*!@::slotted(ion-note[slot=end])*/.sc-ion-item-md-s>ion-note[slot=end]{padding-left:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-note[slot=end])*/.sc-ion-item-md-s>ion-note[slot=end]{padding-left:unset;-webkit-padding-start:16px;padding-inline-start:16px}}/*!@::slotted(ion-avatar)*/.sc-ion-item-md-s>ion-avatar{width:40px;height:40px}/*!@::slotted(ion-thumbnail)*/.sc-ion-item-md-s>ion-thumbnail{width:56px;height:56px}/*!@::slotted(ion-avatar),\n::slotted(ion-thumbnail)*/.sc-ion-item-md-s>ion-avatar,.sc-ion-item-md-s>ion-thumbnail{margin-top:8px;margin-bottom:8px}/*!@::slotted(ion-avatar[slot=start]),\n::slotted(ion-thumbnail[slot=start])*/.sc-ion-item-md-s>ion-avatar[slot=start],.sc-ion-item-md-s>ion-thumbnail[slot=start]{margin-right:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-avatar[slot=start]),\n::slotted(ion-thumbnail[slot=start])*/.sc-ion-item-md-s>ion-avatar[slot=start],.sc-ion-item-md-s>ion-thumbnail[slot=start]{margin-right:unset;-webkit-margin-end:16px;margin-inline-end:16px}}/*!@::slotted(ion-avatar[slot=end]),\n::slotted(ion-thumbnail[slot=end])*/.sc-ion-item-md-s>ion-avatar[slot=end],.sc-ion-item-md-s>ion-thumbnail[slot=end]{margin-left:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-avatar[slot=end]),\n::slotted(ion-thumbnail[slot=end])*/.sc-ion-item-md-s>ion-avatar[slot=end],.sc-ion-item-md-s>ion-thumbnail[slot=end]{margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}/*!@::slotted(ion-label)*/.sc-ion-item-md-s>ion-label{margin-left:0;margin-right:0;margin-top:11px;margin-bottom:10px}/*!@:host(.item-label-stacked) ::slotted([slot=end]),\n:host(.item-label-floating) ::slotted([slot=end])*/.sc-ion-item-md-h.item-label-stacked .sc-ion-item-md-s>[slot=end],.sc-ion-item-md-h.item-label-floating .sc-ion-item-md-s>[slot=end]{margin-top:7px;margin-bottom:7px}/*!@:host(.item-label-fixed) ::slotted(ion-select),\n:host(.item-label-fixed) ::slotted(ion-datetime)*/.sc-ion-item-md-h.item-label-fixed .sc-ion-item-md-s>ion-select,.sc-ion-item-md-h.item-label-fixed .sc-ion-item-md-s>ion-datetime{--padding-start:8px}/*!@:host(.item-toggle) ::slotted(ion-label),\n:host(.item-radio) ::slotted(ion-label)*/.sc-ion-item-md-h.item-toggle .sc-ion-item-md-s>ion-label,.sc-ion-item-md-h.item-radio .sc-ion-item-md-s>ion-label{margin-left:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.item-toggle) ::slotted(ion-label),\n:host(.item-radio) ::slotted(ion-label)*/.sc-ion-item-md-h.item-toggle .sc-ion-item-md-s>ion-label,.sc-ion-item-md-h.item-radio .sc-ion-item-md-s>ion-label{margin-left:unset;-webkit-margin-start:0;margin-inline-start:0}}/*!@::slotted(.button-small)*/.sc-ion-item-md-s>.button-small{--padding-top:0;--padding-bottom:0;--padding-start:.6em;--padding-end:.6em;height:25px;font-size:12px}/*!@:host(.item-label-floating),\n:host(.item-label-stacked)*/.item-label-floating.sc-ion-item-md-h,.item-label-stacked.sc-ion-item-md-h{--min-height:55px}/*!@:host(.item-label-stacked) ::slotted(ion-select),\n:host(.item-label-floating) ::slotted(ion-select)*/.sc-ion-item-md-h.item-label-stacked .sc-ion-item-md-s>ion-select,.sc-ion-item-md-h.item-label-floating .sc-ion-item-md-s>ion-select{--padding-top:8px;--padding-bottom:8px;--padding-start:0}/*!@:host(.item-has-focus:not(.ion-color)) ::slotted(.label-stacked),\n:host(.item-has-focus:not(.ion-color)) ::slotted(.label-floating)*/.sc-ion-item-md-h.item-has-focus:not(.ion-color) .sc-ion-item-md-s>.label-stacked,.sc-ion-item-md-h.item-has-focus:not(.ion-color) .sc-ion-item-md-s>.label-floating{color:var(--ion-color-primary, #3880ff)}/*!@:host(.ion-color)*/.ion-color.sc-ion-item-md-h{--highlight-color-focused:var(--ion-color-contrast)}/*!@:host(.item-label-color)*/.item-label-color.sc-ion-item-md-h{--highlight-color-focused:var(--ion-color-base)}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @slot - Content is placed between the named slots if provided without a slot.
     * @slot start - Content is placed to the left of the item text in LTR, and to the right in RTL.
     * @slot end - Content is placed to the right of the item text in LTR, and to the left in RTL.
     *
     * @part native - The native HTML button, anchor or div element that wraps all child elements.
     * @part detail-icon - The chevron icon for the item. Only applies when `detail="true"`.
     */
    class Item {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.labelColorStyles = {};
        this.itemStyles = new Map();
        this.multipleInputs = false;
        /**
         * If `true`, a button tag will be rendered and the item will be tappable.
         */
        this.button = false;
        /**
         * The icon to use when `detail` is set to `true`.
         */
        this.detailIcon = 'chevron-forward';
        /**
         * If `true`, the user cannot interact with the item.
         */
        this.disabled = false;
        /**
         * When using a router, it specifies the transition direction when navigating to
         * another page using `href`.
         */
        this.routerDirection = 'forward';
        /**
         * The type of the button. Only used when an `onclick` or `button` property is present.
         */
        this.type = 'button';
      }
      labelColorChanged(ev) {
        const { color } = this;
        // There will be a conflict with item color if
        // we apply the label color to item, so we ignore
        // the label color if the user sets a color on item
        if (color === undefined) {
          this.labelColorStyles = ev.detail;
        }
      }
      itemStyle(ev) {
        ev.stopPropagation();
        const tagName = ev.target.tagName;
        const updatedStyles = ev.detail;
        const newStyles = {};
        const childStyles = this.itemStyles.get(tagName) || {};
        let hasStyleChange = false;
        Object.keys(updatedStyles).forEach(key => {
          if (updatedStyles[key]) {
            const itemKey = `item-${key}`;
            if (!childStyles[itemKey]) {
              hasStyleChange = true;
            }
            newStyles[itemKey] = true;
          }
        });
        if (!hasStyleChange && Object.keys(newStyles).length !== Object.keys(childStyles).length) {
          hasStyleChange = true;
        }
        if (hasStyleChange) {
          this.itemStyles.set(tagName, newStyles);
          forceUpdate$1(this);
        }
      }
      componentDidUpdate() {
        // Do not use @Listen here to avoid making all items
        // appear as clickable to screen readers
        // https://github.com/ionic-team/ionic-framework/issues/22011
        const input = this.getFirstInput();
        if (input && !this.clickListener) {
          this.clickListener = ev => this.delegateFocus(ev, input);
          this.el.addEventListener('click', this.clickListener);
        }
      }
      disconnectedCallback() {
        const input = this.getFirstInput();
        if (input && this.clickListener) {
          this.el.removeEventListener('click', this.clickListener);
          this.clickListener = undefined;
        }
      }
      componentDidLoad() {
        raf(() => this.setMultipleInputs());
      }
      // If the item contains multiple clickable elements and/or inputs, then the item
      // should not have a clickable input cover over the entire item to prevent
      // interfering with their individual click events
      setMultipleInputs() {
        // The following elements have a clickable cover that is relative to the entire item
        const covers = this.el.querySelectorAll('ion-checkbox, ion-datetime, ion-select, ion-radio');
        // The following elements can accept focus alongside the previous elements
        // therefore if these elements are also a child of item, we don't want the
        // input cover on top of those interfering with their clicks
        const inputs = this.el.querySelectorAll('ion-input, ion-range, ion-searchbar, ion-segment, ion-textarea, ion-toggle');
        // The following elements should also stay clickable when an input with cover is present
        const clickables = this.el.querySelectorAll('ion-anchor, ion-button, a, button');
        // Check for multiple inputs to change the position of the input cover to relative
        // for all of the covered inputs above
        this.multipleInputs = covers.length + inputs.length > 1 || covers.length + clickables.length > 1 || (covers.length > 0 && this.isClickable());
      }
      // If the item contains an input including a checkbox, datetime, select, or radio
      // then the item will have a clickable input cover that covers the item
      // that should get the hover, focused and activated states UNLESS it has multiple
      // inputs, then those need to individually get each click
      hasCover() {
        const inputs = this.el.querySelectorAll('ion-checkbox, ion-datetime, ion-select, ion-radio');
        return inputs.length === 1 && !this.multipleInputs;
      }
      // If the item has an href or button property it will render a native
      // anchor or button that is clickable
      isClickable() {
        return this.href !== undefined || this.button;
      }
      canActivate() {
        return this.isClickable() || this.hasCover();
      }
      getFirstInput() {
        const inputs = this.el.querySelectorAll('ion-input, ion-textarea');
        return inputs[0];
      }
      // This is needed for WebKit due to a delegatesFocus bug where
      // clicking on the left padding of an item is not focusing the input
      // but is opening the keyboard. It will no longer be needed with
      // iOS 14.
      delegateFocus(ev, input) {
        const clickedItem = ev.target.tagName === 'ION-ITEM';
        let firstActive = false;
        // If the first input is the same as the active element we need
        // to focus the first input again, but if the active element
        // is another input inside of the item we shouldn't switch focus
        if (document.activeElement) {
          firstActive = input.querySelector('input, textarea') === document.activeElement;
        }
        // Only focus the first input if we clicked on an ion-item
        // and the first input exists
        if (clickedItem && firstActive) {
          input.fireFocusEvents = false;
          input.setBlur();
          input.setFocus();
          raf(() => {
            input.fireFocusEvents = true;
          });
        }
      }
      render() {
        const { detail, detailIcon, download, labelColorStyles, lines, disabled, href, rel, target, routerAnimation, routerDirection } = this;
        const childStyles = {};
        const mode = getIonMode$1(this);
        const clickable = this.isClickable();
        const canActivate = this.canActivate();
        const TagType = clickable ? (href === undefined ? 'button' : 'a') : 'div';
        const attrs =
          TagType === 'button'
            ? { type: this.type }
            : {
                download,
                href,
                rel,
                target,
              };
        // Only set onClick if the item is clickable to prevent screen
        // readers from reading all items as clickable
        const clickFn = clickable
          ? {
              onClick: ev => {
                openURL(href, ev, routerDirection, routerAnimation);
              },
            }
          : {};
        const showDetail = detail !== undefined ? detail : mode === 'ios' && clickable;
        this.itemStyles.forEach(value => {
          Object.assign(childStyles, value);
        });
        const ariaDisabled = disabled || childStyles['item-interactive-disabled'] ? 'true' : null;
        return hAsync(
          Host,
          {
            'aria-disabled': ariaDisabled,
            'class': Object.assign(
              Object.assign(Object.assign({}, childStyles), labelColorStyles),
              createColorClasses$1(this.color, {
                'item': true,
                [mode]: true,
                [`item-lines-${lines}`]: lines !== undefined,
                'item-disabled': disabled,
                'in-list': hostContext('ion-list', this.el),
                'item-multiple-inputs': this.multipleInputs,
                'ion-activatable': canActivate,
                'ion-focusable': true,
              }),
            ),
          },
          hAsync(
            TagType,
            Object.assign({}, attrs, { class: 'item-native', part: 'native', disabled: disabled }, clickFn),
            hAsync('slot', { name: 'start' }),
            hAsync(
              'div',
              { class: 'item-inner' },
              hAsync('div', { class: 'input-wrapper' }, hAsync('slot', null)),
              hAsync('slot', { name: 'end' }),
              showDetail && hAsync('ion-icon', { 'icon': detailIcon, 'lazy': false, 'class': 'item-detail-icon', 'part': 'detail-icon', 'aria-hidden': 'true' }),
              hAsync('div', { class: 'item-inner-highlight' }),
            ),
            canActivate && mode === 'md' && hAsync('ion-ripple-effect', null),
          ),
          hAsync('div', { class: 'item-highlight' }),
        );
      }
      static get delegatesFocus() {
        return true;
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: itemIosCss,
          md: itemMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 57,
          $tagName$: 'ion-item',
          $members$: {
            color: [513],
            button: [4],
            detail: [4],
            detailIcon: [1, 'detail-icon'],
            disabled: [4],
            download: [1],
            href: [1],
            rel: [1],
            lines: [1],
            routerAnimation: [16],
            routerDirection: [1, 'router-direction'],
            target: [1],
            type: [1],
            multipleInputs: [32],
          },
          $listeners$: [
            [0, 'ionColor', 'labelColorChanged'],
            [0, 'ionStyle', 'itemStyle'],
          ],
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const itemDividerIosCss =
      '/*!@:host*/.sc-ion-item-divider-ios-h{--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--inner-padding-top:0px;--inner-padding-end:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:flex;align-items:center;justify-content:space-between;width:100%;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);overflow:hidden;z-index:100;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-item-divider-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@:host(.ion-color)*/.ion-color.sc-ion-item-divider-ios-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(.item-divider-sticky)*/.item-divider-sticky.sc-ion-item-divider-ios-h{position:sticky;top:0}/*!@.item-divider-inner*/.item-divider-inner.sc-ion-item-divider-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--inner-padding-start);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:flex;flex:1;flex-direction:inherit;align-items:inherit;align-self:stretch;min-height:inherit;border:0;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.item-divider-inner*/.item-divider-inner.sc-ion-item-divider-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end))}}/*!@.item-divider-wrapper*/.item-divider-wrapper.sc-ion-item-divider-ios{display:flex;flex:1;flex-direction:inherit;align-items:inherit;align-self:stretch;text-overflow:ellipsis;overflow:hidden}/*!@:host*/.sc-ion-item-divider-ios-h{--background:var(--ion-color-step-100, #e6e6e6);--color:var(--ion-color-step-850, #262626);--padding-start:20px;--inner-padding-end:10px;border-radius:0;position:relative;min-height:28px;font-size:17px;font-weight:600}/*!@:host([slot=start])*/[slot=start].sc-ion-item-divider-ios-h{margin-left:0;margin-right:20px;margin-top:2px;margin-bottom:2px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host([slot=start])*/[slot=start].sc-ion-item-divider-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:20px;margin-inline-end:20px}}/*!@:host([slot=end])*/[slot=end].sc-ion-item-divider-ios-h{margin-left:10px;margin-right:10px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host([slot=end])*/[slot=end].sc-ion-item-divider-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px}}/*!@::slotted(ion-icon[slot=start]),\n::slotted(ion-icon[slot=end])*/.sc-ion-item-divider-ios-s>ion-icon[slot=start],.sc-ion-item-divider-ios-s>ion-icon[slot=end]{margin-top:7px;margin-bottom:7px}/*!@::slotted(h1)*/.sc-ion-item-divider-ios-s>h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}/*!@::slotted(h2)*/.sc-ion-item-divider-ios-s>h2{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:17px;font-weight:normal}/*!@::slotted(h3),\n::slotted(h4),\n::slotted(h5),\n::slotted(h6)*/.sc-ion-item-divider-ios-s>h3,.sc-ion-item-divider-ios-s>h4,.sc-ion-item-divider-ios-s>h5,.sc-ion-item-divider-ios-s>h6{margin-left:0;margin-right:0;margin-top:0;margin-bottom:3px;font-size:14px;font-weight:normal;line-height:normal}/*!@::slotted(p)*/.sc-ion-item-divider-ios-s>p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.4);font-size:14px;line-height:normal;text-overflow:inherit;overflow:inherit}/*!@::slotted(h2:last-child) ::slotted(h3:last-child),\n::slotted(h4:last-child),\n::slotted(h5:last-child),\n::slotted(h6:last-child),\n::slotted(p:last-child)*/.sc-ion-item-divider-ios-s>h2:last-child -shadowcssslotted(h3:last-child),.sc-ion-item-divider-ios-s>h4:last-child,.sc-ion-item-divider-ios-s>h5:last-child,.sc-ion-item-divider-ios-s>h6:last-child,.sc-ion-item-divider-ios-s>p:last-child{margin-bottom:0}';

    const itemDividerMdCss =
      '/*!@:host*/.sc-ion-item-divider-md-h{--padding-top:0px;--padding-end:0px;--padding-bottom:0px;--padding-start:0px;--inner-padding-top:0px;--inner-padding-end:0px;--inner-padding-bottom:0px;--inner-padding-start:0px;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:flex;align-items:center;justify-content:space-between;width:100%;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);overflow:hidden;z-index:100;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-item-divider-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));padding-inline-start:calc(var(--padding-start) + var(--ion-safe-area-left, 0px));-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@:host(.ion-color)*/.ion-color.sc-ion-item-divider-md-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@:host(.item-divider-sticky)*/.item-divider-sticky.sc-ion-item-divider-md-h{position:sticky;top:0}/*!@.item-divider-inner*/.item-divider-inner.sc-ion-item-divider-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--inner-padding-start);padding-right:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-top:var(--inner-padding-top);padding-bottom:var(--inner-padding-bottom);display:flex;flex:1;flex-direction:inherit;align-items:inherit;align-self:stretch;min-height:inherit;border:0;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.item-divider-inner*/.item-divider-inner.sc-ion-item-divider-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--inner-padding-start);padding-inline-start:var(--inner-padding-start);-webkit-padding-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end));padding-inline-end:calc(var(--ion-safe-area-right, 0px) + var(--inner-padding-end))}}/*!@.item-divider-wrapper*/.item-divider-wrapper.sc-ion-item-divider-md{display:flex;flex:1;flex-direction:inherit;align-items:inherit;align-self:stretch;text-overflow:ellipsis;overflow:hidden}/*!@:host*/.sc-ion-item-divider-md-h{--background:var(--ion-background-color, #fff);--color:var(--ion-color-step-400, #999999);--padding-start:16px;--inner-padding-end:0;min-height:30px;border-bottom:1px solid var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));font-size:14px}/*!@::slotted([slot=start])*/.sc-ion-item-divider-md-s>[slot=start]{margin-right:32px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=start])*/.sc-ion-item-divider-md-s>[slot=start]{margin-right:unset;-webkit-margin-end:32px;margin-inline-end:32px}}/*!@::slotted([slot=end])*/.sc-ion-item-divider-md-s>[slot=end]{margin-left:32px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=end])*/.sc-ion-item-divider-md-s>[slot=end]{margin-left:unset;-webkit-margin-start:32px;margin-inline-start:32px}}/*!@::slotted(ion-label)*/.sc-ion-item-divider-md-s>ion-label{margin-left:0;margin-right:0;margin-top:13px;margin-bottom:10px}/*!@::slotted(ion-icon)*/.sc-ion-item-divider-md-s>ion-icon{color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.54);font-size:24px}/*!@:host(.ion-color) ::slotted(ion-icon)*/.sc-ion-item-divider-md-h.ion-color .sc-ion-item-divider-md-s>ion-icon{color:var(--ion-color-contrast)}/*!@::slotted(ion-icon[slot])*/.sc-ion-item-divider-md-s>ion-icon[slot]{margin-top:12px;margin-bottom:12px}/*!@::slotted(ion-icon[slot=start])*/.sc-ion-item-divider-md-s>ion-icon[slot=start]{margin-right:32px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon[slot=start])*/.sc-ion-item-divider-md-s>ion-icon[slot=start]{margin-right:unset;-webkit-margin-end:32px;margin-inline-end:32px}}/*!@::slotted(ion-icon[slot=end])*/.sc-ion-item-divider-md-s>ion-icon[slot=end]{margin-left:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-icon[slot=end])*/.sc-ion-item-divider-md-s>ion-icon[slot=end]{margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}/*!@::slotted(ion-note)*/.sc-ion-item-divider-md-s>ion-note{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;align-self:flex-start;font-size:11px}/*!@::slotted(ion-note[slot])*/.sc-ion-item-divider-md-s>ion-note[slot]{padding-left:0;padding-right:0;padding-top:18px;padding-bottom:10px}/*!@::slotted(ion-note[slot=start])*/.sc-ion-item-divider-md-s>ion-note[slot=start]{padding-right:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-note[slot=start])*/.sc-ion-item-divider-md-s>ion-note[slot=start]{padding-right:unset;-webkit-padding-end:16px;padding-inline-end:16px}}/*!@::slotted(ion-note[slot=end])*/.sc-ion-item-divider-md-s>ion-note[slot=end]{padding-left:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-note[slot=end])*/.sc-ion-item-divider-md-s>ion-note[slot=end]{padding-left:unset;-webkit-padding-start:16px;padding-inline-start:16px}}/*!@::slotted(ion-avatar)*/.sc-ion-item-divider-md-s>ion-avatar{width:40px;height:40px}/*!@::slotted(ion-thumbnail)*/.sc-ion-item-divider-md-s>ion-thumbnail{width:56px;height:56px}/*!@::slotted(ion-avatar),\n::slotted(ion-thumbnail)*/.sc-ion-item-divider-md-s>ion-avatar,.sc-ion-item-divider-md-s>ion-thumbnail{margin-top:8px;margin-bottom:8px}/*!@::slotted(ion-avatar[slot=start]),\n::slotted(ion-thumbnail[slot=start])*/.sc-ion-item-divider-md-s>ion-avatar[slot=start],.sc-ion-item-divider-md-s>ion-thumbnail[slot=start]{margin-right:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-avatar[slot=start]),\n::slotted(ion-thumbnail[slot=start])*/.sc-ion-item-divider-md-s>ion-avatar[slot=start],.sc-ion-item-divider-md-s>ion-thumbnail[slot=start]{margin-right:unset;-webkit-margin-end:16px;margin-inline-end:16px}}/*!@::slotted(ion-avatar[slot=end]),\n::slotted(ion-thumbnail[slot=end])*/.sc-ion-item-divider-md-s>ion-avatar[slot=end],.sc-ion-item-divider-md-s>ion-thumbnail[slot=end]{margin-left:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-avatar[slot=end]),\n::slotted(ion-thumbnail[slot=end])*/.sc-ion-item-divider-md-s>ion-avatar[slot=end],.sc-ion-item-divider-md-s>ion-thumbnail[slot=end]{margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}/*!@::slotted(h1)*/.sc-ion-item-divider-md-s>h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}/*!@::slotted(h2)*/.sc-ion-item-divider-md-s>h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}/*!@::slotted(h3, h4, h5, h6)*/.sc-ion-item-divider-md-s>h3,h4.sc-ion-item-divider-md,h5.sc-ion-item-divider-md,h6.sc-ion-item-divider-md{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal;line-height:normal}/*!@::slotted(p)*/.sc-ion-item-divider-md-s>p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;color:var(--ion-color-step-600, #666666);font-size:14px;line-height:normal;text-overflow:inherit;overflow:inherit}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @slot - Content is placed between the named slots if provided without a slot.
     * @slot start - Content is placed to the left of the divider text in LTR, and to the right in RTL.
     * @slot end - Content is placed to the right of the divider text in LTR, and to the left in RTL.
     */
    class ItemDivider {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * When it's set to `true`, the item-divider will stay visible when it reaches the top
         * of the viewport until the next `ion-item-divider` replaces it.
         *
         * This feature relies in `position:sticky`:
         * https://caniuse.com/#feat=css-sticky
         */
        this.sticky = false;
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: createColorClasses$1(this.color, {
              [mode]: true,
              'item-divider-sticky': this.sticky,
              'item': true,
            }),
          },
          hAsync('slot', { name: 'start' }),
          hAsync('div', { class: 'item-divider-inner' }, hAsync('div', { class: 'item-divider-wrapper' }, hAsync('slot', null)), hAsync('slot', { name: 'end' })),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: itemDividerIosCss,
          md: itemDividerMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-item-divider',
          $members$: {
            color: [513],
            sticky: [4],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const itemGroupIosCss = 'ion-item-group{display:block}';

    const itemGroupMdCss = 'ion-item-group{display:block}';

    class ItemGroup {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          role: 'group',
          class: {
            [mode]: true,
            // Used internally for styling
            [`item-group-${mode}`]: true,
            item: true,
          },
        });
      }
      static get style() {
        return {
          ios: itemGroupIosCss,
          md: itemGroupMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 32,
          $tagName$: 'ion-item-group',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const itemOptionIosCss =
      '/*!@:host*/.sc-ion-item-option-ios-h{--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff);background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit)}/*!@:host(.in-list.item-options-end:last-child)*/.in-list.item-options-end.sc-ion-item-option-ios-h:last-child{padding-right:calc(.7em + var(--ion-safe-area-right))}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-list.item-options-end:last-child)*/.in-list.item-options-end.sc-ion-item-option-ios-h:last-child{padding-right:unset;-webkit-padding-end:calc(.7em + var(--ion-safe-area-right));padding-inline-end:calc(.7em + var(--ion-safe-area-right))}}/*!@:host(.in-list.item-options-start:first-child)*/.in-list.item-options-start.sc-ion-item-option-ios-h:first-child{padding-left:calc(.7em + var(--ion-safe-area-left))}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-list.item-options-start:first-child)*/.in-list.item-options-start.sc-ion-item-option-ios-h:first-child{padding-left:unset;-webkit-padding-start:calc(.7em + var(--ion-safe-area-left));padding-inline-start:calc(.7em + var(--ion-safe-area-left))}}/*!@:host(.ion-color)*/.ion-color.sc-ion-item-option-ios-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@.button-native*/.button-native.sc-ion-item-option-ios{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-left:0.7em;padding-right:0.7em;padding-top:0;padding-bottom:0;display:inline-block;position:relative;width:100%;height:100%;border:0;outline:none;background:transparent;cursor:pointer;appearance:none;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-item-option-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:0.7em;padding-inline-start:0.7em;-webkit-padding-end:0.7em;padding-inline-end:0.7em}}/*!@.button-inner*/.button-inner.sc-ion-item-option-ios{display:flex;flex-flow:column nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%}/*!@.horizontal-wrapper*/.horizontal-wrapper.sc-ion-item-option-ios{display:flex;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%}/*!@::slotted(*)*/.sc-ion-item-option-ios-s>*{flex-shrink:0}/*!@::slotted([slot=start])*/.sc-ion-item-option-ios-s>[slot=start]{margin-left:0;margin-right:5px;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=start])*/.sc-ion-item-option-ios-s>[slot=start]{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:5px;margin-inline-end:5px}}/*!@::slotted([slot=end])*/.sc-ion-item-option-ios-s>[slot=end]{margin-left:5px;margin-right:0;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=end])*/.sc-ion-item-option-ios-s>[slot=end]{margin-left:unset;margin-right:unset;-webkit-margin-start:5px;margin-inline-start:5px;-webkit-margin-end:0;margin-inline-end:0}}/*!@::slotted([slot=icon-only])*/.sc-ion-item-option-ios-s>[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:10px;margin-right:10px;margin-top:0;margin-bottom:0;min-width:0.9em;font-size:1.8em}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=icon-only])*/.sc-ion-item-option-ios-s>[slot=icon-only]{margin-left:unset;margin-right:unset;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px}}/*!@:host(.item-option-expandable)*/.item-option-expandable.sc-ion-item-option-ios-h{flex-shrink:0;transition-duration:0;transition-property:none;transition-timing-function:cubic-bezier(0.65, 0.05, 0.36, 1)}/*!@:host(.item-option-disabled)*/.item-option-disabled.sc-ion-item-option-ios-h{pointer-events:none}/*!@:host(.item-option-disabled) .button-native*/.item-option-disabled.sc-ion-item-option-ios-h .button-native.sc-ion-item-option-ios{cursor:default;opacity:0.5;pointer-events:none}/*!@:host*/.sc-ion-item-option-ios-h{font-size:16px}/*!@:host(.ion-activated)*/.ion-activated.sc-ion-item-option-ios-h{background:var(--ion-color-primary-shade, #3171e0)}/*!@:host(.ion-color.ion-activated)*/.ion-color.ion-activated.sc-ion-item-option-ios-h{background:var(--ion-color-shade)}';

    const itemOptionMdCss =
      '/*!@:host*/.sc-ion-item-option-md-h{--background:var(--ion-color-primary, #3880ff);--color:var(--ion-color-primary-contrast, #fff);background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit)}/*!@:host(.in-list.item-options-end:last-child)*/.in-list.item-options-end.sc-ion-item-option-md-h:last-child{padding-right:calc(.7em + var(--ion-safe-area-right))}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-list.item-options-end:last-child)*/.in-list.item-options-end.sc-ion-item-option-md-h:last-child{padding-right:unset;-webkit-padding-end:calc(.7em + var(--ion-safe-area-right));padding-inline-end:calc(.7em + var(--ion-safe-area-right))}}/*!@:host(.in-list.item-options-start:first-child)*/.in-list.item-options-start.sc-ion-item-option-md-h:first-child{padding-left:calc(.7em + var(--ion-safe-area-left))}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-list.item-options-start:first-child)*/.in-list.item-options-start.sc-ion-item-option-md-h:first-child{padding-left:unset;-webkit-padding-start:calc(.7em + var(--ion-safe-area-left));padding-inline-start:calc(.7em + var(--ion-safe-area-left))}}/*!@:host(.ion-color)*/.ion-color.sc-ion-item-option-md-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@.button-native*/.button-native.sc-ion-item-option-md{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;padding-left:0.7em;padding-right:0.7em;padding-top:0;padding-bottom:0;display:inline-block;position:relative;width:100%;height:100%;border:0;outline:none;background:transparent;cursor:pointer;appearance:none;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-item-option-md{padding-left:unset;padding-right:unset;-webkit-padding-start:0.7em;padding-inline-start:0.7em;-webkit-padding-end:0.7em;padding-inline-end:0.7em}}/*!@.button-inner*/.button-inner.sc-ion-item-option-md{display:flex;flex-flow:column nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%}/*!@.horizontal-wrapper*/.horizontal-wrapper.sc-ion-item-option-md{display:flex;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%}/*!@::slotted(*)*/.sc-ion-item-option-md-s>*{flex-shrink:0}/*!@::slotted([slot=start])*/.sc-ion-item-option-md-s>[slot=start]{margin-left:0;margin-right:5px;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=start])*/.sc-ion-item-option-md-s>[slot=start]{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:5px;margin-inline-end:5px}}/*!@::slotted([slot=end])*/.sc-ion-item-option-md-s>[slot=end]{margin-left:5px;margin-right:0;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=end])*/.sc-ion-item-option-md-s>[slot=end]{margin-left:unset;margin-right:unset;-webkit-margin-start:5px;margin-inline-start:5px;-webkit-margin-end:0;margin-inline-end:0}}/*!@::slotted([slot=icon-only])*/.sc-ion-item-option-md-s>[slot=icon-only]{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:10px;margin-right:10px;margin-top:0;margin-bottom:0;min-width:0.9em;font-size:1.8em}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=icon-only])*/.sc-ion-item-option-md-s>[slot=icon-only]{margin-left:unset;margin-right:unset;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:10px;margin-inline-end:10px}}/*!@:host(.item-option-expandable)*/.item-option-expandable.sc-ion-item-option-md-h{flex-shrink:0;transition-duration:0;transition-property:none;transition-timing-function:cubic-bezier(0.65, 0.05, 0.36, 1)}/*!@:host(.item-option-disabled)*/.item-option-disabled.sc-ion-item-option-md-h{pointer-events:none}/*!@:host(.item-option-disabled) .button-native*/.item-option-disabled.sc-ion-item-option-md-h .button-native.sc-ion-item-option-md{cursor:default;opacity:0.5;pointer-events:none}/*!@:host*/.sc-ion-item-option-md-h{font-size:14px;font-weight:500;text-transform:uppercase}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @slot - Content is placed between the named slots if provided without a slot.
     * @slot start - Content is placed to the left of the option text in LTR, and to the right in RTL.
     * @slot top - Content is placed above the option text.
     * @slot icon-only - Should be used on an icon in an option that has no text.
     * @slot bottom - Content is placed below the option text.
     * @slot end - Content is placed to the right of the option text in LTR, and to the left in RTL.
     *
     * @part native - The native HTML button or anchor element that wraps all child elements.
     */
    class ItemOption {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If `true`, the user cannot interact with the item option.
         */
        this.disabled = false;
        /**
         * If `true`, the option will expand to take up the available width and cover any other options.
         */
        this.expandable = false;
        /**
         * The type of the button.
         */
        this.type = 'button';
        this.onClick = ev => {
          const el = ev.target.closest('ion-item-option');
          if (el) {
            ev.preventDefault();
          }
        };
      }
      render() {
        const { disabled, expandable, href } = this;
        const TagType = href === undefined ? 'button' : 'a';
        const mode = getIonMode$1(this);
        const attrs =
          TagType === 'button'
            ? { type: this.type }
            : {
                download: this.download,
                href: this.href,
                target: this.target,
              };
        return hAsync(
          Host,
          {
            onClick: this.onClick,
            class: createColorClasses$1(this.color, {
              [mode]: true,
              'item-option-disabled': disabled,
              'item-option-expandable': expandable,
              'ion-activatable': true,
            }),
          },
          hAsync(
            TagType,
            Object.assign({}, attrs, { class: 'button-native', part: 'native', disabled: disabled }),
            hAsync(
              'span',
              { class: 'button-inner' },
              hAsync('slot', { name: 'top' }),
              hAsync(
                'div',
                { class: 'horizontal-wrapper' },
                hAsync('slot', { name: 'start' }),
                hAsync('slot', { name: 'icon-only' }),
                hAsync('slot', null),
                hAsync('slot', { name: 'end' }),
              ),
              hAsync('slot', { name: 'bottom' }),
            ),
            mode === 'md' && hAsync('ion-ripple-effect', null),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: itemOptionIosCss,
          md: itemOptionMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-item-option',
          $members$: {
            color: [513],
            disabled: [4],
            download: [1],
            expandable: [4],
            href: [1],
            rel: [1],
            target: [1],
            type: [1],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const itemOptionsIosCss =
      'ion-item-options{top:0;right:0;justify-content:flex-end;display:none;position:absolute;height:100%;font-size:14px;user-select:none;z-index:1}[dir=rtl] ion-item-options,:host-context([dir=rtl]) ion-item-options{justify-content:flex-start}[dir=rtl] ion-item-options:not(.item-options-end),:host-context([dir=rtl]) ion-item-options:not(.item-options-end){right:auto;left:0;justify-content:flex-end}.item-options-start{right:auto;left:0;justify-content:flex-start}[dir=rtl] .item-options-start,:host-context([dir=rtl]) .item-options-start{justify-content:flex-end}.item-options-start ion-item-option:first-child{padding-right:var(--ion-safe-area-left)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.item-options-start ion-item-option:first-child{padding-right:unset;-webkit-padding-end:var(--ion-safe-area-left);padding-inline-end:var(--ion-safe-area-left)}}.item-options-end ion-item-option:last-child{padding-right:var(--ion-safe-area-right)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.item-options-end ion-item-option:last-child{padding-right:unset;-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}[dir=rtl] .item-sliding-active-slide.item-sliding-active-options-start ion-item-options:not(.item-options-end),:host-context([dir=rtl]) .item-sliding-active-slide.item-sliding-active-options-start ion-item-options:not(.item-options-end){width:100%;visibility:visible}.item-sliding-active-slide ion-item-options{display:flex;visibility:hidden}.item-sliding-active-slide.item-sliding-active-options-start .item-options-start,.item-sliding-active-slide.item-sliding-active-options-end ion-item-options:not(.item-options-start){width:100%;visibility:visible}.item-options-ios{border-bottom-width:0;border-bottom-style:solid;border-bottom-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)))}.item-options-ios.item-options-end{border-bottom-width:0.55px}.list-ios-lines-none .item-options-ios{border-bottom-width:0}.list-ios-lines-full .item-options-ios,.list-ios-lines-inset .item-options-ios.item-options-end{border-bottom-width:0.55px}';

    const itemOptionsMdCss =
      'ion-item-options{top:0;right:0;justify-content:flex-end;display:none;position:absolute;height:100%;font-size:14px;user-select:none;z-index:1}[dir=rtl] ion-item-options,:host-context([dir=rtl]) ion-item-options{justify-content:flex-start}[dir=rtl] ion-item-options:not(.item-options-end),:host-context([dir=rtl]) ion-item-options:not(.item-options-end){right:auto;left:0;justify-content:flex-end}.item-options-start{right:auto;left:0;justify-content:flex-start}[dir=rtl] .item-options-start,:host-context([dir=rtl]) .item-options-start{justify-content:flex-end}.item-options-start ion-item-option:first-child{padding-right:var(--ion-safe-area-left)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.item-options-start ion-item-option:first-child{padding-right:unset;-webkit-padding-end:var(--ion-safe-area-left);padding-inline-end:var(--ion-safe-area-left)}}.item-options-end ion-item-option:last-child{padding-right:var(--ion-safe-area-right)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.item-options-end ion-item-option:last-child{padding-right:unset;-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}[dir=rtl] .item-sliding-active-slide.item-sliding-active-options-start ion-item-options:not(.item-options-end),:host-context([dir=rtl]) .item-sliding-active-slide.item-sliding-active-options-start ion-item-options:not(.item-options-end){width:100%;visibility:visible}.item-sliding-active-slide ion-item-options{display:flex;visibility:hidden}.item-sliding-active-slide.item-sliding-active-options-start .item-options-start,.item-sliding-active-slide.item-sliding-active-options-end ion-item-options:not(.item-options-start){width:100%;visibility:visible}.item-options-md{border-bottom-width:0;border-bottom-style:solid;border-bottom-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))))}.list-md-lines-none .item-options-md{border-bottom-width:0}.list-md-lines-full .item-options-md,.list-md-lines-inset .item-options-md.item-options-end{border-bottom-width:1px}';

    class ItemOptions {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionSwipe = createEvent(this, 'ionSwipe', 7);
        /**
         * The side the option button should be on. Possible values: `"start"` and `"end"`. If you have multiple `ion-item-options`, a side must be provided for each.
         *
         */
        this.side = 'end';
      }
      /** @internal */
      async fireSwipeEvent() {
        this.ionSwipe.emit({
          side: this.side,
        });
      }
      render() {
        const mode = getIonMode$1(this);
        const isEnd = isEndSide(this.side);
        return hAsync(Host, {
          class: {
            [mode]: true,
            // Used internally for styling
            [`item-options-${mode}`]: true,
            'item-options-start': !isEnd,
            'item-options-end': isEnd,
          },
        });
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: itemOptionsIosCss,
          md: itemOptionsMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 32,
          $tagName$: 'ion-item-options',
          $members$: {
            side: [1],
            fireSwipeEvent: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const itemSlidingCss =
      'ion-item-sliding{display:block;position:relative;width:100%;overflow:hidden;user-select:none}ion-item-sliding .item{user-select:none}.item-sliding-active-slide .item{position:relative;transition:transform 500ms cubic-bezier(0.36, 0.66, 0.04, 1);opacity:1;z-index:2;pointer-events:none;will-change:transform}.item-sliding-active-swipe-end .item-options-end .item-option-expandable{padding-left:100%;order:1;transition-duration:0.6s;transition-property:padding-left}[dir=rtl] .item-sliding-active-swipe-end .item-options-end .item-option-expandable,:host-context([dir=rtl]) .item-sliding-active-swipe-end .item-options-end .item-option-expandable{order:-1}.item-sliding-active-swipe-start .item-options-start .item-option-expandable{padding-right:100%;order:-1;transition-duration:0.6s;transition-property:padding-right}[dir=rtl] .item-sliding-active-swipe-start .item-options-start .item-option-expandable,:host-context([dir=rtl]) .item-sliding-active-swipe-start .item-options-start .item-option-expandable{order:1}';

    const SWIPE_MARGIN = 30;
    const ELASTIC_FACTOR = 0.55;
    let openSlidingItem;
    class ItemSliding {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionDrag = createEvent(this, 'ionDrag', 7);
        this.item = null;
        this.openAmount = 0;
        this.initialOpenAmount = 0;
        this.optsWidthRightSide = 0;
        this.optsWidthLeftSide = 0;
        this.sides = 0 /* None */;
        this.optsDirty = true;
        this.closestContent = null;
        this.initialContentScrollY = true;
        this.state = 2 /* Disabled */;
        /**
         * If `true`, the user cannot interact with the sliding item.
         */
        this.disabled = false;
      }
      disabledChanged() {
        if (this.gesture) {
          this.gesture.enable(!this.disabled);
        }
      }
      async connectedCallback() {
        this.item = this.el.querySelector('ion-item');
        this.closestContent = this.el.closest('ion-content');
        await this.updateOptions();
        this.gesture = (
          await Promise.resolve().then(function () {
            return index$2;
          })
        ).createGesture({
          el: this.el,
          gestureName: 'item-swipe',
          gesturePriority: 100,
          threshold: 5,
          canStart: ev => this.canStart(ev),
          onStart: () => this.onStart(),
          onMove: ev => this.onMove(ev),
          onEnd: ev => this.onEnd(ev),
        });
        this.disabledChanged();
      }
      disconnectedCallback() {
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
        this.item = null;
        this.leftOptions = this.rightOptions = undefined;
        if (openSlidingItem === this.el) {
          openSlidingItem = undefined;
        }
      }
      /**
       * Get the amount the item is open in pixels.
       */
      getOpenAmount() {
        return Promise.resolve(this.openAmount);
      }
      /**
       * Get the ratio of the open amount of the item compared to the width of the options.
       * If the number returned is positive, then the options on the right side are open.
       * If the number returned is negative, then the options on the left side are open.
       * If the absolute value of the number is greater than 1, the item is open more than
       * the width of the options.
       */
      getSlidingRatio() {
        return Promise.resolve(this.getSlidingRatioSync());
      }
      /**
       * Open the sliding item.
       *
       * @param side The side of the options to open. If a side is not provided, it will open the first set of options it finds within the item.
       */
      async open(side) {
        if (this.item === null) {
          return;
        }
        const optionsToOpen = this.getOptions(side);
        if (!optionsToOpen) {
          return;
        }
        /**
         * If side is not set, we need to infer the side
         * so we know which direction to move the options
         */
        if (side === undefined) {
          side = optionsToOpen === this.leftOptions ? 'start' : 'end';
        }
        // In RTL we want to switch the sides
        side = isEndSide(side) ? 'end' : 'start';
        const isStartOpen = this.openAmount < 0;
        const isEndOpen = this.openAmount > 0;
        /**
         * If a side is open and a user tries to
         * re-open the same side, we should not do anything
         */
        if (isStartOpen && optionsToOpen === this.leftOptions) {
          return;
        }
        if (isEndOpen && optionsToOpen === this.rightOptions) {
          return;
        }
        this.closeOpened();
        this.state = 4 /* Enabled */;
        requestAnimationFrame(() => {
          this.calculateOptsWidth();
          const width = side === 'end' ? this.optsWidthRightSide : -this.optsWidthLeftSide;
          openSlidingItem = this.el;
          this.setOpenAmount(width, false);
          this.state = side === 'end' ? 8 /* End */ : 16 /* Start */;
        });
      }
      /**
       * Close the sliding item. Items can also be closed from the [List](../list).
       */
      async close() {
        this.setOpenAmount(0, true);
      }
      /**
       * Close all of the sliding items in the list. Items can also be closed from the [List](../list).
       */
      async closeOpened() {
        if (openSlidingItem !== undefined) {
          openSlidingItem.close();
          openSlidingItem = undefined;
          return true;
        }
        return false;
      }
      /**
       * Given an optional side, return the ion-item-options element.
       *
       * @param side This side of the options to get. If a side is not provided it will
       * return the first one available.
       */
      getOptions(side) {
        if (side === undefined) {
          return this.leftOptions || this.rightOptions;
        } else if (side === 'start') {
          return this.leftOptions;
        } else {
          return this.rightOptions;
        }
      }
      async updateOptions() {
        const options = this.el.querySelectorAll('ion-item-options');
        let sides = 0;
        // Reset left and right options in case they were removed
        this.leftOptions = this.rightOptions = undefined;
        for (let i = 0; i < options.length; i++) {
          const item = options.item(i);
          /**
           * We cannot use the componentOnReady helper
           * util here since we need to wait for all of these items
           * to be ready before we set `this.sides` and `this.optsDirty`.
           */
          const option = item.componentOnReady !== undefined ? await item.componentOnReady() : item;
          const side = isEndSide(option.side) ? 'end' : 'start';
          if (side === 'start') {
            this.leftOptions = option;
            sides |= 1 /* Start */;
          } else {
            this.rightOptions = option;
            sides |= 2 /* End */;
          }
        }
        this.optsDirty = true;
        this.sides = sides;
      }
      canStart(gesture) {
        /**
         * If very close to start of the screen
         * do not open left side so swipe to go
         * back will still work.
         */
        const rtl = document.dir === 'rtl';
        const atEdge = rtl ? window.innerWidth - gesture.startX < 15 : gesture.startX < 15;
        if (atEdge) {
          return false;
        }
        const selected = openSlidingItem;
        if (selected && selected !== this.el) {
          this.closeOpened();
        }
        return !!(this.rightOptions || this.leftOptions);
      }
      disableContentScrollY() {
        if (this.closestContent === null) {
          return;
        }
        this.initialContentScrollY = this.closestContent.scrollY;
        this.closestContent.scrollY = false;
      }
      restoreContentScrollY() {
        if (this.closestContent === null) {
          return;
        }
        this.closestContent.scrollY = this.initialContentScrollY;
      }
      onStart() {
        /**
         * We need to query for the ion-item
         * every time the gesture starts. Developers
         * may toggle ion-item elements via *ngIf.
         */
        this.item = this.el.querySelector('ion-item');
        // Prevent scrolling during gesture
        this.disableContentScrollY();
        openSlidingItem = this.el;
        if (this.tmr !== undefined) {
          clearTimeout(this.tmr);
          this.tmr = undefined;
        }
        if (this.openAmount === 0) {
          this.optsDirty = true;
          this.state = 4 /* Enabled */;
        }
        this.initialOpenAmount = this.openAmount;
        if (this.item) {
          this.item.style.transition = 'none';
        }
      }
      onMove(gesture) {
        if (this.optsDirty) {
          this.calculateOptsWidth();
        }
        let openAmount = this.initialOpenAmount - gesture.deltaX;
        switch (this.sides) {
          case 2 /* End */:
            openAmount = Math.max(0, openAmount);
            break;
          case 1 /* Start */:
            openAmount = Math.min(0, openAmount);
            break;
          case 3 /* Both */:
            break;
          case 0 /* None */:
            return;
          default:
            console.warn('invalid ItemSideFlags value', this.sides);
            break;
        }
        let optsWidth;
        if (openAmount > this.optsWidthRightSide) {
          optsWidth = this.optsWidthRightSide;
          openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
        } else if (openAmount < -this.optsWidthLeftSide) {
          optsWidth = -this.optsWidthLeftSide;
          openAmount = optsWidth + (openAmount - optsWidth) * ELASTIC_FACTOR;
        }
        this.setOpenAmount(openAmount, false);
      }
      onEnd(gesture) {
        // Restore ion-content scrollY to initial value when gesture ends
        this.restoreContentScrollY();
        const velocity = gesture.velocityX;
        let restingPoint = this.openAmount > 0 ? this.optsWidthRightSide : -this.optsWidthLeftSide;
        // Check if the drag didn't clear the buttons mid-point
        // and we aren't moving fast enough to swipe open
        const isResetDirection = this.openAmount > 0 === !(velocity < 0);
        const isMovingFast = Math.abs(velocity) > 0.3;
        const isOnCloseZone = Math.abs(this.openAmount) < Math.abs(restingPoint / 2);
        if (swipeShouldReset(isResetDirection, isMovingFast, isOnCloseZone)) {
          restingPoint = 0;
        }
        const state = this.state;
        this.setOpenAmount(restingPoint, true);
        if ((state & 32) /* SwipeEnd */ !== 0 && this.rightOptions) {
          this.rightOptions.fireSwipeEvent();
        } else if ((state & 64) /* SwipeStart */ !== 0 && this.leftOptions) {
          this.leftOptions.fireSwipeEvent();
        }
      }
      calculateOptsWidth() {
        this.optsWidthRightSide = 0;
        if (this.rightOptions) {
          this.rightOptions.style.display = 'flex';
          this.optsWidthRightSide = this.rightOptions.offsetWidth;
          this.rightOptions.style.display = '';
        }
        this.optsWidthLeftSide = 0;
        if (this.leftOptions) {
          this.leftOptions.style.display = 'flex';
          this.optsWidthLeftSide = this.leftOptions.offsetWidth;
          this.leftOptions.style.display = '';
        }
        this.optsDirty = false;
      }
      setOpenAmount(openAmount, isFinal) {
        if (this.tmr !== undefined) {
          clearTimeout(this.tmr);
          this.tmr = undefined;
        }
        if (!this.item) {
          return;
        }
        const style = this.item.style;
        this.openAmount = openAmount;
        if (isFinal) {
          style.transition = '';
        }
        if (openAmount > 0) {
          this.state = openAmount >= this.optsWidthRightSide + SWIPE_MARGIN ? 8 /* End */ | 32 /* SwipeEnd */ : 8 /* End */;
        } else if (openAmount < 0) {
          this.state = openAmount <= -this.optsWidthLeftSide - SWIPE_MARGIN ? 16 /* Start */ | 64 /* SwipeStart */ : 16 /* Start */;
        } else {
          /**
           * Item sliding cannot be interrupted
           * while closing the item. If it did,
           * it would allow the item to get into an
           * inconsistent state where multiple
           * items are then open at the same time.
           */
          if (this.gesture) {
            this.gesture.enable(false);
          }
          this.tmr = setTimeout(() => {
            this.state = 2 /* Disabled */;
            this.tmr = undefined;
            if (this.gesture) {
              this.gesture.enable(true);
            }
          }, 600);
          openSlidingItem = undefined;
          style.transform = '';
          return;
        }
        style.transform = `translate3d(${-openAmount}px,0,0)`;
        this.ionDrag.emit({
          amount: openAmount,
          ratio: this.getSlidingRatioSync(),
        });
      }
      getSlidingRatioSync() {
        if (this.openAmount > 0) {
          return this.openAmount / this.optsWidthRightSide;
        } else if (this.openAmount < 0) {
          return this.openAmount / this.optsWidthLeftSide;
        } else {
          return 0;
        }
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          class: {
            [mode]: true,
            'item-sliding-active-slide': this.state !== 2 /* Disabled */,
            'item-sliding-active-options-end': (this.state & 8) /* End */ !== 0,
            'item-sliding-active-options-start': (this.state & 16) /* Start */ !== 0,
            'item-sliding-active-swipe-end': (this.state & 32) /* SwipeEnd */ !== 0,
            'item-sliding-active-swipe-start': (this.state & 64) /* SwipeStart */ !== 0,
          },
        });
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          disabled: ['disabledChanged'],
        };
      }
      static get style() {
        return itemSlidingCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-item-sliding',
          $members$: {
            disabled: [4],
            state: [32],
            getOpenAmount: [64],
            getSlidingRatio: [64],
            open: [64],
            close: [64],
            closeOpened: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const swipeShouldReset = (isResetDirection, isMovingFast, isOnResetZone) => {
      // The logic required to know when the sliding item should close (openAmount=0)
      // depends on three booleans (isResetDirection, isMovingFast, isOnResetZone)
      // and it ended up being too complicated to be written manually without errors
      // so the truth table is attached below: (0=false, 1=true)
      // isResetDirection | isMovingFast | isOnResetZone || shouldClose
      //         0        |       0      |       0       ||    0
      //         0        |       0      |       1       ||    1
      //         0        |       1      |       0       ||    0
      //         0        |       1      |       1       ||    0
      //         1        |       0      |       0       ||    0
      //         1        |       0      |       1       ||    1
      //         1        |       1      |       0       ||    1
      //         1        |       1      |       1       ||    1
      // The resulting expression was generated by resolving the K-map (Karnaugh map):
      return (!isMovingFast && isOnResetZone) || (isResetDirection && isMovingFast);
    };

    const labelIosCss =
      '.item.sc-ion-label-ios-h,.item .sc-ion-label-ios-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;box-sizing:border-box}.ion-color.sc-ion-label-ios-h{color:var(--ion-color-base)}.ion-text-wrap.sc-ion-label-ios-h,[text-wrap].sc-ion-label-ios-h{white-space:normal}.item-interactive-disabled.sc-ion-label-ios-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-ios-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-ios-h,.item-input .sc-ion-label-ios-h{flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-ios-h,.item-textarea .sc-ion-label-ios-h{align-self:baseline}.label-fixed.sc-ion-label-ios-h{flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-ios-h,.label-floating.sc-ion-label-ios-h{margin-bottom:0;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-ios-h{transition:none}.sc-ion-label-ios-s h1,.sc-ion-label-ios-s h2,.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-ios-h,[text-wrap].sc-ion-label-ios-h{font-size:14px;line-height:1.5}.label-stacked.sc-ion-label-ios-h{margin-bottom:4px;font-size:14px}.label-floating.sc-ion-label-ios-h{margin-bottom:0;transform:translate3d(0,  29px,  0);transform-origin:left top;transition:transform 150ms ease-in-out}[dir=rtl].sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl] .sc-ion-label-ios-h -no-combinator.label-floating.sc-ion-label-ios-h,[dir=rtl].label-floating.sc-ion-label-ios-h,[dir=rtl] .label-floating.sc-ion-label-ios-h{transform-origin:right top}.item-textarea.label-floating.sc-ion-label-ios-h,.item-textarea .label-floating.sc-ion-label-ios-h{transform:translate3d(0,  28px,  0)}.item-has-focus.label-floating.sc-ion-label-ios-h,.item-has-focus .label-floating.sc-ion-label-ios-h,.item-has-placeholder.sc-ion-label-ios-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-ios-h,.item-has-value.label-floating.sc-ion-label-ios-h,.item-has-value .label-floating.sc-ion-label-ios-h{transform:translate3d(0,  0,  0) scale(0.82)}.sc-ion-label-ios-s h1{margin-left:0;margin-right:0;margin-top:3px;margin-bottom:2px;font-size:22px;font-weight:normal}.sc-ion-label-ios-s h2{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:17px;font-weight:normal}.sc-ion-label-ios-s h3,.sc-ion-label-ios-s h4,.sc-ion-label-ios-s h5,.sc-ion-label-ios-s h6{margin-left:0;margin-right:0;margin-top:0;margin-bottom:3px;font-size:14px;font-weight:normal;line-height:normal}.sc-ion-label-ios-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;line-height:normal;text-overflow:inherit;overflow:inherit}.sc-ion-label-ios-s>p{color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.4)}.sc-ion-label-ios-h.in-item-color.sc-ion-label-ios-s>p{color:inherit}.sc-ion-label-ios-s h2:last-child,.sc-ion-label-ios-s h3:last-child,.sc-ion-label-ios-s h4:last-child,.sc-ion-label-ios-s h5:last-child,.sc-ion-label-ios-s h6:last-child,.sc-ion-label-ios-s p:last-child{margin-bottom:0}';

    const labelMdCss =
      '.item.sc-ion-label-md-h,.item .sc-ion-label-md-h{--color:initial;display:block;color:var(--color);font-family:var(--ion-font-family, inherit);font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;box-sizing:border-box}.ion-color.sc-ion-label-md-h{color:var(--ion-color-base)}.ion-text-wrap.sc-ion-label-md-h,[text-wrap].sc-ion-label-md-h{white-space:normal}.item-interactive-disabled.sc-ion-label-md-h:not(.item-multiple-inputs),.item-interactive-disabled:not(.item-multiple-inputs) .sc-ion-label-md-h{cursor:default;opacity:0.3;pointer-events:none}.item-input.sc-ion-label-md-h,.item-input .sc-ion-label-md-h{flex:initial;max-width:200px;pointer-events:none}.item-textarea.sc-ion-label-md-h,.item-textarea .sc-ion-label-md-h{align-self:baseline}.label-fixed.sc-ion-label-md-h{flex:0 0 100px;width:100px;min-width:100px;max-width:200px}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-bottom:0;align-self:stretch;width:auto;max-width:100%}.label-no-animate.label-floating.sc-ion-label-md-h{transition:none}.sc-ion-label-md-s h1,.sc-ion-label-md-s h2,.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{text-overflow:inherit;overflow:inherit}.ion-text-wrap.sc-ion-label-md-h,[text-wrap].sc-ion-label-md-h{line-height:1.5}.label-stacked.sc-ion-label-md-h{transform-origin:left top;transform:translateY(50%) scale(0.75);transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1)}[dir=rtl].sc-ion-label-md-h -no-combinator.label-stacked.sc-ion-label-md-h,[dir=rtl] .sc-ion-label-md-h -no-combinator.label-stacked.sc-ion-label-md-h,[dir=rtl].label-stacked.sc-ion-label-md-h,[dir=rtl] .label-stacked.sc-ion-label-md-h{transform-origin:right top}.label-floating.sc-ion-label-md-h{transform:translateY(96%);transform-origin:left top;transition:color 150ms cubic-bezier(0.4, 0, 0.2, 1), transform 150ms cubic-bezier(0.4, 0, 0.2, 1)}[dir=rtl].sc-ion-label-md-h -no-combinator.label-floating.sc-ion-label-md-h,[dir=rtl] .sc-ion-label-md-h -no-combinator.label-floating.sc-ion-label-md-h,[dir=rtl].label-floating.sc-ion-label-md-h,[dir=rtl] .label-floating.sc-ion-label-md-h{transform-origin:right top}.item-textarea.label-floating.sc-ion-label-md-h,.item-textarea .label-floating.sc-ion-label-md-h{transform:translateY(185%)}.label-stacked.sc-ion-label-md-h,.label-floating.sc-ion-label-md-h{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.item-has-focus.label-floating.sc-ion-label-md-h,.item-has-focus .label-floating.sc-ion-label-md-h,.item-has-placeholder.sc-ion-label-md-h:not(.item-input).label-floating,.item-has-placeholder:not(.item-input) .label-floating.sc-ion-label-md-h,.item-has-value.label-floating.sc-ion-label-md-h,.item-has-value .label-floating.sc-ion-label-md-h{transform:translateY(50%) scale(0.75)}.item-has-focus.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-primary, #3880ff)}.item-has-focus.ion-color.label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-stacked.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color.label-floating.sc-ion-label-md-h:not(.ion-color),.item-has-focus.ion-color .label-floating.sc-ion-label-md-h:not(.ion-color){color:var(--ion-color-contrast)}.sc-ion-label-md-s h1{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:24px;font-weight:normal}.sc-ion-label-md-s h2{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:16px;font-weight:normal}.sc-ion-label-md-s h3,.sc-ion-label-md-s h4,.sc-ion-label-md-s h5,.sc-ion-label-md-s h6{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:14px;font-weight:normal;line-height:normal}.sc-ion-label-md-s p{margin-left:0;margin-right:0;margin-top:0;margin-bottom:2px;font-size:14px;line-height:20px;text-overflow:inherit;overflow:inherit}.sc-ion-label-md-s>p{color:var(--ion-color-step-600, #666666)}.sc-ion-label-md-h.in-item-color.sc-ion-label-md-s>p{color:inherit}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Label {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionColor = createEvent(this, 'ionColor', 7);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.inRange = false;
        this.noAnimate = false;
      }
      componentWillLoad() {
        this.inRange = !!this.el.closest('ion-range');
        this.noAnimate = this.position === 'floating';
        this.emitStyle();
        this.emitColor();
      }
      componentDidLoad() {
        if (this.noAnimate) {
          setTimeout(() => {
            this.noAnimate = false;
          }, 1000);
        }
      }
      colorChanged() {
        this.emitColor();
      }
      positionChanged() {
        this.emitStyle();
      }
      emitColor() {
        const { color } = this;
        this.ionColor.emit({
          'item-label-color': color !== undefined,
          [`ion-color-${color}`]: color !== undefined,
        });
      }
      emitStyle() {
        const { inRange, position } = this;
        // If the label is inside of a range we don't want
        // to override the classes added by the label that
        // is a direct child of the item
        if (!inRange) {
          this.ionStyle.emit({
            label: true,
            [`label-${position}`]: position !== undefined,
          });
        }
      }
      render() {
        const position = this.position;
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          class: createColorClasses$1(this.color, {
            [mode]: true,
            'in-item-color': hostContext('ion-item.ion-color', this.el),
            [`label-${position}`]: position !== undefined,
            [`label-no-animate`]: this.noAnimate,
          }),
        });
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          color: ['colorChanged'],
          position: ['positionChanged'],
        };
      }
      static get style() {
        return {
          ios: labelIosCss,
          md: labelMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-label',
          $members$: {
            color: [513],
            position: [1],
            noAnimate: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const listIosCss =
      'ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{transform:translateZ(0);overflow:hidden}.list-ios{background:var(--ion-item-background, var(--ion-background-color, #fff))}.list-ios.list-inset{margin-left:16px;margin-right:16px;margin-top:16px;margin-bottom:16px;border-radius:4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.list-ios.list-inset{margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px}}.list-ios.list-inset ion-item{--border-width:0 0 1px 0;--inner-border-width:0}.list-ios.list-inset ion-item:last-child{--border-width:0;--inner-border-width:0}.list-ios.list-inset+ion-list.list-inset{margin-top:0}.list-ios-lines-none .item{--border-width:0;--inner-border-width:0}.list-ios-lines-full .item,.list-ios .item-lines-full{--border-width:0 0 0.55px 0}.list-ios-lines-full .item{--inner-border-width:0}.list-ios-lines-inset .item,.list-ios .item-lines-inset{--inner-border-width:0 0 0.55px 0}.list-ios .item-lines-inset{--border-width:0}.list-ios .item-lines-full{--inner-border-width:0}.list-ios .item-lines-none{--border-width:0;--inner-border-width:0}ion-card .list-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}';

    const listMdCss =
      'ion-list{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:block;contain:content;list-style-type:none}ion-list.list-inset{transform:translateZ(0);overflow:hidden}.list-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:8px;padding-bottom:8px;background:var(--ion-item-background, var(--ion-background-color, #fff))}.list-md>.input:last-child::after{left:0}[dir=rtl] .list-md>.input:last-child::after,:host-context([dir=rtl]) .list-md>.input:last-child::after{left:unset;right:unset;right:0}.list-md.list-inset{margin-left:16px;margin-right:16px;margin-top:16px;margin-bottom:16px;border-radius:2px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.list-md.list-inset{margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:16px;margin-inline-end:16px}}.list-md.list-inset ion-item:first-child{--border-radius:2px 2px 0 0;--border-width:0 0 1px 0}.list-md.list-inset ion-item:last-child{--border-radius:0 0 2px, 2px;--border-width:0}.list-md.list-inset .item-interactive{--padding-start:0;--padding-end:0}.list-md.list-inset+ion-list.list-inset{margin-top:0}.list-md-lines-none .item{--border-width:0;--inner-border-width:0}.list-md-lines-full .item,.list-md .item-lines-full{--border-width:0 0 1px 0}.list-md-lines-full .item{--inner-border-width:0}.list-md-lines-inset .item,.list-md .item-lines-inset{--inner-border-width:0 0 1px 0}.list-md .item-lines-inset{--border-width:0}.list-md .item-lines-full{--inner-border-width:0}.list-md .item-lines-none{--border-width:0;--inner-border-width:0}ion-card .list-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class List {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If `true`, the list will have margin around it and rounded corners.
         */
        this.inset = false;
      }
      /**
       * If `ion-item-sliding` are used inside the list, this method closes
       * any open sliding item.
       *
       * Returns `true` if an actual `ion-item-sliding` is closed.
       */
      async closeSlidingItems() {
        const item = this.el.querySelector('ion-item-sliding');
        if (item && item.closeOpened) {
          return item.closeOpened();
        }
        return false;
      }
      render() {
        const mode = getIonMode$1(this);
        const { lines, inset } = this;
        return hAsync(Host, {
          class: {
            [mode]: true,
            // Used internally for styling
            [`list-${mode}`]: true,
            'list-inset': inset,
            [`list-lines-${lines}`]: lines !== undefined,
            [`list-${mode}-lines-${lines}`]: lines !== undefined,
          },
        });
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: listIosCss,
          md: listMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 32,
          $tagName$: 'ion-list',
          $members$: {
            lines: [1],
            inset: [4],
            closeSlidingItems: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const listHeaderIosCss =
      '/*!@:host*/.sc-ion-list-header-ios-h{--border-style:solid;--border-width:0;--inner-border-width:0;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:flex;align-items:center;justify-content:space-between;width:100%;min-height:40px;border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);color:var(--color);overflow:hidden}/*!@:host(.ion-color)*/.ion-color.sc-ion-list-header-ios-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@.list-header-inner*/.list-header-inner.sc-ion-list-header-ios{display:flex;position:relative;flex:1;flex-direction:inherit;align-items:inherit;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);overflow:inherit;box-sizing:border-box}/*!@::slotted(ion-label)*/.sc-ion-list-header-ios-s>ion-label{flex:1 1 auto}/*!@:host(.list-header-lines-inset),\n:host(.list-header-lines-none)*/.list-header-lines-inset.sc-ion-list-header-ios-h,.list-header-lines-none.sc-ion-list-header-ios-h{--border-width:0}/*!@:host(.list-header-lines-full),\n:host(.list-header-lines-none)*/.list-header-lines-full.sc-ion-list-header-ios-h,.list-header-lines-none.sc-ion-list-header-ios-h{--inner-border-width:0}/*!@:host*/.sc-ion-list-header-ios-h{--background:transparent;--color:var(--ion-color-step-850, #262626);--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));padding-left:calc(var(--ion-safe-area-left, 0px) + 20px);position:relative;align-items:flex-end;font-size:22px;font-weight:700;letter-spacing:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-list-header-ios-h{padding-left:unset;-webkit-padding-start:calc(var(--ion-safe-area-left, 0px) + 20px);padding-inline-start:calc(var(--ion-safe-area-left, 0px) + 20px)}}/*!@::slotted(ion-button),\n::slotted(ion-label)*/.sc-ion-list-header-ios-s>ion-button,.sc-ion-list-header-ios-s>ion-label{margin-top:29px;margin-bottom:6px}/*!@::slotted(ion-button)*/.sc-ion-list-header-ios-s>ion-button{margin-left:3px;margin-right:3px;height:1.4em}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-button)*/.sc-ion-list-header-ios-s>ion-button{margin-left:unset;margin-right:unset;-webkit-margin-start:3px;margin-inline-start:3px;-webkit-margin-end:3px;margin-inline-end:3px}}/*!@:host(.list-header-lines-full)*/.list-header-lines-full.sc-ion-list-header-ios-h{--border-width:0 0 0.55px 0}/*!@:host(.list-header-lines-inset)*/.list-header-lines-inset.sc-ion-list-header-ios-h{--inner-border-width:0 0 0.55px 0}';

    const listHeaderMdCss =
      '/*!@:host*/.sc-ion-list-header-md-h{--border-style:solid;--border-width:0;--inner-border-width:0;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:flex;align-items:center;justify-content:space-between;width:100%;min-height:40px;border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);color:var(--color);overflow:hidden}/*!@:host(.ion-color)*/.ion-color.sc-ion-list-header-md-h{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@.list-header-inner*/.list-header-inner.sc-ion-list-header-md{display:flex;position:relative;flex:1;flex-direction:inherit;align-items:inherit;align-self:stretch;min-height:inherit;border-width:var(--inner-border-width);border-style:var(--border-style);border-color:var(--border-color);overflow:inherit;box-sizing:border-box}/*!@::slotted(ion-label)*/.sc-ion-list-header-md-s>ion-label{flex:1 1 auto}/*!@:host(.list-header-lines-inset),\n:host(.list-header-lines-none)*/.list-header-lines-inset.sc-ion-list-header-md-h,.list-header-lines-none.sc-ion-list-header-md-h{--border-width:0}/*!@:host(.list-header-lines-full),\n:host(.list-header-lines-none)*/.list-header-lines-full.sc-ion-list-header-md-h,.list-header-lines-none.sc-ion-list-header-md-h{--inner-border-width:0}/*!@:host*/.sc-ion-list-header-md-h{--background:transparent;--color:var(--ion-text-color, #000);--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));padding-left:calc(var(--ion-safe-area-left, 0) + 16px);min-height:45px;font-size:14px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-list-header-md-h{padding-left:unset;-webkit-padding-start:calc(var(--ion-safe-area-left, 0) + 16px);padding-inline-start:calc(var(--ion-safe-area-left, 0) + 16px)}}/*!@:host(.list-header-lines-full)*/.list-header-lines-full.sc-ion-list-header-md-h{--border-width:0 0 1px 0}/*!@:host(.list-header-lines-inset)*/.list-header-lines-inset.sc-ion-list-header-md-h{--inner-border-width:0 0 1px 0}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class ListHeader {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        const { lines } = this;
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: createColorClasses$1(this.color, {
              [mode]: true,
              [`list-header-lines-${lines}`]: lines !== undefined,
            }),
          },
          hAsync('div', { class: 'list-header-inner' }, hAsync('slot', null)),
        );
      }
      static get style() {
        return {
          ios: listHeaderIosCss,
          md: listHeaderMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-list-header',
          $members$: {
            color: [513],
            lines: [1],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    /**
     * iOS Loading Enter Animation
     */
    const iosEnterAnimation$4 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      wrapperAnimation.addElement(baseEl.querySelector('.loading-wrapper')).keyframes([
        { offset: 0, opacity: 0.01, transform: 'scale(1.1)' },
        { offset: 1, opacity: 1, transform: 'scale(1)' },
      ]);
      return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * iOS Loading Leave Animation
     */
    const iosLeaveAnimation$4 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);
      wrapperAnimation.addElement(baseEl.querySelector('.loading-wrapper')).keyframes([
        { offset: 0, opacity: 0.99, transform: 'scale(1)' },
        { offset: 1, opacity: 0, transform: 'scale(0.9)' },
      ]);
      return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * Md Loading Enter Animation
     */
    const mdEnterAnimation$3 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      wrapperAnimation.addElement(baseEl.querySelector('.loading-wrapper')).keyframes([
        { offset: 0, opacity: 0.01, transform: 'scale(1.1)' },
        { offset: 1, opacity: 1, transform: 'scale(1)' },
      ]);
      return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * Md Loading Leave Animation
     */
    const mdLeaveAnimation$3 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);
      wrapperAnimation.addElement(baseEl.querySelector('.loading-wrapper')).keyframes([
        { offset: 0, opacity: 0.99, transform: 'scale(1)' },
        { offset: 1, opacity: 0, transform: 'scale(0.9)' },
      ]);
      return baseAnimation.addElement(baseEl).easing('ease-in-out').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    const loadingIosCss =
      '.sc-ion-loading-ios-h{--min-width:auto;--width:auto;--min-height:auto;--height:auto;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:flex;position:fixed;align-items:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;touch-action:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-loading-ios-h{display:none}.loading-wrapper.sc-ion-loading-ios{display:flex;align-items:inherit;justify-content:inherit;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);opacity:0;z-index:10}.spinner-lines.sc-ion-loading-ios,.spinner-lines-small.sc-ion-loading-ios,.spinner-bubbles.sc-ion-loading-ios,.spinner-circles.sc-ion-loading-ios,.spinner-crescent.sc-ion-loading-ios,.spinner-dots.sc-ion-loading-ios{color:var(--spinner-color)}.sc-ion-loading-ios-h{--background:var(--ion-overlay-background-color, var(--ion-color-step-100, #f9f9f9));--max-width:270px;--max-height:90%;--spinner-color:var(--ion-color-step-600, #666666);--backdrop-opacity:var(--ion-backdrop-opacity, 0.3);color:var(--ion-text-color, #000);font-size:14px}.loading-wrapper.sc-ion-loading-ios{border-radius:8px;padding-left:34px;padding-right:34px;padding-top:24px;padding-bottom:24px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.loading-wrapper.sc-ion-loading-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:34px;padding-inline-start:34px;-webkit-padding-end:34px;padding-inline-end:34px}}@supports (backdrop-filter: blur(0)){.loading-translucent.sc-ion-loading-ios-h .loading-wrapper.sc-ion-loading-ios{background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);backdrop-filter:saturate(180%) blur(20px)}}.loading-content.sc-ion-loading-ios{font-weight:bold}.loading-spinner.sc-ion-loading-ios+.loading-content.sc-ion-loading-ios{margin-left:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.loading-spinner.sc-ion-loading-ios+.loading-content.sc-ion-loading-ios{margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}';

    const loadingMdCss =
      '.sc-ion-loading-md-h{--min-width:auto;--width:auto;--min-height:auto;--height:auto;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;right:0;top:0;bottom:0;display:flex;position:fixed;align-items:center;justify-content:center;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;touch-action:none;user-select:none;z-index:1001}.overlay-hidden.sc-ion-loading-md-h{display:none}.loading-wrapper.sc-ion-loading-md{display:flex;align-items:inherit;justify-content:inherit;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);opacity:0;z-index:10}.spinner-lines.sc-ion-loading-md,.spinner-lines-small.sc-ion-loading-md,.spinner-bubbles.sc-ion-loading-md,.spinner-circles.sc-ion-loading-md,.spinner-crescent.sc-ion-loading-md,.spinner-dots.sc-ion-loading-md{color:var(--spinner-color)}.sc-ion-loading-md-h{--background:var(--ion-color-step-50, #f2f2f2);--max-width:280px;--max-height:90%;--spinner-color:var(--ion-color-primary, #3880ff);--backdrop-opacity:var(--ion-backdrop-opacity, 0.32);color:var(--ion-color-step-850, #262626);font-size:14px}.loading-wrapper.sc-ion-loading-md{border-radius:2px;padding-left:24px;padding-right:24px;padding-top:24px;padding-bottom:24px;box-shadow:0 16px 20px rgba(0, 0, 0, 0.4)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.loading-wrapper.sc-ion-loading-md{padding-left:unset;padding-right:unset;-webkit-padding-start:24px;padding-inline-start:24px;-webkit-padding-end:24px;padding-inline-end:24px}}.loading-spinner.sc-ion-loading-md+.loading-content.sc-ion-loading-md{margin-left:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.loading-spinner.sc-ion-loading-md+.loading-content.sc-ion-loading-md{margin-left:unset;-webkit-margin-start:16px;margin-inline-start:16px}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Loading {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.didPresent = createEvent(this, 'ionLoadingDidPresent', 7);
        this.willPresent = createEvent(this, 'ionLoadingWillPresent', 7);
        this.willDismiss = createEvent(this, 'ionLoadingWillDismiss', 7);
        this.didDismiss = createEvent(this, 'ionLoadingDidDismiss', 7);
        this.presented = false;
        /**
         * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
         */
        this.keyboardClose = true;
        /**
         * Number of milliseconds to wait before dismissing the loading indicator.
         */
        this.duration = 0;
        /**
         * If `true`, the loading indicator will be dismissed when the backdrop is clicked.
         */
        this.backdropDismiss = false;
        /**
         * If `true`, a backdrop will be displayed behind the loading indicator.
         */
        this.showBackdrop = true;
        /**
         * If `true`, the loading indicator will be translucent.
         * Only applies when the mode is `"ios"` and the device supports
         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
         */
        this.translucent = false;
        /**
         * If `true`, the loading indicator will animate.
         */
        this.animated = true;
        this.onBackdropTap = () => {
          this.dismiss(undefined, BACKDROP);
        };
      }
      connectedCallback() {
        prepareOverlay(this.el);
      }
      componentWillLoad() {
        if (this.spinner === undefined) {
          const mode = getIonMode$1(this);
          this.spinner = config$2.get('loadingSpinner', config$2.get('spinner', mode === 'ios' ? 'lines' : 'crescent'));
        }
      }
      /**
       * Present the loading overlay after it has been created.
       */
      async present() {
        await present(this, 'loadingEnter', iosEnterAnimation$4, mdEnterAnimation$3, undefined);
        if (this.duration > 0) {
          this.durationTimeout = setTimeout(() => this.dismiss(), this.duration + 10);
        }
      }
      /**
       * Dismiss the loading overlay after it has been presented.
       *
       * @param data Any data to emit in the dismiss events.
       * @param role The role of the element that is dismissing the loading.
       * This can be useful in a button handler for determining which button was
       * clicked to dismiss the loading.
       * Some examples include: ``"cancel"`, `"destructive"`, "selected"`, and `"backdrop"`.
       */
      dismiss(data, role) {
        if (this.durationTimeout) {
          clearTimeout(this.durationTimeout);
        }
        return dismiss(this, data, role, 'loadingLeave', iosLeaveAnimation$4, mdLeaveAnimation$3);
      }
      /**
       * Returns a promise that resolves when the loading did dismiss.
       */
      onDidDismiss() {
        return eventMethod(this.el, 'ionLoadingDidDismiss');
      }
      /**
       * Returns a promise that resolves when the loading will dismiss.
       */
      onWillDismiss() {
        return eventMethod(this.el, 'ionLoadingWillDismiss');
      }
      render() {
        const { message, spinner, htmlAttributes } = this;
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          Object.assign({ tabindex: '-1' }, htmlAttributes, {
            style: {
              zIndex: `${40000 + this.overlayIndex}`,
            },
            onIonBackdropTap: this.onBackdropTap,
            class: Object.assign(Object.assign({}, getClassMap(this.cssClass)), { [mode]: true, 'loading-translucent': this.translucent }),
          }),
          hAsync('ion-backdrop', { visible: this.showBackdrop, tappable: this.backdropDismiss }),
          hAsync('div', { tabindex: '0' }),
          hAsync(
            'div',
            { class: 'loading-wrapper ion-overlay-wrapper', role: 'dialog' },
            spinner && hAsync('div', { class: 'loading-spinner' }, hAsync('ion-spinner', { 'name': spinner, 'aria-hidden': 'true' })),
            message && hAsync('div', { class: 'loading-content', innerHTML: sanitizeDOMString(message) }),
          ),
          hAsync('div', { tabindex: '0' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: loadingIosCss,
          md: loadingMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-loading',
          $members$: {
            overlayIndex: [2, 'overlay-index'],
            keyboardClose: [4, 'keyboard-close'],
            enterAnimation: [16],
            leaveAnimation: [16],
            message: [1],
            cssClass: [1, 'css-class'],
            duration: [2],
            backdropDismiss: [4, 'backdrop-dismiss'],
            showBackdrop: [4, 'show-backdrop'],
            spinner: [1025],
            translucent: [4],
            animated: [4],
            htmlAttributes: [16],
            present: [64],
            dismiss: [64],
            onDidDismiss: [64],
            onWillDismiss: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const menuIosCss =
      '/*!@:host*/.sc-ion-menu-ios-h{--width:304px;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--background:var(--ion-background-color, #fff);left:0;right:0;top:0;bottom:0;display:none;position:absolute;contain:strict}/*!@:host(.show-menu)*/.show-menu.sc-ion-menu-ios-h{display:block}/*!@.menu-inner*/.menu-inner.sc-ion-menu-ios{left:0;right:auto;top:0;bottom:0;transform:translate3d(-9999px,  0,  0);display:flex;position:absolute;flex-direction:column;justify-content:space-between;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:strict}/*!@[dir=rtl] .menu-inner, :host-context([dir=rtl]) .menu-inner*/[dir=rtl].sc-ion-menu-ios .menu-inner.sc-ion-menu-ios,[dir=rtl].sc-ion-menu-ios-h .menu-inner.sc-ion-menu-ios,[dir=rtl] .sc-ion-menu-ios-h .menu-inner.sc-ion-menu-ios{left:unset;right:unset;left:auto;right:0}/*!@[dir=rtl] .menu-inner, :host-context([dir=rtl]) .menu-inner*/[dir=rtl].sc-ion-menu-ios .menu-inner.sc-ion-menu-ios,[dir=rtl].sc-ion-menu-ios-h .menu-inner.sc-ion-menu-ios,[dir=rtl] .sc-ion-menu-ios-h .menu-inner.sc-ion-menu-ios{transform:translate3d(calc(-1 * -9999px),  0,  0)}/*!@:host(.menu-side-start) .menu-inner*/.menu-side-start.sc-ion-menu-ios-h .menu-inner.sc-ion-menu-ios{--ion-safe-area-right:0px;right:auto;left:0}/*!@:host(.menu-side-end) .menu-inner*/.menu-side-end.sc-ion-menu-ios-h .menu-inner.sc-ion-menu-ios{--ion-safe-area-left:0px;right:0;left:auto}/*!@ion-backdrop*/ion-backdrop.sc-ion-menu-ios{display:none;opacity:0.01;z-index:-1}@media (max-width: 340px){/*!@.menu-inner*/.menu-inner.sc-ion-menu-ios{--width:264px}}/*!@:host(.menu-type-reveal)*/.menu-type-reveal.sc-ion-menu-ios-h{z-index:0}/*!@:host(.menu-type-reveal.show-menu) .menu-inner*/.menu-type-reveal.show-menu.sc-ion-menu-ios-h .menu-inner.sc-ion-menu-ios{transform:translate3d(0,  0,  0)}/*!@:host(.menu-type-overlay)*/.menu-type-overlay.sc-ion-menu-ios-h{z-index:1000}/*!@:host(.menu-type-overlay) .show-backdrop*/.menu-type-overlay.sc-ion-menu-ios-h .show-backdrop.sc-ion-menu-ios{display:block;cursor:pointer}/*!@:host(.menu-pane-visible)*/.menu-pane-visible.sc-ion-menu-ios-h{width:var(--width);min-width:var(--min-width);max-width:var(--max-width)}/*!@:host(.menu-pane-visible) .menu-inner*/.menu-pane-visible.sc-ion-menu-ios-h .menu-inner.sc-ion-menu-ios{left:0;right:0;width:auto;transform:none !important;box-shadow:none !important}/*!@:host(.menu-pane-visible) ion-backdrop*/.menu-pane-visible.sc-ion-menu-ios-h ion-backdrop.sc-ion-menu-ios{display:hidden !important}/*!@:host(.menu-type-push)*/.menu-type-push.sc-ion-menu-ios-h{z-index:1000}/*!@:host(.menu-type-push) .show-backdrop*/.menu-type-push.sc-ion-menu-ios-h .show-backdrop.sc-ion-menu-ios{display:block}';

    const menuMdCss =
      '/*!@:host*/.sc-ion-menu-md-h{--width:304px;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--background:var(--ion-background-color, #fff);left:0;right:0;top:0;bottom:0;display:none;position:absolute;contain:strict}/*!@:host(.show-menu)*/.show-menu.sc-ion-menu-md-h{display:block}/*!@.menu-inner*/.menu-inner.sc-ion-menu-md{left:0;right:auto;top:0;bottom:0;transform:translate3d(-9999px,  0,  0);display:flex;position:absolute;flex-direction:column;justify-content:space-between;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);contain:strict}/*!@[dir=rtl] .menu-inner, :host-context([dir=rtl]) .menu-inner*/[dir=rtl].sc-ion-menu-md .menu-inner.sc-ion-menu-md,[dir=rtl].sc-ion-menu-md-h .menu-inner.sc-ion-menu-md,[dir=rtl] .sc-ion-menu-md-h .menu-inner.sc-ion-menu-md{left:unset;right:unset;left:auto;right:0}/*!@[dir=rtl] .menu-inner, :host-context([dir=rtl]) .menu-inner*/[dir=rtl].sc-ion-menu-md .menu-inner.sc-ion-menu-md,[dir=rtl].sc-ion-menu-md-h .menu-inner.sc-ion-menu-md,[dir=rtl] .sc-ion-menu-md-h .menu-inner.sc-ion-menu-md{transform:translate3d(calc(-1 * -9999px),  0,  0)}/*!@:host(.menu-side-start) .menu-inner*/.menu-side-start.sc-ion-menu-md-h .menu-inner.sc-ion-menu-md{--ion-safe-area-right:0px;right:auto;left:0}/*!@:host(.menu-side-end) .menu-inner*/.menu-side-end.sc-ion-menu-md-h .menu-inner.sc-ion-menu-md{--ion-safe-area-left:0px;right:0;left:auto}/*!@ion-backdrop*/ion-backdrop.sc-ion-menu-md{display:none;opacity:0.01;z-index:-1}@media (max-width: 340px){/*!@.menu-inner*/.menu-inner.sc-ion-menu-md{--width:264px}}/*!@:host(.menu-type-reveal)*/.menu-type-reveal.sc-ion-menu-md-h{z-index:0}/*!@:host(.menu-type-reveal.show-menu) .menu-inner*/.menu-type-reveal.show-menu.sc-ion-menu-md-h .menu-inner.sc-ion-menu-md{transform:translate3d(0,  0,  0)}/*!@:host(.menu-type-overlay)*/.menu-type-overlay.sc-ion-menu-md-h{z-index:1000}/*!@:host(.menu-type-overlay) .show-backdrop*/.menu-type-overlay.sc-ion-menu-md-h .show-backdrop.sc-ion-menu-md{display:block;cursor:pointer}/*!@:host(.menu-pane-visible)*/.menu-pane-visible.sc-ion-menu-md-h{width:var(--width);min-width:var(--min-width);max-width:var(--max-width)}/*!@:host(.menu-pane-visible) .menu-inner*/.menu-pane-visible.sc-ion-menu-md-h .menu-inner.sc-ion-menu-md{left:0;right:0;width:auto;transform:none !important;box-shadow:none !important}/*!@:host(.menu-pane-visible) ion-backdrop*/.menu-pane-visible.sc-ion-menu-md-h ion-backdrop.sc-ion-menu-md{display:hidden !important}/*!@:host(.menu-type-overlay) .menu-inner*/.menu-type-overlay.sc-ion-menu-md-h .menu-inner.sc-ion-menu-md{box-shadow:4px 0px 16px rgba(0, 0, 0, 0.18)}';

    const iosEasing = 'cubic-bezier(0.32,0.72,0,1)';
    const mdEasing = 'cubic-bezier(0.0,0.0,0.2,1)';
    const iosEasingReverse = 'cubic-bezier(1, 0, 0.68, 0.28)';
    const mdEasingReverse = 'cubic-bezier(0.4, 0, 0.6, 1)';
    /**
     * @part container - The container for the menu content.
     * @part backdrop - The backdrop that appears over the main content when the menu is open.
     */
    class Menu {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionWillOpen = createEvent(this, 'ionWillOpen', 7);
        this.ionWillClose = createEvent(this, 'ionWillClose', 7);
        this.ionDidOpen = createEvent(this, 'ionDidOpen', 7);
        this.ionDidClose = createEvent(this, 'ionDidClose', 7);
        this.ionMenuChange = createEvent(this, 'ionMenuChange', 7);
        this.lastOnEnd = 0;
        this.blocker = GESTURE_CONTROLLER.createBlocker({ disableScroll: true });
        this.isAnimating = false;
        this._isOpen = false;
        this.isPaneVisible = false;
        this.isEndSide = false;
        /**
         * If `true`, the menu is disabled.
         */
        this.disabled = false;
        /**
         * Which side of the view the menu should be placed.
         */
        this.side = 'start';
        /**
         * If `true`, swiping the menu is enabled.
         */
        this.swipeGesture = true;
        /**
         * The edge threshold for dragging the menu open.
         * If a drag/swipe happens over this value, the menu is not triggered.
         */
        this.maxEdgeStart = 50;
      }
      typeChanged(type, oldType) {
        const contentEl = this.contentEl;
        if (contentEl) {
          if (oldType !== undefined) {
            contentEl.classList.remove(`menu-content-${oldType}`);
          }
          contentEl.classList.add(`menu-content-${type}`);
          contentEl.removeAttribute('style');
        }
        if (this.menuInnerEl) {
          // Remove effects of previous animations
          this.menuInnerEl.removeAttribute('style');
        }
        this.animation = undefined;
      }
      disabledChanged() {
        this.updateState();
        this.ionMenuChange.emit({
          disabled: this.disabled,
          open: this._isOpen,
        });
      }
      sideChanged() {
        this.isEndSide = isEndSide(this.side);
      }
      swipeGestureChanged() {
        this.updateState();
      }
      async connectedCallback() {
        if (this.type === undefined) {
          this.type = config$2.get('menuType', 'overlay');
        }
        {
          this.disabled = true;
          return;
        }
      }
      async componentDidLoad() {
        this.ionMenuChange.emit({ disabled: this.disabled, open: this._isOpen });
        this.updateState();
      }
      disconnectedCallback() {
        this.blocker.destroy();
        menuController._unregister(this);
        if (this.animation) {
          this.animation.destroy();
        }
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
        this.animation = undefined;
        this.contentEl = this.backdropEl = this.menuInnerEl = undefined;
      }
      onSplitPaneChanged(ev) {
        this.isPaneVisible = ev.detail.isPane(this.el);
        this.updateState();
      }
      onBackdropClick(ev) {
        if (this._isOpen && this.lastOnEnd < ev.timeStamp - 100) {
          const shouldClose = ev.composedPath ? !ev.composedPath().includes(this.menuInnerEl) : false;
          if (shouldClose) {
            ev.preventDefault();
            ev.stopPropagation();
            this.close();
          }
        }
      }
      /**
       * Returns `true` is the menu is open.
       */
      isOpen() {
        return Promise.resolve(this._isOpen);
      }
      /**
       * Returns `true` is the menu is active.
       *
       * A menu is active when it can be opened or closed, meaning it's enabled
       * and it's not part of a `ion-split-pane`.
       */
      isActive() {
        return Promise.resolve(this._isActive());
      }
      /**
       * Opens the menu. If the menu is already open or it can't be opened,
       * it returns `false`.
       */
      open(animated = true) {
        return this.setOpen(true, animated);
      }
      /**
       * Closes the menu. If the menu is already closed or it can't be closed,
       * it returns `false`.
       */
      close(animated = true) {
        return this.setOpen(false, animated);
      }
      /**
       * Toggles the menu. If the menu is already open, it will try to close, otherwise it will try to open it.
       * If the operation can't be completed successfully, it returns `false`.
       */
      toggle(animated = true) {
        return this.setOpen(!this._isOpen, animated);
      }
      /**
       * Opens or closes the button.
       * If the operation can't be completed successfully, it returns `false`.
       */
      setOpen(shouldOpen, animated = true) {
        return menuController._setOpen(this, shouldOpen, animated);
      }
      async _setOpen(shouldOpen, animated = true) {
        // If the menu is disabled or it is currently being animated, let's do nothing
        if (!this._isActive() || this.isAnimating || shouldOpen === this._isOpen) {
          return false;
        }
        this.beforeAnimation(shouldOpen);
        await this.loadAnimation();
        await this.startAnimation(shouldOpen, animated);
        this.afterAnimation(shouldOpen);
        return true;
      }
      async loadAnimation() {
        // Menu swipe animation takes the menu's inner width as parameter,
        // If `offsetWidth` changes, we need to create a new animation.
        const width = this.menuInnerEl.offsetWidth;
        if (width === this.width && this.animation !== undefined) {
          return;
        }
        this.width = width;
        // Destroy existing animation
        if (this.animation) {
          this.animation.destroy();
          this.animation = undefined;
        }
        // Create new animation
        this.animation = await menuController._createAnimation(this.type, this);
        if (!config$2.getBoolean('animated', true)) {
          this.animation.duration(0);
        }
        this.animation.fill('both');
      }
      async startAnimation(shouldOpen, animated) {
        const isReversed = !shouldOpen;
        const mode = getIonMode$1(this);
        const easing = mode === 'ios' ? iosEasing : mdEasing;
        const easingReverse = mode === 'ios' ? iosEasingReverse : mdEasingReverse;
        const ani = this.animation
          .direction(isReversed ? 'reverse' : 'normal')
          .easing(isReversed ? easingReverse : easing)
          .onFinish(() => {
            if (ani.getDirection() === 'reverse') {
              ani.direction('normal');
            }
          });
        if (animated) {
          await ani.play();
        } else {
          ani.play({ sync: true });
        }
      }
      _isActive() {
        return !this.disabled && !this.isPaneVisible;
      }
      canSwipe() {
        return this.swipeGesture && !this.isAnimating && this._isActive();
      }
      canStart(detail) {
        // Do not allow swipe gesture if a modal is open
        const isModalPresented = !!document.querySelector('ion-modal.show-modal');
        if (isModalPresented || !this.canSwipe()) {
          return false;
        }
        if (this._isOpen) {
          return true;
          // TODO error
        } else if (menuController._getOpenSync()) {
          return false;
        }
        return checkEdgeSide(window, detail.currentX, this.isEndSide, this.maxEdgeStart);
      }
      onWillStart() {
        this.beforeAnimation(!this._isOpen);
        return this.loadAnimation();
      }
      onStart() {
        if (!this.isAnimating || !this.animation) {
          assert(false, 'isAnimating has to be true');
          return;
        }
        // the cloned animation should not use an easing curve during seek
        this.animation.progressStart(true, this._isOpen ? 1 : 0);
      }
      onMove(detail) {
        if (!this.isAnimating || !this.animation) {
          assert(false, 'isAnimating has to be true');
          return;
        }
        const delta = computeDelta(detail.deltaX, this._isOpen, this.isEndSide);
        const stepValue = delta / this.width;
        this.animation.progressStep(this._isOpen ? 1 - stepValue : stepValue);
      }
      onEnd(detail) {
        if (!this.isAnimating || !this.animation) {
          assert(false, 'isAnimating has to be true');
          return;
        }
        const isOpen = this._isOpen;
        const isEndSide = this.isEndSide;
        const delta = computeDelta(detail.deltaX, isOpen, isEndSide);
        const width = this.width;
        const stepValue = delta / width;
        const velocity = detail.velocityX;
        const z = width / 2.0;
        const shouldCompleteRight = velocity >= 0 && (velocity > 0.2 || detail.deltaX > z);
        const shouldCompleteLeft = velocity <= 0 && (velocity < -0.2 || detail.deltaX < -z);
        const shouldComplete = isOpen ? (isEndSide ? shouldCompleteRight : shouldCompleteLeft) : isEndSide ? shouldCompleteLeft : shouldCompleteRight;
        let shouldOpen = !isOpen && shouldComplete;
        if (isOpen && !shouldComplete) {
          shouldOpen = true;
        }
        this.lastOnEnd = detail.currentTime;
        // Account for rounding errors in JS
        let newStepValue = shouldComplete ? 0.001 : -0.001;
        /**
         * TODO: stepValue can sometimes return a negative
         * value, but you can't have a negative time value
         * for the cubic bezier curve (at least with web animations)
         * Not sure if the negative step value is an error or not
         */
        const adjustedStepValue = stepValue < 0 ? 0.01 : stepValue;
        /**
         * Animation will be reversed here, so need to
         * reverse the easing curve as well
         *
         * Additionally, we need to account for the time relative
         * to the new easing curve, as `stepValue` is going to be given
         * in terms of a linear curve.
         */
        newStepValue += getTimeGivenProgression([0, 0], [0.4, 0], [0.6, 1], [1, 1], clamp(0, adjustedStepValue, 0.9999))[0] || 0;
        const playTo = this._isOpen ? !shouldComplete : shouldComplete;
        this.animation
          .easing('cubic-bezier(0.4, 0.0, 0.6, 1)')
          .onFinish(() => this.afterAnimation(shouldOpen), { oneTimeCallback: true })
          .progressEnd(playTo ? 1 : 0, this._isOpen ? 1 - newStepValue : newStepValue, 300);
      }
      beforeAnimation(shouldOpen) {
        assert(!this.isAnimating, '_before() should not be called while animating');
        // this places the menu into the correct location before it animates in
        // this css class doesn't actually kick off any animations
        this.el.classList.add(SHOW_MENU);
        if (this.backdropEl) {
          this.backdropEl.classList.add(SHOW_BACKDROP);
        }
        this.blocker.block();
        this.isAnimating = true;
        if (shouldOpen) {
          this.ionWillOpen.emit();
        } else {
          this.ionWillClose.emit();
        }
      }
      afterAnimation(isOpen) {
        assert(this.isAnimating, '_before() should be called while animating');
        // keep opening/closing the menu disabled for a touch more yet
        // only add listeners/css if it's enabled and isOpen
        // and only remove listeners/css if it's not open
        // emit opened/closed events
        this._isOpen = isOpen;
        this.isAnimating = false;
        if (!this._isOpen) {
          this.blocker.unblock();
        }
        if (isOpen) {
          // add css class
          if (this.contentEl) {
            this.contentEl.classList.add(MENU_CONTENT_OPEN);
          }
          // emit open event
          this.ionDidOpen.emit();
        } else {
          // remove css classes
          this.el.classList.remove(SHOW_MENU);
          if (this.contentEl) {
            this.contentEl.classList.remove(MENU_CONTENT_OPEN);
          }
          if (this.backdropEl) {
            this.backdropEl.classList.remove(SHOW_BACKDROP);
          }
          if (this.animation) {
            this.animation.stop();
          }
          // emit close event
          this.ionDidClose.emit();
        }
      }
      updateState() {
        const isActive = this._isActive();
        if (this.gesture) {
          this.gesture.enable(isActive && this.swipeGesture);
        }
        // Close menu immediately
        if (!isActive && this._isOpen) {
          // close if this menu is open, and should not be enabled
          this.forceClosing();
        }
        if (!this.disabled) {
          menuController._setActiveMenu(this);
        }
        assert(!this.isAnimating, 'can not be animating');
      }
      forceClosing() {
        assert(this._isOpen, 'menu cannot be closed');
        this.isAnimating = true;
        const ani = this.animation.direction('reverse');
        ani.play({ sync: true });
        this.afterAnimation(false);
      }
      render() {
        const { isEndSide, type, disabled, isPaneVisible } = this;
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            role: 'navigation',
            class: {
              [mode]: true,
              [`menu-type-${type}`]: true,
              'menu-enabled': !disabled,
              'menu-side-end': isEndSide,
              'menu-side-start': !isEndSide,
              'menu-pane-visible': isPaneVisible,
            },
          },
          hAsync('div', { class: 'menu-inner', part: 'container', ref: el => (this.menuInnerEl = el) }, hAsync('slot', null)),
          hAsync('ion-backdrop', { ref: el => (this.backdropEl = el), class: 'menu-backdrop', tappable: false, stopPropagation: false, part: 'backdrop' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          type: ['typeChanged'],
          disabled: ['disabledChanged'],
          side: ['sideChanged'],
          swipeGesture: ['swipeGestureChanged'],
        };
      }
      static get style() {
        return {
          ios: menuIosCss,
          md: menuMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-menu',
          $members$: {
            contentId: [513, 'content-id'],
            menuId: [513, 'menu-id'],
            type: [1025],
            disabled: [1028],
            side: [513],
            swipeGesture: [4, 'swipe-gesture'],
            maxEdgeStart: [2, 'max-edge-start'],
            isPaneVisible: [32],
            isEndSide: [32],
            isOpen: [64],
            isActive: [64],
            open: [64],
            close: [64],
            toggle: [64],
            setOpen: [64],
          },
          $listeners$: [
            [16, 'ionSplitPaneVisible', 'onSplitPaneChanged'],
            [2, 'click', 'onBackdropClick'],
          ],
          $lazyBundleId$: '-',
          $attrsToReflect$: [
            ['contentId', 'content-id'],
            ['menuId', 'menu-id'],
            ['side', 'side'],
          ],
        };
      }
    }
    const computeDelta = (deltaX, isOpen, isEndSide) => {
      return Math.max(0, isOpen !== isEndSide ? -deltaX : deltaX);
    };
    const checkEdgeSide = (win, posX, isEndSide, maxEdgeStart) => {
      if (isEndSide) {
        return posX >= win.innerWidth - maxEdgeStart;
      } else {
        return posX <= maxEdgeStart;
      }
    };
    const SHOW_MENU = 'show-menu';
    const SHOW_BACKDROP = 'show-backdrop';
    const MENU_CONTENT_OPEN = 'menu-content-open';

    // Given a menu, return whether or not the menu toggle should be visible
    const updateVisibility = async menu => {
      const menuEl = await menuController.get(menu);
      return !!(menuEl && (await menuEl.isActive()));
    };

    const menuButtonIosCss =
      '/*!@:host*/.sc-ion-menu-button-ios-h{--background:transparent;--color-focused:currentColor;--border-radius:initial;--padding-top:0;--padding-bottom:0;color:var(--color);text-align:center;text-decoration:none;text-overflow:ellipsis;text-transform:none;white-space:nowrap;font-kerning:none}/*!@.button-native*/.button-native.sc-ion-menu-button-ios{border-radius:var(--border-radius);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%;border:0;outline:none;background:var(--background);line-height:1;cursor:pointer;overflow:hidden;user-select:none;z-index:0;appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-menu-button-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.button-inner*/.button-inner.sc-ion-menu-button-ios{display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%;z-index:1}/*!@ion-icon*/ion-icon.sc-ion-menu-button-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;pointer-events:none}/*!@:host(.menu-button-hidden)*/.menu-button-hidden.sc-ion-menu-button-ios-h{display:none}/*!@:host(.menu-button-disabled)*/.menu-button-disabled.sc-ion-menu-button-ios-h{cursor:default;opacity:0.5;pointer-events:none}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-menu-button-ios-h .button-native.sc-ion-menu-button-ios{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-menu-button-ios-h .button-native.sc-ion-menu-button-ios::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}/*!@.button-native::after*/.button-native.sc-ion-menu-button-ios::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}@media (any-hover: hover){/*!@:host(:hover) .button-native*/.sc-ion-menu-button-ios-h:hover .button-native.sc-ion-menu-button-ios{color:var(--color-hover)}/*!@:host(:hover) .button-native::after*/.sc-ion-menu-button-ios-h:hover .button-native.sc-ion-menu-button-ios::after{background:var(--background-hover);opacity:var(--background-hover-opacity, 0)}}/*!@:host(.ion-color) .button-native*/.ion-color.sc-ion-menu-button-ios-h .button-native.sc-ion-menu-button-ios{color:var(--ion-color-base)}/*!@:host(.in-toolbar:not(.in-toolbar-color))*/.in-toolbar.sc-ion-menu-button-ios-h:not(.in-toolbar-color){color:var(--ion-toolbar-color, var(--color))}/*!@:host*/.sc-ion-menu-button-ios-h{--background-focused:currentColor;--background-focused-opacity:.1;--border-radius:4px;--color:var(--ion-color-primary, #3880ff);--padding-start:5px;--padding-end:5px;height:32px;font-size:31px}/*!@:host(.ion-activated)*/.ion-activated.sc-ion-menu-button-ios-h{opacity:0.4}@media (any-hover: hover){/*!@:host(:hover)*/.sc-ion-menu-button-ios-h:hover{opacity:0.6}}';

    const menuButtonMdCss =
      '/*!@:host*/.sc-ion-menu-button-md-h{--background:transparent;--color-focused:currentColor;--border-radius:initial;--padding-top:0;--padding-bottom:0;color:var(--color);text-align:center;text-decoration:none;text-overflow:ellipsis;text-transform:none;white-space:nowrap;font-kerning:none}/*!@.button-native*/.button-native.sc-ion-menu-button-md{border-radius:var(--border-radius);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%;border:0;outline:none;background:var(--background);line-height:1;cursor:pointer;overflow:hidden;user-select:none;z-index:0;appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-menu-button-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.button-inner*/.button-inner.sc-ion-menu-button-md{display:flex;position:relative;flex-flow:row nowrap;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%;z-index:1}/*!@ion-icon*/ion-icon.sc-ion-menu-button-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;pointer-events:none}/*!@:host(.menu-button-hidden)*/.menu-button-hidden.sc-ion-menu-button-md-h{display:none}/*!@:host(.menu-button-disabled)*/.menu-button-disabled.sc-ion-menu-button-md-h{cursor:default;opacity:0.5;pointer-events:none}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-menu-button-md-h .button-native.sc-ion-menu-button-md{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-menu-button-md-h .button-native.sc-ion-menu-button-md::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}/*!@.button-native::after*/.button-native.sc-ion-menu-button-md::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}@media (any-hover: hover){/*!@:host(:hover) .button-native*/.sc-ion-menu-button-md-h:hover .button-native.sc-ion-menu-button-md{color:var(--color-hover)}/*!@:host(:hover) .button-native::after*/.sc-ion-menu-button-md-h:hover .button-native.sc-ion-menu-button-md::after{background:var(--background-hover);opacity:var(--background-hover-opacity, 0)}}/*!@:host(.ion-color) .button-native*/.ion-color.sc-ion-menu-button-md-h .button-native.sc-ion-menu-button-md{color:var(--ion-color-base)}/*!@:host(.in-toolbar:not(.in-toolbar-color))*/.in-toolbar.sc-ion-menu-button-md-h:not(.in-toolbar-color){color:var(--ion-toolbar-color, var(--color))}/*!@:host*/.sc-ion-menu-button-md-h{--background-focused:currentColor;--background-focused-opacity:.12;--background-hover:currentColor;--background-hover-opacity:.04;--border-radius:50%;--color:initial;--padding-start:8px;--padding-end:8px;width:48px;height:48px;font-size:24px}/*!@:host(.ion-color.ion-focused)::after*/.ion-color.ion-focused.sc-ion-menu-button-md-h::after{background:var(--ion-color-base)}@media (any-hover: hover){/*!@:host(.ion-color:hover) .button-native::after*/.ion-color.sc-ion-menu-button-md-h:hover .button-native.sc-ion-menu-button-md::after{background:var(--ion-color-base)}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part native - The native HTML button element that wraps all child elements.
     * @part icon - The menu button icon (uses ion-icon).
     */
    class MenuButton {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.inheritedAttributes = {};
        this.visible = false;
        /**
         * If `true`, the user cannot interact with the menu button.
         */
        this.disabled = false;
        /**
         * Automatically hides the menu button when the corresponding menu is not active
         */
        this.autoHide = true;
        /**
         * The type of the button.
         */
        this.type = 'button';
        this.onClick = async () => {
          return menuController.toggle(this.menu);
        };
      }
      componentWillLoad() {
        this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);
      }
      componentDidLoad() {
        this.visibilityChanged();
      }
      async visibilityChanged() {
        this.visible = await updateVisibility(this.menu);
      }
      render() {
        const { color, disabled, inheritedAttributes } = this;
        const mode = getIonMode$1(this);
        const menuIcon = config$2.get('menuIcon', mode === 'ios' ? 'menu-outline' : 'menu-sharp');
        const hidden = this.autoHide && !this.visible;
        const attrs = {
          type: this.type,
        };
        const ariaLabel = inheritedAttributes['aria-label'] || 'menu';
        return hAsync(
          Host,
          {
            'onClick': this.onClick,
            'aria-disabled': disabled ? 'true' : null,
            'aria-hidden': hidden ? 'true' : null,
            'class': createColorClasses$1(color, {
              [mode]: true,
              'button': true,
              'menu-button-hidden': hidden,
              'menu-button-disabled': disabled,
              'in-toolbar': hostContext('ion-toolbar', this.el),
              'in-toolbar-color': hostContext('ion-toolbar[color]', this.el),
              'ion-activatable': true,
              'ion-focusable': true,
            }),
          },
          hAsync(
            'button',
            Object.assign({}, attrs, { 'disabled': disabled, 'class': 'button-native', 'part': 'native', 'aria-label': ariaLabel }),
            hAsync(
              'span',
              { class: 'button-inner' },
              hAsync('slot', null, hAsync('ion-icon', { 'part': 'icon', 'icon': menuIcon, 'mode': mode, 'lazy': false, 'aria-hidden': 'true' })),
            ),
            mode === 'md' && hAsync('ion-ripple-effect', { type: 'unbounded' }),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: menuButtonIosCss,
          md: menuButtonMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-menu-button',
          $members$: {
            color: [513],
            disabled: [4],
            menu: [1],
            autoHide: [4, 'auto-hide'],
            type: [1],
            visible: [32],
          },
          $listeners$: [
            [16, 'ionMenuChange', 'visibilityChanged'],
            [16, 'ionSplitPaneVisible', 'visibilityChanged'],
          ],
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const menuToggleCss = '/*!@:host(.menu-toggle-hidden)*/.menu-toggle-hidden.sc-ion-menu-toggle-h{display:none}';

    class MenuToggle {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.visible = false;
        /**
         * Automatically hides the content when the corresponding menu is not active.
         *
         * By default, it's `true`. Change it to `false` in order to
         * keep `ion-menu-toggle` always visible regardless the state of the menu.
         */
        this.autoHide = true;
        this.onClick = () => {
          return menuController.toggle(this.menu);
        };
      }
      connectedCallback() {
        this.visibilityChanged();
      }
      async visibilityChanged() {
        this.visible = await updateVisibility(this.menu);
      }
      render() {
        const mode = getIonMode$1(this);
        const hidden = this.autoHide && !this.visible;
        return hAsync(
          Host,
          {
            'onClick': this.onClick,
            'aria-hidden': hidden ? 'true' : null,
            'class': {
              [mode]: true,
              'menu-toggle-hidden': hidden,
            },
          },
          hAsync('slot', null),
        );
      }
      static get style() {
        return menuToggleCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-menu-toggle',
          $members$: {
            menu: [1],
            autoHide: [4, 'auto-hide'],
            visible: [32],
          },
          $listeners$: [
            [16, 'ionMenuChange', 'visibilityChanged'],
            [16, 'ionSplitPaneVisible', 'visibilityChanged'],
          ],
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const attachComponent = async (delegate, container, component, cssClasses, componentProps) => {
      if (delegate) {
        return delegate.attachViewToDom(container, component, componentProps, cssClasses);
      }
      if (typeof component !== 'string' && !(component instanceof HTMLElement)) {
        throw new Error('framework delegate is missing');
      }
      const el = typeof component === 'string' ? container.ownerDocument && container.ownerDocument.createElement(component) : component;
      if (cssClasses) {
        cssClasses.forEach(c => el.classList.add(c));
      }
      if (componentProps) {
        Object.assign(el, componentProps);
      }
      container.appendChild(el);
      await new Promise(resolve => componentOnReady(el, resolve));
      return el;
    };
    const detachComponent = (delegate, element) => {
      if (element) {
        if (delegate) {
          const container = element.parentElement;
          return delegate.removeViewFromDom(container, element);
        }
        element.remove();
      }
      return Promise.resolve();
    };

    // Defaults for the card swipe animation
    const SwipeToCloseDefaults = {
      MIN_PRESENTING_SCALE: 0.93,
    };
    const createSwipeToCloseGesture = (el, animation, onDismiss) => {
      const height = el.offsetHeight;
      let isOpen = false;
      const canStart = detail => {
        const target = detail.event.target;
        if (target === null || !target.closest) {
          return true;
        }
        const contentOrFooter = target.closest('ion-content, ion-footer');
        if (contentOrFooter === null) {
          return true;
        }
        // Target is in the content or the footer so do not start the gesture.
        // We could be more nuanced here and allow it for content that
        // does not need to scroll.
        return false;
      };
      const onStart = () => {
        animation.progressStart(true, isOpen ? 1 : 0);
      };
      const onMove = detail => {
        const step = clamp(0.0001, detail.deltaY / height, 0.9999);
        animation.progressStep(step);
      };
      const onEnd = detail => {
        const velocity = detail.velocityY;
        const step = clamp(0.0001, detail.deltaY / height, 0.9999);
        const threshold = (detail.deltaY + velocity * 1000) / height;
        const shouldComplete = threshold >= 0.5;
        let newStepValue = shouldComplete ? -0.001 : 0.001;
        if (!shouldComplete) {
          animation.easing('cubic-bezier(1, 0, 0.68, 0.28)');
          newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];
        } else {
          animation.easing('cubic-bezier(0.32, 0.72, 0, 1)');
          newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];
        }
        const duration = shouldComplete ? computeDuration(step * height, velocity) : computeDuration((1 - step) * height, velocity);
        isOpen = shouldComplete;
        gesture.enable(false);
        animation
          .onFinish(() => {
            if (!shouldComplete) {
              gesture.enable(true);
            }
          })
          .progressEnd(shouldComplete ? 1 : 0, newStepValue, duration);
        if (shouldComplete) {
          onDismiss();
        }
      };
      const gesture = createGesture({
        el,
        gestureName: 'modalSwipeToClose',
        gesturePriority: 40,
        direction: 'y',
        threshold: 10,
        canStart,
        onStart,
        onMove,
        onEnd,
      });
      return gesture;
    };
    const computeDuration = (remaining, velocity) => {
      return clamp(400, remaining / Math.abs(velocity * 1.1), 500);
    };

    /**
     * iOS Modal Enter Animation for the Card presentation style
     */
    const iosEnterAnimation$3 = (baseEl, presentingEl) => {
      const backdropAnimation = createAnimation()
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      const wrapperAnimation = createAnimation()
        .addElement(baseEl.querySelectorAll('.modal-wrapper, .modal-shadow'))
        .beforeStyles({ opacity: 1 })
        .fromTo('transform', 'translateY(100vh)', 'translateY(0vh)');
      const baseAnimation = createAnimation().addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(500).addAnimation(wrapperAnimation);
      if (presentingEl) {
        const isMobile = window.innerWidth < 768;
        const hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;
        const presentingAnimation = createAnimation().beforeStyles({
          'transform': 'translateY(0)',
          'transform-origin': 'top center',
          'overflow': 'hidden',
        });
        const bodyEl = document.body;
        if (isMobile) {
          /**
           * Fallback for browsers that does not support `max()` (ex: Firefox)
           * No need to worry about statusbar padding since engines like Gecko
           * are not used as the engine for standlone Cordova/Capacitor apps
           */
          const transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';
          const modalTransform = hasCardModal ? '-10px' : transformOffset;
          const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
          const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;
          presentingAnimation
            .afterStyles({
              transform: finalTransform,
            })
            .beforeAddWrite(() => bodyEl.style.setProperty('background-color', 'black'))
            .addElement(presentingEl)
            .keyframes([
              { offset: 0, filter: 'contrast(1)', transform: 'translateY(0px) scale(1)', borderRadius: '0px' },
              { offset: 1, filter: 'contrast(0.85)', transform: finalTransform, borderRadius: '10px 10px 0 0' },
            ]);
          baseAnimation.addAnimation(presentingAnimation);
        } else {
          baseAnimation.addAnimation(backdropAnimation);
          if (!hasCardModal) {
            wrapperAnimation.fromTo('opacity', '0', '1');
          } else {
            const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;
            const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;
            presentingAnimation
              .afterStyles({
                transform: finalTransform,
              })
              .addElement(presentingEl.querySelector('.modal-wrapper'))
              .keyframes([
                { offset: 0, filter: 'contrast(1)', transform: 'translateY(0) scale(1)' },
                { offset: 1, filter: 'contrast(0.85)', transform: finalTransform },
              ]);
            const shadowAnimation = createAnimation()
              .afterStyles({
                transform: finalTransform,
              })
              .addElement(presentingEl.querySelector('.modal-shadow'))
              .keyframes([
                { offset: 0, opacity: '1', transform: 'translateY(0) scale(1)' },
                { offset: 1, opacity: '0', transform: finalTransform },
              ]);
            baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
          }
        }
      } else {
        baseAnimation.addAnimation(backdropAnimation);
      }
      return baseAnimation;
    };

    /**
     * iOS Modal Leave Animation
     */
    const iosLeaveAnimation$3 = (baseEl, presentingEl, duration = 500) => {
      const backdropAnimation = createAnimation().addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0.0);
      const wrapperAnimation = createAnimation()
        .addElement(baseEl.querySelectorAll('.modal-wrapper, .modal-shadow'))
        .beforeStyles({ opacity: 1 })
        .fromTo('transform', 'translateY(0vh)', 'translateY(100vh)');
      const baseAnimation = createAnimation().addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(duration).addAnimation(wrapperAnimation);
      if (presentingEl) {
        const isMobile = window.innerWidth < 768;
        const hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;
        const presentingAnimation = createAnimation()
          .beforeClearStyles(['transform'])
          .afterClearStyles(['transform'])
          .onFinish(currentStep => {
            // only reset background color if this is the last card-style modal
            if (currentStep !== 1) {
              return;
            }
            presentingEl.style.setProperty('overflow', '');
            const numModals = Array.from(bodyEl.querySelectorAll('ion-modal')).filter(m => m.presentingElement !== undefined).length;
            if (numModals <= 1) {
              bodyEl.style.setProperty('background-color', '');
            }
          });
        const bodyEl = document.body;
        if (isMobile) {
          const transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';
          const modalTransform = hasCardModal ? '-10px' : transformOffset;
          const toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;
          const finalTransform = `translateY(${modalTransform}) scale(${toPresentingScale})`;
          presentingAnimation.addElement(presentingEl).keyframes([
            { offset: 0, filter: 'contrast(0.85)', transform: finalTransform, borderRadius: '10px 10px 0 0' },
            { offset: 1, filter: 'contrast(1)', transform: 'translateY(0px) scale(1)', borderRadius: '0px' },
          ]);
          baseAnimation.addAnimation(presentingAnimation);
        } else {
          baseAnimation.addAnimation(backdropAnimation);
          if (!hasCardModal) {
            wrapperAnimation.fromTo('opacity', '1', '0');
          } else {
            const toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;
            const finalTransform = `translateY(-10px) scale(${toPresentingScale})`;
            presentingAnimation
              .addElement(presentingEl.querySelector('.modal-wrapper'))
              .afterStyles({
                transform: 'translate3d(0, 0, 0)',
              })
              .keyframes([
                { offset: 0, filter: 'contrast(0.85)', transform: finalTransform },
                { offset: 1, filter: 'contrast(1)', transform: 'translateY(0) scale(1)' },
              ]);
            const shadowAnimation = createAnimation()
              .addElement(presentingEl.querySelector('.modal-shadow'))
              .afterStyles({
                transform: 'translateY(0) scale(1)',
              })
              .keyframes([
                { offset: 0, opacity: '0', transform: finalTransform },
                { offset: 1, opacity: '1', transform: 'translateY(0) scale(1)' },
              ]);
            baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);
          }
        }
      } else {
        baseAnimation.addAnimation(backdropAnimation);
      }
      return baseAnimation;
    };

    /**
     * Md Modal Enter Animation
     */
    const mdEnterAnimation$2 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      wrapperAnimation.addElement(baseEl.querySelector('.modal-wrapper')).keyframes([
        { offset: 0, opacity: 0.01, transform: 'translateY(40px)' },
        { offset: 1, opacity: 1, transform: 'translateY(0px)' },
      ]);
      return baseAnimation.addElement(baseEl).easing('cubic-bezier(0.36,0.66,0.04,1)').duration(280).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * Md Modal Leave Animation
     */
    const mdLeaveAnimation$2 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      const wrapperEl = baseEl.querySelector('.modal-wrapper');
      backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0.0);
      wrapperAnimation.addElement(wrapperEl).keyframes([
        { offset: 0, opacity: 0.99, transform: 'translateY(0px)' },
        { offset: 1, opacity: 0, transform: 'translateY(40px)' },
      ]);
      return baseAnimation.addElement(baseEl).easing('cubic-bezier(0.47,0,0.745,0.715)').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    const modalIosCss =
      '.sc-ion-modal-ios-h{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:flex;position:absolute;align-items:center;justify-content:center;outline:none;contain:strict}.overlay-hidden.sc-ion-modal-ios-h{display:none}.modal-wrapper.sc-ion-modal-ios,.modal-shadow.sc-ion-modal-ios{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow.sc-ion-modal-ios{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){.sc-ion-modal-ios-h{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){.sc-ion-modal-ios-h{--width:600px;--height:600px}}.sc-ion-modal-ios-h:first-of-type{--backdrop-opacity:var(--ion-backdrop-opacity, 0.4)}@media only screen and (min-width: 768px) and (min-height: 600px){.sc-ion-modal-ios-h{--border-radius:10px}}.modal-wrapper.sc-ion-modal-ios{transform:translate3d(0,  100%,  0)}@media screen and (max-width: 767px){@supports (width: max(0px, 1px)){.modal-card.sc-ion-modal-ios-h{--height:calc(100% - max(30px, var(--ion-safe-area-top)) - 10px)}}@supports not (width: max(0px, 1px)){.modal-card.sc-ion-modal-ios-h{--height:calc(100% - 40px)}}.modal-card.sc-ion-modal-ios-h .modal-wrapper.sc-ion-modal-ios{border-top-left-radius:10px;border-top-right-radius:10px;border-bottom-right-radius:0;border-bottom-left-radius:0}[dir=rtl].sc-ion-modal-ios-h -no-combinator.modal-card.sc-ion-modal-ios-h .modal-wrapper.sc-ion-modal-ios,[dir=rtl] .sc-ion-modal-ios-h -no-combinator.modal-card.sc-ion-modal-ios-h .modal-wrapper.sc-ion-modal-ios,[dir=rtl].modal-card.sc-ion-modal-ios-h .modal-wrapper.sc-ion-modal-ios,[dir=rtl] .modal-card.sc-ion-modal-ios-h .modal-wrapper.sc-ion-modal-ios{border-top-left-radius:10px;border-top-right-radius:10px;border-bottom-right-radius:0;border-bottom-left-radius:0}.modal-card.sc-ion-modal-ios-h{--backdrop-opacity:0;--width:100%;align-items:flex-end}.modal-card.sc-ion-modal-ios-h .modal-shadow.sc-ion-modal-ios{display:none}.modal-card.sc-ion-modal-ios-h ion-backdrop.sc-ion-modal-ios{pointer-events:none}}@media screen and (min-width: 768px){.modal-card.sc-ion-modal-ios-h{--width:calc(100% - 120px);--height:calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));--max-width:720px;--max-height:1000px}.modal-card.sc-ion-modal-ios-h{--backdrop-opacity:0;transition:all 0.5s ease-in-out}.modal-card.sc-ion-modal-ios-h:first-of-type{--backdrop-opacity:0.18}.modal-card.sc-ion-modal-ios-h .modal-shadow.sc-ion-modal-ios{box-shadow:0px 0px 30px 10px rgba(0, 0, 0, 0.1)}}';

    const modalMdCss =
      '.sc-ion-modal-md-h{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:flex;position:absolute;align-items:center;justify-content:center;outline:none;contain:strict}.overlay-hidden.sc-ion-modal-md-h{display:none}.modal-wrapper.sc-ion-modal-md,.modal-shadow.sc-ion-modal-md{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow.sc-ion-modal-md{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){.sc-ion-modal-md-h{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){.sc-ion-modal-md-h{--width:600px;--height:600px}}.sc-ion-modal-md-h:first-of-type{--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}@media only screen and (min-width: 768px) and (min-height: 600px){.sc-ion-modal-md-h{--border-radius:2px}.sc-ion-modal-md-h:first-of-type{--box-shadow:0 28px 48px rgba(0, 0, 0, 0.4)}}.modal-wrapper.sc-ion-modal-md{transform:translate3d(0,  40px,  0);opacity:0.01}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Modal {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.didPresent = createEvent(this, 'ionModalDidPresent', 7);
        this.willPresent = createEvent(this, 'ionModalWillPresent', 7);
        this.willDismiss = createEvent(this, 'ionModalWillDismiss', 7);
        this.didDismiss = createEvent(this, 'ionModalDidDismiss', 7);
        // Whether or not modal is being dismissed via gesture
        this.gestureAnimationDismissing = false;
        this.presented = false;
        /**
         * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
         */
        this.keyboardClose = true;
        /**
         * If `true`, the modal will be dismissed when the backdrop is clicked.
         */
        this.backdropDismiss = true;
        /**
         * If `true`, a backdrop will be displayed behind the modal.
         */
        this.showBackdrop = true;
        /**
         * If `true`, the modal will animate.
         */
        this.animated = true;
        /**
         * If `true`, the modal can be swiped to dismiss. Only applies in iOS mode.
         */
        this.swipeToClose = false;
        this.onBackdropTap = () => {
          this.dismiss(undefined, BACKDROP);
        };
        this.onDismiss = ev => {
          ev.stopPropagation();
          ev.preventDefault();
          this.dismiss();
        };
        this.onLifecycle = modalEvent => {
          const el = this.usersElement;
          const name = LIFECYCLE_MAP$1[modalEvent.type];
          if (el && name) {
            const ev = new CustomEvent(name, {
              bubbles: false,
              cancelable: false,
              detail: modalEvent.detail,
            });
            el.dispatchEvent(ev);
          }
        };
      }
      swipeToCloseChanged(enable) {
        if (this.gesture) {
          this.gesture.enable(enable);
        } else if (enable) {
          this.initSwipeToClose();
        }
      }
      connectedCallback() {
        prepareOverlay(this.el);
      }
      /**
       * Present the modal overlay after it has been created.
       */
      async present() {
        if (this.presented) {
          return;
        }
        const container = this.el.querySelector(`.modal-wrapper`);
        if (!container) {
          throw new Error('container is undefined');
        }
        const componentProps = Object.assign(Object.assign({}, this.componentProps), { modal: this.el });
        this.usersElement = await attachComponent(this.delegate, container, this.component, ['ion-page'], componentProps);
        await deepReady(this.usersElement);
        writeTask(() => this.el.classList.add('show-modal'));
        await present(this, 'modalEnter', iosEnterAnimation$3, mdEnterAnimation$2, this.presentingElement);
        if (this.swipeToClose) {
          this.initSwipeToClose();
        }
      }
      initSwipeToClose() {
        if (getIonMode$1(this) !== 'ios') {
          return;
        }
        // All of the elements needed for the swipe gesture
        // should be in the DOM and referenced by now, except
        // for the presenting el
        const animationBuilder = this.leaveAnimation || config$2.get('modalLeave', iosLeaveAnimation$3);
        const ani = (this.animation = animationBuilder(this.el, this.presentingElement));
        this.gesture = createSwipeToCloseGesture(this.el, ani, () => {
          /**
           * While the gesture animation is finishing
           * it is possible for a user to tap the backdrop.
           * This would result in the dismiss animation
           * being played again. Typically this is avoided
           * by setting `presented = false` on the overlay
           * component; however, we cannot do that here as
           * that would prevent the element from being
           * removed from the DOM.
           */
          this.gestureAnimationDismissing = true;
          this.animation.onFinish(async () => {
            await this.dismiss(undefined, 'gesture');
            this.gestureAnimationDismissing = false;
          });
        });
        this.gesture.enable(true);
      }
      /**
       * Dismiss the modal overlay after it has been presented.
       *
       * @param data Any data to emit in the dismiss events.
       * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.
       */
      async dismiss(data, role) {
        if (this.gestureAnimationDismissing && role !== 'gesture') {
          return false;
        }
        const enteringAnimation = activeAnimations.get(this) || [];
        const dismissed = await dismiss(this, data, role, 'modalLeave', iosLeaveAnimation$3, mdLeaveAnimation$2, this.presentingElement);
        if (dismissed) {
          await detachComponent(this.delegate, this.usersElement);
          if (this.animation) {
            this.animation.destroy();
          }
          enteringAnimation.forEach(ani => ani.destroy());
        }
        this.animation = undefined;
        return dismissed;
      }
      /**
       * Returns a promise that resolves when the modal did dismiss.
       */
      onDidDismiss() {
        return eventMethod(this.el, 'ionModalDidDismiss');
      }
      /**
       * Returns a promise that resolves when the modal will dismiss.
       */
      onWillDismiss() {
        return eventMethod(this.el, 'ionModalWillDismiss');
      }
      render() {
        const { htmlAttributes } = this;
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          Object.assign({ 'no-router': true, 'aria-modal': 'true', 'tabindex': '-1' }, htmlAttributes, {
            style: {
              zIndex: `${20000 + this.overlayIndex}`,
            },
            class: Object.assign({ [mode]: true, [`modal-card`]: this.presentingElement !== undefined && mode === 'ios' }, getClassMap(this.cssClass)),
            onIonBackdropTap: this.onBackdropTap,
            onIonDismiss: this.onDismiss,
            onIonModalDidPresent: this.onLifecycle,
            onIonModalWillPresent: this.onLifecycle,
            onIonModalWillDismiss: this.onLifecycle,
            onIonModalDidDismiss: this.onLifecycle,
          }),
          hAsync('ion-backdrop', { visible: this.showBackdrop, tappable: this.backdropDismiss }),
          mode === 'ios' && hAsync('div', { class: 'modal-shadow' }),
          hAsync('div', { tabindex: '0' }),
          hAsync('div', { role: 'dialog', class: 'modal-wrapper ion-overlay-wrapper' }),
          hAsync('div', { tabindex: '0' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          swipeToClose: ['swipeToCloseChanged'],
        };
      }
      static get style() {
        return {
          ios: modalIosCss,
          md: modalMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-modal',
          $members$: {
            overlayIndex: [2, 'overlay-index'],
            delegate: [16],
            keyboardClose: [4, 'keyboard-close'],
            enterAnimation: [16],
            leaveAnimation: [16],
            component: [1],
            componentProps: [16],
            cssClass: [1, 'css-class'],
            backdropDismiss: [4, 'backdrop-dismiss'],
            showBackdrop: [4, 'show-backdrop'],
            animated: [4],
            swipeToClose: [4, 'swipe-to-close'],
            presentingElement: [16],
            htmlAttributes: [16],
            present: [64],
            dismiss: [64],
            onDidDismiss: [64],
            onWillDismiss: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const LIFECYCLE_MAP$1 = {
      ionModalDidPresent: 'ionViewDidEnter',
      ionModalWillPresent: 'ionViewWillEnter',
      ionModalWillDismiss: 'ionViewWillLeave',
      ionModalDidDismiss: 'ionViewDidLeave',
    };

    const VIEW_STATE_NEW = 1;
    const VIEW_STATE_ATTACHED = 2;
    const VIEW_STATE_DESTROYED = 3;
    class ViewController {
      constructor(component, params) {
        this.component = component;
        this.params = params;
        this.state = VIEW_STATE_NEW;
      }
      async init(container) {
        this.state = VIEW_STATE_ATTACHED;
        if (!this.element) {
          const component = this.component;
          this.element = await attachComponent(this.delegate, container, component, ['ion-page', 'ion-page-invisible'], this.params);
        }
      }
      /**
       * DOM WRITE
       */
      _destroy() {
        assert(this.state !== VIEW_STATE_DESTROYED, 'view state must be ATTACHED');
        const element = this.element;
        if (element) {
          if (this.delegate) {
            this.delegate.removeViewFromDom(element.parentElement, element);
          } else {
            element.remove();
          }
        }
        this.nav = undefined;
        this.state = VIEW_STATE_DESTROYED;
      }
    }
    const matches = (view, id, params) => {
      if (!view) {
        return false;
      }
      if (view.component !== id) {
        return false;
      }
      const currentParams = view.params;
      if (currentParams === params) {
        return true;
      }
      if (!currentParams && !params) {
        return true;
      }
      if (!currentParams || !params) {
        return false;
      }
      const keysA = Object.keys(currentParams);
      const keysB = Object.keys(params);
      if (keysA.length !== keysB.length) {
        return false;
      }
      // Test for A's keys different from B.
      for (const key of keysA) {
        if (currentParams[key] !== params[key]) {
          return false;
        }
      }
      return true;
    };
    const convertToView = (page, params) => {
      if (!page) {
        return null;
      }
      if (page instanceof ViewController) {
        return page;
      }
      return new ViewController(page, params);
    };
    const convertToViews = pages => {
      return pages
        .map(page => {
          if (page instanceof ViewController) {
            return page;
          }
          if ('component' in page) {
            /**
             * TODO Ionic 6:
             * Consider switching to just using `undefined` here
             * as well as on the public interfaces and on
             * `NavComponentWithProps`. Previously `pages` was
             * of type `any[]` so TypeScript did not catch this.
             */
            return convertToView(page.component, page.componentProps === null ? undefined : page.componentProps);
          }
          return convertToView(page, undefined);
        })
        .filter(v => v !== null);
    };

    const navCss = '/*!@:host*/.sc-ion-nav-h{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}';

    class Nav {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionNavWillLoad = createEvent(this, 'ionNavWillLoad', 7);
        this.ionNavWillChange = createEvent(this, 'ionNavWillChange', 3);
        this.ionNavDidChange = createEvent(this, 'ionNavDidChange', 3);
        this.transInstr = [];
        this.animationEnabled = true;
        this.useRouter = false;
        this.isTransitioning = false;
        this.destroyed = false;
        this.views = [];
        /**
         * If `true`, the nav should animate the transition of components.
         */
        this.animated = true;
      }
      swipeGestureChanged() {
        if (this.gesture) {
          this.gesture.enable(this.swipeGesture === true);
        }
      }
      rootChanged() {
        if (this.root !== undefined) {
          if (!this.useRouter) {
            this.setRoot(this.root, this.rootParams);
          }
        }
      }
      componentWillLoad() {
        this.useRouter = !!document.querySelector('ion-router') && !this.el.closest('[no-router]');
        if (this.swipeGesture === undefined) {
          const mode = getIonMode$1(this);
          this.swipeGesture = config$2.getBoolean('swipeBackEnabled', mode === 'ios');
        }
        this.ionNavWillLoad.emit();
      }
      async componentDidLoad() {
        this.rootChanged();
        this.gesture = (
          await Promise.resolve().then(function () {
            return swipeBack;
          })
        ).createSwipeBackGesture(this.el, this.canStart.bind(this), this.onStart.bind(this), this.onMove.bind(this), this.onEnd.bind(this));
        this.swipeGestureChanged();
      }
      disconnectedCallback() {
        for (const view of this.views) {
          lifecycle(view.element, LIFECYCLE_WILL_UNLOAD);
          view._destroy();
        }
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
        // release swipe back gesture and transition
        this.transInstr.length = this.views.length = 0;
        this.destroyed = true;
      }
      /**
       * Push a new component onto the current navigation stack. Pass any additional
       * information along as an object. This additional information is accessible
       * through NavParams.
       *
       * @param component The component to push onto the navigation stack.
       * @param componentProps Any properties of the component.
       * @param opts The navigation options.
       * @param done The transition complete function.
       */
      push(component, componentProps, opts, done) {
        return this.queueTrns(
          {
            insertStart: -1,
            insertViews: [{ component, componentProps }],
            opts,
          },
          done,
        );
      }
      /**
       * Inserts a component into the navigation stack at the specified index.
       * This is useful to add a component at any point in the navigation stack.
       *
       * @param insertIndex The index to insert the component at in the stack.
       * @param component The component to insert into the navigation stack.
       * @param componentProps Any properties of the component.
       * @param opts The navigation options.
       * @param done The transition complete function.
       */
      insert(insertIndex, component, componentProps, opts, done) {
        return this.queueTrns(
          {
            insertStart: insertIndex,
            insertViews: [{ component, componentProps }],
            opts,
          },
          done,
        );
      }
      /**
       * Inserts an array of components into the navigation stack at the specified index.
       * The last component in the array will become instantiated as a view, and animate
       * in to become the active view.
       *
       * @param insertIndex The index to insert the components at in the stack.
       * @param insertComponents The components to insert into the navigation stack.
       * @param opts The navigation options.
       * @param done The transition complete function.
       */
      insertPages(insertIndex, insertComponents, opts, done) {
        return this.queueTrns(
          {
            insertStart: insertIndex,
            insertViews: insertComponents,
            opts,
          },
          done,
        );
      }
      /**
       * Pop a component off of the navigation stack. Navigates back from the current
       * component.
       *
       * @param opts The navigation options.
       * @param done The transition complete function.
       */
      pop(opts, done) {
        return this.queueTrns(
          {
            removeStart: -1,
            removeCount: 1,
            opts,
          },
          done,
        );
      }
      /**
       * Pop to a specific index in the navigation stack.
       *
       * @param indexOrViewCtrl The index or view controller to pop to.
       * @param opts The navigation options.
       * @param done The transition complete function.
       */
      popTo(indexOrViewCtrl, opts, done) {
        const tiConfig = {
          removeStart: -1,
          removeCount: -1,
          opts,
        };
        if (typeof indexOrViewCtrl === 'object' && indexOrViewCtrl.component) {
          tiConfig.removeView = indexOrViewCtrl;
          tiConfig.removeStart = 1;
        } else if (typeof indexOrViewCtrl === 'number') {
          tiConfig.removeStart = indexOrViewCtrl + 1;
        }
        return this.queueTrns(tiConfig, done);
      }
      /**
       * Navigate back to the root of the stack, no matter how far back that is.
       *
       * @param opts The navigation options.
       * @param done The transition complete function.
       */
      popToRoot(opts, done) {
        return this.queueTrns(
          {
            removeStart: 1,
            removeCount: -1,
            opts,
          },
          done,
        );
      }
      /**
       * Removes a component from the navigation stack at the specified index.
       *
       * @param startIndex The number to begin removal at.
       * @param removeCount The number of components to remove.
       * @param opts The navigation options.
       * @param done The transition complete function.
       */
      removeIndex(startIndex, removeCount = 1, opts, done) {
        return this.queueTrns(
          {
            removeStart: startIndex,
            removeCount,
            opts,
          },
          done,
        );
      }
      /**
       * Set the root for the current navigation stack to a component.
       *
       * @param component The component to set as the root of the navigation stack.
       * @param componentProps Any properties of the component.
       * @param opts The navigation options.
       * @param done The transition complete function.
       */
      setRoot(component, componentProps, opts, done) {
        return this.setPages([{ component, componentProps }], opts, done);
      }
      /**
       * Set the views of the current navigation stack and navigate to the last view.
       * By default animations are disabled, but they can be enabled by passing options
       * to the navigation controller. Navigation parameters can also be passed to the
       * individual pages in the array.
       *
       * @param views The list of views to set as the navigation stack.
       * @param opts The navigation options.
       * @param done The transition complete function.
       */
      setPages(views, opts, done) {
        if (opts == null) {
          opts = {};
        }
        // if animation wasn't set to true then default it to NOT animate
        if (opts.animated !== true) {
          opts.animated = false;
        }
        return this.queueTrns(
          {
            insertStart: 0,
            insertViews: views,
            removeStart: 0,
            removeCount: -1,
            opts,
          },
          done,
        );
      }
      /** @internal */
      setRouteId(id, params, direction, animation) {
        const active = this.getActiveSync();
        if (matches(active, id, params)) {
          return Promise.resolve({
            changed: false,
            element: active.element,
          });
        }
        let resolve;
        const promise = new Promise(r => (resolve = r));
        let finish;
        const commonOpts = {
          updateURL: false,
          viewIsReady: enteringEl => {
            let mark;
            const p = new Promise(r => (mark = r));
            resolve({
              changed: true,
              element: enteringEl,
              markVisible: async () => {
                mark();
                await finish;
              },
            });
            return p;
          },
        };
        if (direction === 'root') {
          finish = this.setRoot(id, params, commonOpts);
        } else {
          const viewController = this.views.find(v => matches(v, id, params));
          if (viewController) {
            finish = this.popTo(viewController, Object.assign(Object.assign({}, commonOpts), { direction: 'back', animationBuilder: animation }));
          } else if (direction === 'forward') {
            finish = this.push(id, params, Object.assign(Object.assign({}, commonOpts), { animationBuilder: animation }));
          } else if (direction === 'back') {
            finish = this.setRoot(id, params, Object.assign(Object.assign({}, commonOpts), { direction: 'back', animated: true, animationBuilder: animation }));
          }
        }
        return promise;
      }
      /** @internal */
      async getRouteId() {
        const active = this.getActiveSync();
        return active
          ? {
              id: active.element.tagName,
              params: active.params,
              element: active.element,
            }
          : undefined;
      }
      /**
       * Get the active view.
       */
      getActive() {
        return Promise.resolve(this.getActiveSync());
      }
      /**
       * Get the view at the specified index.
       *
       * @param index The index of the view.
       */
      getByIndex(index) {
        return Promise.resolve(this.views[index]);
      }
      /**
       * Returns `true` if the current view can go back.
       *
       * @param view The view to check.
       */
      canGoBack(view) {
        return Promise.resolve(this.canGoBackSync(view));
      }
      /**
       * Get the previous view.
       *
       * @param view The view to get.
       */
      getPrevious(view) {
        return Promise.resolve(this.getPreviousSync(view));
      }
      getLength() {
        return this.views.length;
      }
      getActiveSync() {
        return this.views[this.views.length - 1];
      }
      canGoBackSync(view = this.getActiveSync()) {
        return !!(view && this.getPreviousSync(view));
      }
      getPreviousSync(view = this.getActiveSync()) {
        if (!view) {
          return undefined;
        }
        const views = this.views;
        const index = views.indexOf(view);
        return index > 0 ? views[index - 1] : undefined;
      }
      // _queueTrns() adds a navigation stack change to the queue and schedules it to run:
      // 1. _nextTrns(): consumes the next transition in the queue
      // 2. _viewInit(): initializes enteringView if required
      // 3. _viewTest(): ensures canLeave/canEnter Returns `true`, so the operation can continue
      // 4. _postViewInit(): add/remove the views from the navigation stack
      // 5. _transitionInit(): initializes the visual transition if required and schedules it to run
      // 6. _viewAttachToDOM(): attaches the enteringView to the DOM
      // 7. _transitionStart(): called once the transition actually starts, it initializes the Animation underneath.
      // 8. _transitionFinish(): called once the transition finishes
      // 9. _cleanup(): syncs the navigation internal state with the DOM. For example it removes the pages from the DOM or hides/show them.
      async queueTrns(ti, done) {
        if (this.isTransitioning && ti.opts != null && ti.opts.skipIfBusy) {
          return Promise.resolve(false);
        }
        const promise = new Promise((resolve, reject) => {
          ti.resolve = resolve;
          ti.reject = reject;
        });
        ti.done = done;
        /**
         * If using router, check to see if navigation hooks
         * will allow us to perform this transition. This
         * is required in order for hooks to work with
         * the ion-back-button or swipe to go back.
         */
        if (ti.opts && ti.opts.updateURL !== false && this.useRouter) {
          const router = document.querySelector('ion-router');
          if (router) {
            const canTransition = await router.canTransition();
            if (canTransition === false) {
              return Promise.resolve(false);
            } else if (typeof canTransition === 'string') {
              router.push(canTransition, ti.opts.direction || 'back');
              return Promise.resolve(false);
            }
          }
        }
        // Normalize empty
        if (ti.insertViews && ti.insertViews.length === 0) {
          ti.insertViews = undefined;
        }
        // Enqueue transition instruction
        this.transInstr.push(ti);
        // if there isn't a transition already happening
        // then this will kick off this transition
        this.nextTrns();
        return promise;
      }
      success(result, ti) {
        if (this.destroyed) {
          this.fireError('nav controller was destroyed', ti);
          return;
        }
        if (ti.done) {
          ti.done(result.hasCompleted, result.requiresTransition, result.enteringView, result.leavingView, result.direction);
        }
        ti.resolve(result.hasCompleted);
        if (ti.opts.updateURL !== false && this.useRouter) {
          const router = document.querySelector('ion-router');
          if (router) {
            const direction = result.direction === 'back' ? 'back' : 'forward';
            router.navChanged(direction);
          }
        }
      }
      failed(rejectReason, ti) {
        if (this.destroyed) {
          this.fireError('nav controller was destroyed', ti);
          return;
        }
        this.transInstr.length = 0;
        this.fireError(rejectReason, ti);
      }
      fireError(rejectReason, ti) {
        if (ti.done) {
          ti.done(false, false, rejectReason);
        }
        if (ti.reject && !this.destroyed) {
          ti.reject(rejectReason);
        } else {
          ti.resolve(false);
        }
      }
      nextTrns() {
        // this is the framework's bread 'n butta function
        // only one transition is allowed at any given time
        if (this.isTransitioning) {
          return false;
        }
        // there is no transition happening right now
        // get the next instruction
        const ti = this.transInstr.shift();
        if (!ti) {
          return false;
        }
        this.runTransition(ti);
        return true;
      }
      async runTransition(ti) {
        try {
          // set that this nav is actively transitioning
          this.ionNavWillChange.emit();
          this.isTransitioning = true;
          this.prepareTI(ti);
          const leavingView = this.getActiveSync();
          const enteringView = this.getEnteringView(ti, leavingView);
          if (!leavingView && !enteringView) {
            throw new Error('no views in the stack to be removed');
          }
          if (enteringView && enteringView.state === VIEW_STATE_NEW) {
            await enteringView.init(this.el);
          }
          this.postViewInit(enteringView, leavingView, ti);
          // Needs transition?
          const requiresTransition = (ti.enteringRequiresTransition || ti.leavingRequiresTransition) && enteringView !== leavingView;
          if (requiresTransition && ti.opts && leavingView) {
            const isBackDirection = ti.opts.direction === 'back';
            /**
             * If heading back, use the entering page's animation
             * unless otherwise specified by the developer.
             */
            if (isBackDirection) {
              ti.opts.animationBuilder = ti.opts.animationBuilder || (enteringView && enteringView.animationBuilder);
            }
            leavingView.animationBuilder = ti.opts.animationBuilder;
          }
          const result = requiresTransition
            ? await this.transition(enteringView, leavingView, ti)
            : {
                // transition is not required, so we are already done!
                // they're inserting/removing the views somewhere in the middle or
                // beginning, so visually nothing needs to animate/transition
                // resolve immediately because there's no animation that's happening
                hasCompleted: true,
                requiresTransition: false,
              };
          this.success(result, ti);
          this.ionNavDidChange.emit();
        } catch (rejectReason) {
          this.failed(rejectReason, ti);
        }
        this.isTransitioning = false;
        this.nextTrns();
      }
      prepareTI(ti) {
        const viewsLength = this.views.length;
        ti.opts = ti.opts || {};
        if (ti.opts.delegate === undefined) {
          ti.opts.delegate = this.delegate;
        }
        if (ti.removeView !== undefined) {
          assert(ti.removeStart !== undefined, 'removeView needs removeStart');
          assert(ti.removeCount !== undefined, 'removeView needs removeCount');
          const index = this.views.indexOf(ti.removeView);
          if (index < 0) {
            throw new Error('removeView was not found');
          }
          ti.removeStart += index;
        }
        if (ti.removeStart !== undefined) {
          if (ti.removeStart < 0) {
            ti.removeStart = viewsLength - 1;
          }
          if (ti.removeCount < 0) {
            ti.removeCount = viewsLength - ti.removeStart;
          }
          ti.leavingRequiresTransition = ti.removeCount > 0 && ti.removeStart + ti.removeCount === viewsLength;
        }
        if (ti.insertViews) {
          // allow -1 to be passed in to auto push it on the end
          // and clean up the index if it's larger then the size of the stack
          if (ti.insertStart < 0 || ti.insertStart > viewsLength) {
            ti.insertStart = viewsLength;
          }
          ti.enteringRequiresTransition = ti.insertStart === viewsLength;
        }
        const insertViews = ti.insertViews;
        if (!insertViews) {
          return;
        }
        assert(insertViews.length > 0, 'length can not be zero');
        const viewControllers = convertToViews(insertViews);
        if (viewControllers.length === 0) {
          throw new Error('invalid views to insert');
        }
        // Check all the inserted view are correct
        for (const view of viewControllers) {
          view.delegate = ti.opts.delegate;
          const nav = view.nav;
          if (nav && nav !== this) {
            throw new Error('inserted view was already inserted');
          }
          if (view.state === VIEW_STATE_DESTROYED) {
            throw new Error('inserted view was already destroyed');
          }
        }
        ti.insertViews = viewControllers;
      }
      getEnteringView(ti, leavingView) {
        const insertViews = ti.insertViews;
        if (insertViews !== undefined) {
          // grab the very last view of the views to be inserted
          // and initialize it as the new entering view
          return insertViews[insertViews.length - 1];
        }
        const removeStart = ti.removeStart;
        if (removeStart !== undefined) {
          const views = this.views;
          const removeEnd = removeStart + ti.removeCount;
          for (let i = views.length - 1; i >= 0; i--) {
            const view = views[i];
            if ((i < removeStart || i >= removeEnd) && view !== leavingView) {
              return view;
            }
          }
        }
        return undefined;
      }
      postViewInit(enteringView, leavingView, ti) {
        assert(leavingView || enteringView, 'Both leavingView and enteringView are null');
        assert(ti.resolve, 'resolve must be valid');
        assert(ti.reject, 'reject must be valid');
        const opts = ti.opts;
        const insertViews = ti.insertViews;
        const removeStart = ti.removeStart;
        const removeCount = ti.removeCount;
        let destroyQueue;
        // there are views to remove
        if (removeStart !== undefined && removeCount !== undefined) {
          assert(removeStart >= 0, 'removeStart can not be negative');
          assert(removeCount >= 0, 'removeCount can not be negative');
          destroyQueue = [];
          for (let i = 0; i < removeCount; i++) {
            const view = this.views[i + removeStart];
            if (view && view !== enteringView && view !== leavingView) {
              destroyQueue.push(view);
            }
          }
          // default the direction to "back"
          opts.direction = opts.direction || 'back';
        }
        const finalBalance = this.views.length + (insertViews !== undefined ? insertViews.length : 0) - (removeCount !== undefined ? removeCount : 0);
        assert(finalBalance >= 0, 'final balance can not be negative');
        if (finalBalance === 0) {
          console.warn(`You can't remove all the pages in the navigation stack. nav.pop() is probably called too many times.`, this, this.el);
          throw new Error('navigation stack needs at least one root page');
        }
        // At this point the transition can not be rejected, any throw should be an error
        // there are views to insert
        if (insertViews) {
          // add the views to the
          let insertIndex = ti.insertStart;
          for (const view of insertViews) {
            this.insertViewAt(view, insertIndex);
            insertIndex++;
          }
          if (ti.enteringRequiresTransition) {
            // default to forward if not already set
            opts.direction = opts.direction || 'forward';
          }
        }
        // if the views to be removed are in the beginning or middle
        // and there is not a view that needs to visually transition out
        // then just destroy them and don't transition anything
        // batch all of lifecycles together
        // let's make sure, callbacks are zoned
        if (destroyQueue && destroyQueue.length > 0) {
          for (const view of destroyQueue) {
            lifecycle(view.element, LIFECYCLE_WILL_LEAVE);
            lifecycle(view.element, LIFECYCLE_DID_LEAVE);
            lifecycle(view.element, LIFECYCLE_WILL_UNLOAD);
          }
          // once all lifecycle events has been delivered, we can safely detroy the views
          for (const view of destroyQueue) {
            this.destroyView(view);
          }
        }
      }
      async transition(enteringView, leavingView, ti) {
        // we should animate (duration > 0) if the pushed page is not the first one (startup)
        // or if it is a portal (modal, actionsheet, etc.)
        const opts = ti.opts;
        const progressCallback = opts.progressAnimation ? ani => (this.sbAni = ani) : undefined;
        const mode = getIonMode$1(this);
        const enteringEl = enteringView.element;
        const leavingEl = leavingView && leavingView.element;
        const animationOpts = Object.assign(
          Object.assign(
            {
              mode,
              showGoBack: this.canGoBackSync(enteringView),
              baseEl: this.el,
              progressCallback,
              animated: this.animated && config$2.getBoolean('animated', true),
              enteringEl,
              leavingEl,
            },
            opts,
          ),
          { animationBuilder: opts.animationBuilder || this.animation || config$2.get('navAnimation') },
        );
        const { hasCompleted } = await transition$4(animationOpts);
        return this.transitionFinish(hasCompleted, enteringView, leavingView, opts);
      }
      transitionFinish(hasCompleted, enteringView, leavingView, opts) {
        const cleanupView = hasCompleted ? enteringView : leavingView;
        if (cleanupView) {
          this.cleanup(cleanupView);
        }
        return {
          hasCompleted,
          requiresTransition: true,
          enteringView,
          leavingView,
          direction: opts.direction,
        };
      }
      insertViewAt(view, index) {
        const views = this.views;
        const existingIndex = views.indexOf(view);
        if (existingIndex > -1) {
          // this view is already in the stack!!
          // move it to its new location
          assert(view.nav === this, 'view is not part of the nav');
          views.splice(index, 0, views.splice(existingIndex, 1)[0]);
        } else {
          assert(!view.nav, 'nav is used');
          // this is a new view to add to the stack
          // create the new entering view
          view.nav = this;
          // insert the entering view into the correct index in the stack
          views.splice(index, 0, view);
        }
      }
      removeView(view) {
        assert(view.state === VIEW_STATE_ATTACHED || view.state === VIEW_STATE_DESTROYED, 'view state should be loaded or destroyed');
        const views = this.views;
        const index = views.indexOf(view);
        assert(index > -1, 'view must be part of the stack');
        if (index >= 0) {
          views.splice(index, 1);
        }
      }
      destroyView(view) {
        view._destroy();
        this.removeView(view);
      }
      /**
       * DOM WRITE
       */
      cleanup(activeView) {
        // ok, cleanup time!! Destroy all of the views that are
        // INACTIVE and come after the active view
        // only do this if the views exist, though
        if (this.destroyed) {
          return;
        }
        const views = this.views;
        const activeViewIndex = views.indexOf(activeView);
        for (let i = views.length - 1; i >= 0; i--) {
          const view = views[i];
          /**
           * When inserting multiple views via insertPages
           * the last page will be transitioned to, but the
           * others will not be. As a result, a DOM element
           * will only be created for the last page inserted.
           * As a result, it is possible to have views in the
           * stack that do not have `view.element` yet.
           */
          const element = view.element;
          if (element) {
            if (i > activeViewIndex) {
              // this view comes after the active view
              // let's unload it
              lifecycle(element, LIFECYCLE_WILL_UNLOAD);
              this.destroyView(view);
            } else if (i < activeViewIndex) {
              // this view comes before the active view
              // and it is not a portal then ensure it is hidden
              setPageHidden(element, true);
            }
          }
        }
      }
      canStart() {
        return !!this.swipeGesture && !this.isTransitioning && this.transInstr.length === 0 && this.animationEnabled && this.canGoBackSync();
      }
      onStart() {
        this.queueTrns(
          {
            removeStart: -1,
            removeCount: 1,
            opts: {
              direction: 'back',
              progressAnimation: true,
            },
          },
          undefined,
        );
      }
      onMove(stepValue) {
        if (this.sbAni) {
          this.sbAni.progressStep(stepValue);
        }
      }
      onEnd(shouldComplete, stepValue, dur) {
        if (this.sbAni) {
          this.animationEnabled = false;
          this.sbAni.onFinish(
            () => {
              this.animationEnabled = true;
            },
            { oneTimeCallback: true },
          );
          // Account for rounding errors in JS
          let newStepValue = shouldComplete ? -0.001 : 0.001;
          /**
           * Animation will be reversed here, so need to
           * reverse the easing curve as well
           *
           * Additionally, we need to account for the time relative
           * to the new easing curve, as `stepValue` is going to be given
           * in terms of a linear curve.
           */
          if (!shouldComplete) {
            this.sbAni.easing('cubic-bezier(1, 0, 0.68, 0.28)');
            newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], stepValue)[0];
          } else {
            newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], stepValue)[0];
          }
          this.sbAni.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);
        }
      }
      render() {
        return hAsync('slot', null);
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          swipeGesture: ['swipeGestureChanged'],
          root: ['rootChanged'],
        };
      }
      static get style() {
        return navCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-nav',
          $members$: {
            delegate: [16],
            swipeGesture: [1028, 'swipe-gesture'],
            animated: [4],
            animation: [16],
            rootParams: [16],
            root: [1],
            push: [64],
            insert: [64],
            insertPages: [64],
            pop: [64],
            popTo: [64],
            popToRoot: [64],
            removeIndex: [64],
            setRoot: [64],
            setPages: [64],
            setRouteId: [64],
            getRouteId: [64],
            getActive: [64],
            getByIndex: [64],
            canGoBack: [64],
            getPrevious: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const navLink = (el, routerDirection, component, componentProps, routerAnimation) => {
      const nav = el.closest('ion-nav');
      if (nav) {
        if (routerDirection === 'forward') {
          if (component !== undefined) {
            return nav.push(component, componentProps, { skipIfBusy: true, animationBuilder: routerAnimation });
          }
        } else if (routerDirection === 'root') {
          if (component !== undefined) {
            return nav.setRoot(component, componentProps, { skipIfBusy: true, animationBuilder: routerAnimation });
          }
        } else if (routerDirection === 'back') {
          return nav.pop({ skipIfBusy: true, animationBuilder: routerAnimation });
        }
      }
      return Promise.resolve(false);
    };

    class NavLink {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * The transition direction when navigating to another page.
         */
        this.routerDirection = 'forward';
        this.onClick = () => {
          return navLink(this.el, this.routerDirection, this.component, this.componentProps, this.routerAnimation);
        };
      }
      render() {
        return hAsync(Host, { onClick: this.onClick });
      }
      get el() {
        return getElement(this);
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-nav-link',
          $members$: {
            component: [1],
            componentProps: [16],
            routerDirection: [1, 'router-direction'],
            routerAnimation: [16],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const noteIosCss =
      '/*!@:host*/.sc-ion-note-ios-h{color:var(--color);font-family:var(--ion-font-family, inherit);box-sizing:border-box}/*!@:host(.ion-color)*/.ion-color.sc-ion-note-ios-h{color:var(--ion-color-base)}/*!@:host*/.sc-ion-note-ios-h{--color:var(--ion-color-step-350, #a6a6a6)}';

    const noteMdCss =
      '/*!@:host*/.sc-ion-note-md-h{color:var(--color);font-family:var(--ion-font-family, inherit);box-sizing:border-box}/*!@:host(.ion-color)*/.ion-color.sc-ion-note-md-h{color:var(--ion-color-base)}/*!@:host*/.sc-ion-note-md-h{--color:var(--ion-color-step-600, #666666);font-size:14px}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Note {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: createColorClasses$1(this.color, {
              [mode]: true,
            }),
          },
          hAsync('slot', null),
        );
      }
      static get style() {
        return {
          ios: noteIosCss,
          md: noteMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-note',
          $members$: {
            color: [513],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    /**
     * iOS Picker Enter Animation
     */
    const iosEnterAnimation$2 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      wrapperAnimation.addElement(baseEl.querySelector('.picker-wrapper')).fromTo('transform', 'translateY(100%)', 'translateY(0%)');
      return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * iOS Picker Leave Animation
     */
    const iosLeaveAnimation$2 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0.01);
      wrapperAnimation.addElement(baseEl.querySelector('.picker-wrapper')).fromTo('transform', 'translateY(0%)', 'translateY(100%)');
      return baseAnimation.addElement(baseEl).easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    const pickerIosCss =
      '.sc-ion-picker-ios-h{--border-radius:0;--border-style:solid;--min-width:auto;--width:100%;--max-width:500px;--min-height:auto;--max-height:auto;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;top:0;display:block;position:absolute;width:100%;height:100%;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;user-select:none;z-index:1001}[dir=rtl].sc-ion-picker-ios-h,[dir=rtl] .sc-ion-picker-ios-h{left:unset;right:unset;right:0}.overlay-hidden.sc-ion-picker-ios-h{display:none}.picker-wrapper.sc-ion-picker-ios{border-radius:var(--border-radius);left:0;right:0;bottom:0;margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;transform:translate3d(0,  100%,  0);display:flex;position:absolute;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;overflow:hidden;z-index:10}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.picker-wrapper.sc-ion-picker-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.picker-toolbar.sc-ion-picker-ios{width:100%;background:transparent;contain:strict;z-index:1}.picker-button.sc-ion-picker-ios{border:0;font-family:inherit}.picker-button.sc-ion-picker-ios:active,.picker-button.sc-ion-picker-ios:focus{outline:none}.picker-columns.sc-ion-picker-ios{display:flex;position:relative;justify-content:center;margin-bottom:var(--ion-safe-area-bottom, 0);contain:strict;direction:ltr;overflow:hidden}.picker-above-highlight.sc-ion-picker-ios,.picker-below-highlight.sc-ion-picker-ios{display:none;pointer-events:none}.sc-ion-picker-ios-h{--background:var(--ion-background-color, #fff);--border-width:1px 0 0;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));--height:260px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.26);color:var(--ion-item-color, var(--ion-text-color, #000))}.picker-toolbar.sc-ion-picker-ios{display:flex;height:44px;border-bottom:0.55px solid var(--border-color)}.picker-toolbar-button.sc-ion-picker-ios{flex:1;text-align:end}.picker-toolbar-button.sc-ion-picker-ios:last-child .picker-button.sc-ion-picker-ios{font-weight:600}.picker-toolbar-button.sc-ion-picker-ios:first-child{font-weight:normal;text-align:start}.picker-button.sc-ion-picker-ios,.picker-button.ion-activated.sc-ion-picker-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:1em;padding-right:1em;padding-top:0;padding-bottom:0;height:44px;background:transparent;color:var(--ion-color-primary, #3880ff);font-size:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.picker-button.sc-ion-picker-ios,.picker-button.ion-activated.sc-ion-picker-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:1em;padding-inline-start:1em;-webkit-padding-end:1em;padding-inline-end:1em}}.picker-columns.sc-ion-picker-ios{height:215px;perspective:1000px}.picker-above-highlight.sc-ion-picker-ios{left:0;top:0;transform:translate3d(0,  0,  90px);display:block;position:absolute;width:100%;height:81px;border-bottom:1px solid var(--border-color);background:linear-gradient(to bottom, var(--background, var(--ion-background-color, #fff)) 20%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8) 100%);z-index:10}[dir=rtl].sc-ion-picker-ios .picker-above-highlight.sc-ion-picker-ios,[dir=rtl].sc-ion-picker-ios-h .picker-above-highlight.sc-ion-picker-ios,[dir=rtl] .sc-ion-picker-ios-h .picker-above-highlight.sc-ion-picker-ios{left:unset;right:unset;right:0}.picker-below-highlight.sc-ion-picker-ios{left:0;top:115px;transform:translate3d(0,  0,  90px);display:block;position:absolute;width:100%;height:119px;border-top:1px solid var(--border-color);background:linear-gradient(to top, var(--background, var(--ion-background-color, #fff)) 30%, rgba(var(--background-rgb, var(--ion-background-color-rgb, 255, 255, 255)), 0.8) 100%);z-index:11}[dir=rtl].sc-ion-picker-ios .picker-below-highlight.sc-ion-picker-ios,[dir=rtl].sc-ion-picker-ios-h .picker-below-highlight.sc-ion-picker-ios,[dir=rtl] .sc-ion-picker-ios-h .picker-below-highlight.sc-ion-picker-ios{left:unset;right:unset;right:0}';

    const pickerMdCss =
      '.sc-ion-picker-md-h{--border-radius:0;--border-style:solid;--min-width:auto;--width:100%;--max-width:500px;--min-height:auto;--max-height:auto;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;left:0;top:0;display:block;position:absolute;width:100%;height:100%;outline:none;font-family:var(--ion-font-family, inherit);contain:strict;user-select:none;z-index:1001}[dir=rtl].sc-ion-picker-md-h,[dir=rtl] .sc-ion-picker-md-h{left:unset;right:unset;right:0}.overlay-hidden.sc-ion-picker-md-h{display:none}.picker-wrapper.sc-ion-picker-md{border-radius:var(--border-radius);left:0;right:0;bottom:0;margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;transform:translate3d(0,  100%,  0);display:flex;position:absolute;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;overflow:hidden;z-index:10}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.picker-wrapper.sc-ion-picker-md{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.picker-toolbar.sc-ion-picker-md{width:100%;background:transparent;contain:strict;z-index:1}.picker-button.sc-ion-picker-md{border:0;font-family:inherit}.picker-button.sc-ion-picker-md:active,.picker-button.sc-ion-picker-md:focus{outline:none}.picker-columns.sc-ion-picker-md{display:flex;position:relative;justify-content:center;margin-bottom:var(--ion-safe-area-bottom, 0);contain:strict;direction:ltr;overflow:hidden}.picker-above-highlight.sc-ion-picker-md,.picker-below-highlight.sc-ion-picker-md{display:none;pointer-events:none}.sc-ion-picker-md-h{--background:var(--ion-background-color, #fff);--border-width:0.55px 0 0;--border-color:var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));--height:260px;--backdrop-opacity:var(--ion-backdrop-opacity, 0.26);color:var(--ion-item-color, var(--ion-text-color, #000))}.picker-toolbar.sc-ion-picker-md{display:flex;justify-content:flex-end;height:44px}.picker-button.sc-ion-picker-md,.picker-button.ion-activated.sc-ion-picker-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:1.1em;padding-right:1.1em;padding-top:0;padding-bottom:0;height:44px;background:transparent;color:var(--ion-color-primary, #3880ff);font-size:14px;font-weight:500;text-transform:uppercase;box-shadow:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.picker-button.sc-ion-picker-md,.picker-button.ion-activated.sc-ion-picker-md{padding-left:unset;padding-right:unset;-webkit-padding-start:1.1em;padding-inline-start:1.1em;-webkit-padding-end:1.1em;padding-inline-end:1.1em}}.picker-columns.sc-ion-picker-md{height:216px;perspective:1800px}.picker-above-highlight.sc-ion-picker-md{left:0;top:0;transform:translate3d(0,  0,  90px);position:absolute;width:100%;height:81px;border-bottom:1px solid var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));background:linear-gradient(to bottom, var(--ion-background-color, #fff) 20%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8) 100%);z-index:10}[dir=rtl].sc-ion-picker-md .picker-above-highlight.sc-ion-picker-md,[dir=rtl].sc-ion-picker-md-h .picker-above-highlight.sc-ion-picker-md,[dir=rtl] .sc-ion-picker-md-h .picker-above-highlight.sc-ion-picker-md{left:unset;right:unset;right:0}.picker-below-highlight.sc-ion-picker-md{left:0;top:115px;transform:translate3d(0,  0,  90px);position:absolute;width:100%;height:119px;border-top:1px solid var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));background:linear-gradient(to top, var(--ion-background-color, #fff) 30%, rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8) 100%);z-index:11}[dir=rtl].sc-ion-picker-md .picker-below-highlight.sc-ion-picker-md,[dir=rtl].sc-ion-picker-md-h .picker-below-highlight.sc-ion-picker-md,[dir=rtl] .sc-ion-picker-md-h .picker-below-highlight.sc-ion-picker-md{left:unset;right:unset;right:0}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Picker {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.didPresent = createEvent(this, 'ionPickerDidPresent', 7);
        this.willPresent = createEvent(this, 'ionPickerWillPresent', 7);
        this.willDismiss = createEvent(this, 'ionPickerWillDismiss', 7);
        this.didDismiss = createEvent(this, 'ionPickerDidDismiss', 7);
        this.presented = false;
        /**
         * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
         */
        this.keyboardClose = true;
        /**
         * Array of buttons to be displayed at the top of the picker.
         */
        this.buttons = [];
        /**
         * Array of columns to be displayed in the picker.
         */
        this.columns = [];
        /**
         * Number of milliseconds to wait before dismissing the picker.
         */
        this.duration = 0;
        /**
         * If `true`, a backdrop will be displayed behind the picker.
         */
        this.showBackdrop = true;
        /**
         * If `true`, the picker will be dismissed when the backdrop is clicked.
         */
        this.backdropDismiss = true;
        /**
         * If `true`, the picker will animate.
         */
        this.animated = true;
        this.onBackdropTap = () => {
          this.dismiss(undefined, BACKDROP);
        };
        this.dispatchCancelHandler = ev => {
          const role = ev.detail.role;
          if (isCancel(role)) {
            const cancelButton = this.buttons.find(b => b.role === 'cancel');
            this.callButtonHandler(cancelButton);
          }
        };
      }
      connectedCallback() {
        prepareOverlay(this.el);
      }
      /**
       * Present the picker overlay after it has been created.
       */
      async present() {
        await present(this, 'pickerEnter', iosEnterAnimation$2, iosEnterAnimation$2, undefined);
        if (this.duration > 0) {
          this.durationTimeout = setTimeout(() => this.dismiss(), this.duration);
        }
      }
      /**
       * Dismiss the picker overlay after it has been presented.
       *
       * @param data Any data to emit in the dismiss events.
       * @param role The role of the element that is dismissing the picker.
       * This can be useful in a button handler for determining which button was
       * clicked to dismiss the picker.
       * Some examples include: ``"cancel"`, `"destructive"`, "selected"`, and `"backdrop"`.
       */
      dismiss(data, role) {
        if (this.durationTimeout) {
          clearTimeout(this.durationTimeout);
        }
        return dismiss(this, data, role, 'pickerLeave', iosLeaveAnimation$2, iosLeaveAnimation$2);
      }
      /**
       * Returns a promise that resolves when the picker did dismiss.
       */
      onDidDismiss() {
        return eventMethod(this.el, 'ionPickerDidDismiss');
      }
      /**
       * Returns a promise that resolves when the picker will dismiss.
       */
      onWillDismiss() {
        return eventMethod(this.el, 'ionPickerWillDismiss');
      }
      /**
       * Get the column that matches the specified name.
       *
       * @param name The name of the column.
       */
      getColumn(name) {
        return Promise.resolve(this.columns.find(column => column.name === name));
      }
      async buttonClick(button) {
        const role = button.role;
        if (isCancel(role)) {
          return this.dismiss(undefined, role);
        }
        const shouldDismiss = await this.callButtonHandler(button);
        if (shouldDismiss) {
          return this.dismiss(this.getSelected(), button.role);
        }
        return Promise.resolve();
      }
      async callButtonHandler(button) {
        if (button) {
          // a handler has been provided, execute it
          // pass the handler the values from the inputs
          const rtn = await safeCall(button.handler, this.getSelected());
          if (rtn === false) {
            // if the return value of the handler is false then do not dismiss
            return false;
          }
        }
        return true;
      }
      getSelected() {
        const selected = {};
        this.columns.forEach((col, index) => {
          const selectedColumn = col.selectedIndex !== undefined ? col.options[col.selectedIndex] : undefined;
          selected[col.name] = {
            text: selectedColumn ? selectedColumn.text : undefined,
            value: selectedColumn ? selectedColumn.value : undefined,
            columnIndex: index,
          };
        });
        return selected;
      }
      render() {
        const { htmlAttributes } = this;
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          Object.assign({ 'aria-modal': 'true', 'tabindex': '-1' }, htmlAttributes, {
            style: {
              zIndex: `${20000 + this.overlayIndex}`,
            },
            class: Object.assign(
              {
                [mode]: true,
                // Used internally for styling
                [`picker-${mode}`]: true,
              },
              getClassMap(this.cssClass),
            ),
            onIonBackdropTap: this.onBackdropTap,
            onIonPickerWillDismiss: this.dispatchCancelHandler,
          }),
          hAsync('ion-backdrop', { visible: this.showBackdrop, tappable: this.backdropDismiss }),
          hAsync('div', { tabindex: '0' }),
          hAsync(
            'div',
            { class: 'picker-wrapper ion-overlay-wrapper', role: 'dialog' },
            hAsync(
              'div',
              { class: 'picker-toolbar' },
              this.buttons.map(b =>
                hAsync('div', { class: buttonWrapperClass(b) }, hAsync('button', { type: 'button', onClick: () => this.buttonClick(b), class: buttonClass$1(b) }, b.text)),
              ),
            ),
            hAsync(
              'div',
              { class: 'picker-columns' },
              hAsync('div', { class: 'picker-above-highlight' }),
              this.presented && this.columns.map(c => hAsync('ion-picker-column', { col: c })),
              hAsync('div', { class: 'picker-below-highlight' }),
            ),
          ),
          hAsync('div', { tabindex: '0' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: pickerIosCss,
          md: pickerMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-picker',
          $members$: {
            overlayIndex: [2, 'overlay-index'],
            keyboardClose: [4, 'keyboard-close'],
            enterAnimation: [16],
            leaveAnimation: [16],
            buttons: [16],
            columns: [16],
            cssClass: [1, 'css-class'],
            duration: [2],
            showBackdrop: [4, 'show-backdrop'],
            backdropDismiss: [4, 'backdrop-dismiss'],
            animated: [4],
            htmlAttributes: [16],
            presented: [32],
            present: [64],
            dismiss: [64],
            onDidDismiss: [64],
            onWillDismiss: [64],
            getColumn: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const buttonWrapperClass = button => {
      return {
        [`picker-toolbar-${button.role}`]: button.role !== undefined,
        'picker-toolbar-button': true,
      };
    };
    const buttonClass$1 = button => {
      return Object.assign({ 'picker-button': true, 'ion-activatable': true }, getClassMap(button.cssClass));
    };

    const pickerColumnIosCss =
      '.picker-col{display:flex;position:relative;flex:1;justify-content:center;height:100%;box-sizing:content-box;contain:content}.picker-opts{position:relative;flex:1;max-width:100%}.picker-opt{left:0;top:0;display:block;position:absolute;width:100%;border:0;text-align:center;text-overflow:ellipsis;white-space:nowrap;contain:strict;overflow:hidden;will-change:transform}[dir=rtl] .picker-opt,:host-context([dir=rtl]) .picker-opt{left:unset;right:unset;right:0}.picker-opt.picker-opt-disabled{pointer-events:none}.picker-opt-disabled{opacity:0}.picker-opts-left{justify-content:flex-start}.picker-opts-right{justify-content:flex-end}.picker-opt:active,.picker-opt:focus{outline:none}.picker-prefix{position:relative;flex:1;text-align:end;white-space:nowrap}.picker-suffix{position:relative;flex:1;text-align:start;white-space:nowrap}.picker-col{padding-left:4px;padding-right:4px;padding-top:0;padding-bottom:0;transform-style:preserve-3d}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.picker-col{padding-left:unset;padding-right:unset;-webkit-padding-start:4px;padding-inline-start:4px;-webkit-padding-end:4px;padding-inline-end:4px}}.picker-prefix,.picker-suffix,.picker-opts{top:77px;transform-style:preserve-3d;color:inherit;font-size:20px;line-height:42px;pointer-events:none}.picker-opt{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;transform-origin:center center;height:46px;transform-style:preserve-3d;transition-timing-function:ease-out;background:transparent;color:inherit;font-size:20px;line-height:42px;backface-visibility:hidden;pointer-events:auto}[dir=rtl] .picker-opt,:host-context([dir=rtl]) .picker-opt{transform-origin:calc(100% - center) center}';

    const pickerColumnMdCss =
      '.picker-col{display:flex;position:relative;flex:1;justify-content:center;height:100%;box-sizing:content-box;contain:content}.picker-opts{position:relative;flex:1;max-width:100%}.picker-opt{left:0;top:0;display:block;position:absolute;width:100%;border:0;text-align:center;text-overflow:ellipsis;white-space:nowrap;contain:strict;overflow:hidden;will-change:transform}[dir=rtl] .picker-opt,:host-context([dir=rtl]) .picker-opt{left:unset;right:unset;right:0}.picker-opt.picker-opt-disabled{pointer-events:none}.picker-opt-disabled{opacity:0}.picker-opts-left{justify-content:flex-start}.picker-opts-right{justify-content:flex-end}.picker-opt:active,.picker-opt:focus{outline:none}.picker-prefix{position:relative;flex:1;text-align:end;white-space:nowrap}.picker-suffix{position:relative;flex:1;text-align:start;white-space:nowrap}.picker-col{padding-left:8px;padding-right:8px;padding-top:0;padding-bottom:0;transform-style:preserve-3d}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.picker-col{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px}}.picker-prefix,.picker-suffix,.picker-opts{top:77px;transform-style:preserve-3d;color:inherit;font-size:22px;line-height:42px;pointer-events:none}.picker-opt{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;height:43px;transition-timing-function:ease-out;background:transparent;color:inherit;font-size:22px;line-height:42px;backface-visibility:hidden;pointer-events:auto}.picker-prefix,.picker-suffix,.picker-opt.picker-opt-selected{color:var(--ion-color-primary, #3880ff)}';

    /**
     * @internal
     */
    class PickerColumnCmp {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionPickerColChange = createEvent(this, 'ionPickerColChange', 7);
        this.optHeight = 0;
        this.rotateFactor = 0;
        this.scaleFactor = 1;
        this.velocity = 0;
        this.y = 0;
        this.noAnimate = true;
      }
      colChanged() {
        this.refresh();
      }
      async connectedCallback() {
        let pickerRotateFactor = 0;
        let pickerScaleFactor = 0.81;
        const mode = getIonMode$1(this);
        if (mode === 'ios') {
          pickerRotateFactor = -0.46;
          pickerScaleFactor = 1;
        }
        this.rotateFactor = pickerRotateFactor;
        this.scaleFactor = pickerScaleFactor;
        this.gesture = (
          await Promise.resolve().then(function () {
            return index$2;
          })
        ).createGesture({
          el: this.el,
          gestureName: 'picker-swipe',
          gesturePriority: 100,
          threshold: 0,
          passive: false,
          onStart: ev => this.onStart(ev),
          onMove: ev => this.onMove(ev),
          onEnd: ev => this.onEnd(ev),
        });
        this.gesture.enable();
        this.tmrId = setTimeout(() => {
          this.noAnimate = false;
          this.refresh(true);
        }, 250);
      }
      componentDidLoad() {
        const colEl = this.optsEl;
        if (colEl) {
          // DOM READ
          // We perfom a DOM read over a rendered item, this needs to happen after the first render
          this.optHeight = colEl.firstElementChild ? colEl.firstElementChild.clientHeight : 0;
        }
        this.refresh();
      }
      disconnectedCallback() {
        cancelAnimationFrame(this.rafId);
        clearTimeout(this.tmrId);
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
      }
      emitColChange() {
        this.ionPickerColChange.emit(this.col);
      }
      setSelected(selectedIndex, duration) {
        // if there is a selected index, then figure out it's y position
        // if there isn't a selected index, then just use the top y position
        const y = selectedIndex > -1 ? -(selectedIndex * this.optHeight) : 0;
        this.velocity = 0;
        // set what y position we're at
        cancelAnimationFrame(this.rafId);
        this.update(y, duration, true);
        this.emitColChange();
      }
      update(y, duration, saveY) {
        if (!this.optsEl) {
          return;
        }
        // ensure we've got a good round number :)
        let translateY = 0;
        let translateZ = 0;
        const { col, rotateFactor } = this;
        const selectedIndex = (col.selectedIndex = this.indexForY(-y));
        const durationStr = duration === 0 ? '' : duration + 'ms';
        const scaleStr = `scale(${this.scaleFactor})`;
        const children = this.optsEl.children;
        for (let i = 0; i < children.length; i++) {
          const button = children[i];
          const opt = col.options[i];
          const optOffset = i * this.optHeight + y;
          let transform = '';
          if (rotateFactor !== 0) {
            const rotateX = optOffset * rotateFactor;
            if (Math.abs(rotateX) <= 90) {
              translateY = 0;
              translateZ = 90;
              transform = `rotateX(${rotateX}deg) `;
            } else {
              translateY = -9999;
            }
          } else {
            translateZ = 0;
            translateY = optOffset;
          }
          const selected = selectedIndex === i;
          transform += `translate3d(0px,${translateY}px,${translateZ}px) `;
          if (this.scaleFactor !== 1 && !selected) {
            transform += scaleStr;
          }
          // Update transition duration
          if (this.noAnimate) {
            opt.duration = 0;
            button.style.transitionDuration = '';
          } else if (duration !== opt.duration) {
            opt.duration = duration;
            button.style.transitionDuration = durationStr;
          }
          // Update transform
          if (transform !== opt.transform) {
            opt.transform = transform;
            button.style.transform = transform;
          }
          // Update selected item
          if (selected !== opt.selected) {
            opt.selected = selected;
            if (selected) {
              button.classList.add(PICKER_OPT_SELECTED);
            } else {
              button.classList.remove(PICKER_OPT_SELECTED);
            }
          }
        }
        this.col.prevSelected = selectedIndex;
        if (saveY) {
          this.y = y;
        }
        if (this.lastIndex !== selectedIndex) {
          // have not set a last index yet
          hapticSelectionChanged();
          this.lastIndex = selectedIndex;
        }
      }
      decelerate() {
        if (this.velocity !== 0) {
          // still decelerating
          this.velocity *= DECELERATION_FRICTION;
          // do not let it go slower than a velocity of 1
          this.velocity = this.velocity > 0 ? Math.max(this.velocity, 1) : Math.min(this.velocity, -1);
          let y = this.y + this.velocity;
          if (y > this.minY) {
            // whoops, it's trying to scroll up farther than the options we have!
            y = this.minY;
            this.velocity = 0;
          } else if (y < this.maxY) {
            // gahh, it's trying to scroll down farther than we can!
            y = this.maxY;
            this.velocity = 0;
          }
          this.update(y, 0, true);
          const notLockedIn = Math.round(y) % this.optHeight !== 0 || Math.abs(this.velocity) > 1;
          if (notLockedIn) {
            // isn't locked in yet, keep decelerating until it is
            this.rafId = requestAnimationFrame(() => this.decelerate());
          } else {
            this.velocity = 0;
            this.emitColChange();
            hapticSelectionEnd();
          }
        } else if (this.y % this.optHeight !== 0) {
          // needs to still get locked into a position so options line up
          const currentPos = Math.abs(this.y % this.optHeight);
          // create a velocity in the direction it needs to scroll
          this.velocity = currentPos > this.optHeight / 2 ? 1 : -1;
          this.decelerate();
        }
      }
      indexForY(y) {
        return Math.min(Math.max(Math.abs(Math.round(y / this.optHeight)), 0), this.col.options.length - 1);
      }
      // TODO should this check disabled?
      onStart(detail) {
        // We have to prevent default in order to block scrolling under the picker
        // but we DO NOT have to stop propagation, since we still want
        // some "click" events to capture
        if (detail.event.cancelable) {
          detail.event.preventDefault();
        }
        detail.event.stopPropagation();
        hapticSelectionStart();
        // reset everything
        cancelAnimationFrame(this.rafId);
        const options = this.col.options;
        let minY = options.length - 1;
        let maxY = 0;
        for (let i = 0; i < options.length; i++) {
          if (!options[i].disabled) {
            minY = Math.min(minY, i);
            maxY = Math.max(maxY, i);
          }
        }
        this.minY = -(minY * this.optHeight);
        this.maxY = -(maxY * this.optHeight);
      }
      onMove(detail) {
        if (detail.event.cancelable) {
          detail.event.preventDefault();
        }
        detail.event.stopPropagation();
        // update the scroll position relative to pointer start position
        let y = this.y + detail.deltaY;
        if (y > this.minY) {
          // scrolling up higher than scroll area
          y = Math.pow(y, 0.8);
          this.bounceFrom = y;
        } else if (y < this.maxY) {
          // scrolling down below scroll area
          y += Math.pow(this.maxY - y, 0.9);
          this.bounceFrom = y;
        } else {
          this.bounceFrom = 0;
        }
        this.update(y, 0, false);
      }
      onEnd(detail) {
        if (this.bounceFrom > 0) {
          // bounce back up
          this.update(this.minY, 100, true);
          this.emitColChange();
          return;
        } else if (this.bounceFrom < 0) {
          // bounce back down
          this.update(this.maxY, 100, true);
          this.emitColChange();
          return;
        }
        this.velocity = clamp(-MAX_PICKER_SPEED, detail.velocityY * 23, MAX_PICKER_SPEED);
        if (this.velocity === 0 && detail.deltaY === 0) {
          const opt = detail.event.target.closest('.picker-opt');
          if (opt && opt.hasAttribute('opt-index')) {
            this.setSelected(parseInt(opt.getAttribute('opt-index'), 10), TRANSITION_DURATION);
          }
        } else {
          this.y += detail.deltaY;
          if (Math.abs(detail.velocityY) < 0.05) {
            const isScrollingUp = detail.deltaY > 0;
            const optHeightFraction = (Math.abs(this.y) % this.optHeight) / this.optHeight;
            if (isScrollingUp && optHeightFraction > 0.5) {
              this.velocity = Math.abs(this.velocity) * -1;
            } else if (!isScrollingUp && optHeightFraction <= 0.5) {
              this.velocity = Math.abs(this.velocity);
            }
          }
          this.decelerate();
        }
      }
      refresh(forceRefresh) {
        let min = this.col.options.length - 1;
        let max = 0;
        const options = this.col.options;
        for (let i = 0; i < options.length; i++) {
          if (!options[i].disabled) {
            min = Math.min(min, i);
            max = Math.max(max, i);
          }
        }
        /**
         * Only update selected value if column has a
         * velocity of 0. If it does not, then the
         * column is animating might land on
         * a value different than the value at
         * selectedIndex
         */
        if (this.velocity !== 0) {
          return;
        }
        const selectedIndex = clamp(min, this.col.selectedIndex || 0, max);
        if (this.col.prevSelected !== selectedIndex || forceRefresh) {
          const y = selectedIndex * this.optHeight * -1;
          this.velocity = 0;
          this.update(y, TRANSITION_DURATION, true);
        }
      }
      render() {
        const col = this.col;
        const Button = 'button';
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: {
              [mode]: true,
              'picker-col': true,
              'picker-opts-left': this.col.align === 'left',
              'picker-opts-right': this.col.align === 'right',
            },
            style: {
              'max-width': this.col.columnWidth,
            },
          },
          col.prefix && hAsync('div', { class: 'picker-prefix', style: { width: col.prefixWidth } }, col.prefix),
          hAsync(
            'div',
            { class: 'picker-opts', style: { maxWidth: col.optionsWidth }, ref: el => (this.optsEl = el) },
            col.options.map((o, index) => hAsync(Button, { 'type': 'button', 'class': { 'picker-opt': true, 'picker-opt-disabled': !!o.disabled }, 'opt-index': index }, o.text)),
          ),
          col.suffix && hAsync('div', { class: 'picker-suffix', style: { width: col.suffixWidth } }, col.suffix),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          col: ['colChanged'],
        };
      }
      static get style() {
        return {
          ios: pickerColumnIosCss,
          md: pickerColumnMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 32,
          $tagName$: 'ion-picker-column',
          $members$: {
            col: [16],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const PICKER_OPT_SELECTED = 'picker-opt-selected';
    const DECELERATION_FRICTION = 0.97;
    const MAX_PICKER_SPEED = 90;
    const TRANSITION_DURATION = 150;

    /**
     * iOS Popover Enter Animation
     */
    const iosEnterAnimation$1 = (baseEl, ev) => {
      let originY = 'top';
      let originX = 'left';
      const contentEl = baseEl.querySelector('.popover-content');
      const contentDimentions = contentEl.getBoundingClientRect();
      const contentWidth = contentDimentions.width;
      const contentHeight = contentDimentions.height;
      const bodyWidth = baseEl.ownerDocument.defaultView.innerWidth;
      const bodyHeight = baseEl.ownerDocument.defaultView.innerHeight;
      // If ev was passed, use that for target element
      const targetDim = ev && ev.target && ev.target.getBoundingClientRect();
      const targetTop = targetDim != null && 'top' in targetDim ? targetDim.top : bodyHeight / 2 - contentHeight / 2;
      const targetLeft = targetDim != null && 'left' in targetDim ? targetDim.left : bodyWidth / 2;
      const targetWidth = (targetDim && targetDim.width) || 0;
      const targetHeight = (targetDim && targetDim.height) || 0;
      const arrowEl = baseEl.querySelector('.popover-arrow');
      const arrowDim = arrowEl.getBoundingClientRect();
      const arrowWidth = arrowDim.width;
      const arrowHeight = arrowDim.height;
      if (targetDim == null) {
        arrowEl.style.display = 'none';
      }
      const arrowCSS = {
        top: targetTop + targetHeight,
        left: targetLeft + targetWidth / 2 - arrowWidth / 2,
      };
      const popoverCSS = {
        top: targetTop + targetHeight + (arrowHeight - 1),
        left: targetLeft + targetWidth / 2 - contentWidth / 2,
      };
      // If the popover left is less than the padding it is off screen
      // to the left so adjust it, else if the width of the popover
      // exceeds the body width it is off screen to the right so adjust
      //
      let checkSafeAreaLeft = false;
      let checkSafeAreaRight = false;
      // If the popover left is less than the padding it is off screen
      // to the left so adjust it, else if the width of the popover
      // exceeds the body width it is off screen to the right so adjust
      // 25 is a random/arbitrary number. It seems to work fine for ios11
      // and iPhoneX. Is it perfect? No. Does it work? Yes.
      if (popoverCSS.left < POPOVER_IOS_BODY_PADDING + 25) {
        checkSafeAreaLeft = true;
        popoverCSS.left = POPOVER_IOS_BODY_PADDING;
      } else if (contentWidth + POPOVER_IOS_BODY_PADDING + popoverCSS.left + 25 > bodyWidth) {
        // Ok, so we're on the right side of the screen,
        // but now we need to make sure we're still a bit further right
        // cus....notchurally... Again, 25 is random. It works tho
        checkSafeAreaRight = true;
        popoverCSS.left = bodyWidth - contentWidth - POPOVER_IOS_BODY_PADDING;
        originX = 'right';
      }
      // make it pop up if there's room above
      if (targetTop + targetHeight + contentHeight > bodyHeight && targetTop - contentHeight > 0) {
        arrowCSS.top = targetTop - (arrowHeight + 1);
        popoverCSS.top = targetTop - contentHeight - (arrowHeight - 1);
        baseEl.className = baseEl.className + ' popover-bottom';
        originY = 'bottom';
        // If there isn't room for it to pop up above the target cut it off
      } else if (targetTop + targetHeight + contentHeight > bodyHeight) {
        contentEl.style.bottom = POPOVER_IOS_BODY_PADDING + '%';
      }
      arrowEl.style.top = arrowCSS.top + 'px';
      arrowEl.style.left = arrowCSS.left + 'px';
      contentEl.style.top = popoverCSS.top + 'px';
      contentEl.style.left = popoverCSS.left + 'px';
      if (checkSafeAreaLeft) {
        contentEl.style.left = `calc(${popoverCSS.left}px + var(--ion-safe-area-left, 0px))`;
      }
      if (checkSafeAreaRight) {
        contentEl.style.left = `calc(${popoverCSS.left}px - var(--ion-safe-area-right, 0px))`;
      }
      contentEl.style.transformOrigin = originY + ' ' + originX;
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      wrapperAnimation.addElement(baseEl.querySelector('.popover-wrapper')).fromTo('opacity', 0.01, 1);
      return baseAnimation.addElement(baseEl).easing('ease').duration(100).addAnimation([backdropAnimation, wrapperAnimation]);
    };
    const POPOVER_IOS_BODY_PADDING = 5;

    /**
     * iOS Popover Leave Animation
     */
    const iosLeaveAnimation$1 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);
      wrapperAnimation.addElement(baseEl.querySelector('.popover-wrapper')).fromTo('opacity', 0.99, 0);
      return baseAnimation.addElement(baseEl).easing('ease').duration(500).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    /**
     * Md Popover Enter Animation
     */
    const mdEnterAnimation$1 = (baseEl, ev) => {
      const POPOVER_MD_BODY_PADDING = 12;
      const doc = baseEl.ownerDocument;
      const isRTL = doc.dir === 'rtl';
      let originY = 'top';
      let originX = isRTL ? 'right' : 'left';
      const contentEl = baseEl.querySelector('.popover-content');
      const contentDimentions = contentEl.getBoundingClientRect();
      const contentWidth = contentDimentions.width;
      const contentHeight = contentDimentions.height;
      const bodyWidth = doc.defaultView.innerWidth;
      const bodyHeight = doc.defaultView.innerHeight;
      // If ev was passed, use that for target element
      const targetDim = ev && ev.target && ev.target.getBoundingClientRect();
      // As per MD spec, by default position the popover below the target (trigger) element
      const targetTop = targetDim != null && 'bottom' in targetDim ? targetDim.bottom : bodyHeight / 2 - contentHeight / 2;
      const targetLeft = targetDim != null && 'left' in targetDim ? (isRTL ? targetDim.left - contentWidth + targetDim.width : targetDim.left) : bodyWidth / 2 - contentWidth / 2;
      const targetHeight = (targetDim && targetDim.height) || 0;
      const popoverCSS = {
        top: targetTop,
        left: targetLeft,
      };
      // If the popover left is less than the padding it is off screen
      // to the left so adjust it, else if the width of the popover
      // exceeds the body width it is off screen to the right so adjust
      if (popoverCSS.left < POPOVER_MD_BODY_PADDING) {
        popoverCSS.left = POPOVER_MD_BODY_PADDING;
        // Same origin in this case for both LTR & RTL
        // Note: in LTR, originX is already 'left'
        originX = 'left';
      } else if (contentWidth + POPOVER_MD_BODY_PADDING + popoverCSS.left > bodyWidth) {
        popoverCSS.left = bodyWidth - contentWidth - POPOVER_MD_BODY_PADDING;
        // Same origin in this case for both LTR & RTL
        // Note: in RTL, originX is already 'right'
        originX = 'right';
      }
      // If the popover when popped down stretches past bottom of screen,
      // make it pop up if there's room above
      if (targetTop + targetHeight + contentHeight > bodyHeight && targetTop - contentHeight > 0) {
        popoverCSS.top = targetTop - contentHeight - targetHeight;
        baseEl.className = baseEl.className + ' popover-bottom';
        originY = 'bottom';
        // If there isn't room for it to pop up above the target cut it off
      } else if (targetTop + targetHeight + contentHeight > bodyHeight) {
        contentEl.style.bottom = POPOVER_MD_BODY_PADDING + 'px';
      }
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      const contentAnimation = createAnimation();
      const viewportAnimation = createAnimation();
      backdropAnimation
        .addElement(baseEl.querySelector('ion-backdrop'))
        .fromTo('opacity', 0.01, 'var(--backdrop-opacity)')
        .beforeStyles({
          'pointer-events': 'none',
        })
        .afterClearStyles(['pointer-events']);
      wrapperAnimation.addElement(baseEl.querySelector('.popover-wrapper')).fromTo('opacity', 0.01, 1);
      contentAnimation
        .addElement(contentEl)
        .beforeStyles({
          'top': `${popoverCSS.top}px`,
          'left': `${popoverCSS.left}px`,
          'transform-origin': `${originY} ${originX}`,
        })
        .fromTo('transform', 'scale(0.001)', 'scale(1)');
      viewportAnimation.addElement(baseEl.querySelector('.popover-viewport')).fromTo('opacity', 0.01, 1);
      return baseAnimation
        .addElement(baseEl)
        .easing('cubic-bezier(0.36,0.66,0.04,1)')
        .duration(300)
        .addAnimation([backdropAnimation, wrapperAnimation, contentAnimation, viewportAnimation]);
    };

    /**
     * Md Popover Leave Animation
     */
    const mdLeaveAnimation$1 = baseEl => {
      const baseAnimation = createAnimation();
      const backdropAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      backdropAnimation.addElement(baseEl.querySelector('ion-backdrop')).fromTo('opacity', 'var(--backdrop-opacity)', 0);
      wrapperAnimation.addElement(baseEl.querySelector('.popover-wrapper')).fromTo('opacity', 0.99, 0);
      return baseAnimation.addElement(baseEl).easing('ease').duration(500).addAnimation([backdropAnimation, wrapperAnimation]);
    };

    const popoverIosCss =
      '.sc-ion-popover-ios-h{--background:var(--ion-background-color, #fff);--min-width:0;--min-height:0;--max-width:auto;--height:auto;left:0;right:0;top:0;bottom:0;display:flex;position:fixed;align-items:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);z-index:1001}.overlay-hidden.sc-ion-popover-ios-h{display:none}.popover-wrapper.sc-ion-popover-ios{opacity:0;z-index:10}.popover-content.sc-ion-popover-ios{display:flex;position:absolute;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);box-shadow:var(--box-shadow);overflow:auto;z-index:10}.popover-viewport.sc-ion-popover-ios{--ion-safe-area-top:0px;--ion-safe-area-right:0px;--ion-safe-area-bottom:0px;--ion-safe-area-left:0px}.sc-ion-popover-ios-h{--width:200px;--max-height:90%;--box-shadow:none;--backdrop-opacity:var(--ion-backdrop-opacity, 0.08)}.popover-content.sc-ion-popover-ios{border-radius:10px}.popover-arrow.sc-ion-popover-ios{display:block;position:absolute;width:20px;height:10px;overflow:hidden}.popover-arrow.sc-ion-popover-ios::after{left:3px;top:3px;border-radius:3px;position:absolute;width:14px;height:14px;transform:rotate(45deg);background:var(--background);content:"";z-index:10}[dir=rtl].sc-ion-popover-ios .popover-arrow.sc-ion-popover-ios::after,[dir=rtl].sc-ion-popover-ios-h .popover-arrow.sc-ion-popover-ios::after,[dir=rtl] .sc-ion-popover-ios-h .popover-arrow.sc-ion-popover-ios::after{left:unset;right:unset;right:3px}.popover-bottom.sc-ion-popover-ios-h .popover-arrow.sc-ion-popover-ios{top:auto;bottom:-10px}.popover-bottom.sc-ion-popover-ios-h .popover-arrow.sc-ion-popover-ios::after{top:-6px}@supports (backdrop-filter: blur(0)){.popover-translucent.sc-ion-popover-ios-h .popover-content.sc-ion-popover-ios,.popover-translucent.sc-ion-popover-ios-h .popover-arrow.sc-ion-popover-ios::after{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);backdrop-filter:saturate(180%) blur(20px)}}';

    const popoverMdCss =
      '.sc-ion-popover-md-h{--background:var(--ion-background-color, #fff);--min-width:0;--min-height:0;--max-width:auto;--height:auto;left:0;right:0;top:0;bottom:0;display:flex;position:fixed;align-items:center;justify-content:center;outline:none;color:var(--ion-text-color, #000);z-index:1001}.overlay-hidden.sc-ion-popover-md-h{display:none}.popover-wrapper.sc-ion-popover-md{opacity:0;z-index:10}.popover-content.sc-ion-popover-md{display:flex;position:absolute;flex-direction:column;width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);background:var(--background);box-shadow:var(--box-shadow);overflow:auto;z-index:10}.popover-viewport.sc-ion-popover-md{--ion-safe-area-top:0px;--ion-safe-area-right:0px;--ion-safe-area-bottom:0px;--ion-safe-area-left:0px}.sc-ion-popover-md-h{--width:250px;--max-height:90%;--box-shadow:0 5px 5px -3px rgba(0, 0, 0, 0.2), 0 8px 10px 1px rgba(0, 0, 0, 0.14), 0 3px 14px 2px rgba(0, 0, 0, 0.12);--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}.popover-content.sc-ion-popover-md{border-radius:4px;transform-origin:left top}[dir=rtl].sc-ion-popover-md .popover-content.sc-ion-popover-md,[dir=rtl].sc-ion-popover-md-h .popover-content.sc-ion-popover-md,[dir=rtl] .sc-ion-popover-md-h .popover-content.sc-ion-popover-md{transform-origin:right top}.popover-viewport.sc-ion-popover-md{transition-delay:100ms}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Popover {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.didPresent = createEvent(this, 'ionPopoverDidPresent', 7);
        this.willPresent = createEvent(this, 'ionPopoverWillPresent', 7);
        this.willDismiss = createEvent(this, 'ionPopoverWillDismiss', 7);
        this.didDismiss = createEvent(this, 'ionPopoverDidDismiss', 7);
        this.presented = false;
        /**
         * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
         */
        this.keyboardClose = true;
        /**
         * If `true`, the popover will be dismissed when the backdrop is clicked.
         */
        this.backdropDismiss = true;
        /**
         * If `true`, a backdrop will be displayed behind the popover.
         */
        this.showBackdrop = true;
        /**
         * If `true`, the popover will be translucent.
         * Only applies when the mode is `"ios"` and the device supports
         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
         */
        this.translucent = false;
        /**
         * If `true`, the popover will animate.
         */
        this.animated = true;
        this.onDismiss = ev => {
          ev.stopPropagation();
          ev.preventDefault();
          this.dismiss();
        };
        this.onBackdropTap = () => {
          this.dismiss(undefined, BACKDROP);
        };
        this.onLifecycle = modalEvent => {
          const el = this.usersElement;
          const name = LIFECYCLE_MAP[modalEvent.type];
          if (el && name) {
            const event = new CustomEvent(name, {
              bubbles: false,
              cancelable: false,
              detail: modalEvent.detail,
            });
            el.dispatchEvent(event);
          }
        };
      }
      connectedCallback() {
        prepareOverlay(this.el);
      }
      /**
       * Present the popover overlay after it has been created.
       */
      async present() {
        if (this.presented) {
          return;
        }
        const container = this.el.querySelector('.popover-content');
        if (!container) {
          throw new Error('container is undefined');
        }
        const data = Object.assign(Object.assign({}, this.componentProps), { popover: this.el });
        this.usersElement = await attachComponent(this.delegate, container, this.component, ['popover-viewport', this.el['s-sc']], data);
        await deepReady(this.usersElement);
        return present(this, 'popoverEnter', iosEnterAnimation$1, mdEnterAnimation$1, this.event);
      }
      /**
       * Dismiss the popover overlay after it has been presented.
       *
       * @param data Any data to emit in the dismiss events.
       * @param role The role of the element that is dismissing the popover. For example, 'cancel' or 'backdrop'.
       */
      async dismiss(data, role) {
        const shouldDismiss = await dismiss(this, data, role, 'popoverLeave', iosLeaveAnimation$1, mdLeaveAnimation$1, this.event);
        if (shouldDismiss) {
          await detachComponent(this.delegate, this.usersElement);
        }
        return shouldDismiss;
      }
      /**
       * Returns a promise that resolves when the popover did dismiss.
       */
      onDidDismiss() {
        return eventMethod(this.el, 'ionPopoverDidDismiss');
      }
      /**
       * Returns a promise that resolves when the popover will dismiss.
       */
      onWillDismiss() {
        return eventMethod(this.el, 'ionPopoverWillDismiss');
      }
      render() {
        const mode = getIonMode$1(this);
        const { onLifecycle, htmlAttributes } = this;
        return hAsync(
          Host,
          Object.assign({ 'aria-modal': 'true', 'no-router': true, 'tabindex': '-1' }, htmlAttributes, {
            style: {
              zIndex: `${20000 + this.overlayIndex}`,
            },
            class: Object.assign(Object.assign({}, getClassMap(this.cssClass)), { [mode]: true, 'popover-translucent': this.translucent }),
            onIonPopoverDidPresent: onLifecycle,
            onIonPopoverWillPresent: onLifecycle,
            onIonPopoverWillDismiss: onLifecycle,
            onIonPopoverDidDismiss: onLifecycle,
            onIonDismiss: this.onDismiss,
            onIonBackdropTap: this.onBackdropTap,
          }),
          hAsync('ion-backdrop', { tappable: this.backdropDismiss, visible: this.showBackdrop }),
          hAsync('div', { tabindex: '0' }),
          hAsync('div', { class: 'popover-wrapper ion-overlay-wrapper' }, hAsync('div', { class: 'popover-arrow' }), hAsync('div', { class: 'popover-content' })),
          hAsync('div', { tabindex: '0' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: popoverIosCss,
          md: popoverMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-popover',
          $members$: {
            delegate: [16],
            overlayIndex: [2, 'overlay-index'],
            enterAnimation: [16],
            leaveAnimation: [16],
            component: [1],
            componentProps: [16],
            keyboardClose: [4, 'keyboard-close'],
            cssClass: [1, 'css-class'],
            backdropDismiss: [4, 'backdrop-dismiss'],
            event: [8],
            showBackdrop: [4, 'show-backdrop'],
            translucent: [4],
            animated: [4],
            htmlAttributes: [16],
            present: [64],
            dismiss: [64],
            onDidDismiss: [64],
            onWillDismiss: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const LIFECYCLE_MAP = {
      ionPopoverDidPresent: 'ionViewDidEnter',
      ionPopoverWillPresent: 'ionViewWillEnter',
      ionPopoverWillDismiss: 'ionViewWillLeave',
      ionPopoverDidDismiss: 'ionViewDidLeave',
    };

    const progressBarIosCss =
      '/*!@:host*/.sc-ion-progress-bar-ios-h{--background:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.3);--progress-background:var(--ion-color-primary, #3880ff);--buffer-background:var(--background);display:block;position:relative;width:100%;contain:strict;direction:ltr;overflow:hidden}/*!@.progress,\n.progress-indeterminate,\n.indeterminate-bar-primary,\n.indeterminate-bar-secondary,\n.progress-buffer-bar*/.progress.sc-ion-progress-bar-ios,.progress-indeterminate.sc-ion-progress-bar-ios,.indeterminate-bar-primary.sc-ion-progress-bar-ios,.indeterminate-bar-secondary.sc-ion-progress-bar-ios,.progress-buffer-bar.sc-ion-progress-bar-ios{left:0;right:0;top:0;bottom:0;position:absolute;width:100%;height:100%}/*!@.buffer-circles-container,\n.buffer-circles*/.buffer-circles-container.sc-ion-progress-bar-ios,.buffer-circles.sc-ion-progress-bar-ios{left:0;right:0;top:0;bottom:0;position:absolute}/*!@.buffer-circles*/.buffer-circles.sc-ion-progress-bar-ios{right:-10px;left:-10px}/*!@.progress,\n.progress-buffer-bar,\n.buffer-circles-container*/.progress.sc-ion-progress-bar-ios,.progress-buffer-bar.sc-ion-progress-bar-ios,.buffer-circles-container.sc-ion-progress-bar-ios{transform-origin:left top;transition:transform 150ms linear}/*!@.progress,\n.progress-indeterminate*/.progress.sc-ion-progress-bar-ios,.progress-indeterminate.sc-ion-progress-bar-ios{background:var(--progress-background);z-index:2}/*!@.progress-buffer-bar*/.progress-buffer-bar.sc-ion-progress-bar-ios{background:var(--buffer-background);z-index:1}/*!@.buffer-circles-container*/.buffer-circles-container.sc-ion-progress-bar-ios{overflow:hidden}/*!@.indeterminate-bar-primary*/.indeterminate-bar-primary.sc-ion-progress-bar-ios{top:0;right:0;bottom:0;left:-145.166611%;animation:primary-indeterminate-translate 2s infinite linear}/*!@.indeterminate-bar-primary .progress-indeterminate*/.indeterminate-bar-primary.sc-ion-progress-bar-ios .progress-indeterminate.sc-ion-progress-bar-ios{animation:primary-indeterminate-scale 2s infinite linear;animation-play-state:inherit}/*!@.indeterminate-bar-secondary*/.indeterminate-bar-secondary.sc-ion-progress-bar-ios{top:0;right:0;bottom:0;left:-54.888891%;animation:secondary-indeterminate-translate 2s infinite linear}/*!@.indeterminate-bar-secondary .progress-indeterminate*/.indeterminate-bar-secondary.sc-ion-progress-bar-ios .progress-indeterminate.sc-ion-progress-bar-ios{animation:secondary-indeterminate-scale 2s infinite linear;animation-play-state:inherit}/*!@.buffer-circles*/.buffer-circles.sc-ion-progress-bar-ios{background-image:radial-gradient(ellipse at center, var(--buffer-background) 0%, var(--buffer-background) 30%, transparent 30%);background-repeat:repeat-x;background-position:5px center;background-size:10px 10px;z-index:0;animation:buffering 450ms infinite linear}/*!@:host(.progress-bar-reversed)*/.progress-bar-reversed.sc-ion-progress-bar-ios-h{transform:scaleX(-1)}/*!@:host(.progress-paused) .indeterminate-bar-secondary,\n:host(.progress-paused) .indeterminate-bar-primary,\n:host(.progress-paused) .buffer-circles*/.progress-paused.sc-ion-progress-bar-ios-h .indeterminate-bar-secondary.sc-ion-progress-bar-ios,.progress-paused.sc-ion-progress-bar-ios-h .indeterminate-bar-primary.sc-ion-progress-bar-ios,.progress-paused.sc-ion-progress-bar-ios-h .buffer-circles.sc-ion-progress-bar-ios{animation-play-state:paused}/*!@:host(.ion-color) .progress-buffer-bar*/.ion-color.sc-ion-progress-bar-ios-h .progress-buffer-bar.sc-ion-progress-bar-ios{background:rgba(var(--ion-color-base-rgb), 0.3)}/*!@:host(.ion-color) .buffer-circles*/.ion-color.sc-ion-progress-bar-ios-h .buffer-circles.sc-ion-progress-bar-ios{background-image:radial-gradient(ellipse at center, rgba(var(--ion-color-base-rgb), 0.3) 0%, rgba(var(--ion-color-base-rgb), 0.3) 30%, transparent 30%)}/*!@:host(.ion-color) .progress,\n:host(.ion-color) .progress-indeterminate*/.ion-color.sc-ion-progress-bar-ios-h .progress.sc-ion-progress-bar-ios,.ion-color.sc-ion-progress-bar-ios-h .progress-indeterminate.sc-ion-progress-bar-ios{background:var(--ion-color-base)}@keyframes primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes buffering{to{transform:translateX(-10px)}}/*!@:host*/.sc-ion-progress-bar-ios-h{height:3px}';

    const progressBarMdCss =
      '/*!@:host*/.sc-ion-progress-bar-md-h{--background:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.3);--progress-background:var(--ion-color-primary, #3880ff);--buffer-background:var(--background);display:block;position:relative;width:100%;contain:strict;direction:ltr;overflow:hidden}/*!@.progress,\n.progress-indeterminate,\n.indeterminate-bar-primary,\n.indeterminate-bar-secondary,\n.progress-buffer-bar*/.progress.sc-ion-progress-bar-md,.progress-indeterminate.sc-ion-progress-bar-md,.indeterminate-bar-primary.sc-ion-progress-bar-md,.indeterminate-bar-secondary.sc-ion-progress-bar-md,.progress-buffer-bar.sc-ion-progress-bar-md{left:0;right:0;top:0;bottom:0;position:absolute;width:100%;height:100%}/*!@.buffer-circles-container,\n.buffer-circles*/.buffer-circles-container.sc-ion-progress-bar-md,.buffer-circles.sc-ion-progress-bar-md{left:0;right:0;top:0;bottom:0;position:absolute}/*!@.buffer-circles*/.buffer-circles.sc-ion-progress-bar-md{right:-10px;left:-10px}/*!@.progress,\n.progress-buffer-bar,\n.buffer-circles-container*/.progress.sc-ion-progress-bar-md,.progress-buffer-bar.sc-ion-progress-bar-md,.buffer-circles-container.sc-ion-progress-bar-md{transform-origin:left top;transition:transform 150ms linear}/*!@.progress,\n.progress-indeterminate*/.progress.sc-ion-progress-bar-md,.progress-indeterminate.sc-ion-progress-bar-md{background:var(--progress-background);z-index:2}/*!@.progress-buffer-bar*/.progress-buffer-bar.sc-ion-progress-bar-md{background:var(--buffer-background);z-index:1}/*!@.buffer-circles-container*/.buffer-circles-container.sc-ion-progress-bar-md{overflow:hidden}/*!@.indeterminate-bar-primary*/.indeterminate-bar-primary.sc-ion-progress-bar-md{top:0;right:0;bottom:0;left:-145.166611%;animation:primary-indeterminate-translate 2s infinite linear}/*!@.indeterminate-bar-primary .progress-indeterminate*/.indeterminate-bar-primary.sc-ion-progress-bar-md .progress-indeterminate.sc-ion-progress-bar-md{animation:primary-indeterminate-scale 2s infinite linear;animation-play-state:inherit}/*!@.indeterminate-bar-secondary*/.indeterminate-bar-secondary.sc-ion-progress-bar-md{top:0;right:0;bottom:0;left:-54.888891%;animation:secondary-indeterminate-translate 2s infinite linear}/*!@.indeterminate-bar-secondary .progress-indeterminate*/.indeterminate-bar-secondary.sc-ion-progress-bar-md .progress-indeterminate.sc-ion-progress-bar-md{animation:secondary-indeterminate-scale 2s infinite linear;animation-play-state:inherit}/*!@.buffer-circles*/.buffer-circles.sc-ion-progress-bar-md{background-image:radial-gradient(ellipse at center, var(--buffer-background) 0%, var(--buffer-background) 30%, transparent 30%);background-repeat:repeat-x;background-position:5px center;background-size:10px 10px;z-index:0;animation:buffering 450ms infinite linear}/*!@:host(.progress-bar-reversed)*/.progress-bar-reversed.sc-ion-progress-bar-md-h{transform:scaleX(-1)}/*!@:host(.progress-paused) .indeterminate-bar-secondary,\n:host(.progress-paused) .indeterminate-bar-primary,\n:host(.progress-paused) .buffer-circles*/.progress-paused.sc-ion-progress-bar-md-h .indeterminate-bar-secondary.sc-ion-progress-bar-md,.progress-paused.sc-ion-progress-bar-md-h .indeterminate-bar-primary.sc-ion-progress-bar-md,.progress-paused.sc-ion-progress-bar-md-h .buffer-circles.sc-ion-progress-bar-md{animation-play-state:paused}/*!@:host(.ion-color) .progress-buffer-bar*/.ion-color.sc-ion-progress-bar-md-h .progress-buffer-bar.sc-ion-progress-bar-md{background:rgba(var(--ion-color-base-rgb), 0.3)}/*!@:host(.ion-color) .buffer-circles*/.ion-color.sc-ion-progress-bar-md-h .buffer-circles.sc-ion-progress-bar-md{background-image:radial-gradient(ellipse at center, rgba(var(--ion-color-base-rgb), 0.3) 0%, rgba(var(--ion-color-base-rgb), 0.3) 30%, transparent 30%)}/*!@:host(.ion-color) .progress,\n:host(.ion-color) .progress-indeterminate*/.ion-color.sc-ion-progress-bar-md-h .progress.sc-ion-progress-bar-md,.ion-color.sc-ion-progress-bar-md-h .progress-indeterminate.sc-ion-progress-bar-md{background:var(--ion-color-base)}@keyframes primary-indeterminate-translate{0%{transform:translateX(0)}20%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(0)}59.15%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(83.67142%)}100%{transform:translateX(200.611057%)}}@keyframes primary-indeterminate-scale{0%{transform:scaleX(0.08)}36.65%{animation-timing-function:cubic-bezier(0.334731, 0.12482, 0.785844, 1);transform:scaleX(0.08)}69.15%{animation-timing-function:cubic-bezier(0.06, 0.11, 0.6, 1);transform:scaleX(0.661479)}100%{transform:scaleX(0.08)}}@keyframes secondary-indeterminate-translate{0%{animation-timing-function:cubic-bezier(0.15, 0, 0.515058, 0.409685);transform:translateX(0)}25%{animation-timing-function:cubic-bezier(0.31033, 0.284058, 0.8, 0.733712);transform:translateX(37.651913%)}48.35%{animation-timing-function:cubic-bezier(0.4, 0.627035, 0.6, 0.902026);transform:translateX(84.386165%)}100%{transform:translateX(160.277782%)}}@keyframes secondary-indeterminate-scale{0%{animation-timing-function:cubic-bezier(0.205028, 0.057051, 0.57661, 0.453971);transform:scaleX(0.08)}19.15%{animation-timing-function:cubic-bezier(0.152313, 0.196432, 0.648374, 1.004315);transform:scaleX(0.457104)}44.15%{animation-timing-function:cubic-bezier(0.257759, -0.003163, 0.211762, 1.38179);transform:scaleX(0.72796)}100%{transform:scaleX(0.08)}}@keyframes buffering{to{transform:translateX(-10px)}}/*!@:host*/.sc-ion-progress-bar-md-h{height:4px}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part progress - The progress bar that shows the current value when `type` is `"determinate"` and slides back and forth when `type` is `"indeterminate"`.
     * @part stream - The animated circles that appear while buffering. This only shows when `buffer` is set and `type` is `"determinate"`.
     * @part track - The track bar behind the progress bar. If the `buffer` property is set and `type` is `"determinate"` the track will be the
     * width of the `buffer` value.
     */
    class ProgressBar {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * The state of the progress bar, based on if the time the process takes is known or not.
         * Default options are: `"determinate"` (no animation), `"indeterminate"` (animate from left to right).
         */
        this.type = 'determinate';
        /**
         * If true, reverse the progress bar direction.
         */
        this.reversed = false;
        /**
         * The value determines how much of the active bar should display when the
         * `type` is `"determinate"`.
         * The value should be between [0, 1].
         */
        this.value = 0;
        /**
         * If the buffer and value are smaller than 1, the buffer circles will show.
         * The buffer should be between [0, 1].
         */
        this.buffer = 1;
      }
      render() {
        const { color, type, reversed, value, buffer } = this;
        const paused = config$2.getBoolean('_testing');
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            'role': 'progressbar',
            'aria-valuenow': type === 'determinate' ? value : null,
            'aria-valuemin': '0',
            'aria-valuemax': '1',
            'class': createColorClasses$1(color, {
              [mode]: true,
              [`progress-bar-${type}`]: true,
              'progress-paused': paused,
              'progress-bar-reversed': document.dir === 'rtl' ? !reversed : reversed,
            }),
          },
          type === 'indeterminate' ? renderIndeterminate() : renderProgress(value, buffer),
        );
      }
      static get style() {
        return {
          ios: progressBarIosCss,
          md: progressBarMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-progress-bar',
          $members$: {
            type: [1],
            reversed: [4],
            value: [2],
            buffer: [2],
            color: [513],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }
    const renderIndeterminate = () => {
      return hAsync(
        'div',
        { part: 'track', class: 'progress-buffer-bar' },
        hAsync('div', { class: 'indeterminate-bar-primary' }, hAsync('span', { part: 'progress', class: 'progress-indeterminate' })),
        hAsync('div', { class: 'indeterminate-bar-secondary' }, hAsync('span', { part: 'progress', class: 'progress-indeterminate' })),
      );
    };
    const renderProgress = (value, buffer) => {
      const finalValue = clamp(0, value, 1);
      const finalBuffer = clamp(0, buffer, 1);
      return [
        hAsync('div', { part: 'progress', class: 'progress', style: { transform: `scaleX(${finalValue})` } }),
        /**
         * Buffer circles with two container to move
         * the circles behind the buffer progress
         * with respecting the animation.
         * When finalBuffer === 1, we use display: none
         * instead of removing the element to avoid flickering.
         */
        hAsync(
          'div',
          { class: { 'buffer-circles-container': true, 'ion-hide': finalBuffer === 1 }, style: { transform: `translateX(${finalBuffer * 100}%)` } },
          hAsync(
            'div',
            { class: 'buffer-circles-container', style: { transform: `translateX(-${finalBuffer * 100}%)` } },
            hAsync('div', { part: 'stream', class: 'buffer-circles' }),
          ),
        ),
        hAsync('div', { part: 'track', class: 'progress-buffer-bar', style: { transform: `scaleX(${finalBuffer})` } }),
      ];
    };

    const radioIosCss =
      '/*!@:host*/.sc-ion-radio-ios-h{--inner-border-radius:50%;display:inline-block;position:relative;box-sizing:border-box;user-select:none;z-index:2}/*!@:host(.radio-disabled)*/.radio-disabled.sc-ion-radio-ios-h{pointer-events:none}/*!@.radio-icon*/.radio-icon.sc-ion-radio-ios{display:flex;align-items:center;justify-content:center;width:100%;height:100%;contain:layout size style}/*!@.radio-icon,\n.radio-inner*/.radio-icon.sc-ion-radio-ios,.radio-inner.sc-ion-radio-ios{box-sizing:border-box}/*!@label*/label.sc-ion-radio-ios{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;appearance:none;outline:none;display:flex;align-items:center;opacity:0}/*!@[dir=rtl] label, :host-context([dir=rtl]) label*/[dir=rtl].sc-ion-radio-ios label.sc-ion-radio-ios,[dir=rtl].sc-ion-radio-ios-h label.sc-ion-radio-ios,[dir=rtl] .sc-ion-radio-ios-h label.sc-ion-radio-ios{left:unset;right:unset;right:0}/*!@label::-moz-focus-inner*/label.sc-ion-radio-ios::-moz-focus-inner{border:0}/*!@input*/input.sc-ion-radio-ios{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}/*!@:host(:focus)*/.sc-ion-radio-ios-h:focus{outline:none}/*!@:host*/.sc-ion-radio-ios-h{--color-checked:var(--ion-color-primary, #3880ff);width:15px;height:24px}/*!@:host(.ion-color.radio-checked) .radio-inner*/.ion-color.radio-checked.sc-ion-radio-ios-h .radio-inner.sc-ion-radio-ios{border-color:var(--ion-color-base)}/*!@.item-radio.item-ios ion-label*/.item-radio.item-ios.sc-ion-radio-ios ion-label.sc-ion-radio-ios{margin-left:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.item-radio.item-ios ion-label*/.item-radio.item-ios.sc-ion-radio-ios ion-label.sc-ion-radio-ios{margin-left:unset;-webkit-margin-start:0;margin-inline-start:0}}/*!@.radio-inner*/.radio-inner.sc-ion-radio-ios{width:33%;height:50%}/*!@:host(.radio-checked) .radio-inner*/.radio-checked.sc-ion-radio-ios-h .radio-inner.sc-ion-radio-ios{transform:rotate(45deg);border-width:2px;border-top-width:0;border-left-width:0;border-style:solid;border-color:var(--color-checked)}/*!@:host(.radio-disabled)*/.radio-disabled.sc-ion-radio-ios-h{opacity:0.3}/*!@:host(.ion-focused) .radio-icon::after*/.ion-focused.sc-ion-radio-ios-h .radio-icon.sc-ion-radio-ios::after{border-radius:var(--inner-border-radius);left:-9px;top:-8px;display:block;position:absolute;width:36px;height:36px;background:var(--ion-color-primary-tint, #4c8dff);content:"";opacity:0.2}/*!@:host-context([dir=rtl]):host(.ion-focused) .radio-icon::after, :host-context([dir=rtl]).ion-focused .radio-icon::after*/[dir=rtl].sc-ion-radio-ios-h -no-combinator.ion-focused.sc-ion-radio-ios-h .radio-icon.sc-ion-radio-ios::after,[dir=rtl] .sc-ion-radio-ios-h -no-combinator.ion-focused.sc-ion-radio-ios-h .radio-icon.sc-ion-radio-ios::after,[dir=rtl].ion-focused.sc-ion-radio-ios-h .radio-icon.sc-ion-radio-ios::after,[dir=rtl] .ion-focused.sc-ion-radio-ios-h .radio-icon.sc-ion-radio-ios::after{left:unset;right:unset;right:-9px}/*!@:host(.in-item)*/.in-item.sc-ion-radio-ios-h{margin-left:10px;margin-right:11px;margin-top:8px;margin-bottom:8px;display:block;position:static}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-item)*/.in-item.sc-ion-radio-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:10px;margin-inline-start:10px;-webkit-margin-end:11px;margin-inline-end:11px}}/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-radio-ios-h{margin-left:3px;margin-right:21px;margin-top:8px;margin-bottom:8px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-radio-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:3px;margin-inline-start:3px;-webkit-margin-end:21px;margin-inline-end:21px}}';

    const radioMdCss =
      '/*!@:host*/.sc-ion-radio-md-h{--inner-border-radius:50%;display:inline-block;position:relative;box-sizing:border-box;user-select:none;z-index:2}/*!@:host(.radio-disabled)*/.radio-disabled.sc-ion-radio-md-h{pointer-events:none}/*!@.radio-icon*/.radio-icon.sc-ion-radio-md{display:flex;align-items:center;justify-content:center;width:100%;height:100%;contain:layout size style}/*!@.radio-icon,\n.radio-inner*/.radio-icon.sc-ion-radio-md,.radio-inner.sc-ion-radio-md{box-sizing:border-box}/*!@label*/label.sc-ion-radio-md{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;appearance:none;outline:none;display:flex;align-items:center;opacity:0}/*!@[dir=rtl] label, :host-context([dir=rtl]) label*/[dir=rtl].sc-ion-radio-md label.sc-ion-radio-md,[dir=rtl].sc-ion-radio-md-h label.sc-ion-radio-md,[dir=rtl] .sc-ion-radio-md-h label.sc-ion-radio-md{left:unset;right:unset;right:0}/*!@label::-moz-focus-inner*/label.sc-ion-radio-md::-moz-focus-inner{border:0}/*!@input*/input.sc-ion-radio-md{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}/*!@:host(:focus)*/.sc-ion-radio-md-h:focus{outline:none}/*!@:host*/.sc-ion-radio-md-h{--color:var(--ion-color-step-400, #999999);--color-checked:var(--ion-color-primary, #3880ff);--border-width:2px;--border-style:solid;--border-radius:50%;width:20px;height:20px}/*!@:host(.ion-color) .radio-inner*/.ion-color.sc-ion-radio-md-h .radio-inner.sc-ion-radio-md{background:var(--ion-color-base)}/*!@:host(.ion-color.radio-checked) .radio-icon*/.ion-color.radio-checked.sc-ion-radio-md-h .radio-icon.sc-ion-radio-md{border-color:var(--ion-color-base)}/*!@.radio-icon*/.radio-icon.sc-ion-radio-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border-radius:var(--border-radius);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--color)}/*!@.radio-inner*/.radio-inner.sc-ion-radio-md{border-radius:var(--inner-border-radius);width:calc(50% + var(--border-width));height:calc(50% + var(--border-width));transform:scale3d(0, 0, 0);transition:transform 280ms cubic-bezier(0.4, 0, 0.2, 1);background:var(--color-checked)}/*!@:host(.radio-checked) .radio-icon*/.radio-checked.sc-ion-radio-md-h .radio-icon.sc-ion-radio-md{border-color:var(--color-checked)}/*!@:host(.radio-checked) .radio-inner*/.radio-checked.sc-ion-radio-md-h .radio-inner.sc-ion-radio-md{transform:scale3d(1, 1, 1)}/*!@:host(.radio-disabled)*/.radio-disabled.sc-ion-radio-md-h{opacity:0.3}/*!@:host(.ion-focused) .radio-icon::after*/.ion-focused.sc-ion-radio-md-h .radio-icon.sc-ion-radio-md::after{border-radius:var(--inner-border-radius);left:-12px;top:-12px;display:block;position:absolute;width:36px;height:36px;background:var(--ion-color-primary-tint, #4c8dff);content:"";opacity:0.2}/*!@:host-context([dir=rtl]):host(.ion-focused) .radio-icon::after, :host-context([dir=rtl]).ion-focused .radio-icon::after*/[dir=rtl].sc-ion-radio-md-h -no-combinator.ion-focused.sc-ion-radio-md-h .radio-icon.sc-ion-radio-md::after,[dir=rtl] .sc-ion-radio-md-h -no-combinator.ion-focused.sc-ion-radio-md-h .radio-icon.sc-ion-radio-md::after,[dir=rtl].ion-focused.sc-ion-radio-md-h .radio-icon.sc-ion-radio-md::after,[dir=rtl] .ion-focused.sc-ion-radio-md-h .radio-icon.sc-ion-radio-md::after{left:unset;right:unset;right:-12px}/*!@:host(.in-item)*/.in-item.sc-ion-radio-md-h{margin-left:0;margin-right:0;margin-top:9px;margin-bottom:9px;display:block;position:static}/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-radio-md-h{margin-left:4px;margin-right:36px;margin-top:11px;margin-bottom:10px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-radio-md-h{margin-left:unset;margin-right:unset;-webkit-margin-start:4px;margin-inline-start:4px;-webkit-margin-end:36px;margin-inline-end:36px}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part container - The container for the radio mark.
     * @part mark - The checkmark or dot used to indicate the checked state.
     */
    class Radio {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        this.inputId = `ion-rb-${radioButtonIds++}`;
        this.radioGroup = null;
        /**
         * If `true`, the radio is selected.
         */
        this.checked = false;
        /**
         * The tabindex of the radio button.
         * @internal
         */
        this.buttonTabindex = -1;
        /**
         * The name of the control, which is submitted with the form data.
         */
        this.name = this.inputId;
        /**
         * If `true`, the user cannot interact with the radio.
         */
        this.disabled = false;
        this.updateState = () => {
          if (this.radioGroup) {
            this.checked = this.radioGroup.value === this.value;
          }
        };
        this.onFocus = () => {
          this.ionFocus.emit();
        };
        this.onBlur = () => {
          this.ionBlur.emit();
        };
      }
      /** @internal */
      async setFocus(ev) {
        ev.stopPropagation();
        ev.preventDefault();
        this.el.focus();
      }
      /** @internal */
      async setButtonTabindex(value) {
        this.buttonTabindex = value;
      }
      connectedCallback() {
        if (this.value === undefined) {
          this.value = this.inputId;
        }
        const radioGroup = (this.radioGroup = this.el.closest('ion-radio-group'));
        if (radioGroup) {
          this.updateState();
          addEventListener(radioGroup, 'ionChange', this.updateState);
        }
      }
      disconnectedCallback() {
        const radioGroup = this.radioGroup;
        if (radioGroup) {
          removeEventListener(radioGroup, 'ionChange', this.updateState);
          this.radioGroup = null;
        }
      }
      componentWillLoad() {
        this.emitStyle();
      }
      emitStyle() {
        this.ionStyle.emit({
          'radio-checked': this.checked,
          'interactive-disabled': this.disabled,
        });
      }
      render() {
        const { inputId, disabled, checked, color, el, buttonTabindex } = this;
        const mode = getIonMode$1(this);
        const { label, labelId, labelText } = getAriaLabel(el, inputId);
        return hAsync(
          Host,
          {
            'aria-checked': `${checked}`,
            'aria-hidden': disabled ? 'true' : null,
            'aria-labelledby': label ? labelId : null,
            'role': 'radio',
            'tabindex': buttonTabindex,
            'onFocus': this.onFocus,
            'onBlur': this.onBlur,
            'class': createColorClasses$1(color, {
              [mode]: true,
              'in-item': hostContext('ion-item', el),
              'interactive': true,
              'radio-checked': checked,
              'radio-disabled': disabled,
            }),
          },
          hAsync('div', { class: 'radio-icon', part: 'container' }, hAsync('div', { class: 'radio-inner', part: 'mark' }), hAsync('div', { class: 'radio-ripple' })),
          hAsync('label', { htmlFor: inputId }, labelText),
          hAsync('input', { type: 'radio', checked: checked, disabled: disabled, tabindex: '-1', id: inputId }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          color: ['emitStyle'],
          checked: ['emitStyle'],
          disabled: ['emitStyle'],
        };
      }
      static get style() {
        return {
          ios: radioIosCss,
          md: radioMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-radio',
          $members$: {
            color: [513],
            name: [1],
            disabled: [4],
            value: [8],
            checked: [32],
            buttonTabindex: [32],
            setFocus: [64],
            setButtonTabindex: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }
    let radioButtonIds = 0;

    class RadioGroup {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionChange = createEvent(this, 'ionChange', 7);
        this.inputId = `ion-rg-${radioGroupIds++}`;
        this.labelId = `${this.inputId}-lbl`;
        /**
         * If `true`, the radios can be deselected.
         */
        this.allowEmptySelection = false;
        /**
         * The name of the control, which is submitted with the form data.
         */
        this.name = this.inputId;
        this.setRadioTabindex = value => {
          const radios = this.getRadios();
          // Get the first radio that is not disabled and the checked one
          const first = radios.find(radio => !radio.disabled);
          const checked = radios.find(radio => radio.value === value && !radio.disabled);
          if (!first && !checked) {
            return;
          }
          // If an enabled checked radio exists, set it to be the focusable radio
          // otherwise we default to focus the first radio
          const focusable = checked || first;
          for (const radio of radios) {
            const tabindex = radio === focusable ? 0 : -1;
            radio.setButtonTabindex(tabindex);
          }
        };
        this.onClick = ev => {
          ev.preventDefault();
          const selectedRadio = ev.target && ev.target.closest('ion-radio');
          if (selectedRadio) {
            const currentValue = this.value;
            const newValue = selectedRadio.value;
            if (newValue !== currentValue) {
              this.value = newValue;
            } else if (this.allowEmptySelection) {
              this.value = undefined;
            }
          }
        };
      }
      valueChanged(value) {
        this.setRadioTabindex(value);
        this.ionChange.emit({ value });
      }
      componentDidLoad() {
        this.setRadioTabindex(this.value);
      }
      async connectedCallback() {
        // Get the list header if it exists and set the id
        // this is used to set aria-labelledby
        const header = this.el.querySelector('ion-list-header') || this.el.querySelector('ion-item-divider');
        if (header) {
          const label = (this.label = header.querySelector('ion-label'));
          if (label) {
            this.labelId = label.id = this.name + '-lbl';
          }
        }
      }
      getRadios() {
        return Array.from(this.el.querySelectorAll('ion-radio'));
      }
      onKeydown(ev) {
        const inSelectPopover = !!this.el.closest('ion-select-popover');
        if (ev.target && !this.el.contains(ev.target)) {
          return;
        }
        // Get all radios inside of the radio group and then
        // filter out disabled radios since we need to skip those
        const radios = this.getRadios().filter(radio => !radio.disabled);
        // Only move the radio if the current focus is in the radio group
        if (ev.target && radios.includes(ev.target)) {
          const index = radios.findIndex(radio => radio === ev.target);
          const current = radios[index];
          let next;
          // If hitting arrow down or arrow right, move to the next radio
          // If we're on the last radio, move to the first radio
          if (['ArrowDown', 'ArrowRight'].includes(ev.code)) {
            next = index === radios.length - 1 ? radios[0] : radios[index + 1];
          }
          // If hitting arrow up or arrow left, move to the previous radio
          // If we're on the first radio, move to the last radio
          if (['ArrowUp', 'ArrowLeft'].includes(ev.code)) {
            next = index === 0 ? radios[radios.length - 1] : radios[index - 1];
          }
          if (next && radios.includes(next)) {
            next.setFocus(ev);
            if (!inSelectPopover) {
              this.value = next.value;
            }
          }
          // Update the radio group value when a user presses the
          // space bar on top of a selected radio
          if (['Space'].includes(ev.code)) {
            this.value = this.allowEmptySelection && this.value !== undefined ? undefined : current.value;
            // Prevent browsers from jumping
            // to the bottom of the screen
            ev.preventDefault();
          }
        }
      }
      render() {
        const { label, labelId } = this;
        const mode = getIonMode$1(this);
        return hAsync(Host, { 'role': 'radiogroup', 'aria-labelledby': label ? labelId : null, 'onClick': this.onClick, 'class': mode });
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          value: ['valueChanged'],
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-radio-group',
          $members$: {
            allowEmptySelection: [4, 'allow-empty-selection'],
            name: [1],
            value: [1032],
          },
          $listeners$: [[4, 'keydown', 'onKeydown']],
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    let radioGroupIds = 0;

    const rangeIosCss =
      '/*!@:host*/.sc-ion-range-ios-h{--knob-handle-size:calc(var(--knob-size) * 2);display:flex;position:relative;flex:3;align-items:center;font-family:var(--ion-font-family, inherit);user-select:none;z-index:2}/*!@:host(.range-disabled)*/.range-disabled.sc-ion-range-ios-h{pointer-events:none}/*!@::slotted(ion-label)*/.sc-ion-range-ios-s>ion-label{flex:initial}/*!@::slotted(ion-icon[slot])*/.sc-ion-range-ios-s>ion-icon[slot]{font-size:24px}/*!@.range-slider*/.range-slider.sc-ion-range-ios{position:relative;flex:1;width:100%;height:var(--height);contain:size layout style;cursor:grab;touch-action:pan-y}/*!@:host(.range-pressed) .range-slider*/.range-pressed.sc-ion-range-ios-h .range-slider.sc-ion-range-ios{cursor:grabbing}/*!@.range-pin*/.range-pin.sc-ion-range-ios{position:absolute;background:var(--ion-color-base);color:var(--ion-color-contrast);text-align:center;box-sizing:border-box}/*!@.range-knob-handle*/.range-knob-handle.sc-ion-range-ios{left:0;top:calc((var(--height) - var(--knob-handle-size)) / 2);margin-left:calc(0px - var(--knob-handle-size) / 2);position:absolute;width:var(--knob-handle-size);height:var(--knob-handle-size);text-align:center}/*!@[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle*/[dir=rtl].sc-ion-range-ios .range-knob-handle.sc-ion-range-ios,[dir=rtl].sc-ion-range-ios-h .range-knob-handle.sc-ion-range-ios,[dir=rtl] .sc-ion-range-ios-h .range-knob-handle.sc-ion-range-ios{left:unset;right:unset;right:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.range-knob-handle*/.range-knob-handle.sc-ion-range-ios{margin-left:unset;-webkit-margin-start:calc(0px - var(--knob-handle-size) / 2);margin-inline-start:calc(0px - var(--knob-handle-size) / 2)}}/*!@[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle*/[dir=rtl].sc-ion-range-ios .range-knob-handle.sc-ion-range-ios,[dir=rtl].sc-ion-range-ios-h .range-knob-handle.sc-ion-range-ios,[dir=rtl] .sc-ion-range-ios-h .range-knob-handle.sc-ion-range-ios{left:unset}/*!@.range-knob-handle:active, .range-knob-handle:focus*/.range-knob-handle.sc-ion-range-ios:active,.range-knob-handle.sc-ion-range-ios:focus{outline:none}/*!@.range-bar*/.range-bar.sc-ion-range-ios{border-radius:var(--bar-border-radius);left:0;top:calc((var(--height) - var(--bar-height)) / 2);position:absolute;width:100%;height:var(--bar-height);background:var(--bar-background);pointer-events:none}/*!@[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar*/[dir=rtl].sc-ion-range-ios .range-bar.sc-ion-range-ios,[dir=rtl].sc-ion-range-ios-h .range-bar.sc-ion-range-ios,[dir=rtl] .sc-ion-range-ios-h .range-bar.sc-ion-range-ios{left:unset;right:unset;right:0}/*!@[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar*/[dir=rtl].sc-ion-range-ios .range-bar.sc-ion-range-ios,[dir=rtl].sc-ion-range-ios-h .range-bar.sc-ion-range-ios,[dir=rtl] .sc-ion-range-ios-h .range-bar.sc-ion-range-ios{left:unset}/*!@.range-knob*/.range-knob.sc-ion-range-ios{border-radius:var(--knob-border-radius);left:calc(50% - var(--knob-size) / 2);top:calc(50% - var(--knob-size) / 2);position:absolute;width:var(--knob-size);height:var(--knob-size);background:var(--knob-background);box-shadow:var(--knob-box-shadow);z-index:2;pointer-events:none}/*!@[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob*/[dir=rtl].sc-ion-range-ios .range-knob.sc-ion-range-ios,[dir=rtl].sc-ion-range-ios-h .range-knob.sc-ion-range-ios,[dir=rtl] .sc-ion-range-ios-h .range-knob.sc-ion-range-ios{left:unset;right:unset;right:calc(50% - var(--knob-size) / 2)}/*!@[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob*/[dir=rtl].sc-ion-range-ios .range-knob.sc-ion-range-ios,[dir=rtl].sc-ion-range-ios-h .range-knob.sc-ion-range-ios,[dir=rtl] .sc-ion-range-ios-h .range-knob.sc-ion-range-ios{left:unset}/*!@:host(.range-pressed) .range-bar-active*/.range-pressed.sc-ion-range-ios-h .range-bar-active.sc-ion-range-ios{will-change:left, right}/*!@:host(.in-item)*/.in-item.sc-ion-range-ios-h{width:100%}/*!@:host(.in-item) ::slotted(ion-label)*/.sc-ion-range-ios-h.in-item .sc-ion-range-ios-s>ion-label{align-self:center}/*!@:host*/.sc-ion-range-ios-h{--knob-border-radius:50%;--knob-background:#ffffff;--knob-box-shadow:0 3px 1px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.13), 0 0 0 1px rgba(0, 0, 0, 0.02);--knob-size:28px;--bar-height:2px;--bar-background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1);--bar-background-active:var(--ion-color-primary, #3880ff);--bar-border-radius:0;--height:42px;padding-left:16px;padding-right:16px;padding-top:8px;padding-bottom:8px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-range-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}/*!@:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-tick-active*/.ion-color.sc-ion-range-ios-h .range-bar-active.sc-ion-range-ios,.ion-color.sc-ion-range-ios-h .range-tick-active.sc-ion-range-ios{background:var(--ion-color-base)}/*!@::slotted([slot=start])*/.sc-ion-range-ios-s>[slot=start]{margin-left:0;margin-right:16px;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=start])*/.sc-ion-range-ios-s>[slot=start]{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:16px;margin-inline-end:16px}}/*!@::slotted([slot=end])*/.sc-ion-range-ios-s>[slot=end]{margin-left:16px;margin-right:0;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=end])*/.sc-ion-range-ios-s>[slot=end]{margin-left:unset;margin-right:unset;-webkit-margin-start:16px;margin-inline-start:16px;-webkit-margin-end:0;margin-inline-end:0}}/*!@:host(.range-has-pin)*/.range-has-pin.sc-ion-range-ios-h{padding-top:20px}/*!@.range-bar-active*/.range-bar-active.sc-ion-range-ios{bottom:0;width:auto;background:var(--bar-background-active)}/*!@.range-tick*/.range-tick.sc-ion-range-ios{margin-left:-1px;border-radius:0;position:absolute;top:18px;width:2px;height:8px;background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1);pointer-events:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.range-tick*/.range-tick.sc-ion-range-ios{margin-left:unset;-webkit-margin-start:-1px;margin-inline-start:-1px}}/*!@.range-tick-active*/.range-tick-active.sc-ion-range-ios{background:var(--bar-background-active)}/*!@.range-pin*/.range-pin.sc-ion-range-ios{transform:translate3d(0,  28px,  0) scale(0.01);padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:8px;display:inline-block;position:relative;top:-20px;min-width:28px;transition:transform 120ms ease;background:transparent;color:var(--ion-text-color, #000);font-size:12px;text-align:center}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.range-pin*/.range-pin.sc-ion-range-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px}}/*!@.range-knob-pressed .range-pin*/.range-knob-pressed.sc-ion-range-ios .range-pin.sc-ion-range-ios{transform:translate3d(0,  0,  0) scale(1)}/*!@:host(.range-disabled)*/.range-disabled.sc-ion-range-ios-h{opacity:0.5}';

    const rangeMdCss =
      '/*!@:host*/.sc-ion-range-md-h{--knob-handle-size:calc(var(--knob-size) * 2);display:flex;position:relative;flex:3;align-items:center;font-family:var(--ion-font-family, inherit);user-select:none;z-index:2}/*!@:host(.range-disabled)*/.range-disabled.sc-ion-range-md-h{pointer-events:none}/*!@::slotted(ion-label)*/.sc-ion-range-md-s>ion-label{flex:initial}/*!@::slotted(ion-icon[slot])*/.sc-ion-range-md-s>ion-icon[slot]{font-size:24px}/*!@.range-slider*/.range-slider.sc-ion-range-md{position:relative;flex:1;width:100%;height:var(--height);contain:size layout style;cursor:grab;touch-action:pan-y}/*!@:host(.range-pressed) .range-slider*/.range-pressed.sc-ion-range-md-h .range-slider.sc-ion-range-md{cursor:grabbing}/*!@.range-pin*/.range-pin.sc-ion-range-md{position:absolute;background:var(--ion-color-base);color:var(--ion-color-contrast);text-align:center;box-sizing:border-box}/*!@.range-knob-handle*/.range-knob-handle.sc-ion-range-md{left:0;top:calc((var(--height) - var(--knob-handle-size)) / 2);margin-left:calc(0px - var(--knob-handle-size) / 2);position:absolute;width:var(--knob-handle-size);height:var(--knob-handle-size);text-align:center}/*!@[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle*/[dir=rtl].sc-ion-range-md .range-knob-handle.sc-ion-range-md,[dir=rtl].sc-ion-range-md-h .range-knob-handle.sc-ion-range-md,[dir=rtl] .sc-ion-range-md-h .range-knob-handle.sc-ion-range-md{left:unset;right:unset;right:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.range-knob-handle*/.range-knob-handle.sc-ion-range-md{margin-left:unset;-webkit-margin-start:calc(0px - var(--knob-handle-size) / 2);margin-inline-start:calc(0px - var(--knob-handle-size) / 2)}}/*!@[dir=rtl] .range-knob-handle, :host-context([dir=rtl]) .range-knob-handle*/[dir=rtl].sc-ion-range-md .range-knob-handle.sc-ion-range-md,[dir=rtl].sc-ion-range-md-h .range-knob-handle.sc-ion-range-md,[dir=rtl] .sc-ion-range-md-h .range-knob-handle.sc-ion-range-md{left:unset}/*!@.range-knob-handle:active, .range-knob-handle:focus*/.range-knob-handle.sc-ion-range-md:active,.range-knob-handle.sc-ion-range-md:focus{outline:none}/*!@.range-bar*/.range-bar.sc-ion-range-md{border-radius:var(--bar-border-radius);left:0;top:calc((var(--height) - var(--bar-height)) / 2);position:absolute;width:100%;height:var(--bar-height);background:var(--bar-background);pointer-events:none}/*!@[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar*/[dir=rtl].sc-ion-range-md .range-bar.sc-ion-range-md,[dir=rtl].sc-ion-range-md-h .range-bar.sc-ion-range-md,[dir=rtl] .sc-ion-range-md-h .range-bar.sc-ion-range-md{left:unset;right:unset;right:0}/*!@[dir=rtl] .range-bar, :host-context([dir=rtl]) .range-bar*/[dir=rtl].sc-ion-range-md .range-bar.sc-ion-range-md,[dir=rtl].sc-ion-range-md-h .range-bar.sc-ion-range-md,[dir=rtl] .sc-ion-range-md-h .range-bar.sc-ion-range-md{left:unset}/*!@.range-knob*/.range-knob.sc-ion-range-md{border-radius:var(--knob-border-radius);left:calc(50% - var(--knob-size) / 2);top:calc(50% - var(--knob-size) / 2);position:absolute;width:var(--knob-size);height:var(--knob-size);background:var(--knob-background);box-shadow:var(--knob-box-shadow);z-index:2;pointer-events:none}/*!@[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob*/[dir=rtl].sc-ion-range-md .range-knob.sc-ion-range-md,[dir=rtl].sc-ion-range-md-h .range-knob.sc-ion-range-md,[dir=rtl] .sc-ion-range-md-h .range-knob.sc-ion-range-md{left:unset;right:unset;right:calc(50% - var(--knob-size) / 2)}/*!@[dir=rtl] .range-knob, :host-context([dir=rtl]) .range-knob*/[dir=rtl].sc-ion-range-md .range-knob.sc-ion-range-md,[dir=rtl].sc-ion-range-md-h .range-knob.sc-ion-range-md,[dir=rtl] .sc-ion-range-md-h .range-knob.sc-ion-range-md{left:unset}/*!@:host(.range-pressed) .range-bar-active*/.range-pressed.sc-ion-range-md-h .range-bar-active.sc-ion-range-md{will-change:left, right}/*!@:host(.in-item)*/.in-item.sc-ion-range-md-h{width:100%}/*!@:host(.in-item) ::slotted(ion-label)*/.sc-ion-range-md-h.in-item .sc-ion-range-md-s>ion-label{align-self:center}/*!@:host*/.sc-ion-range-md-h{--knob-border-radius:50%;--knob-background:var(--bar-background-active);--knob-box-shadow:none;--knob-size:18px;--bar-height:2px;--bar-background:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.26);--bar-background-active:var(--ion-color-primary, #3880ff);--bar-border-radius:0;--height:42px;--pin-background:var(--ion-color-primary, #3880ff);--pin-color:var(--ion-color-primary-contrast, #fff);padding-left:14px;padding-right:14px;padding-top:8px;padding-bottom:8px;font-size:12px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-range-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:14px;padding-inline-start:14px;-webkit-padding-end:14px;padding-inline-end:14px}}/*!@:host(.ion-color) .range-bar*/.ion-color.sc-ion-range-md-h .range-bar.sc-ion-range-md{background:rgba(var(--ion-color-base-rgb), 0.26)}/*!@:host(.ion-color) .range-bar-active,\n:host(.ion-color) .range-knob,\n:host(.ion-color) .range-pin,\n:host(.ion-color) .range-pin::before,\n:host(.ion-color) .range-tick*/.ion-color.sc-ion-range-md-h .range-bar-active.sc-ion-range-md,.ion-color.sc-ion-range-md-h .range-knob.sc-ion-range-md,.ion-color.sc-ion-range-md-h .range-pin.sc-ion-range-md,.ion-color.sc-ion-range-md-h .range-pin.sc-ion-range-md::before,.ion-color.sc-ion-range-md-h .range-tick.sc-ion-range-md{background:var(--ion-color-base);color:var(--ion-color-contrast)}/*!@::slotted([slot=start])*/.sc-ion-range-md-s>[slot=start]{margin-left:0;margin-right:14px;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=start])*/.sc-ion-range-md-s>[slot=start]{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:14px;margin-inline-end:14px}}/*!@::slotted([slot=end])*/.sc-ion-range-md-s>[slot=end]{margin-left:14px;margin-right:0;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted([slot=end])*/.sc-ion-range-md-s>[slot=end]{margin-left:unset;margin-right:unset;-webkit-margin-start:14px;margin-inline-start:14px;-webkit-margin-end:0;margin-inline-end:0}}/*!@:host(.range-has-pin)*/.range-has-pin.sc-ion-range-md-h{padding-top:28px}/*!@.range-bar-active*/.range-bar-active.sc-ion-range-md{bottom:0;width:auto;background:var(--bar-background-active)}/*!@.range-knob*/.range-knob.sc-ion-range-md{transform:scale(0.67);transition-duration:120ms;transition-property:transform, background-color, border;transition-timing-function:ease;z-index:2}/*!@.range-tick*/.range-tick.sc-ion-range-md{position:absolute;top:calc((var(--height) - var(--bar-height)) / 2);width:var(--bar-height);height:var(--bar-height);background:var(--bar-background-active);z-index:1;pointer-events:none}/*!@.range-tick-active*/.range-tick-active.sc-ion-range-md{background:transparent}/*!@.range-pin*/.range-pin.sc-ion-range-md{padding-left:0;padding-right:0;padding-top:8px;padding-bottom:8px;border-radius:50%;transform:translate3d(0,  0,  0) scale(0.01);display:inline-block;position:relative;min-width:28px;height:28px;transition:transform 120ms ease, background 120ms ease;background:var(--pin-background);color:var(--pin-color);text-align:center}/*!@.range-pin::before*/.range-pin.sc-ion-range-md::before{left:50%;top:3px;margin-left:-13px;border-radius:50% 50% 50% 0;position:absolute;width:26px;height:26px;transform:rotate(-45deg);transition:background 120ms ease;background:var(--pin-background);content:"";z-index:-1}/*!@[dir=rtl] .range-pin::before, :host-context([dir=rtl]) .range-pin::before*/[dir=rtl].sc-ion-range-md .range-pin.sc-ion-range-md::before,[dir=rtl].sc-ion-range-md-h .range-pin.sc-ion-range-md::before,[dir=rtl] .sc-ion-range-md-h .range-pin.sc-ion-range-md::before{left:unset;right:unset;right:50%}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.range-pin::before*/.range-pin.sc-ion-range-md::before{margin-left:unset;-webkit-margin-start:-13px;margin-inline-start:-13px}}/*!@[dir=rtl] .range-pin::before, :host-context([dir=rtl]) .range-pin::before*/[dir=rtl].sc-ion-range-md .range-pin.sc-ion-range-md::before,[dir=rtl].sc-ion-range-md-h .range-pin.sc-ion-range-md::before,[dir=rtl] .sc-ion-range-md-h .range-pin.sc-ion-range-md::before{left:unset}/*!@.range-knob-pressed .range-pin*/.range-knob-pressed.sc-ion-range-md .range-pin.sc-ion-range-md{transform:translate3d(0,  -24px,  0) scale(1)}/*!@:host(:not(.range-has-pin)) .range-knob-pressed .range-knob*/.sc-ion-range-md-h:not(.range-has-pin) .range-knob-pressed.sc-ion-range-md .range-knob.sc-ion-range-md{transform:scale(1)}/*!@:host(.range-disabled) .range-bar-active,\n:host(.range-disabled) .range-bar,\n:host(.range-disabled) .range-tick*/.range-disabled.sc-ion-range-md-h .range-bar-active.sc-ion-range-md,.range-disabled.sc-ion-range-md-h .range-bar.sc-ion-range-md,.range-disabled.sc-ion-range-md-h .range-tick.sc-ion-range-md{background-color:var(--ion-color-step-250, #bfbfbf)}/*!@:host(.range-disabled) .range-knob*/.range-disabled.sc-ion-range-md-h .range-knob.sc-ion-range-md{transform:scale(0.55);outline:5px solid #fff;background-color:var(--ion-color-step-250, #bfbfbf)}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @slot start - Content is placed to the left of the range slider in LTR, and to the right in RTL.
     * @slot end - Content is placed to the right of the range slider in LTR, and to the left in RTL.
     *
     * @part tick - An inactive tick mark.
     * @part tick-active - An active tick mark.
     * @part pin - The counter that appears above a knob.
     * @part knob - The handle that is used to drag the range.
     * @part bar - The inactive part of the bar.
     * @part bar-active - The active part of the bar.
     */
    class Range {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionChange = createEvent(this, 'ionChange', 7);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        this.didLoad = false;
        this.noUpdate = false;
        this.hasFocus = false;
        this.inheritedAttributes = {};
        this.ratioA = 0;
        this.ratioB = 0;
        /**
         * How long, in milliseconds, to wait to trigger the
         * `ionChange` event after each change in the range value.
         * This also impacts form bindings such as `ngModel` or `v-model`.
         */
        this.debounce = 0;
        // TODO: In Ionic Framework v6 this should initialize to this.rangeId like the other form components do.
        /**
         * The name of the control, which is submitted with the form data.
         */
        this.name = '';
        /**
         * Show two knobs.
         */
        this.dualKnobs = false;
        /**
         * Minimum integer value of the range.
         */
        this.min = 0;
        /**
         * Maximum integer value of the range.
         */
        this.max = 100;
        /**
         * If `true`, a pin with integer value is shown when the knob
         * is pressed.
         */
        this.pin = false;
        /**
         * If `true`, the knob snaps to tick marks evenly spaced based
         * on the step property value.
         */
        this.snaps = false;
        /**
         * Specifies the value granularity.
         */
        this.step = 1;
        /**
         * If `true`, tick marks are displayed based on the step value.
         * Only applies when `snaps` is `true`.
         */
        this.ticks = true;
        /**
         * If `true`, the user cannot interact with the range.
         */
        this.disabled = false;
        /**
         * the value of the range.
         */
        this.value = 0;
        this.clampBounds = value => {
          return clamp(this.min, value, this.max);
        };
        this.ensureValueInBounds = value => {
          if (this.dualKnobs) {
            return {
              lower: this.clampBounds(value.lower),
              upper: this.clampBounds(value.upper),
            };
          } else {
            return this.clampBounds(value);
          }
        };
        this.setupGesture = async () => {
          const rangeSlider = this.rangeSlider;
          if (rangeSlider) {
            this.gesture = (
              await Promise.resolve().then(function () {
                return index$2;
              })
            ).createGesture({
              el: rangeSlider,
              gestureName: 'range',
              gesturePriority: 100,
              threshold: 0,
              onStart: ev => this.onStart(ev),
              onMove: ev => this.onMove(ev),
              onEnd: ev => this.onEnd(ev),
            });
            this.gesture.enable(!this.disabled);
          }
        };
        this.handleKeyboard = (knob, isIncrease) => {
          let step = this.step;
          step = step > 0 ? step : 1;
          step = step / (this.max - this.min);
          if (!isIncrease) {
            step *= -1;
          }
          if (knob === 'A') {
            this.ratioA = clamp(0, this.ratioA + step, 1);
          } else {
            this.ratioB = clamp(0, this.ratioB + step, 1);
          }
          this.updateValue();
        };
        this.onBlur = () => {
          if (this.hasFocus) {
            this.hasFocus = false;
            this.ionBlur.emit();
            this.emitStyle();
          }
        };
        this.onFocus = () => {
          if (!this.hasFocus) {
            this.hasFocus = true;
            this.ionFocus.emit();
            this.emitStyle();
          }
        };
      }
      debounceChanged() {
        this.ionChange = debounceEvent(this.ionChange, this.debounce);
      }
      minChanged() {
        if (!this.noUpdate) {
          this.updateRatio();
        }
      }
      maxChanged() {
        if (!this.noUpdate) {
          this.updateRatio();
        }
      }
      disabledChanged() {
        if (this.gesture) {
          this.gesture.enable(!this.disabled);
        }
        this.emitStyle();
      }
      valueChanged(value) {
        if (!this.noUpdate) {
          this.updateRatio();
        }
        value = this.ensureValueInBounds(value);
        this.ionChange.emit({ value });
      }
      componentWillLoad() {
        /**
         * If user has custom ID set then we should
         * not assign the default incrementing ID.
         */
        this.rangeId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : `ion-r-${rangeIds++}`;
        this.inheritedAttributes = inheritAttributes(this.el, ['aria-label']);
      }
      componentDidLoad() {
        this.setupGesture();
        this.didLoad = true;
      }
      connectedCallback() {
        this.updateRatio();
        this.debounceChanged();
        this.disabledChanged();
        /**
         * If we have not yet rendered
         * ion-range, then rangeSlider is not defined.
         * But if we are moving ion-range via appendChild,
         * then rangeSlider will be defined.
         */
        if (this.didLoad) {
          this.setupGesture();
        }
      }
      disconnectedCallback() {
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
      }
      getValue() {
        const value = this.value || 0;
        if (this.dualKnobs) {
          if (typeof value === 'object') {
            return value;
          }
          return {
            lower: 0,
            upper: value,
          };
        } else {
          if (typeof value === 'object') {
            return value.upper;
          }
          return value;
        }
      }
      emitStyle() {
        this.ionStyle.emit({
          'interactive': true,
          'interactive-disabled': this.disabled,
        });
      }
      onStart(detail) {
        const rect = (this.rect = this.rangeSlider.getBoundingClientRect());
        const currentX = detail.currentX;
        // figure out which knob they started closer to
        let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);
        if (document.dir === 'rtl') {
          ratio = 1 - ratio;
        }
        this.pressedKnob = !this.dualKnobs || Math.abs(this.ratioA - ratio) < Math.abs(this.ratioB - ratio) ? 'A' : 'B';
        this.setFocus(this.pressedKnob);
        // update the active knob's position
        this.update(currentX);
      }
      onMove(detail) {
        this.update(detail.currentX);
      }
      onEnd(detail) {
        this.update(detail.currentX);
        this.pressedKnob = undefined;
      }
      update(currentX) {
        // figure out where the pointer is currently at
        // update the knob being interacted with
        const rect = this.rect;
        let ratio = clamp(0, (currentX - rect.left) / rect.width, 1);
        if (document.dir === 'rtl') {
          ratio = 1 - ratio;
        }
        if (this.snaps) {
          // snaps the ratio to the current value
          ratio = valueToRatio(ratioToValue(ratio, this.min, this.max, this.step), this.min, this.max);
        }
        // update which knob is pressed
        if (this.pressedKnob === 'A') {
          this.ratioA = ratio;
        } else {
          this.ratioB = ratio;
        }
        // Update input value
        this.updateValue();
      }
      get valA() {
        return ratioToValue(this.ratioA, this.min, this.max, this.step);
      }
      get valB() {
        return ratioToValue(this.ratioB, this.min, this.max, this.step);
      }
      get ratioLower() {
        if (this.dualKnobs) {
          return Math.min(this.ratioA, this.ratioB);
        }
        return 0;
      }
      get ratioUpper() {
        if (this.dualKnobs) {
          return Math.max(this.ratioA, this.ratioB);
        }
        return this.ratioA;
      }
      updateRatio() {
        const value = this.getValue();
        const { min, max } = this;
        if (this.dualKnobs) {
          this.ratioA = valueToRatio(value.lower, min, max);
          this.ratioB = valueToRatio(value.upper, min, max);
        } else {
          this.ratioA = valueToRatio(value, min, max);
        }
      }
      updateValue() {
        this.noUpdate = true;
        const { valA, valB } = this;
        this.value = !this.dualKnobs
          ? valA
          : {
              lower: Math.min(valA, valB),
              upper: Math.max(valA, valB),
            };
        this.noUpdate = false;
      }
      setFocus(knob) {
        if (this.el.shadowRoot) {
          const knobEl = this.el.shadowRoot.querySelector(knob === 'A' ? '.range-knob-a' : '.range-knob-b');
          if (knobEl) {
            knobEl.focus();
          }
        }
      }
      render() {
        const { min, max, step, el, handleKeyboard, pressedKnob, disabled, pin, ratioLower, ratioUpper, inheritedAttributes, rangeId } = this;
        /**
         * Look for external label, ion-label, or aria-labelledby.
         * If none, see if user placed an aria-label on the host
         * and use that instead.
         */
        let { labelText } = getAriaLabel(el, rangeId);
        if (labelText === undefined || labelText === null) {
          labelText = inheritedAttributes['aria-label'];
        }
        const mode = getIonMode$1(this);
        const barStart = `${ratioLower * 100}%`;
        const barEnd = `${100 - ratioUpper * 100}%`;
        const doc = document;
        const isRTL = doc.dir === 'rtl';
        const start = isRTL ? 'right' : 'left';
        const end = isRTL ? 'left' : 'right';
        const tickStyle = tick => {
          return {
            [start]: tick[start],
          };
        };
        const barStyle = {
          [start]: barStart,
          [end]: barEnd,
        };
        const ticks = [];
        if (this.snaps && this.ticks) {
          for (let value = min; value <= max; value += step) {
            const ratio = valueToRatio(value, min, max);
            const tick = {
              ratio,
              active: ratio >= ratioLower && ratio <= ratioUpper,
            };
            tick[start] = `${ratio * 100}%`;
            ticks.push(tick);
          }
        }
        renderHiddenInput(true, el, this.name, JSON.stringify(this.getValue()), disabled);
        return hAsync(
          Host,
          {
            onFocusin: this.onFocus,
            onFocusout: this.onBlur,
            id: rangeId,
            class: createColorClasses$1(this.color, {
              [mode]: true,
              'in-item': hostContext('ion-item', el),
              'range-disabled': disabled,
              'range-pressed': pressedKnob !== undefined,
              'range-has-pin': pin,
            }),
          },
          hAsync('slot', { name: 'start' }),
          hAsync(
            'div',
            { class: 'range-slider', ref: rangeEl => (this.rangeSlider = rangeEl) },
            ticks.map(tick =>
              hAsync('div', {
                style: tickStyle(tick),
                role: 'presentation',
                class: {
                  'range-tick': true,
                  'range-tick-active': tick.active,
                },
                part: tick.active ? 'tick-active' : 'tick',
              }),
            ),
            hAsync('div', { class: 'range-bar', role: 'presentation', part: 'bar' }),
            hAsync('div', { class: 'range-bar range-bar-active', role: 'presentation', style: barStyle, part: 'bar-active' }),
            renderKnob(isRTL, {
              knob: 'A',
              pressed: pressedKnob === 'A',
              value: this.valA,
              ratio: this.ratioA,
              pin,
              disabled,
              handleKeyboard,
              min,
              max,
              labelText,
            }),
            this.dualKnobs &&
              renderKnob(isRTL, {
                knob: 'B',
                pressed: pressedKnob === 'B',
                value: this.valB,
                ratio: this.ratioB,
                pin,
                disabled,
                handleKeyboard,
                min,
                max,
                labelText,
              }),
          ),
          hAsync('slot', { name: 'end' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          debounce: ['debounceChanged'],
          min: ['minChanged'],
          max: ['maxChanged'],
          disabled: ['disabledChanged'],
          value: ['valueChanged'],
        };
      }
      static get style() {
        return {
          ios: rangeIosCss,
          md: rangeMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-range',
          $members$: {
            color: [513],
            debounce: [2],
            name: [1],
            dualKnobs: [4, 'dual-knobs'],
            min: [2],
            max: [2],
            pin: [4],
            snaps: [4],
            step: [2],
            ticks: [4],
            disabled: [4],
            value: [1026],
            ratioA: [32],
            ratioB: [32],
            pressedKnob: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }
    const renderKnob = (isRTL, { knob, value, ratio, min, max, disabled, pressed, pin, handleKeyboard, labelText }) => {
      const start = isRTL ? 'right' : 'left';
      const knobStyle = () => {
        const style = {};
        style[start] = `${ratio * 100}%`;
        return style;
      };
      return hAsync(
        'div',
        {
          'onKeyDown': ev => {
            const key = ev.key;
            if (key === 'ArrowLeft' || key === 'ArrowDown') {
              handleKeyboard(knob, false);
              ev.preventDefault();
              ev.stopPropagation();
            } else if (key === 'ArrowRight' || key === 'ArrowUp') {
              handleKeyboard(knob, true);
              ev.preventDefault();
              ev.stopPropagation();
            }
          },
          'class': {
            'range-knob-handle': true,
            'range-knob-a': knob === 'A',
            'range-knob-b': knob === 'B',
            'range-knob-pressed': pressed,
            'range-knob-min': value === min,
            'range-knob-max': value === max,
          },
          'style': knobStyle(),
          'role': 'slider',
          'tabindex': disabled ? -1 : 0,
          'aria-label': labelText,
          'aria-valuemin': min,
          'aria-valuemax': max,
          'aria-disabled': disabled ? 'true' : null,
          'aria-valuenow': value,
        },
        pin && hAsync('div', { class: 'range-pin', role: 'presentation', part: 'pin' }, Math.round(value)),
        hAsync('div', { class: 'range-knob', role: 'presentation', part: 'knob' }),
      );
    };
    const ratioToValue = (ratio, min, max, step) => {
      let value = (max - min) * ratio;
      if (step > 0) {
        value = Math.round(value / step) * step + min;
      }
      return clamp(min, value, max);
    };
    const valueToRatio = (value, min, max) => {
      return clamp(0, (value - min) / (max - min), 1);
    };
    let rangeIds = 0;

    const getRefresherAnimationType = contentEl => {
      const previousSibling = contentEl.previousElementSibling;
      const hasHeader = previousSibling !== null && previousSibling.tagName === 'ION-HEADER';
      return hasHeader ? 'translate' : 'scale';
    };
    const createPullingAnimation = (type, pullingSpinner, refresherEl) => {
      return type === 'scale' ? createScaleAnimation(pullingSpinner, refresherEl) : createTranslateAnimation(pullingSpinner, refresherEl);
    };
    const createBaseAnimation = pullingRefresherIcon => {
      const spinner = pullingRefresherIcon.querySelector('ion-spinner');
      const circle = spinner.shadowRoot.querySelector('circle');
      const spinnerArrowContainer = pullingRefresherIcon.querySelector('.spinner-arrow-container');
      const arrowContainer = pullingRefresherIcon.querySelector('.arrow-container');
      const arrow = arrowContainer ? arrowContainer.querySelector('ion-icon') : null;
      const baseAnimation = createAnimation().duration(1000).easing('ease-out');
      const spinnerArrowContainerAnimation = createAnimation()
        .addElement(spinnerArrowContainer)
        .keyframes([
          { offset: 0, opacity: '0.3' },
          { offset: 0.45, opacity: '0.3' },
          { offset: 0.55, opacity: '1' },
          { offset: 1, opacity: '1' },
        ]);
      const circleInnerAnimation = createAnimation()
        .addElement(circle)
        .keyframes([
          { offset: 0, strokeDasharray: '1px, 200px' },
          { offset: 0.2, strokeDasharray: '1px, 200px' },
          { offset: 0.55, strokeDasharray: '100px, 200px' },
          { offset: 1, strokeDasharray: '100px, 200px' },
        ]);
      const circleOuterAnimation = createAnimation()
        .addElement(spinner)
        .keyframes([
          { offset: 0, transform: 'rotate(-90deg)' },
          { offset: 1, transform: 'rotate(210deg)' },
        ]);
      /**
       * Only add arrow animation if present
       * this allows users to customize the spinners
       * without errors being thrown
       */
      if (arrowContainer && arrow) {
        const arrowContainerAnimation = createAnimation()
          .addElement(arrowContainer)
          .keyframes([
            { offset: 0, transform: 'rotate(0deg)' },
            { offset: 0.3, transform: 'rotate(0deg)' },
            { offset: 0.55, transform: 'rotate(280deg)' },
            { offset: 1, transform: 'rotate(400deg)' },
          ]);
        const arrowAnimation = createAnimation()
          .addElement(arrow)
          .keyframes([
            { offset: 0, transform: 'translateX(2px) scale(0)' },
            { offset: 0.3, transform: 'translateX(2px) scale(0)' },
            { offset: 0.55, transform: 'translateX(-1.5px) scale(1)' },
            { offset: 1, transform: 'translateX(-1.5px) scale(1)' },
          ]);
        baseAnimation.addAnimation([arrowContainerAnimation, arrowAnimation]);
      }
      return baseAnimation.addAnimation([spinnerArrowContainerAnimation, circleInnerAnimation, circleOuterAnimation]);
    };
    const createScaleAnimation = (pullingRefresherIcon, refresherEl) => {
      /**
       * Do not take the height of the refresher icon
       * because at this point the DOM has not updated,
       * so the refresher icon is still hidden with
       * display: none.
       * The `ion-refresher` container height
       * is roughly the amount we need to offset
       * the icon by when pulling down.
       */
      const height = refresherEl.clientHeight;
      const spinnerAnimation = createAnimation()
        .addElement(pullingRefresherIcon)
        .keyframes([
          { offset: 0, transform: `scale(0) translateY(-${height}px)` },
          { offset: 1, transform: 'scale(1) translateY(100px)' },
        ]);
      return createBaseAnimation(pullingRefresherIcon).addAnimation([spinnerAnimation]);
    };
    const createTranslateAnimation = (pullingRefresherIcon, refresherEl) => {
      /**
       * Do not take the height of the refresher icon
       * because at this point the DOM has not updated,
       * so the refresher icon is still hidden with
       * display: none.
       * The `ion-refresher` container height
       * is roughly the amount we need to offset
       * the icon by when pulling down.
       */
      const height = refresherEl.clientHeight;
      const spinnerAnimation = createAnimation()
        .addElement(pullingRefresherIcon)
        .keyframes([
          { offset: 0, transform: `translateY(-${height}px)` },
          { offset: 1, transform: 'translateY(100px)' },
        ]);
      return createBaseAnimation(pullingRefresherIcon).addAnimation([spinnerAnimation]);
    };
    const createSnapBackAnimation = pullingRefresherIcon => {
      return createAnimation().duration(125).addElement(pullingRefresherIcon).fromTo('transform', 'translateY(var(--ion-pulling-refresher-translate, 100px))', 'translateY(0px)');
    };
    // iOS Native Refresher
    // -----------------------------
    const setSpinnerOpacity = (spinner, opacity) => {
      spinner.style.setProperty('opacity', opacity.toString());
    };
    const handleScrollWhilePulling = (spinner, ticks, opacity, currentTickToShow) => {
      writeTask(() => {
        setSpinnerOpacity(spinner, opacity);
        ticks.forEach((el, i) => el.style.setProperty('opacity', i <= currentTickToShow ? '0.99' : '0'));
      });
    };
    const handleScrollWhileRefreshing = (spinner, lastVelocityY) => {
      writeTask(() => {
        // If user pulls down quickly, the spinner should spin faster
        spinner.style.setProperty('--refreshing-rotation-duration', lastVelocityY >= 1.0 ? '0.5s' : '2s');
        spinner.style.setProperty('opacity', '1');
      });
    };
    const translateElement = (el, value) => {
      if (!el) {
        return Promise.resolve();
      }
      const trans = transitionEndAsync(el, 200);
      writeTask(() => {
        el.style.setProperty('transition', '0.2s all ease-out');
        if (value === undefined) {
          el.style.removeProperty('transform');
        } else {
          el.style.setProperty('transform', `translate3d(0px, ${value}, 0px)`);
        }
      });
      return trans;
    };
    // Utils
    // -----------------------------
    const shouldUseNativeRefresher = async (referenceEl, mode) => {
      const refresherContent = referenceEl.querySelector('ion-refresher-content');
      if (!refresherContent) {
        return Promise.resolve(false);
      }
      await new Promise(resolve => componentOnReady(refresherContent, resolve));
      const pullingSpinner = referenceEl.querySelector('ion-refresher-content .refresher-pulling ion-spinner');
      const refreshingSpinner = referenceEl.querySelector('ion-refresher-content .refresher-refreshing ion-spinner');
      return (
        pullingSpinner !== null &&
        refreshingSpinner !== null &&
        ((mode === 'ios' && isPlatform('mobile') && referenceEl.style.webkitOverflowScrolling !== undefined) || mode === 'md')
      );
    };
    const transitionEndAsync = (el, expectedDuration = 0) => {
      return new Promise(resolve => {
        transitionEnd$2(el, expectedDuration, resolve);
      });
    };
    const transitionEnd$2 = (el, expectedDuration = 0, callback) => {
      let unRegTrans;
      let animationTimeout;
      const opts = { passive: true };
      const ANIMATION_FALLBACK_TIMEOUT = 500;
      const unregister = () => {
        if (unRegTrans) {
          unRegTrans();
        }
      };
      const onTransitionEnd = ev => {
        if (ev === undefined || el === ev.target) {
          unregister();
          callback(ev);
        }
      };
      if (el) {
        el.addEventListener('webkitTransitionEnd', onTransitionEnd, opts);
        el.addEventListener('transitionend', onTransitionEnd, opts);
        animationTimeout = setTimeout(onTransitionEnd, expectedDuration + ANIMATION_FALLBACK_TIMEOUT);
        unRegTrans = () => {
          if (animationTimeout) {
            clearTimeout(animationTimeout);
            animationTimeout = undefined;
          }
          el.removeEventListener('webkitTransitionEnd', onTransitionEnd, opts);
          el.removeEventListener('transitionend', onTransitionEnd, opts);
        };
      }
      return unregister;
    };

    const refresherIosCss =
      'ion-refresher{left:0;top:0;display:none;position:absolute;width:100%;height:60px;pointer-events:none;z-index:-1}[dir=rtl] ion-refresher,:host-context([dir=rtl]) ion-refresher{left:unset;right:unset;right:0}ion-refresher.refresher-active{display:block}ion-refresher-content{display:flex;flex-direction:column;justify-content:center;height:100%}.refresher-pulling,.refresher-refreshing{display:none;width:100%}.refresher-pulling-icon,.refresher-refreshing-icon{transform-origin:center;transition:200ms;font-size:30px;text-align:center}[dir=rtl] .refresher-pulling-icon,:host-context([dir=rtl]) .refresher-pulling-icon,[dir=rtl] .refresher-refreshing-icon,:host-context([dir=rtl]) .refresher-refreshing-icon{transform-origin:calc(100% - center)}.refresher-pulling-text,.refresher-refreshing-text{font-size:16px;text-align:center}ion-refresher-content .arrow-container{display:none}.refresher-pulling ion-refresher-content .refresher-pulling{display:block}.refresher-ready ion-refresher-content .refresher-pulling{display:block}.refresher-ready ion-refresher-content .refresher-pulling-icon{transform:rotate(180deg)}.refresher-refreshing ion-refresher-content .refresher-refreshing{display:block}.refresher-cancelling ion-refresher-content .refresher-pulling{display:block}.refresher-cancelling ion-refresher-content .refresher-pulling-icon{transform:scale(0)}.refresher-completing ion-refresher-content .refresher-refreshing{display:block}.refresher-completing ion-refresher-content .refresher-refreshing-icon{transform:scale(0)}.refresher-native .refresher-pulling-text,.refresher-native .refresher-refreshing-text{display:none}.refresher-ios .refresher-pulling-icon,.refresher-ios .refresher-refreshing-icon{color:var(--ion-text-color, #000)}.refresher-ios .refresher-pulling-text,.refresher-ios .refresher-refreshing-text{color:var(--ion-text-color, #000)}.refresher-ios .refresher-refreshing .spinner-lines-ios line,.refresher-ios .refresher-refreshing .spinner-lines-small-ios line,.refresher-ios .refresher-refreshing .spinner-crescent circle{stroke:var(--ion-text-color, #000)}.refresher-ios .refresher-refreshing .spinner-bubbles circle,.refresher-ios .refresher-refreshing .spinner-circles circle,.refresher-ios .refresher-refreshing .spinner-dots circle{fill:var(--ion-text-color, #000)}ion-refresher.refresher-native{display:block;z-index:1}ion-refresher.refresher-native ion-spinner{margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){ion-refresher.refresher-native ion-spinner{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}.refresher-native .refresher-refreshing ion-spinner{--refreshing-rotation-duration:2s;display:none;animation:var(--refreshing-rotation-duration) ease-out refresher-rotate forwards}.refresher-native .refresher-refreshing{display:none;animation:250ms linear refresher-pop forwards}.refresher-native.refresher-refreshing .refresher-pulling ion-spinner,.refresher-native.refresher-completing .refresher-pulling ion-spinner{display:none}.refresher-native.refresher-refreshing .refresher-refreshing ion-spinner,.refresher-native.refresher-completing .refresher-refreshing ion-spinner{display:block}.refresher-native.refresher-pulling .refresher-pulling ion-spinner{display:block}.refresher-native.refresher-pulling .refresher-refreshing ion-spinner{display:none}@keyframes refresher-pop{0%{transform:scale(1);animation-timing-function:ease-in}50%{transform:scale(1.2);animation-timing-function:ease-out}100%{transform:scale(1)}}@keyframes refresher-rotate{from{transform:rotate(0deg)}to{transform:rotate(180deg)}}';

    const refresherMdCss =
      'ion-refresher{left:0;top:0;display:none;position:absolute;width:100%;height:60px;pointer-events:none;z-index:-1}[dir=rtl] ion-refresher,:host-context([dir=rtl]) ion-refresher{left:unset;right:unset;right:0}ion-refresher.refresher-active{display:block}ion-refresher-content{display:flex;flex-direction:column;justify-content:center;height:100%}.refresher-pulling,.refresher-refreshing{display:none;width:100%}.refresher-pulling-icon,.refresher-refreshing-icon{transform-origin:center;transition:200ms;font-size:30px;text-align:center}[dir=rtl] .refresher-pulling-icon,:host-context([dir=rtl]) .refresher-pulling-icon,[dir=rtl] .refresher-refreshing-icon,:host-context([dir=rtl]) .refresher-refreshing-icon{transform-origin:calc(100% - center)}.refresher-pulling-text,.refresher-refreshing-text{font-size:16px;text-align:center}ion-refresher-content .arrow-container{display:none}.refresher-pulling ion-refresher-content .refresher-pulling{display:block}.refresher-ready ion-refresher-content .refresher-pulling{display:block}.refresher-ready ion-refresher-content .refresher-pulling-icon{transform:rotate(180deg)}.refresher-refreshing ion-refresher-content .refresher-refreshing{display:block}.refresher-cancelling ion-refresher-content .refresher-pulling{display:block}.refresher-cancelling ion-refresher-content .refresher-pulling-icon{transform:scale(0)}.refresher-completing ion-refresher-content .refresher-refreshing{display:block}.refresher-completing ion-refresher-content .refresher-refreshing-icon{transform:scale(0)}.refresher-native .refresher-pulling-text,.refresher-native .refresher-refreshing-text{display:none}.refresher-md .refresher-pulling-icon,.refresher-md .refresher-refreshing-icon{color:var(--ion-text-color, #000)}.refresher-md .refresher-pulling-text,.refresher-md .refresher-refreshing-text{color:var(--ion-text-color, #000)}.refresher-md .refresher-refreshing .spinner-lines-md line,.refresher-md .refresher-refreshing .spinner-lines-small-md line,.refresher-md .refresher-refreshing .spinner-crescent circle{stroke:var(--ion-text-color, #000)}.refresher-md .refresher-refreshing .spinner-bubbles circle,.refresher-md .refresher-refreshing .spinner-circles circle,.refresher-md .refresher-refreshing .spinner-dots circle{fill:var(--ion-text-color, #000)}ion-refresher.refresher-native{display:block;z-index:1}ion-refresher.refresher-native ion-spinner{margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;width:24px;height:24px;color:var(--ion-color-primary, #3880ff)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){ion-refresher.refresher-native ion-spinner{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}ion-refresher.refresher-native .spinner-arrow-container{display:inherit}ion-refresher.refresher-native .arrow-container{display:block;position:absolute;width:24px;height:24px}ion-refresher.refresher-native .arrow-container ion-icon{margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;left:0;right:0;bottom:-4px;position:absolute;color:var(--ion-color-primary, #3880ff);font-size:12px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){ion-refresher.refresher-native .arrow-container ion-icon{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}ion-refresher.refresher-native.refresher-pulling ion-refresher-content .refresher-pulling,ion-refresher.refresher-native.refresher-ready ion-refresher-content .refresher-pulling{display:flex}ion-refresher.refresher-native.refresher-refreshing ion-refresher-content .refresher-refreshing,ion-refresher.refresher-native.refresher-completing ion-refresher-content .refresher-refreshing,ion-refresher.refresher-native.refresher-cancelling ion-refresher-content .refresher-refreshing{display:flex}ion-refresher.refresher-native .refresher-pulling-icon{transform:translateY(calc(-100% - 10px))}ion-refresher.refresher-native .refresher-pulling-icon,ion-refresher.refresher-native .refresher-refreshing-icon{margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;border-radius:100%;padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:8px;display:flex;border:1px solid var(--ion-color-step-200, #ececec);background:var(--ion-color-step-250, #ffffff);box-shadow:0px 1px 6px rgba(0, 0, 0, 0.1)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){ion-refresher.refresher-native .refresher-pulling-icon,ion-refresher.refresher-native .refresher-refreshing-icon{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){ion-refresher.refresher-native .refresher-pulling-icon,ion-refresher.refresher-native .refresher-refreshing-icon{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px}}';

    class Refresher {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionRefresh = createEvent(this, 'ionRefresh', 7);
        this.ionPull = createEvent(this, 'ionPull', 7);
        this.ionStart = createEvent(this, 'ionStart', 7);
        this.appliedStyles = false;
        this.didStart = false;
        this.progress = 0;
        this.pointerDown = false;
        this.needsCompletion = false;
        this.didRefresh = false;
        this.lastVelocityY = 0;
        this.animations = [];
        this.nativeRefresher = false;
        /**
         * The current state which the refresher is in. The refresher's states include:
         *
         * - `inactive` - The refresher is not being pulled down or refreshing and is currently hidden.
         * - `pulling` - The user is actively pulling down the refresher, but has not reached the point yet that if the user lets go, it'll refresh.
         * - `cancelling` - The user pulled down the refresher and let go, but did not pull down far enough to kick off the `refreshing` state. After letting go, the refresher is in the `cancelling` state while it is closing, and will go back to the `inactive` state once closed.
         * - `ready` - The user has pulled down the refresher far enough that if they let go, it'll begin the `refreshing` state.
         * - `refreshing` - The refresher is actively waiting on the async operation to end. Once the refresh handler calls `complete()` it will begin the `completing` state.
         * - `completing` - The `refreshing` state has finished and the refresher is in the way of closing itself. Once closed, the refresher will go back to the `inactive` state.
         */
        this.state = 1 /* Inactive */;
        /**
         * The minimum distance the user must pull down until the
         * refresher will go into the `refreshing` state.
         * Does not apply when the refresher content uses a spinner,
         * enabling the native refresher.
         */
        this.pullMin = 60;
        /**
         * The maximum distance of the pull until the refresher
         * will automatically go into the `refreshing` state.
         * Defaults to the result of `pullMin + 60`.
         * Does not apply when  the refresher content uses a spinner,
         * enabling the native refresher.
         */
        this.pullMax = this.pullMin + 60;
        /**
         * Time it takes to close the refresher.
         * Does not apply when the refresher content uses a spinner,
         * enabling the native refresher.
         */
        this.closeDuration = '280ms';
        /**
         * Time it takes the refresher to snap back to the `refreshing` state.
         * Does not apply when the refresher content uses a spinner,
         * enabling the native refresher.
         */
        this.snapbackDuration = '280ms';
        /**
         * How much to multiply the pull speed by. To slow the pull animation down,
         * pass a number less than `1`. To speed up the pull, pass a number greater
         * than `1`. The default value is `1` which is equal to the speed of the cursor.
         * If a negative value is passed in, the factor will be `1` instead.
         *
         * For example: If the value passed is `1.2` and the content is dragged by
         * `10` pixels, instead of `10` pixels the content will be pulled by `12` pixels
         * (an increase of 20 percent). If the value passed is `0.8`, the dragged amount
         * will be `8` pixels, less than the amount the cursor has moved.
         *
         * Does not apply when the refresher content uses a spinner,
         * enabling the native refresher.
         */
        this.pullFactor = 1;
        /**
         * If `true`, the refresher will be hidden.
         */
        this.disabled = false;
      }
      disabledChanged() {
        if (this.gesture) {
          this.gesture.enable(!this.disabled);
        }
      }
      async checkNativeRefresher() {
        const useNativeRefresher = await shouldUseNativeRefresher(this.el, getIonMode$1(this));
        if (useNativeRefresher && !this.nativeRefresher) {
          const contentEl = this.el.closest('ion-content');
          this.setupNativeRefresher(contentEl);
        } else if (!useNativeRefresher) {
          this.destroyNativeRefresher();
        }
      }
      destroyNativeRefresher() {
        if (this.scrollEl && this.scrollListenerCallback) {
          this.scrollEl.removeEventListener('scroll', this.scrollListenerCallback);
          this.scrollListenerCallback = undefined;
        }
        this.nativeRefresher = false;
      }
      async resetNativeRefresher(el, state) {
        this.state = state;
        if (getIonMode$1(this) === 'ios') {
          await translateElement(el, undefined);
        } else {
          await transitionEndAsync(this.el.querySelector('.refresher-refreshing-icon'), 200);
        }
        this.didRefresh = false;
        this.needsCompletion = false;
        this.pointerDown = false;
        this.animations.forEach(ani => ani.destroy());
        this.animations = [];
        this.progress = 0;
        this.state = 1 /* Inactive */;
      }
      async setupiOSNativeRefresher(pullingSpinner, refreshingSpinner) {
        this.elementToTransform = this.scrollEl;
        const ticks = pullingSpinner.shadowRoot.querySelectorAll('svg');
        let MAX_PULL = this.scrollEl.clientHeight * 0.16;
        const NUM_TICKS = ticks.length;
        writeTask(() => ticks.forEach(el => el.style.setProperty('animation', 'none')));
        this.scrollListenerCallback = () => {
          // If pointer is not on screen or refresher is not active, ignore scroll
          if (!this.pointerDown && this.state === 1 /* Inactive */) {
            return;
          }
          readTask(() => {
            // PTR should only be active when overflow scrolling at the top
            const scrollTop = this.scrollEl.scrollTop;
            const refresherHeight = this.el.clientHeight;
            if (scrollTop > 0) {
              /**
               * If refresher is refreshing and user tries to scroll
               * progressively fade refresher out/in
               */
              if (this.state === 8 /* Refreshing */) {
                const ratio = clamp(0, scrollTop / (refresherHeight * 0.5), 1);
                writeTask(() => setSpinnerOpacity(refreshingSpinner, 1 - ratio));
                return;
              }
              writeTask(() => setSpinnerOpacity(pullingSpinner, 0));
              return;
            }
            if (this.pointerDown) {
              if (!this.didStart) {
                this.didStart = true;
                this.ionStart.emit();
              }
              // emit "pulling" on every move
              if (this.pointerDown) {
                this.ionPull.emit();
              }
            }
            // delay showing the next tick marks until user has pulled 30px
            const opacity = clamp(0, Math.abs(scrollTop) / refresherHeight, 0.99);
            const pullAmount = (this.progress = clamp(0, (Math.abs(scrollTop) - 30) / MAX_PULL, 1));
            const currentTickToShow = clamp(0, Math.floor(pullAmount * NUM_TICKS), NUM_TICKS - 1);
            const shouldShowRefreshingSpinner = this.state === 8 /* Refreshing */ || currentTickToShow === NUM_TICKS - 1;
            if (shouldShowRefreshingSpinner) {
              if (this.pointerDown) {
                handleScrollWhileRefreshing(refreshingSpinner, this.lastVelocityY);
              }
              if (!this.didRefresh) {
                this.beginRefresh();
                this.didRefresh = true;
                hapticImpact({ style: 'light' });
                /**
                 * Translate the content element otherwise when pointer is removed
                 * from screen the scroll content will bounce back over the refresher
                 */
                if (!this.pointerDown) {
                  translateElement(this.elementToTransform, `${refresherHeight}px`);
                }
              }
            } else {
              this.state = 2 /* Pulling */;
              handleScrollWhilePulling(pullingSpinner, ticks, opacity, currentTickToShow);
            }
          });
        };
        this.scrollEl.addEventListener('scroll', this.scrollListenerCallback);
        this.gesture = (
          await Promise.resolve().then(function () {
            return index$2;
          })
        ).createGesture({
          el: this.scrollEl,
          gestureName: 'refresher',
          gesturePriority: 31,
          direction: 'y',
          threshold: 5,
          onStart: () => {
            this.pointerDown = true;
            if (!this.didRefresh) {
              translateElement(this.elementToTransform, '0px');
            }
            /**
             * If the content had `display: none` when
             * the refresher was initialized, its clientHeight
             * will be 0. When the gesture starts, the content
             * will be visible, so try to get the correct
             * client height again. This is most common when
             * using the refresher in an ion-menu.
             */
            if (MAX_PULL === 0) {
              MAX_PULL = this.scrollEl.clientHeight * 0.16;
            }
          },
          onMove: ev => {
            this.lastVelocityY = ev.velocityY;
          },
          onEnd: () => {
            this.pointerDown = false;
            this.didStart = false;
            if (this.needsCompletion) {
              this.resetNativeRefresher(this.elementToTransform, 32 /* Completing */);
              this.needsCompletion = false;
            } else if (this.didRefresh) {
              readTask(() => translateElement(this.elementToTransform, `${this.el.clientHeight}px`));
            }
          },
        });
        this.disabledChanged();
      }
      async setupMDNativeRefresher(contentEl, pullingSpinner, refreshingSpinner) {
        const circle = getElementRoot(pullingSpinner).querySelector('circle');
        const pullingRefresherIcon = this.el.querySelector('ion-refresher-content .refresher-pulling-icon');
        const refreshingCircle = getElementRoot(refreshingSpinner).querySelector('circle');
        if (circle !== null && refreshingCircle !== null) {
          writeTask(() => {
            circle.style.setProperty('animation', 'none');
            // This lines up the animation on the refreshing spinner with the pulling spinner
            refreshingSpinner.style.setProperty('animation-delay', '-655ms');
            refreshingCircle.style.setProperty('animation-delay', '-655ms');
          });
        }
        this.gesture = (
          await Promise.resolve().then(function () {
            return index$2;
          })
        ).createGesture({
          el: this.scrollEl,
          gestureName: 'refresher',
          gesturePriority: 31,
          direction: 'y',
          threshold: 5,
          canStart: () => this.state !== 8 /* Refreshing */ && this.state !== 32 /* Completing */ && this.scrollEl.scrollTop === 0,
          onStart: ev => {
            ev.data = { animation: undefined, didStart: false, cancelled: false };
          },
          onMove: ev => {
            if ((ev.velocityY < 0 && this.progress === 0 && !ev.data.didStart) || ev.data.cancelled) {
              ev.data.cancelled = true;
              return;
            }
            if (!ev.data.didStart) {
              ev.data.didStart = true;
              this.state = 2 /* Pulling */;
              writeTask(() => this.scrollEl.style.setProperty('--overflow', 'hidden'));
              const animationType = getRefresherAnimationType(contentEl);
              const animation = createPullingAnimation(animationType, pullingRefresherIcon, this.el);
              ev.data.animation = animation;
              animation.progressStart(false, 0);
              this.ionStart.emit();
              this.animations.push(animation);
              return;
            }
            // Since we are using an easing curve, slow the gesture tracking down a bit
            this.progress = clamp(0, (ev.deltaY / 180) * 0.5, 1);
            ev.data.animation.progressStep(this.progress);
            this.ionPull.emit();
          },
          onEnd: ev => {
            if (!ev.data.didStart) {
              return;
            }
            writeTask(() => this.scrollEl.style.removeProperty('--overflow'));
            if (this.progress <= 0.4) {
              this.gesture.enable(false);
              ev.data.animation.progressEnd(0, this.progress, 500).onFinish(() => {
                this.animations.forEach(ani => ani.destroy());
                this.animations = [];
                this.gesture.enable(true);
                this.state = 1 /* Inactive */;
              });
              return;
            }
            const progress = getTimeGivenProgression([0, 0], [0, 0], [1, 1], [1, 1], this.progress)[0];
            const snapBackAnimation = createSnapBackAnimation(pullingRefresherIcon);
            this.animations.push(snapBackAnimation);
            writeTask(async () => {
              pullingRefresherIcon.style.setProperty('--ion-pulling-refresher-translate', `${progress * 100}px`);
              ev.data.animation.progressEnd();
              await snapBackAnimation.play();
              this.beginRefresh();
              ev.data.animation.destroy();
            });
          },
        });
        this.disabledChanged();
      }
      async setupNativeRefresher(contentEl) {
        if (this.scrollListenerCallback || !contentEl || this.nativeRefresher || !this.scrollEl) {
          return;
        }
        /**
         * If using non-native refresher before make sure
         * we clean up any old CSS. This can happen when
         * a user manually calls the refresh method in a
         * component create callback before the native
         * refresher is setup.
         */
        this.setCss(0, '', false, '');
        this.nativeRefresher = true;
        const pullingSpinner = this.el.querySelector('ion-refresher-content .refresher-pulling ion-spinner');
        const refreshingSpinner = this.el.querySelector('ion-refresher-content .refresher-refreshing ion-spinner');
        if (getIonMode$1(this) === 'ios') {
          this.setupiOSNativeRefresher(pullingSpinner, refreshingSpinner);
        } else {
          this.setupMDNativeRefresher(contentEl, pullingSpinner, refreshingSpinner);
        }
      }
      componentDidUpdate() {
        this.checkNativeRefresher();
      }
      async connectedCallback() {
        if (this.el.getAttribute('slot') !== 'fixed') {
          console.error('Make sure you use: <ion-refresher slot="fixed">');
          return;
        }
        const contentEl = this.el.closest('ion-content');
        if (!contentEl) {
          console.error('<ion-refresher> must be used inside an <ion-content>');
          return;
        }
        await new Promise(resolve => componentOnReady(contentEl, resolve));
        this.scrollEl = await contentEl.getScrollElement();
        this.backgroundContentEl = getElementRoot(contentEl).querySelector('#background-content');
        if (await shouldUseNativeRefresher(this.el, getIonMode$1(this))) {
          this.setupNativeRefresher(contentEl);
        } else {
          this.gesture = (
            await Promise.resolve().then(function () {
              return index$2;
            })
          ).createGesture({
            el: contentEl,
            gestureName: 'refresher',
            gesturePriority: 31,
            direction: 'y',
            threshold: 20,
            passive: false,
            canStart: () => this.canStart(),
            onStart: () => this.onStart(),
            onMove: ev => this.onMove(ev),
            onEnd: () => this.onEnd(),
          });
          this.disabledChanged();
        }
      }
      disconnectedCallback() {
        this.destroyNativeRefresher();
        this.scrollEl = undefined;
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
      }
      /**
       * Call `complete()` when your async operation has completed.
       * For example, the `refreshing` state is while the app is performing
       * an asynchronous operation, such as receiving more data from an
       * AJAX request. Once the data has been received, you then call this
       * method to signify that the refreshing has completed and to close
       * the refresher. This method also changes the refresher's state from
       * `refreshing` to `completing`.
       */
      async complete() {
        if (this.nativeRefresher) {
          this.needsCompletion = true;
          // Do not reset scroll el until user removes pointer from screen
          if (!this.pointerDown) {
            raf(() => raf(() => this.resetNativeRefresher(this.elementToTransform, 32 /* Completing */)));
          }
        } else {
          this.close(32 /* Completing */, '120ms');
        }
      }
      /**
       * Changes the refresher's state from `refreshing` to `cancelling`.
       */
      async cancel() {
        if (this.nativeRefresher) {
          // Do not reset scroll el until user removes pointer from screen
          if (!this.pointerDown) {
            raf(() => raf(() => this.resetNativeRefresher(this.elementToTransform, 16 /* Cancelling */)));
          }
        } else {
          this.close(16 /* Cancelling */, '');
        }
      }
      /**
       * A number representing how far down the user has pulled.
       * The number `0` represents the user hasn't pulled down at all. The
       * number `1`, and anything greater than `1`, represents that the user
       * has pulled far enough down that when they let go then the refresh will
       * happen. If they let go and the number is less than `1`, then the
       * refresh will not happen, and the content will return to it's original
       * position.
       */
      getProgress() {
        return Promise.resolve(this.progress);
      }
      canStart() {
        if (!this.scrollEl) {
          return false;
        }
        if (this.state !== 1 /* Inactive */) {
          return false;
        }
        // if the scrollTop is greater than zero then it's
        // not possible to pull the content down yet
        if (this.scrollEl.scrollTop > 0) {
          return false;
        }
        return true;
      }
      onStart() {
        this.progress = 0;
        this.state = 1 /* Inactive */;
      }
      onMove(detail) {
        if (!this.scrollEl) {
          return;
        }
        // this method can get called like a bazillion times per second,
        // so it's built to be as efficient as possible, and does its
        // best to do any DOM read/writes only when absolutely necessary
        // if multi-touch then get out immediately
        const ev = detail.event;
        if (ev.touches && ev.touches.length > 1) {
          return;
        }
        // do nothing if it's actively refreshing
        // or it's in the way of closing
        // or this was never a startY
        if ((this.state & 56) /* _BUSY_ */ !== 0) {
          return;
        }
        const pullFactor = Number.isNaN(this.pullFactor) || this.pullFactor < 0 ? 1 : this.pullFactor;
        const deltaY = detail.deltaY * pullFactor;
        // don't bother if they're scrolling up
        // and have not already started dragging
        if (deltaY <= 0) {
          // the current Y is higher than the starting Y
          // so they scrolled up enough to be ignored
          this.progress = 0;
          this.state = 1 /* Inactive */;
          if (this.appliedStyles) {
            // reset the styles only if they were applied
            this.setCss(0, '', false, '');
            return;
          }
          return;
        }
        if (this.state === 1 /* Inactive */) {
          // this refresh is not already actively pulling down
          // get the content's scrollTop
          const scrollHostScrollTop = this.scrollEl.scrollTop;
          // if the scrollTop is greater than zero then it's
          // not possible to pull the content down yet
          if (scrollHostScrollTop > 0) {
            this.progress = 0;
            return;
          }
          // content scrolled all the way to the top, and dragging down
          this.state = 2 /* Pulling */;
        }
        // prevent native scroll events
        if (ev.cancelable) {
          ev.preventDefault();
        }
        // the refresher is actively pulling at this point
        // move the scroll element within the content element
        this.setCss(deltaY, '0ms', true, '');
        if (deltaY === 0) {
          // don't continue if there's no delta yet
          this.progress = 0;
          return;
        }
        const pullMin = this.pullMin;
        // set pull progress
        this.progress = deltaY / pullMin;
        // emit "start" if it hasn't started yet
        if (!this.didStart) {
          this.didStart = true;
          this.ionStart.emit();
        }
        // emit "pulling" on every move
        this.ionPull.emit();
        // do nothing if the delta is less than the pull threshold
        if (deltaY < pullMin) {
          // ensure it stays in the pulling state, cuz its not ready yet
          this.state = 2 /* Pulling */;
          return;
        }
        if (deltaY > this.pullMax) {
          // they pulled farther than the max, so kick off the refresh
          this.beginRefresh();
          return;
        }
        // pulled farther than the pull min!!
        // it is now in the `ready` state!!
        // if they let go then it'll refresh, kerpow!!
        this.state = 4 /* Ready */;
        return;
      }
      onEnd() {
        // only run in a zone when absolutely necessary
        if (this.state === 4 /* Ready */) {
          // they pulled down far enough, so it's ready to refresh
          this.beginRefresh();
        } else if (this.state === 2 /* Pulling */) {
          // they were pulling down, but didn't pull down far enough
          // set the content back to it's original location
          // and close the refresher
          // set that the refresh is actively cancelling
          this.cancel();
        }
      }
      beginRefresh() {
        // assumes we're already back in a zone
        // they pulled down far enough, so it's ready to refresh
        this.state = 8 /* Refreshing */;
        // place the content in a hangout position while it thinks
        this.setCss(this.pullMin, this.snapbackDuration, true, '');
        // emit "refresh" because it was pulled down far enough
        // and they let go to begin refreshing
        this.ionRefresh.emit({
          complete: this.complete.bind(this),
        });
      }
      close(state, delay) {
        // create fallback timer incase something goes wrong with transitionEnd event
        setTimeout(() => {
          this.state = 1 /* Inactive */;
          this.progress = 0;
          this.didStart = false;
          this.setCss(0, '0ms', false, '');
        }, 600);
        // reset set the styles on the scroll element
        // set that the refresh is actively cancelling/completing
        this.state = state;
        this.setCss(0, this.closeDuration, true, delay);
        // TODO: stop gesture
      }
      setCss(y, duration, overflowVisible, delay) {
        if (this.nativeRefresher) {
          return;
        }
        this.appliedStyles = y > 0;
        writeTask(() => {
          if (this.scrollEl && this.backgroundContentEl) {
            const scrollStyle = this.scrollEl.style;
            const backgroundStyle = this.backgroundContentEl.style;
            scrollStyle.transform = backgroundStyle.transform = y > 0 ? `translateY(${y}px) translateZ(0px)` : '';
            scrollStyle.transitionDuration = backgroundStyle.transitionDuration = duration;
            scrollStyle.transitionDelay = backgroundStyle.transitionDelay = delay;
            scrollStyle.overflow = overflowVisible ? 'hidden' : '';
          }
        });
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          slot: 'fixed',
          class: {
            [mode]: true,
            // Used internally for styling
            [`refresher-${mode}`]: true,
            'refresher-native': this.nativeRefresher,
            'refresher-active': this.state !== 1 /* Inactive */,
            'refresher-pulling': this.state === 2 /* Pulling */,
            'refresher-ready': this.state === 4 /* Ready */,
            'refresher-refreshing': this.state === 8 /* Refreshing */,
            'refresher-cancelling': this.state === 16 /* Cancelling */,
            'refresher-completing': this.state === 32 /* Completing */,
          },
        });
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          disabled: ['disabledChanged'],
        };
      }
      static get style() {
        return {
          ios: refresherIosCss,
          md: refresherMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 32,
          $tagName$: 'ion-refresher',
          $members$: {
            pullMin: [2, 'pull-min'],
            pullMax: [2, 'pull-max'],
            closeDuration: [1, 'close-duration'],
            snapbackDuration: [1, 'snapback-duration'],
            pullFactor: [2, 'pull-factor'],
            disabled: [4],
            nativeRefresher: [32],
            state: [32],
            complete: [64],
            cancel: [64],
            getProgress: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const spinners = {
      'bubbles': {
        dur: 1000,
        circles: 9,
        fn: (dur, index, total) => {
          const animationDelay = `${(dur * index) / total - dur}ms`;
          const angle = (2 * Math.PI * index) / total;
          return {
            r: 5,
            style: {
              'top': `${9 * Math.sin(angle)}px`,
              'left': `${9 * Math.cos(angle)}px`,
              'animation-delay': animationDelay,
            },
          };
        },
      },
      'circles': {
        dur: 1000,
        circles: 8,
        fn: (dur, index, total) => {
          const step = index / total;
          const animationDelay = `${dur * step - dur}ms`;
          const angle = 2 * Math.PI * step;
          return {
            r: 5,
            style: {
              'top': `${9 * Math.sin(angle)}px`,
              'left': `${9 * Math.cos(angle)}px`,
              'animation-delay': animationDelay,
            },
          };
        },
      },
      'circular': {
        dur: 1400,
        elmDuration: true,
        circles: 1,
        fn: () => {
          return {
            r: 20,
            cx: 48,
            cy: 48,
            fill: 'none',
            viewBox: '24 24 48 48',
            transform: 'translate(0,0)',
            style: {},
          };
        },
      },
      'crescent': {
        dur: 750,
        circles: 1,
        fn: () => {
          return {
            r: 26,
            style: {},
          };
        },
      },
      'dots': {
        dur: 750,
        circles: 3,
        fn: (_, index) => {
          const animationDelay = -(110 * index) + 'ms';
          return {
            r: 6,
            style: {
              'left': `${9 - 9 * index}px`,
              'animation-delay': animationDelay,
            },
          };
        },
      },
      'lines': {
        dur: 1000,
        lines: 12,
        fn: (dur, index, total) => {
          const transform = `rotate(${30 * index + (index < 6 ? 180 : -180)}deg)`;
          const animationDelay = `${(dur * index) / total - dur}ms`;
          return {
            y1: 17,
            y2: 29,
            style: {
              'transform': transform,
              'animation-delay': animationDelay,
            },
          };
        },
      },
      'lines-small': {
        dur: 1000,
        lines: 12,
        fn: (dur, index, total) => {
          const transform = `rotate(${30 * index + (index < 6 ? 180 : -180)}deg)`;
          const animationDelay = `${(dur * index) / total - dur}ms`;
          return {
            y1: 12,
            y2: 20,
            style: {
              'transform': transform,
              'animation-delay': animationDelay,
            },
          };
        },
      },
    };
    const SPINNERS = spinners;

    class RefresherContent {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      componentWillLoad() {
        if (this.pullingIcon === undefined) {
          const mode = getIonMode$1(this);
          const overflowRefresher = this.el.style.webkitOverflowScrolling !== undefined ? 'lines' : 'arrow-down';
          this.pullingIcon = config$2.get('refreshingIcon', mode === 'ios' && isPlatform('mobile') ? config$2.get('spinner', overflowRefresher) : 'circular');
        }
        if (this.refreshingSpinner === undefined) {
          const mode = getIonMode$1(this);
          this.refreshingSpinner = config$2.get('refreshingSpinner', config$2.get('spinner', mode === 'ios' ? 'lines' : 'circular'));
        }
      }
      render() {
        const pullingIcon = this.pullingIcon;
        const hasSpinner = pullingIcon != null && SPINNERS[pullingIcon] !== undefined;
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          { class: mode },
          hAsync(
            'div',
            { class: 'refresher-pulling' },
            this.pullingIcon &&
              hasSpinner &&
              hAsync(
                'div',
                { class: 'refresher-pulling-icon' },
                hAsync(
                  'div',
                  { class: 'spinner-arrow-container' },
                  hAsync('ion-spinner', { name: this.pullingIcon, paused: true }),
                  mode === 'md' && this.pullingIcon === 'circular' && hAsync('div', { class: 'arrow-container' }, hAsync('ion-icon', { name: 'caret-back-sharp' })),
                ),
              ),
            this.pullingIcon && !hasSpinner && hAsync('div', { class: 'refresher-pulling-icon' }, hAsync('ion-icon', { icon: this.pullingIcon, lazy: false })),
            this.pullingText && hAsync('div', { class: 'refresher-pulling-text', innerHTML: sanitizeDOMString(this.pullingText) }),
          ),
          hAsync(
            'div',
            { class: 'refresher-refreshing' },
            this.refreshingSpinner && hAsync('div', { class: 'refresher-refreshing-icon' }, hAsync('ion-spinner', { name: this.refreshingSpinner })),
            this.refreshingText && hAsync('div', { class: 'refresher-refreshing-text', innerHTML: sanitizeDOMString(this.refreshingText) }),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-refresher-content',
          $members$: {
            pullingIcon: [1025, 'pulling-icon'],
            pullingText: [1, 'pulling-text'],
            refreshingSpinner: [1025, 'refreshing-spinner'],
            refreshingText: [1, 'refreshing-text'],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const reorderIosCss =
      '/*!@:host([slot])*/[slot].sc-ion-reorder-ios-h{display:none;line-height:0;z-index:100}/*!@.reorder-icon*/.reorder-icon.sc-ion-reorder-ios{display:block;font-size:22px}/*!@.reorder-icon*/.reorder-icon.sc-ion-reorder-ios{font-size:34px;opacity:0.4}';

    const reorderMdCss =
      '/*!@:host([slot])*/[slot].sc-ion-reorder-md-h{display:none;line-height:0;z-index:100}/*!@.reorder-icon*/.reorder-icon.sc-ion-reorder-md{display:block;font-size:22px}/*!@.reorder-icon*/.reorder-icon.sc-ion-reorder-md{font-size:31px;opacity:0.3}';

    /**
     * @part icon - The icon of the reorder handle (uses ion-icon).
     */
    class Reorder {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      onClick(ev) {
        const reorderGroup = this.el.closest('ion-reorder-group');
        ev.preventDefault();
        // Only stop event propagation if the reorder is inside of an enabled
        // reorder group. This allows interaction with clickable children components.
        if (!reorderGroup || !reorderGroup.disabled) {
          ev.stopImmediatePropagation();
        }
      }
      render() {
        const mode = getIonMode$1(this);
        const reorderIcon = mode === 'ios' ? 'reorder-three-outline' : 'reorder-two-sharp';
        return hAsync(Host, { class: mode }, hAsync('slot', null, hAsync('ion-icon', { name: reorderIcon, lazy: false, class: 'reorder-icon', part: 'icon' })));
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: reorderIosCss,
          md: reorderMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-reorder',
          $members$: undefined,
          $listeners$: [[2, 'click', 'onClick']],
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const reorderGroupCss =
      '.reorder-list-active>*{transition:transform 300ms;will-change:transform}.reorder-enabled{user-select:none}.reorder-enabled ion-reorder{display:block;cursor:grab;pointer-events:all;touch-action:none}.reorder-selected,.reorder-selected ion-reorder{cursor:grabbing}.reorder-selected{position:relative;transition:none !important;box-shadow:0 0 10px rgba(0, 0, 0, 0.4);opacity:0.8;z-index:100}.reorder-visible ion-reorder .reorder-icon{transform:translate3d(0,  0,  0)}';

    class ReorderGroup {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionItemReorder = createEvent(this, 'ionItemReorder', 7);
        this.lastToIndex = -1;
        this.cachedHeights = [];
        this.scrollElTop = 0;
        this.scrollElBottom = 0;
        this.scrollElInitial = 0;
        this.containerTop = 0;
        this.containerBottom = 0;
        this.state = 0 /* Idle */;
        /**
         * If `true`, the reorder will be hidden.
         */
        this.disabled = true;
      }
      disabledChanged() {
        if (this.gesture) {
          this.gesture.enable(!this.disabled);
        }
      }
      async connectedCallback() {
        const contentEl = this.el.closest('ion-content');
        if (contentEl) {
          this.scrollEl = await contentEl.getScrollElement();
        }
        this.gesture = (
          await Promise.resolve().then(function () {
            return index$2;
          })
        ).createGesture({
          el: this.el,
          gestureName: 'reorder',
          gesturePriority: 110,
          threshold: 0,
          direction: 'y',
          passive: false,
          canStart: detail => this.canStart(detail),
          onStart: ev => this.onStart(ev),
          onMove: ev => this.onMove(ev),
          onEnd: () => this.onEnd(),
        });
        this.disabledChanged();
      }
      disconnectedCallback() {
        this.onEnd();
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
      }
      /**
       * Completes the reorder operation. Must be called by the `ionItemReorder` event.
       *
       * If a list of items is passed, the list will be reordered and returned in the
       * proper order.
       *
       * If no parameters are passed or if `true` is passed in, the reorder will complete
       * and the item will remain in the position it was dragged to. If `false` is passed,
       * the reorder will complete and the item will bounce back to its original position.
       *
       * @param listOrReorder A list of items to be sorted and returned in the new order or a
       * boolean of whether or not the reorder should reposition the item.
       */
      complete(listOrReorder) {
        return Promise.resolve(this.completeSync(listOrReorder));
      }
      canStart(ev) {
        if (this.selectedItemEl || this.state !== 0 /* Idle */) {
          return false;
        }
        const target = ev.event.target;
        const reorderEl = target.closest('ion-reorder');
        if (!reorderEl) {
          return false;
        }
        const item = findReorderItem(reorderEl, this.el);
        if (!item) {
          return false;
        }
        ev.data = item;
        return true;
      }
      onStart(ev) {
        ev.event.preventDefault();
        const item = (this.selectedItemEl = ev.data);
        const heights = this.cachedHeights;
        heights.length = 0;
        const el = this.el;
        const children = el.children;
        if (!children || children.length === 0) {
          return;
        }
        let sum = 0;
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          sum += child.offsetHeight;
          heights.push(sum);
          child.$ionIndex = i;
        }
        const box = el.getBoundingClientRect();
        this.containerTop = box.top;
        this.containerBottom = box.bottom;
        if (this.scrollEl) {
          const scrollBox = this.scrollEl.getBoundingClientRect();
          this.scrollElInitial = this.scrollEl.scrollTop;
          this.scrollElTop = scrollBox.top + AUTO_SCROLL_MARGIN;
          this.scrollElBottom = scrollBox.bottom - AUTO_SCROLL_MARGIN;
        } else {
          this.scrollElInitial = 0;
          this.scrollElTop = 0;
          this.scrollElBottom = 0;
        }
        this.lastToIndex = indexForItem(item);
        this.selectedItemHeight = item.offsetHeight;
        this.state = 1 /* Active */;
        item.classList.add(ITEM_REORDER_SELECTED);
        hapticSelectionStart();
      }
      onMove(ev) {
        const selectedItem = this.selectedItemEl;
        if (!selectedItem) {
          return;
        }
        // Scroll if we reach the scroll margins
        const scroll = this.autoscroll(ev.currentY);
        // // Get coordinate
        const top = this.containerTop - scroll;
        const bottom = this.containerBottom - scroll;
        const currentY = Math.max(top, Math.min(ev.currentY, bottom));
        const deltaY = scroll + currentY - ev.startY;
        const normalizedY = currentY - top;
        const toIndex = this.itemIndexForTop(normalizedY);
        if (toIndex !== this.lastToIndex) {
          const fromIndex = indexForItem(selectedItem);
          this.lastToIndex = toIndex;
          hapticSelectionChanged();
          this.reorderMove(fromIndex, toIndex);
        }
        // Update selected item position
        selectedItem.style.transform = `translateY(${deltaY}px)`;
      }
      onEnd() {
        const selectedItemEl = this.selectedItemEl;
        this.state = 2 /* Complete */;
        if (!selectedItemEl) {
          this.state = 0 /* Idle */;
          return;
        }
        const toIndex = this.lastToIndex;
        const fromIndex = indexForItem(selectedItemEl);
        if (toIndex === fromIndex) {
          this.completeSync();
        } else {
          this.ionItemReorder.emit({
            from: fromIndex,
            to: toIndex,
            complete: this.completeSync.bind(this),
          });
        }
        hapticSelectionEnd();
      }
      completeSync(listOrReorder) {
        const selectedItemEl = this.selectedItemEl;
        if (selectedItemEl && this.state === 2 /* Complete */) {
          const children = this.el.children;
          const len = children.length;
          const toIndex = this.lastToIndex;
          const fromIndex = indexForItem(selectedItemEl);
          if (toIndex !== fromIndex && (listOrReorder === undefined || listOrReorder === true)) {
            const ref = fromIndex < toIndex ? children[toIndex + 1] : children[toIndex];
            this.el.insertBefore(selectedItemEl, ref);
          }
          if (Array.isArray(listOrReorder)) {
            listOrReorder = reorderArray(listOrReorder, fromIndex, toIndex);
          }
          for (let i = 0; i < len; i++) {
            children[i].style['transform'] = '';
          }
          selectedItemEl.style.transition = '';
          selectedItemEl.classList.remove(ITEM_REORDER_SELECTED);
          this.selectedItemEl = undefined;
          this.state = 0 /* Idle */;
        }
        return listOrReorder;
      }
      itemIndexForTop(deltaY) {
        const heights = this.cachedHeights;
        // TODO: since heights is a sorted array of integers, we can do
        // speed up the search using binary search. Remember that linear-search is still
        // faster than binary-search for small arrays (<64) due CPU branch misprediction.
        for (let i = 0; i < heights.length; i++) {
          if (heights[i] > deltaY) {
            return i;
          }
        }
        return heights.length - 1;
      }
      /********* DOM WRITE ********* */
      reorderMove(fromIndex, toIndex) {
        const itemHeight = this.selectedItemHeight;
        const children = this.el.children;
        for (let i = 0; i < children.length; i++) {
          const style = children[i].style;
          let value = '';
          if (i > fromIndex && i <= toIndex) {
            value = `translateY(${-itemHeight}px)`;
          } else if (i < fromIndex && i >= toIndex) {
            value = `translateY(${itemHeight}px)`;
          }
          style['transform'] = value;
        }
      }
      autoscroll(posY) {
        if (!this.scrollEl) {
          return 0;
        }
        let amount = 0;
        if (posY < this.scrollElTop) {
          amount = -SCROLL_JUMP;
        } else if (posY > this.scrollElBottom) {
          amount = SCROLL_JUMP;
        }
        if (amount !== 0) {
          this.scrollEl.scrollBy(0, amount);
        }
        return this.scrollEl.scrollTop - this.scrollElInitial;
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          class: {
            [mode]: true,
            'reorder-enabled': !this.disabled,
            'reorder-list-active': this.state !== 0 /* Idle */,
          },
        });
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          disabled: ['disabledChanged'],
        };
      }
      static get style() {
        return reorderGroupCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-reorder-group',
          $members$: {
            disabled: [4],
            state: [32],
            complete: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const indexForItem = element => {
      return element['$ionIndex'];
    };
    const findReorderItem = (node, container) => {
      let parent;
      while (node) {
        parent = node.parentElement;
        if (parent === container) {
          return node;
        }
        node = parent;
      }
      return undefined;
    };
    const AUTO_SCROLL_MARGIN = 60;
    const SCROLL_JUMP = 10;
    const ITEM_REORDER_SELECTED = 'reorder-selected';
    const reorderArray = (array, from, to) => {
      const element = array[from];
      array.splice(from, 1);
      array.splice(to, 0, element);
      return array.slice();
    };

    const rippleEffectCss =
      '/*!@:host*/.sc-ion-ripple-effect-h{left:0;right:0;top:0;bottom:0;position:absolute;contain:strict;pointer-events:none}/*!@:host(.unbounded)*/.unbounded.sc-ion-ripple-effect-h{contain:layout size style}/*!@.ripple-effect*/.ripple-effect.sc-ion-ripple-effect{border-radius:50%;position:absolute;background-color:currentColor;color:inherit;contain:strict;opacity:0;animation:225ms rippleAnimation forwards, 75ms fadeInAnimation forwards;will-change:transform, opacity;pointer-events:none}/*!@.fade-out*/.fade-out.sc-ion-ripple-effect{transform:translate(var(--translate-end)) scale(var(--final-scale, 1));animation:150ms fadeOutAnimation forwards}@keyframes rippleAnimation{from{animation-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transform:scale(1)}to{transform:translate(var(--translate-end)) scale(var(--final-scale, 1))}}@keyframes fadeInAnimation{from{animation-timing-function:linear;opacity:0}to{opacity:0.16}}@keyframes fadeOutAnimation{from{animation-timing-function:linear;opacity:0.16}to{opacity:0}}';

    class RippleEffect {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * Sets the type of ripple-effect:
         *
         * - `bounded`: the ripple effect expands from the user's click position
         * - `unbounded`: the ripple effect expands from the center of the button and overflows the container.
         *
         * NOTE: Surfaces for bounded ripples should have the overflow property set to hidden,
         * while surfaces for unbounded ripples should have it set to visible.
         */
        this.type = 'bounded';
      }
      /**
       * Adds the ripple effect to the parent element.
       *
       * @param x The horizontal coordinate of where the ripple should start.
       * @param y The vertical coordinate of where the ripple should start.
       */
      async addRipple(x, y) {
        return new Promise(resolve => {
          readTask(() => {
            const rect = this.el.getBoundingClientRect();
            const width = rect.width;
            const height = rect.height;
            const hypotenuse = Math.sqrt(width * width + height * height);
            const maxDim = Math.max(height, width);
            const maxRadius = this.unbounded ? maxDim : hypotenuse + PADDING;
            const initialSize = Math.floor(maxDim * INITIAL_ORIGIN_SCALE);
            const finalScale = maxRadius / initialSize;
            let posX = x - rect.left;
            let posY = y - rect.top;
            if (this.unbounded) {
              posX = width * 0.5;
              posY = height * 0.5;
            }
            const styleX = posX - initialSize * 0.5;
            const styleY = posY - initialSize * 0.5;
            const moveX = width * 0.5 - posX;
            const moveY = height * 0.5 - posY;
            writeTask(() => {
              const div = document.createElement('div');
              div.classList.add('ripple-effect');
              const style = div.style;
              style.top = styleY + 'px';
              style.left = styleX + 'px';
              style.width = style.height = initialSize + 'px';
              style.setProperty('--final-scale', `${finalScale}`);
              style.setProperty('--translate-end', `${moveX}px, ${moveY}px`);
              const container = this.el.shadowRoot || this.el;
              container.appendChild(div);
              setTimeout(() => {
                resolve(() => {
                  removeRipple(div);
                });
              }, 225 + 100);
            });
          });
        });
      }
      get unbounded() {
        return this.type === 'unbounded';
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          role: 'presentation',
          class: {
            [mode]: true,
            unbounded: this.unbounded,
          },
        });
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return rippleEffectCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-ripple-effect',
          $members$: {
            type: [1],
            addRipple: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const removeRipple = ripple => {
      ripple.classList.add('fade-out');
      setTimeout(() => {
        ripple.remove();
      }, 200);
    };
    const PADDING = 10;
    const INITIAL_ORIGIN_SCALE = 0.5;

    class Route {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionRouteDataChanged = createEvent(this, 'ionRouteDataChanged', 7);
        /**
         * Relative path that needs to match in order for this route to apply.
         *
         * Accepts paths similar to expressjs so that you can define parameters
         * in the url /foo/:bar where bar would be available in incoming props.
         */
        this.url = '';
      }
      onUpdate(newValue) {
        this.ionRouteDataChanged.emit(newValue);
      }
      onComponentProps(newValue, oldValue) {
        if (newValue === oldValue) {
          return;
        }
        const keys1 = newValue ? Object.keys(newValue) : [];
        const keys2 = oldValue ? Object.keys(oldValue) : [];
        if (keys1.length !== keys2.length) {
          this.onUpdate(newValue);
          return;
        }
        for (const key of keys1) {
          if (newValue[key] !== oldValue[key]) {
            this.onUpdate(newValue);
            return;
          }
        }
      }
      connectedCallback() {
        this.ionRouteDataChanged.emit();
      }
      static get watchers() {
        return {
          url: ['onUpdate'],
          component: ['onUpdate'],
          componentProps: ['onComponentProps'],
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-route',
          $members$: {
            url: [1],
            component: [1],
            componentProps: [16],
            beforeLeave: [16],
            beforeEnter: [16],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    class RouteRedirect {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionRouteRedirectChanged = createEvent(this, 'ionRouteRedirectChanged', 7);
      }
      propDidChange() {
        this.ionRouteRedirectChanged.emit();
      }
      connectedCallback() {
        this.ionRouteRedirectChanged.emit();
      }
      static get watchers() {
        return {
          from: ['propDidChange'],
          to: ['propDidChange'],
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-route-redirect',
          $members$: {
            from: [1],
            to: [1],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const ROUTER_INTENT_NONE = 'root';
    const ROUTER_INTENT_FORWARD = 'forward';
    const ROUTER_INTENT_BACK = 'back';

    // Join the non empty segments with "/".
    const generatePath = segments => {
      const path = segments.filter(s => s.length > 0).join('/');
      return '/' + path;
    };
    const generateUrl = (segments, useHash, queryString) => {
      let url = generatePath(segments);
      if (useHash) {
        url = '#' + url;
      }
      if (queryString !== undefined) {
        url += '?' + queryString;
      }
      return url;
    };
    const writePath = (history, root, useHash, path, direction, state, queryString) => {
      const url = generateUrl([...parsePath(root).segments, ...path], useHash, queryString);
      if (direction === ROUTER_INTENT_FORWARD) {
        history.pushState(state, '', url);
      } else {
        history.replaceState(state, '', url);
      }
    };
    const chainToPath = chain => {
      const path = [];
      for (const route of chain) {
        for (const segment of route.path) {
          if (segment[0] === ':') {
            const param = route.params && route.params[segment.slice(1)];
            if (!param) {
              return null;
            }
            path.push(param);
          } else if (segment !== '') {
            path.push(segment);
          }
        }
      }
      return path;
    };
    // Remove the prefix segments from the path segments.
    //
    // Return:
    // - null when the path segments do not start with the passed prefix,
    // - the path segments after the prefix otherwise.
    const removePrefix = (prefix, path) => {
      if (prefix.length > path.length) {
        return null;
      }
      if (prefix.length <= 1 && prefix[0] === '') {
        return path;
      }
      for (let i = 0; i < prefix.length; i++) {
        if (prefix[i] !== path[i]) {
          return null;
        }
      }
      if (path.length === prefix.length) {
        return [''];
      }
      return path.slice(prefix.length);
    };
    const readPath = (loc, root, useHash) => {
      const prefix = parsePath(root).segments;
      const pathname = useHash ? loc.hash.slice(1) : loc.pathname;
      const path = parsePath(pathname).segments;
      return removePrefix(prefix, path);
    };
    // Parses the path to:
    // - segments an array of '/' separated parts,
    // - queryString (undefined when no query string).
    const parsePath = path => {
      let segments = [''];
      let queryString;
      if (path != null) {
        const qsStart = path.indexOf('?');
        if (qsStart > -1) {
          queryString = path.substr(qsStart + 1);
          path = path.substr(0, qsStart);
        }
        segments = path
          .split('/')
          .map(s => s.trim())
          .filter(s => s.length > 0);
        if (segments.length === 0) {
          segments = [''];
        }
      }
      return { segments, queryString };
    };

    const printRoutes = routes => {
      console.group(`[ion-core] ROUTES[${routes.length}]`);
      for (const chain of routes) {
        const path = [];
        chain.forEach(r => path.push(...r.path));
        const ids = chain.map(r => r.id);
        console.debug(`%c ${generatePath(path)}`, 'font-weight: bold; padding-left: 20px', '=>\t', `(${ids.join(', ')})`);
      }
      console.groupEnd();
    };
    const printRedirects = redirects => {
      console.group(`[ion-core] REDIRECTS[${redirects.length}]`);
      for (const redirect of redirects) {
        if (redirect.to) {
          console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to.segments)}`, 'font-weight: bold');
        }
      }
      console.groupEnd();
    };

    const writeNavState = async (root, chain, direction, index, changed = false, animation) => {
      try {
        // find next navigation outlet in the DOM
        const outlet = searchNavNode(root);
        // make sure we can continue interacting the DOM, otherwise abort
        if (index >= chain.length || !outlet) {
          return changed;
        }
        await new Promise(resolve => componentOnReady(outlet, resolve));
        const route = chain[index];
        const result = await outlet.setRouteId(route.id, route.params, direction, animation);
        // if the outlet changed the page, reset navigation to neutral (no direction)
        // this means nested outlets will not animate
        if (result.changed) {
          direction = ROUTER_INTENT_NONE;
          changed = true;
        }
        // recursively set nested outlets
        changed = await writeNavState(result.element, chain, direction, index + 1, changed, animation);
        // once all nested outlets are visible let's make the parent visible too,
        // using markVisible prevents flickering
        if (result.markVisible) {
          await result.markVisible();
        }
        return changed;
      } catch (e) {
        console.error(e);
        return false;
      }
    };
    const readNavState = async root => {
      const ids = [];
      let outlet;
      let node = root;
      // tslint:disable-next-line:no-constant-condition
      while (true) {
        outlet = searchNavNode(node);
        if (outlet) {
          const id = await outlet.getRouteId();
          if (id) {
            node = id.element;
            id.element = undefined;
            ids.push(id);
          } else {
            break;
          }
        } else {
          break;
        }
      }
      return { ids, outlet };
    };
    const waitUntilNavNode = () => {
      if (searchNavNode(document.body)) {
        return Promise.resolve();
      }
      return new Promise(resolve => {
        window.addEventListener('ionNavWillLoad', resolve, { once: true });
      });
    };
    const QUERY$1 = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';
    const searchNavNode = root => {
      if (!root) {
        return undefined;
      }
      if (root.matches(QUERY$1)) {
        return root;
      }
      const outlet = root.querySelector(QUERY$1);
      return outlet !== null && outlet !== void 0 ? outlet : undefined;
    };

    // Returns whether the given redirect matches the given path segments.
    //
    // A redirect matches when the segments of the path and redirect.from are equal.
    // Note that segments are only checked until redirect.from contains a '*' which matches any path segment.
    // The path ['some', 'path', 'to', 'page'] matches both ['some', 'path', 'to', 'page'] and ['some', 'path', '*'].
    const matchesRedirect = (path, redirect) => {
      const { from, to } = redirect;
      if (to === undefined) {
        return false;
      }
      if (from.length > path.length) {
        return false;
      }
      for (let i = 0; i < from.length; i++) {
        const expected = from[i];
        if (expected === '*') {
          return true;
        }
        if (expected !== path[i]) {
          return false;
        }
      }
      return from.length === path.length;
    };
    // Returns the first redirect matching the path segments or undefined when no match found.
    const findRouteRedirect = (path, redirects) => {
      return redirects.find(redirect => matchesRedirect(path, redirect));
    };
    const matchesIDs = (ids, chain) => {
      const len = Math.min(ids.length, chain.length);
      let i = 0;
      for (; i < len; i++) {
        if (ids[i].toLowerCase() !== chain[i].id) {
          break;
        }
      }
      return i;
    };
    const matchesPath = (inputPath, chain) => {
      const segments = new RouterSegments(inputPath);
      let matchesDefault = false;
      let allparams;
      for (let i = 0; i < chain.length; i++) {
        const path = chain[i].path;
        if (path[0] === '') {
          matchesDefault = true;
        } else {
          for (const segment of path) {
            const data = segments.next();
            // data param
            if (segment[0] === ':') {
              if (data === '') {
                return null;
              }
              allparams = allparams || [];
              const params = allparams[i] || (allparams[i] = {});
              params[segment.slice(1)] = data;
            } else if (data !== segment) {
              return null;
            }
          }
          matchesDefault = false;
        }
      }
      const matches = matchesDefault ? matchesDefault === (segments.next() === '') : true;
      if (!matches) {
        return null;
      }
      if (allparams) {
        return chain.map((route, i) => ({
          id: route.id,
          path: route.path,
          params: mergeParams(route.params, allparams[i]),
          beforeEnter: route.beforeEnter,
          beforeLeave: route.beforeLeave,
        }));
      }
      return chain;
    };
    // Merges the route parameter objects.
    // Returns undefined when both parameters are undefined.
    const mergeParams = (a, b) => {
      return a || b ? Object.assign(Object.assign({}, a), b) : undefined;
    };
    const routerIDsToChain = (ids, chains) => {
      let match = null;
      let maxMatches = 0;
      const plainIDs = ids.map(i => i.id);
      for (const chain of chains) {
        const score = matchesIDs(plainIDs, chain);
        if (score > maxMatches) {
          match = chain;
          maxMatches = score;
        }
      }
      if (match) {
        return match.map((route, i) => ({
          id: route.id,
          path: route.path,
          params: mergeParams(route.params, ids[i] && ids[i].params),
        }));
      }
      return null;
    };
    const routerPathToChain = (path, chains) => {
      let match = null;
      let matches = 0;
      for (const chain of chains) {
        const matchedChain = matchesPath(path, chain);
        if (matchedChain !== null) {
          const score = computePriority(matchedChain);
          if (score > matches) {
            matches = score;
            match = matchedChain;
          }
        }
      }
      return match;
    };
    const computePriority = chain => {
      let score = 1;
      let level = 1;
      for (const route of chain) {
        for (const path of route.path) {
          if (path[0] === ':') {
            score += Math.pow(1, level);
          } else if (path !== '') {
            score += Math.pow(2, level);
          }
          level++;
        }
      }
      return score;
    };
    class RouterSegments {
      constructor(path) {
        this.path = path.slice();
      }
      next() {
        if (this.path.length > 0) {
          return this.path.shift();
        }
        return '';
      }
    }

    const readProp = (el, prop) => {
      if (prop in el) {
        return el[prop];
      }
      if (el.hasAttribute(prop)) {
        return el.getAttribute(prop);
      }
      return null;
    };
    const readRedirects = root => {
      return Array.from(root.children)
        .filter(el => el.tagName === 'ION-ROUTE-REDIRECT')
        .map(el => {
          const to = readProp(el, 'to');
          return {
            from: parsePath(readProp(el, 'from')).segments,
            to: to == null ? undefined : parsePath(to),
          };
        });
    };
    const readRoutes = root => {
      return flattenRouterTree(readRouteNodes(root));
    };
    const readRouteNodes = node => {
      return Array.from(node.children)
        .filter(el => el.tagName === 'ION-ROUTE' && el.component)
        .map(el => {
          const component = readProp(el, 'component');
          return {
            path: parsePath(readProp(el, 'url')).segments,
            id: component.toLowerCase(),
            params: el.componentProps,
            beforeLeave: el.beforeLeave,
            beforeEnter: el.beforeEnter,
            children: readRouteNodes(el),
          };
        });
    };
    const flattenRouterTree = nodes => {
      const chains = [];
      for (const node of nodes) {
        flattenNode([], chains, node);
      }
      return chains;
    };
    const flattenNode = (chain, chains, node) => {
      chain = chain.slice();
      chain.push({
        id: node.id,
        path: node.path,
        params: node.params,
        beforeLeave: node.beforeLeave,
        beforeEnter: node.beforeEnter,
      });
      if (node.children.length === 0) {
        chains.push(chain);
        return;
      }
      for (const child of node.children) {
        flattenNode(chain, chains, child);
      }
    };

    class Router {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionRouteWillChange = createEvent(this, 'ionRouteWillChange', 7);
        this.ionRouteDidChange = createEvent(this, 'ionRouteDidChange', 7);
        this.previousPath = null;
        this.busy = false;
        this.state = 0;
        this.lastState = 0;
        /**
         * The root path to use when matching URLs. By default, this is set to "/", but you can specify
         * an alternate prefix for all URL paths.
         */
        this.root = '/';
        /**
         * The router can work in two "modes":
         * - With hash: `/index.html#/path/to/page`
         * - Without hash: `/path/to/page`
         *
         * Using one or another might depend in the requirements of your app and/or where it's deployed.
         *
         * Usually "hash-less" navigation works better for SEO and it's more user friendly too, but it might
         * requires additional server-side configuration in order to properly work.
         *
         * On the other side hash-navigation is much easier to deploy, it even works over the file protocol.
         *
         * By default, this property is `true`, change to `false` to allow hash-less URLs.
         */
        this.useHash = true;
      }
      async componentWillLoad() {
        await waitUntilNavNode();
        const canProceed = await this.runGuards(this.getPath());
        if (canProceed !== true) {
          if (typeof canProceed === 'object') {
            const { redirect } = canProceed;
            const path = parsePath(redirect);
            this.setPath(path.segments, ROUTER_INTENT_NONE, path.queryString);
            await this.writeNavStateRoot(path.segments, ROUTER_INTENT_NONE);
          }
        } else {
          await this.onRoutesChanged();
        }
      }
      componentDidLoad() {
        window.addEventListener('ionRouteRedirectChanged', debounce$1(this.onRedirectChanged.bind(this), 10));
        window.addEventListener('ionRouteDataChanged', debounce$1(this.onRoutesChanged.bind(this), 100));
      }
      async onPopState() {
        const direction = this.historyDirection();
        let segments = this.getPath();
        const canProceed = await this.runGuards(segments);
        if (canProceed !== true) {
          if (typeof canProceed === 'object') {
            segments = parsePath(canProceed.redirect).segments;
          } else {
            return false;
          }
        }
        return this.writeNavStateRoot(segments, direction);
      }
      onBackButton(ev) {
        ev.detail.register(0, processNextHandler => {
          this.back();
          processNextHandler();
        });
      }
      /** @internal */
      async canTransition() {
        const canProceed = await this.runGuards();
        if (canProceed !== true) {
          if (typeof canProceed === 'object') {
            return canProceed.redirect;
          } else {
            return false;
          }
        }
        return true;
      }
      /**
       * Navigate to the specified URL.
       *
       * @param url The url to navigate to.
       * @param direction The direction of the animation. Defaults to `"forward"`.
       */
      async push(url, direction = 'forward', animation) {
        if (url.startsWith('.')) {
          url = new URL(url, window.location.href).pathname;
        }
        let parsedPath = parsePath(url);
        const canProceed = await this.runGuards(parsedPath.segments);
        if (canProceed !== true) {
          if (typeof canProceed === 'object') {
            parsedPath = parsePath(canProceed.redirect);
          } else {
            return false;
          }
        }
        this.setPath(parsedPath.segments, direction, parsedPath.queryString);
        return this.writeNavStateRoot(parsedPath.segments, direction, animation);
      }
      /**
       * Go back to previous page in the window.history.
       */
      back() {
        window.history.back();
        return Promise.resolve(this.waitPromise);
      }
      /** @internal */
      async printDebug() {
        printRoutes(readRoutes(this.el));
        printRedirects(readRedirects(this.el));
      }
      /** @internal */
      async navChanged(direction) {
        if (this.busy) {
          console.warn('[ion-router] router is busy, navChanged was cancelled');
          return false;
        }
        const { ids, outlet } = await readNavState(window.document.body);
        const routes = readRoutes(this.el);
        const chain = routerIDsToChain(ids, routes);
        if (!chain) {
          console.warn(
            '[ion-router] no matching URL for ',
            ids.map(i => i.id),
          );
          return false;
        }
        const path = chainToPath(chain);
        if (!path) {
          console.warn('[ion-router] router could not match path because some required param is missing');
          return false;
        }
        this.setPath(path, direction);
        await this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, path, null, ids.length);
        return true;
      }
      // This handler gets called when a `ion-route-redirect` component is added to the DOM or if the from or to property of such node changes.
      onRedirectChanged() {
        const path = this.getPath();
        if (path && findRouteRedirect(path, readRedirects(this.el))) {
          this.writeNavStateRoot(path, ROUTER_INTENT_NONE);
        }
      }
      // This handler gets called when a `ion-route` component is added to the DOM or if the from or to property of such node changes.
      onRoutesChanged() {
        return this.writeNavStateRoot(this.getPath(), ROUTER_INTENT_NONE);
      }
      historyDirection() {
        var _a;
        const win = window;
        if (win.history.state === null) {
          this.state++;
          win.history.replaceState(this.state, win.document.title, (_a = win.document.location) === null || _a === void 0 ? void 0 : _a.href);
        }
        const state = win.history.state;
        const lastState = this.lastState;
        this.lastState = state;
        if (state > lastState || (state >= lastState && lastState > 0)) {
          return ROUTER_INTENT_FORWARD;
        }
        if (state < lastState) {
          return ROUTER_INTENT_BACK;
        }
        return ROUTER_INTENT_NONE;
      }
      async writeNavStateRoot(path, direction, animation) {
        if (!path) {
          console.error('[ion-router] URL is not part of the routing set');
          return false;
        }
        // lookup redirect rule
        const redirects = readRedirects(this.el);
        const redirect = findRouteRedirect(path, redirects);
        let redirectFrom = null;
        if (redirect) {
          const { segments, queryString } = redirect.to;
          this.setPath(segments, direction, queryString);
          redirectFrom = redirect.from;
          path = segments;
        }
        // lookup route chain
        const routes = readRoutes(this.el);
        const chain = routerPathToChain(path, routes);
        if (!chain) {
          console.error('[ion-router] the path does not match any route');
          return false;
        }
        // write DOM give
        return this.safeWriteNavState(document.body, chain, direction, path, redirectFrom, 0, animation);
      }
      async safeWriteNavState(node, chain, direction, path, redirectFrom, index = 0, animation) {
        const unlock = await this.lock();
        let changed = false;
        try {
          changed = await this.writeNavState(node, chain, direction, path, redirectFrom, index, animation);
        } catch (e) {
          console.error(e);
        }
        unlock();
        return changed;
      }
      async lock() {
        const p = this.waitPromise;
        let resolve;
        this.waitPromise = new Promise(r => (resolve = r));
        if (p !== undefined) {
          await p;
        }
        return resolve;
      }
      // Executes the beforeLeave hook of the source route and the beforeEnter hook of the target route if they exist.
      //
      // When the beforeLeave hook does not return true (to allow navigating) then that value is returned early and the beforeEnter is executed.
      // Otherwise the beforeEnterHook hook of the target route is executed.
      async runGuards(to = this.getPath(), from) {
        if (from === undefined) {
          from = parsePath(this.previousPath).segments;
        }
        if (!to || !from) {
          return true;
        }
        const routes = readRoutes(this.el);
        const fromChain = routerPathToChain(from, routes);
        const beforeLeaveHook = fromChain && fromChain[fromChain.length - 1].beforeLeave;
        const canLeave = beforeLeaveHook ? await beforeLeaveHook() : true;
        if (canLeave === false || typeof canLeave === 'object') {
          return canLeave;
        }
        const toChain = routerPathToChain(to, routes);
        const beforeEnterHook = toChain && toChain[toChain.length - 1].beforeEnter;
        return beforeEnterHook ? beforeEnterHook() : true;
      }
      async writeNavState(node, chain, direction, path, redirectFrom, index = 0, animation) {
        if (this.busy) {
          console.warn('[ion-router] router is busy, transition was cancelled');
          return false;
        }
        this.busy = true;
        // generate route event and emit will change
        const routeEvent = this.routeChangeEvent(path, redirectFrom);
        if (routeEvent) {
          this.ionRouteWillChange.emit(routeEvent);
        }
        const changed = await writeNavState(node, chain, direction, index, false, animation);
        this.busy = false;
        // emit did change
        if (routeEvent) {
          this.ionRouteDidChange.emit(routeEvent);
        }
        return changed;
      }
      setPath(path, direction, queryString) {
        this.state++;
        writePath(window.history, this.root, this.useHash, path, direction, this.state, queryString);
      }
      getPath() {
        return readPath(window.location, this.root, this.useHash);
      }
      routeChangeEvent(path, redirectFromPath) {
        const from = this.previousPath;
        const to = generatePath(path);
        this.previousPath = to;
        if (to === from) {
          return null;
        }
        const redirectedFrom = redirectFromPath ? generatePath(redirectFromPath) : null;
        return {
          from,
          redirectedFrom,
          to,
        };
      }
      get el() {
        return getElement(this);
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-router',
          $members$: {
            root: [1],
            useHash: [4, 'use-hash'],
            canTransition: [64],
            push: [64],
            back: [64],
            printDebug: [64],
            navChanged: [64],
          },
          $listeners$: [
            [8, 'popstate', 'onPopState'],
            [4, 'ionBackButton', 'onBackButton'],
          ],
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const routerLinkCss =
      '/*!@:host*/.sc-ion-router-link-h{--background:transparent;--color:var(--ion-color-primary, #3880ff);background:var(--background);color:var(--color)}/*!@:host(.ion-color)*/.ion-color.sc-ion-router-link-h{color:var(--ion-color-base)}/*!@a*/a.sc-ion-router-link{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}';

    class RouterLink {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * When using a router, it specifies the transition direction when navigating to
         * another page using `href`.
         */
        this.routerDirection = 'forward';
        this.onClick = ev => {
          openURL(this.href, ev, this.routerDirection, this.routerAnimation);
        };
      }
      render() {
        const mode = getIonMode$1(this);
        const attrs = {
          href: this.href,
          rel: this.rel,
          target: this.target,
        };
        return hAsync(
          Host,
          {
            onClick: this.onClick,
            class: createColorClasses$1(this.color, {
              [mode]: true,
              'ion-activatable': true,
            }),
          },
          hAsync('a', Object.assign({}, attrs), hAsync('slot', null)),
        );
      }
      static get style() {
        return routerLinkCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-router-link',
          $members$: {
            color: [513],
            href: [1],
            rel: [1],
            routerDirection: [1, 'router-direction'],
            routerAnimation: [16],
            target: [1],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const routeOutletCss = '/*!@:host*/.sc-ion-router-outlet-h{left:0;right:0;top:0;bottom:0;position:absolute;contain:layout size style;overflow:hidden;z-index:0}';

    class RouterOutlet {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionNavWillLoad = createEvent(this, 'ionNavWillLoad', 7);
        this.ionNavWillChange = createEvent(this, 'ionNavWillChange', 3);
        this.ionNavDidChange = createEvent(this, 'ionNavDidChange', 3);
        this.gestureOrAnimationInProgress = false;
        /**
         * The mode determines which platform styles to use.
         */
        this.mode = getIonMode$1(this);
        /**
         * If `true`, the router-outlet should animate the transition of components.
         */
        this.animated = true;
      }
      swipeHandlerChanged() {
        if (this.gesture) {
          this.gesture.enable(this.swipeHandler !== undefined);
        }
      }
      async connectedCallback() {
        const onStart = () => {
          this.gestureOrAnimationInProgress = true;
          if (this.swipeHandler) {
            this.swipeHandler.onStart();
          }
        };
        this.gesture = (
          await Promise.resolve().then(function () {
            return swipeBack;
          })
        ).createSwipeBackGesture(
          this.el,
          () => !this.gestureOrAnimationInProgress && !!this.swipeHandler && this.swipeHandler.canStart(),
          () => onStart(),
          step => this.ani && this.ani.progressStep(step),
          (shouldComplete, step, dur) => {
            if (this.ani) {
              this.ani.onFinish(
                () => {
                  this.gestureOrAnimationInProgress = false;
                  if (this.swipeHandler) {
                    this.swipeHandler.onEnd(shouldComplete);
                  }
                },
                { oneTimeCallback: true },
              );
              // Account for rounding errors in JS
              let newStepValue = shouldComplete ? -0.001 : 0.001;
              /**
               * Animation will be reversed here, so need to
               * reverse the easing curve as well
               *
               * Additionally, we need to account for the time relative
               * to the new easing curve, as `stepValue` is going to be given
               * in terms of a linear curve.
               */
              if (!shouldComplete) {
                this.ani.easing('cubic-bezier(1, 0, 0.68, 0.28)');
                newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];
              } else {
                newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];
              }
              this.ani.progressEnd(shouldComplete ? 1 : 0, newStepValue, dur);
            } else {
              this.gestureOrAnimationInProgress = false;
            }
          },
        );
        this.swipeHandlerChanged();
      }
      componentWillLoad() {
        this.ionNavWillLoad.emit();
      }
      disconnectedCallback() {
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
      }
      /** @internal */
      async commit(enteringEl, leavingEl, opts) {
        const unlock = await this.lock();
        let changed = false;
        try {
          changed = await this.transition(enteringEl, leavingEl, opts);
        } catch (e) {
          console.error(e);
        }
        unlock();
        return changed;
      }
      /** @internal */
      async setRouteId(id, params, direction, animation) {
        const changed = await this.setRoot(id, params, {
          duration: direction === 'root' ? 0 : undefined,
          direction: direction === 'back' ? 'back' : 'forward',
          animationBuilder: animation,
        });
        return {
          changed,
          element: this.activeEl,
        };
      }
      /** @internal */
      async getRouteId() {
        const active = this.activeEl;
        return active
          ? {
              id: active.tagName,
              element: active,
            }
          : undefined;
      }
      async setRoot(component, params, opts) {
        if (this.activeComponent === component) {
          return false;
        }
        // attach entering view to DOM
        const leavingEl = this.activeEl;
        const enteringEl = await attachComponent(this.delegate, this.el, component, ['ion-page', 'ion-page-invisible'], params);
        this.activeComponent = component;
        this.activeEl = enteringEl;
        // commit animation
        await this.commit(enteringEl, leavingEl, opts);
        await detachComponent(this.delegate, leavingEl);
        return true;
      }
      async transition(enteringEl, leavingEl, opts = {}) {
        if (leavingEl === enteringEl) {
          return false;
        }
        // emit nav will change event
        this.ionNavWillChange.emit();
        const { el, mode } = this;
        const animated = this.animated && config$2.getBoolean('animated', true);
        const animationBuilder = opts.animationBuilder || this.animation || config$2.get('navAnimation');
        await transition$4(
          Object.assign(
            Object.assign(
              {
                mode,
                animated,
                enteringEl,
                leavingEl,
                baseEl: el,
                progressCallback: opts.progressAnimation
                  ? ani => {
                      /**
                       * Because this progress callback is called asynchronously
                       * it is possible for the gesture to start and end before
                       * the animation is ever set. In that scenario, we should
                       * immediately call progressEnd so that the transition promise
                       * resolves and the gesture does not get locked up.
                       */
                      if (ani !== undefined && !this.gestureOrAnimationInProgress) {
                        this.gestureOrAnimationInProgress = true;
                        ani.onFinish(
                          () => {
                            this.gestureOrAnimationInProgress = false;
                            if (this.swipeHandler) {
                              this.swipeHandler.onEnd(false);
                            }
                          },
                          { oneTimeCallback: true },
                        );
                        /**
                         * Playing animation to beginning
                         * with a duration of 0 prevents
                         * any flickering when the animation
                         * is later cleaned up.
                         */
                        ani.progressEnd(0, 0, 0);
                      } else {
                        this.ani = ani;
                      }
                    }
                  : undefined,
              },
              opts,
            ),
            { animationBuilder },
          ),
        );
        // emit nav changed event
        this.ionNavDidChange.emit();
        return true;
      }
      async lock() {
        const p = this.waitPromise;
        let resolve;
        this.waitPromise = new Promise(r => (resolve = r));
        if (p !== undefined) {
          await p;
        }
        return resolve;
      }
      render() {
        return hAsync('slot', null);
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          swipeHandler: ['swipeHandlerChanged'],
        };
      }
      static get style() {
        return routeOutletCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-router-outlet',
          $members$: {
            mode: [1025],
            delegate: [16],
            animated: [4],
            animation: [16],
            swipeHandler: [16],
            commit: [64],
            setRouteId: [64],
            getRouteId: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const rowCss = '/*!@:host*/.sc-ion-row-h{display:flex;flex-wrap:wrap}';

    class Row {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return hAsync(Host, { class: getIonMode$1(this) }, hAsync('slot', null));
      }
      static get style() {
        return rowCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-row',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const searchbarIosCss =
      '.sc-ion-searchbar-ios-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:.5;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:flex;position:relative;align-items:center;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);box-sizing:border-box}.ion-color.sc-ion-searchbar-ios-h{color:var(--ion-color-contrast)}.ion-color.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{background:var(--ion-color-base)}.ion-color.sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios,.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.ion-color.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{color:inherit}.searchbar-search-icon.sc-ion-searchbar-ios{color:var(--icon-color);pointer-events:none}.searchbar-input-container.sc-ion-searchbar-ios{display:block;position:relative;flex-shrink:1;width:100%}.searchbar-input.sc-ion-searchbar-ios{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;border-radius:var(--border-radius);display:block;width:100%;border:0;outline:none;background:var(--background);font-family:inherit;box-shadow:var(--box-shadow);box-sizing:border-box;appearance:none}.searchbar-input.sc-ion-searchbar-ios::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-ios::-webkit-search-cancel-button,.searchbar-input.sc-ion-searchbar-ios::-ms-clear{display:none}.searchbar-cancel-button.sc-ion-searchbar-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:none;height:100%;border:0;outline:none;color:var(--cancel-button-color);cursor:pointer;appearance:none}.searchbar-cancel-button.sc-ion-searchbar-ios>div.sc-ion-searchbar-ios{display:flex;align-items:center;justify-content:center;width:100%;height:100%}.searchbar-clear-button.sc-ion-searchbar-ios{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:none;min-height:0;outline:none;color:var(--clear-button-color);appearance:none}.searchbar-has-value.searchbar-should-show-clear.sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios{display:block}.searchbar-disabled.sc-ion-searchbar-ios-h{cursor:default;opacity:0.4;pointer-events:none}.sc-ion-searchbar-ios-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.07);--border-radius:10px;--box-shadow:none;--cancel-button-color:var(--ion-color-primary, #3880ff);--clear-button-color:var(--ion-color-step-600, #666666);--color:var(--ion-text-color, #000);--icon-color:var(--ion-color-step-600, #666666);padding-left:12px;padding-right:12px;padding-top:12px;padding-bottom:12px;height:60px;contain:strict}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.sc-ion-searchbar-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px}}.searchbar-input-container.sc-ion-searchbar-ios{height:36px}.searchbar-search-icon.sc-ion-searchbar-ios{margin-left:calc(50% - 60px);left:5px;top:0;position:absolute;width:22px;height:100%;contain:strict}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.searchbar-search-icon.sc-ion-searchbar-ios{margin-left:unset;-webkit-margin-start:calc(50% - 60px);margin-inline-start:calc(50% - 60px)}}[dir=rtl].sc-ion-searchbar-ios .searchbar-search-icon.sc-ion-searchbar-ios,[dir=rtl].sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,[dir=rtl] .sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{left:unset;right:unset;right:5px}.searchbar-input.sc-ion-searchbar-ios{padding-left:28px;padding-right:28px;padding-top:0;padding-bottom:0;height:100%;font-size:17px;font-weight:400;contain:strict}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.searchbar-input.sc-ion-searchbar-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:28px;padding-inline-start:28px;-webkit-padding-end:28px;padding-inline-end:28px}}.searchbar-clear-button.sc-ion-searchbar-ios{right:0;top:0;background-position:center;position:absolute;width:30px;height:100%;border:0;background-color:transparent}[dir=rtl].sc-ion-searchbar-ios .searchbar-clear-button.sc-ion-searchbar-ios,[dir=rtl].sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios,[dir=rtl] .sc-ion-searchbar-ios-h .searchbar-clear-button.sc-ion-searchbar-ios{left:unset;right:unset;left:0}.searchbar-clear-icon.sc-ion-searchbar-ios{width:18px;height:100%}.searchbar-cancel-button.sc-ion-searchbar-ios{padding-left:8px;padding-right:0;padding-top:0;padding-bottom:0;flex-shrink:0;background-color:transparent;font-size:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.searchbar-cancel-button.sc-ion-searchbar-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:0;padding-inline-end:0}}.searchbar-left-aligned.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{margin-left:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.searchbar-left-aligned.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{margin-left:unset;-webkit-margin-start:0;margin-inline-start:0}}.searchbar-left-aligned.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{padding-left:30px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.searchbar-left-aligned.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{padding-left:unset;-webkit-padding-start:30px;padding-inline-start:30px}}.searchbar-has-focus.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-should-show-cancel.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{display:block}.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios{transition:all 300ms ease}.searchbar-animated.searchbar-has-focus.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios,.searchbar-animated.searchbar-should-show-cancel.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{opacity:1;pointer-events:auto}.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{margin-right:-100%;transform:translate3d(0,  0,  0);transition:all 300ms ease;opacity:0;pointer-events:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.searchbar-animated.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{margin-right:unset;-webkit-margin-end:-100%;margin-inline-end:-100%}}.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-input.sc-ion-searchbar-ios,.searchbar-no-animate.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{transition-duration:0ms}.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios{color:var(--ion-color-base)}@media (any-hover: hover){.ion-color.sc-ion-searchbar-ios-h .searchbar-cancel-button.sc-ion-searchbar-ios:hover{color:var(--ion-color-tint)}}ion-toolbar.sc-ion-searchbar-ios-h,ion-toolbar .sc-ion-searchbar-ios-h{padding-top:1px;padding-bottom:15px;height:52px}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color),ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color){color:inherit}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-cancel-button.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-cancel-button.sc-ion-searchbar-ios{color:currentColor}ion-toolbar.ion-color.sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h .searchbar-search-icon.sc-ion-searchbar-ios{color:currentColor;opacity:0.5}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-input.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-input.sc-ion-searchbar-ios{background:rgba(var(--ion-color-contrast-rgb), 0.07);color:currentColor}ion-toolbar.ion-color.sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-clear-button.sc-ion-searchbar-ios,ion-toolbar.ion-color .sc-ion-searchbar-ios-h:not(.ion-color) .searchbar-clear-button.sc-ion-searchbar-ios{color:currentColor;opacity:0.5}';

    const searchbarMdCss =
      '.sc-ion-searchbar-md-h{--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:.5;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:flex;position:relative;align-items:center;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);box-sizing:border-box}.ion-color.sc-ion-searchbar-md-h{color:var(--ion-color-contrast)}.ion-color.sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md{background:var(--ion-color-base)}.ion-color.sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md,.ion-color.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,.ion-color.sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{color:inherit}.searchbar-search-icon.sc-ion-searchbar-md{color:var(--icon-color);pointer-events:none}.searchbar-input-container.sc-ion-searchbar-md{display:block;position:relative;flex-shrink:1;width:100%}.searchbar-input.sc-ion-searchbar-md{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;border-radius:var(--border-radius);display:block;width:100%;border:0;outline:none;background:var(--background);font-family:inherit;box-shadow:var(--box-shadow);box-sizing:border-box;appearance:none}.searchbar-input.sc-ion-searchbar-md::placeholder{color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.searchbar-input.sc-ion-searchbar-md::-webkit-search-cancel-button,.searchbar-input.sc-ion-searchbar-md::-ms-clear{display:none}.searchbar-cancel-button.sc-ion-searchbar-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;display:none;height:100%;border:0;outline:none;color:var(--cancel-button-color);cursor:pointer;appearance:none}.searchbar-cancel-button.sc-ion-searchbar-md>div.sc-ion-searchbar-md{display:flex;align-items:center;justify-content:center;width:100%;height:100%}.searchbar-clear-button.sc-ion-searchbar-md{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;display:none;min-height:0;outline:none;color:var(--clear-button-color);appearance:none}.searchbar-has-value.searchbar-should-show-clear.sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md{display:block}.searchbar-disabled.sc-ion-searchbar-md-h{cursor:default;opacity:0.4;pointer-events:none}.sc-ion-searchbar-md-h{--background:var(--ion-background-color, #fff);--border-radius:2px;--box-shadow:0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 1px 5px 0 rgba(0, 0, 0, 0.12);--cancel-button-color:var(--ion-color-step-900, #1a1a1a);--clear-button-color:initial;--color:var(--ion-color-step-850, #262626);--icon-color:var(--ion-color-step-600, #666666);padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:8px;background:inherit}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.sc-ion-searchbar-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:8px;padding-inline-start:8px;-webkit-padding-end:8px;padding-inline-end:8px}}.searchbar-search-icon.sc-ion-searchbar-md{left:16px;top:11px;width:21px;height:21px}[dir=rtl].sc-ion-searchbar-md .searchbar-search-icon.sc-ion-searchbar-md,[dir=rtl].sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{left:unset;right:unset;right:16px}.searchbar-cancel-button.sc-ion-searchbar-md{left:5px;top:0;background-color:transparent;font-size:1.6em}[dir=rtl].sc-ion-searchbar-md .searchbar-cancel-button.sc-ion-searchbar-md,[dir=rtl].sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md{left:unset;right:unset;right:5px}.searchbar-search-icon.sc-ion-searchbar-md,.searchbar-cancel-button.sc-ion-searchbar-md{position:absolute}.searchbar-search-icon.ion-activated.sc-ion-searchbar-md,.searchbar-cancel-button.ion-activated.sc-ion-searchbar-md{background-color:transparent}.searchbar-input.sc-ion-searchbar-md{padding-left:55px;padding-right:55px;padding-top:6px;padding-bottom:6px;background-position:left 8px center;height:auto;font-size:16px;font-weight:400;line-height:30px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.searchbar-input.sc-ion-searchbar-md{padding-left:unset;padding-right:unset;-webkit-padding-start:55px;padding-inline-start:55px;-webkit-padding-end:55px;padding-inline-end:55px}}[dir=rtl].sc-ion-searchbar-md .searchbar-input.sc-ion-searchbar-md,[dir=rtl].sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-input.sc-ion-searchbar-md{background-position:right 8px center}.searchbar-clear-button.sc-ion-searchbar-md{right:13px;top:0;padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;position:absolute;height:100%;border:0;background-color:transparent}[dir=rtl].sc-ion-searchbar-md .searchbar-clear-button.sc-ion-searchbar-md,[dir=rtl].sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md,[dir=rtl] .sc-ion-searchbar-md-h .searchbar-clear-button.sc-ion-searchbar-md{left:unset;right:unset;left:13px}.searchbar-clear-button.ion-activated.sc-ion-searchbar-md{background-color:transparent}.searchbar-clear-icon.sc-ion-searchbar-md{width:22px;height:100%}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-search-icon.sc-ion-searchbar-md{display:block}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md,.searchbar-should-show-cancel.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md{display:block}.searchbar-has-focus.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md+.searchbar-search-icon.sc-ion-searchbar-md,.searchbar-should-show-cancel.sc-ion-searchbar-md-h .searchbar-cancel-button.sc-ion-searchbar-md+.searchbar-search-icon.sc-ion-searchbar-md{display:none}ion-toolbar.sc-ion-searchbar-md-h,ion-toolbar .sc-ion-searchbar-md-h{padding-left:7px;padding-right:7px;padding-top:3px;padding-bottom:3px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){ion-toolbar.sc-ion-searchbar-md-h,ion-toolbar .sc-ion-searchbar-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:7px;padding-inline-start:7px;-webkit-padding-end:7px;padding-inline-end:7px}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Searchbar {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionInput = createEvent(this, 'ionInput', 7);
        this.ionChange = createEvent(this, 'ionChange', 7);
        this.ionCancel = createEvent(this, 'ionCancel', 7);
        this.ionClear = createEvent(this, 'ionClear', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.isCancelVisible = false;
        this.shouldAlignLeft = true;
        this.focused = false;
        this.noAnimate = true;
        /**
         * If `true`, enable searchbar animation.
         */
        this.animated = false;
        /**
         * Set the input's autocomplete property.
         */
        this.autocomplete = 'off';
        /**
         * Set the input's autocorrect property.
         */
        this.autocorrect = 'off';
        /**
         * Set the cancel button icon. Only applies to `md` mode.
         * Defaults to `"arrow-back-sharp"`.
         */
        this.cancelButtonIcon = config$2.get('backButtonIcon', 'arrow-back-sharp');
        /**
         * Set the the cancel button text. Only applies to `ios` mode.
         */
        this.cancelButtonText = 'Cancel';
        /**
         * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        this.debounce = 250;
        /**
         * If `true`, the user cannot interact with the input.
         */
        this.disabled = false;
        /**
         * Set the input's placeholder.
         * `placeholder` can accept either plaintext or HTML as a string.
         * To display characters normally reserved for HTML, they
         * must be escaped. For example `<Ionic>` would become
         * `&lt;Ionic&gt;`
         *
         * For more information: [Security Documentation](https://ionicframework.com/docs/faq/security)
         */
        this.placeholder = 'Search';
        /**
         * Sets the behavior for the cancel button. Defaults to `"never"`.
         * Setting to `"focus"` shows the cancel button on focus.
         * Setting to `"never"` hides the cancel button.
         * Setting to `"always"` shows the cancel button regardless
         * of focus state.
         */
        this.showCancelButton = 'never';
        /**
         * Sets the behavior for the clear button. Defaults to `"focus"`.
         * Setting to `"focus"` shows the clear button on focus if the
         * input is not empty.
         * Setting to `"never"` hides the clear button.
         * Setting to `"always"` shows the clear button regardless
         * of focus state, but only if the input is not empty.
         */
        this.showClearButton = 'focus';
        /**
         * If `true`, enable spellcheck on the input.
         */
        this.spellcheck = false;
        /**
         * Set the type of the input.
         */
        this.type = 'search';
        /**
         * the value of the searchbar.
         */
        this.value = '';
        /**
         * Clears the input field and triggers the control change.
         */
        this.onClearInput = (ev, shouldFocus) => {
          this.ionClear.emit();
          if (ev) {
            ev.preventDefault();
            ev.stopPropagation();
          }
          // setTimeout() fixes https://github.com/ionic-team/ionic/issues/7527
          // wait for 4 frames
          setTimeout(() => {
            const value = this.getValue();
            if (value !== '') {
              this.value = '';
              this.ionInput.emit();
              /**
               * When tapping clear button
               * ensure input is focused after
               * clearing input so users
               * can quickly start typing.
               */
              if (shouldFocus && !this.focused) {
                this.setFocus();
              }
            }
          }, 16 * 4);
        };
        /**
         * Clears the input field and tells the input to blur since
         * the clearInput function doesn't want the input to blur
         * then calls the custom cancel function if the user passed one in.
         */
        this.onCancelSearchbar = ev => {
          if (ev) {
            ev.preventDefault();
            ev.stopPropagation();
          }
          this.ionCancel.emit();
          this.onClearInput();
          if (this.nativeInput) {
            this.nativeInput.blur();
          }
        };
        /**
         * Update the Searchbar input value when the input changes
         */
        this.onInput = ev => {
          const input = ev.target;
          if (input) {
            this.value = input.value;
          }
          this.ionInput.emit(ev);
        };
        /**
         * Sets the Searchbar to not focused and checks if it should align left
         * based on whether there is a value in the searchbar or not.
         */
        this.onBlur = () => {
          this.focused = false;
          this.ionBlur.emit();
          this.positionElements();
        };
        /**
         * Sets the Searchbar to focused and active on input focus.
         */
        this.onFocus = () => {
          this.focused = true;
          this.ionFocus.emit();
          this.positionElements();
        };
      }
      debounceChanged() {
        this.ionChange = debounceEvent(this.ionChange, this.debounce);
      }
      valueChanged() {
        const inputEl = this.nativeInput;
        const value = this.getValue();
        if (inputEl && inputEl.value !== value) {
          inputEl.value = value;
        }
        this.ionChange.emit({ value });
      }
      showCancelButtonChanged() {
        requestAnimationFrame(() => {
          this.positionElements();
          forceUpdate$1(this);
        });
      }
      connectedCallback() {
        this.emitStyle();
      }
      componentDidLoad() {
        this.positionElements();
        this.debounceChanged();
        setTimeout(() => {
          this.noAnimate = false;
        }, 300);
      }
      emitStyle() {
        this.ionStyle.emit({
          searchbar: true,
        });
      }
      /**
       * Sets focus on the specified `ion-searchbar`. Use this method instead of the global
       * `input.focus()`.
       */
      async setFocus() {
        if (this.nativeInput) {
          this.nativeInput.focus();
        }
      }
      /**
       * Returns the native `<input>` element used under the hood.
       */
      getInputElement() {
        return Promise.resolve(this.nativeInput);
      }
      /**
       * Positions the input search icon, placeholder, and the cancel button
       * based on the input value and if it is focused. (ios only)
       */
      positionElements() {
        const value = this.getValue();
        const prevAlignLeft = this.shouldAlignLeft;
        const mode = getIonMode$1(this);
        const shouldAlignLeft = !this.animated || value.trim() !== '' || !!this.focused;
        this.shouldAlignLeft = shouldAlignLeft;
        if (mode !== 'ios') {
          return;
        }
        if (prevAlignLeft !== shouldAlignLeft) {
          this.positionPlaceholder();
        }
        if (this.animated) {
          this.positionCancelButton();
        }
      }
      /**
       * Positions the input placeholder
       */
      positionPlaceholder() {
        const inputEl = this.nativeInput;
        if (!inputEl) {
          return;
        }
        const isRTL = document.dir === 'rtl';
        const iconEl = (this.el.shadowRoot || this.el).querySelector('.searchbar-search-icon');
        if (this.shouldAlignLeft) {
          inputEl.removeAttribute('style');
          iconEl.removeAttribute('style');
        } else {
          // Create a dummy span to get the placeholder width
          const doc = document;
          const tempSpan = doc.createElement('span');
          tempSpan.innerText = this.placeholder || '';
          doc.body.appendChild(tempSpan);
          // Get the width of the span then remove it
          raf(() => {
            const textWidth = tempSpan.offsetWidth;
            tempSpan.remove();
            // Calculate the input padding
            const inputLeft = 'calc(50% - ' + textWidth / 2 + 'px)';
            // Calculate the icon margin
            const iconLeft = 'calc(50% - ' + (textWidth / 2 + 30) + 'px)';
            // Set the input padding start and icon margin start
            if (isRTL) {
              inputEl.style.paddingRight = inputLeft;
              iconEl.style.marginRight = iconLeft;
            } else {
              inputEl.style.paddingLeft = inputLeft;
              iconEl.style.marginLeft = iconLeft;
            }
          });
        }
      }
      /**
       * Show the iOS Cancel button on focus, hide it offscreen otherwise
       */
      positionCancelButton() {
        const isRTL = document.dir === 'rtl';
        const cancelButton = (this.el.shadowRoot || this.el).querySelector('.searchbar-cancel-button');
        const shouldShowCancel = this.shouldShowCancelButton();
        if (cancelButton && shouldShowCancel !== this.isCancelVisible) {
          const cancelStyle = cancelButton.style;
          this.isCancelVisible = shouldShowCancel;
          if (shouldShowCancel) {
            if (isRTL) {
              cancelStyle.marginLeft = '0';
            } else {
              cancelStyle.marginRight = '0';
            }
          } else {
            const offset = cancelButton.offsetWidth;
            if (offset > 0) {
              if (isRTL) {
                cancelStyle.marginLeft = -offset + 'px';
              } else {
                cancelStyle.marginRight = -offset + 'px';
              }
            }
          }
        }
      }
      getValue() {
        return this.value || '';
      }
      hasValue() {
        return this.getValue() !== '';
      }
      /**
       * Determines whether or not the cancel button should be visible onscreen.
       * Cancel button should be shown if one of two conditions applies:
       * 1. `showCancelButton` is set to `always`.
       * 2. `showCancelButton` is set to `focus`, and the searchbar has been focused.
       */
      shouldShowCancelButton() {
        if (this.showCancelButton === 'never' || (this.showCancelButton === 'focus' && !this.focused)) {
          return false;
        }
        return true;
      }
      /**
       * Determines whether or not the clear button should be visible onscreen.
       * Clear button should be shown if one of two conditions applies:
       * 1. `showClearButton` is set to `always`.
       * 2. `showClearButton` is set to `focus`, and the searchbar has been focused.
       */
      shouldShowClearButton() {
        if (this.showClearButton === 'never' || (this.showClearButton === 'focus' && !this.focused)) {
          return false;
        }
        return true;
      }
      render() {
        const { cancelButtonText } = this;
        const animated = this.animated && config$2.getBoolean('animated', true);
        const mode = getIonMode$1(this);
        const clearIcon = this.clearIcon || (mode === 'ios' ? 'close-circle' : 'close-sharp');
        const searchIcon = this.searchIcon || (mode === 'ios' ? 'search-outline' : 'search-sharp');
        const shouldShowCancelButton = this.shouldShowCancelButton();
        const cancelButton =
          this.showCancelButton !== 'never' &&
          hAsync(
            'button',
            {
              'aria-label': cancelButtonText,
              'aria-hidden': shouldShowCancelButton ? undefined : 'true',
              'type': 'button',
              'tabIndex': mode === 'ios' && !shouldShowCancelButton ? -1 : undefined,
              'onMouseDown': this.onCancelSearchbar,
              'onTouchStart': this.onCancelSearchbar,
              'class': 'searchbar-cancel-button',
            },
            hAsync(
              'div',
              { 'aria-hidden': 'true' },
              mode === 'md' ? hAsync('ion-icon', { 'aria-hidden': 'true', 'mode': mode, 'icon': this.cancelButtonIcon, 'lazy': false }) : cancelButtonText,
            ),
          );
        return hAsync(
          Host,
          {
            'role': 'search',
            'aria-disabled': this.disabled ? 'true' : null,
            'class': createColorClasses$1(this.color, {
              [mode]: true,
              'searchbar-animated': animated,
              'searchbar-disabled': this.disabled,
              'searchbar-no-animate': animated && this.noAnimate,
              'searchbar-has-value': this.hasValue(),
              'searchbar-left-aligned': this.shouldAlignLeft,
              'searchbar-has-focus': this.focused,
              'searchbar-should-show-clear': this.shouldShowClearButton(),
              'searchbar-should-show-cancel': this.shouldShowCancelButton(),
            }),
          },
          hAsync(
            'div',
            { class: 'searchbar-input-container' },
            hAsync('input', {
              'aria-label': 'search text',
              'disabled': this.disabled,
              'ref': el => (this.nativeInput = el),
              'class': 'searchbar-input',
              'inputMode': this.inputmode,
              'enterKeyHint': this.enterkeyhint,
              'onInput': this.onInput,
              'onBlur': this.onBlur,
              'onFocus': this.onFocus,
              'placeholder': this.placeholder,
              'type': this.type,
              'value': this.getValue(),
              'autoComplete': this.autocomplete,
              'autoCorrect': this.autocorrect,
              'spellcheck': this.spellcheck,
            }),
            mode === 'md' && cancelButton,
            hAsync('ion-icon', { 'aria-hidden': 'true', 'mode': mode, 'icon': searchIcon, 'lazy': false, 'class': 'searchbar-search-icon' }),
            hAsync(
              'button',
              {
                'aria-label': 'reset',
                'type': 'button',
                'no-blur': true,
                'class': 'searchbar-clear-button',
                'onMouseDown': ev => this.onClearInput(ev, true),
                'onTouchStart': ev => this.onClearInput(ev, true),
              },
              hAsync('ion-icon', { 'aria-hidden': 'true', 'mode': mode, 'icon': clearIcon, 'lazy': false, 'class': 'searchbar-clear-icon' }),
            ),
          ),
          mode === 'ios' && cancelButton,
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          debounce: ['debounceChanged'],
          value: ['valueChanged'],
          showCancelButton: ['showCancelButtonChanged'],
        };
      }
      static get style() {
        return {
          ios: searchbarIosCss,
          md: searchbarMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-searchbar',
          $members$: {
            color: [513],
            animated: [4],
            autocomplete: [1],
            autocorrect: [1],
            cancelButtonIcon: [1, 'cancel-button-icon'],
            cancelButtonText: [1, 'cancel-button-text'],
            clearIcon: [1, 'clear-icon'],
            debounce: [2],
            disabled: [4],
            inputmode: [1],
            enterkeyhint: [1],
            placeholder: [1],
            searchIcon: [1, 'search-icon'],
            showCancelButton: [1, 'show-cancel-button'],
            showClearButton: [1, 'show-clear-button'],
            spellcheck: [4],
            type: [1],
            value: [1025],
            focused: [32],
            noAnimate: [32],
            setFocus: [64],
            getInputElement: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const segmentIosCss =
      '/*!@:host*/.sc-ion-segment-ios-h{--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:flex;position:relative;align-items:stretch;justify-content:center;width:100%;background:var(--background);font-family:var(--ion-font-family, inherit);text-align:center;contain:paint;user-select:none}/*!@:host(.segment-scrollable)*/.segment-scrollable.sc-ion-segment-ios-h{justify-content:start;width:auto;overflow-x:auto}/*!@:host(.segment-scrollable::-webkit-scrollbar)*/.segment-scrollable.sc-ion-segment-ios-h::-webkit-scrollbar{display:none}/*!@:host*/.sc-ion-segment-ios-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.065);border-radius:8px;overflow:hidden;z-index:0}/*!@:host(.ion-color)*/.ion-color.sc-ion-segment-ios-h{background:rgba(var(--ion-color-base-rgb), 0.065)}/*!@:host(.in-toolbar)*/.in-toolbar.sc-ion-segment-ios-h{margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;width:auto}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-toolbar)*/.in-toolbar.sc-ion-segment-ios-h{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}/*!@:host(.in-toolbar:not(.ion-color))*/.in-toolbar.sc-ion-segment-ios-h:not(.ion-color){background:var(--ion-toolbar-segment-background, var(--background))}/*!@:host(.in-toolbar-color:not(.ion-color))*/.in-toolbar-color.sc-ion-segment-ios-h:not(.ion-color){background:rgba(var(--ion-color-contrast-rgb), 0.11)}';

    const segmentMdCss =
      '/*!@:host*/.sc-ion-segment-md-h{--ripple-color:currentColor;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;display:flex;position:relative;align-items:stretch;justify-content:center;width:100%;background:var(--background);font-family:var(--ion-font-family, inherit);text-align:center;contain:paint;user-select:none}/*!@:host(.segment-scrollable)*/.segment-scrollable.sc-ion-segment-md-h{justify-content:start;width:auto;overflow-x:auto}/*!@:host(.segment-scrollable::-webkit-scrollbar)*/.segment-scrollable.sc-ion-segment-md-h::-webkit-scrollbar{display:none}/*!@:host*/.sc-ion-segment-md-h{--background:transparent}/*!@:host(.segment-scrollable) ::slotted(ion-segment-button)*/.sc-ion-segment-md-h.segment-scrollable .sc-ion-segment-md-s>ion-segment-button{min-width:auto}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Segment {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionChange = createEvent(this, 'ionChange', 7);
        this.ionSelect = createEvent(this, 'ionSelect', 7);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.didInit = false;
        this.activated = false;
        /**
         * If `true`, the user cannot interact with the segment.
         */
        this.disabled = false;
        /**
         * If `true`, the segment buttons will overflow and the user can swipe to see them.
         * In addition, this will disable the gesture to drag the indicator between the buttons
         * in order to swipe to see hidden buttons.
         */
        this.scrollable = false;
        /**
         * If `true`, users will be able to swipe between segment buttons to activate them.
         */
        this.swipeGesture = true;
        this.onClick = ev => {
          const current = ev.target;
          const previous = this.checked;
          // If the current element is a segment then that means
          // the user tried to swipe to a segment button and
          // click a segment button at the same time so we should
          // not update the checked segment button
          if (current.tagName === 'ION-SEGMENT') {
            return;
          }
          this.value = current.value;
          if (this.scrollable || !this.swipeGesture) {
            if (previous) {
              this.checkButton(previous, current);
            } else {
              this.setCheckedClasses();
            }
          }
          this.checked = current;
        };
      }
      colorChanged(value, oldValue) {
        /**
         * If color is set after not having
         * previously been set (or vice versa),
         * we need to emit style so the segment-buttons
         * can apply their color classes properly.
         */
        if ((oldValue === undefined && value !== undefined) || (oldValue !== undefined && value === undefined)) {
          this.emitStyle();
        }
      }
      swipeGestureChanged() {
        this.gestureChanged();
      }
      valueChanged(value, oldValue) {
        this.ionSelect.emit({ value });
        if (oldValue !== '' || this.didInit) {
          if (!this.activated) {
            this.ionChange.emit({ value });
          } else {
            this.valueAfterGesture = value;
          }
        }
      }
      disabledChanged() {
        this.gestureChanged();
        const buttons = this.getButtons();
        for (const button of buttons) {
          button.disabled = this.disabled;
        }
      }
      gestureChanged() {
        if (this.gesture) {
          this.gesture.enable(!this.scrollable && !this.disabled && this.swipeGesture);
        }
      }
      connectedCallback() {
        this.emitStyle();
      }
      componentWillLoad() {
        this.emitStyle();
      }
      async componentDidLoad() {
        this.setCheckedClasses();
        this.gesture = (
          await Promise.resolve().then(function () {
            return index$2;
          })
        ).createGesture({
          el: this.el,
          gestureName: 'segment',
          gesturePriority: 100,
          threshold: 0,
          passive: false,
          onStart: ev => this.onStart(ev),
          onMove: ev => this.onMove(ev),
          onEnd: ev => this.onEnd(ev),
        });
        this.gestureChanged();
        if (this.disabled) {
          this.disabledChanged();
        }
        this.didInit = true;
      }
      onStart(detail) {
        this.activate(detail);
      }
      onMove(detail) {
        this.setNextIndex(detail);
      }
      onEnd(detail) {
        this.setActivated(false);
        const checkedValidButton = this.setNextIndex(detail, true);
        detail.event.stopImmediatePropagation();
        if (checkedValidButton) {
          this.addRipple(detail);
        }
        const value = this.valueAfterGesture;
        if (value !== undefined) {
          this.ionChange.emit({ value });
          this.valueAfterGesture = undefined;
        }
      }
      getButtons() {
        return Array.from(this.el.querySelectorAll('ion-segment-button'));
      }
      /**
       * The gesture blocks the segment button ripple. This
       * function adds the ripple based on the checked segment
       * and where the cursor ended.
       */
      addRipple(detail) {
        const useRippleEffect = config$2.getBoolean('animated', true) && config$2.getBoolean('rippleEffect', true);
        if (!useRippleEffect) {
          return;
        }
        const buttons = this.getButtons();
        const checked = buttons.find(button => button.value === this.value);
        const root = checked.shadowRoot || checked;
        const ripple = root.querySelector('ion-ripple-effect');
        if (!ripple) {
          return;
        }
        const { x, y } = pointerCoord(detail.event);
        ripple.addRipple(x, y).then(remove => remove());
      }
      /*
       * Activate both the segment and the buttons
       * due to a bug with ::slotted in Safari
       */
      setActivated(activated) {
        const buttons = this.getButtons();
        buttons.forEach(button => {
          if (activated) {
            button.classList.add('segment-button-activated');
          } else {
            button.classList.remove('segment-button-activated');
          }
        });
        this.activated = activated;
      }
      activate(detail) {
        const clicked = detail.event.target;
        const buttons = this.getButtons();
        const checked = buttons.find(button => button.value === this.value);
        // Make sure we are only checking for activation on a segment button
        // since disabled buttons will get the click on the segment
        if (clicked.tagName !== 'ION-SEGMENT-BUTTON') {
          return;
        }
        // If there are no checked buttons, set the current button to checked
        if (!checked) {
          this.value = clicked.value;
          this.setCheckedClasses();
        }
        // If the gesture began on the clicked button with the indicator
        // then we should activate the indicator
        if (this.value === clicked.value) {
          this.setActivated(true);
        }
      }
      getIndicator(button) {
        const root = button.shadowRoot || button;
        return root.querySelector('.segment-button-indicator');
      }
      checkButton(previous, current) {
        const previousIndicator = this.getIndicator(previous);
        const currentIndicator = this.getIndicator(current);
        if (previousIndicator === null || currentIndicator === null) {
          return;
        }
        const previousClientRect = previousIndicator.getBoundingClientRect();
        const currentClientRect = currentIndicator.getBoundingClientRect();
        const widthDelta = previousClientRect.width / currentClientRect.width;
        const xPosition = previousClientRect.left - currentClientRect.left;
        // Scale the indicator width to match the previous indicator width
        // and translate it on top of the previous indicator
        const transform = `translate3d(${xPosition}px, 0, 0) scaleX(${widthDelta})`;
        writeTask(() => {
          // Remove the transition before positioning on top of the previous indicator
          currentIndicator.classList.remove('segment-button-indicator-animated');
          currentIndicator.style.setProperty('transform', transform);
          // Force a repaint to ensure the transform happens
          currentIndicator.getBoundingClientRect();
          // Add the transition to move the indicator into place
          currentIndicator.classList.add('segment-button-indicator-animated');
          // Remove the transform to slide the indicator back to the button clicked
          currentIndicator.style.setProperty('transform', '');
        });
        this.value = current.value;
        this.setCheckedClasses();
      }
      setCheckedClasses() {
        const buttons = this.getButtons();
        const index = buttons.findIndex(button => button.value === this.value);
        const next = index + 1;
        // Keep track of the currently checked button
        this.checked = buttons.find(button => button.value === this.value);
        for (const button of buttons) {
          button.classList.remove('segment-button-after-checked');
        }
        if (next < buttons.length) {
          buttons[next].classList.add('segment-button-after-checked');
        }
      }
      setNextIndex(detail, isEnd = false) {
        const isRTL = document.dir === 'rtl';
        const activated = this.activated;
        const buttons = this.getButtons();
        const index = buttons.findIndex(button => button.value === this.value);
        const previous = buttons[index];
        let current;
        let nextIndex;
        if (index === -1) {
          return;
        }
        // Get the element that the touch event started on in case
        // it was the checked button, then we will move the indicator
        const rect = previous.getBoundingClientRect();
        const left = rect.left;
        const width = rect.width;
        // Get the element that the gesture is on top of based on the currentX of the
        // gesture event and the Y coordinate of the starting element, since the gesture
        // can move up and down off of the segment
        const currentX = detail.currentX;
        const previousY = rect.top + rect.height / 2;
        const nextEl = document.elementFromPoint(currentX, previousY);
        const decreaseIndex = isRTL ? currentX > left + width : currentX < left;
        const increaseIndex = isRTL ? currentX < left : currentX > left + width;
        // If the indicator is currently activated then we have started the gesture
        // on top of the checked button so we need to slide the indicator
        // by checking the button next to it as we move
        if (activated && !isEnd) {
          // Decrease index, move left in LTR & right in RTL
          if (decreaseIndex) {
            const newIndex = index - 1;
            if (newIndex >= 0) {
              nextIndex = newIndex;
            }
            // Increase index, moves right in LTR & left in RTL
          } else if (increaseIndex) {
            if (activated && !isEnd) {
              const newIndex = index + 1;
              if (newIndex < buttons.length) {
                nextIndex = newIndex;
              }
            }
          }
          if (nextIndex !== undefined && !buttons[nextIndex].disabled) {
            current = buttons[nextIndex];
          }
        }
        // If the indicator is not activated then we will just set the indicator
        // to the element where the gesture ended
        if (!activated && isEnd) {
          current = nextEl;
        }
        /* tslint:disable-next-line */
        if (current != null) {
          /**
           * If current element is ion-segment then that means
           * user tried to select a disabled ion-segment-button,
           * and we should not update the ripple.
           */
          if (current.tagName === 'ION-SEGMENT') {
            return false;
          }
          if (previous !== current) {
            this.checkButton(previous, current);
          }
        }
        return true;
      }
      emitStyle() {
        this.ionStyle.emit({
          segment: true,
        });
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            role: 'tablist',
            onClick: this.onClick,
            class: createColorClasses$1(this.color, {
              [mode]: true,
              'in-toolbar': hostContext('ion-toolbar', this.el),
              'in-toolbar-color': hostContext('ion-toolbar[color]', this.el),
              'segment-activated': this.activated,
              'segment-disabled': this.disabled,
              'segment-scrollable': this.scrollable,
            }),
          },
          hAsync('slot', null),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          color: ['colorChanged'],
          swipeGesture: ['swipeGestureChanged'],
          value: ['valueChanged'],
          disabled: ['disabledChanged'],
        };
      }
      static get style() {
        return {
          ios: segmentIosCss,
          md: segmentMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-segment',
          $members$: {
            color: [513],
            disabled: [4],
            scrollable: [4],
            swipeGesture: [4, 'swipe-gesture'],
            value: [1025],
            activated: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const segmentButtonIosCss =
      '/*!@:host*/.sc-ion-segment-button-ios-h{--color:initial;--color-hover:var(--color);--color-checked:var(--color);--color-disabled:var(--color);--padding-start:0;--padding-end:0;--padding-top:0;--padding-bottom:0;border-radius:var(--border-radius);display:flex;position:relative;flex:1 1 auto;flex-direction:column;height:auto;background:var(--background);color:var(--color);text-decoration:none;text-overflow:ellipsis;white-space:nowrap;font-kerning:none;cursor:pointer}/*!@.button-native*/.button-native.sc-ion-segment-button-ios{border-radius:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;margin-left:var(--margin-start);margin-right:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);transform:translate3d(0,  0,  0);display:flex;position:relative;flex-direction:inherit;flex-grow:1;align-items:center;justify-content:center;width:100%;min-width:inherit;max-width:inherit;height:auto;min-height:inherit;max-height:inherit;transition:var(--transition);border:none;outline:none;background:transparent;contain:content;pointer-events:none;overflow:hidden;z-index:2}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-segment-button-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end)}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-segment-button-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.button-native::after*/.button-native.sc-ion-segment-button-ios::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}/*!@.button-inner*/.button-inner.sc-ion-segment-button-ios{display:flex;position:relative;flex-flow:inherit;align-items:center;justify-content:center;width:100%;height:100%;z-index:1}/*!@:host(.segment-button-checked)*/.segment-button-checked.sc-ion-segment-button-ios-h{background:var(--background-checked);color:var(--color-checked)}/*!@:host(.segment-button-disabled)*/.segment-button-disabled.sc-ion-segment-button-ios-h{cursor:default;pointer-events:none}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-segment-button-ios-h .button-native.sc-ion-segment-button-ios{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-segment-button-ios-h .button-native.sc-ion-segment-button-ios::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}/*!@:host(:focus)*/.sc-ion-segment-button-ios-h:focus{outline:none}@media (any-hover: hover){/*!@:host(:hover) .button-native*/.sc-ion-segment-button-ios-h:hover .button-native.sc-ion-segment-button-ios{color:var(--color-hover)}/*!@:host(:hover) .button-native::after*/.sc-ion-segment-button-ios-h:hover .button-native.sc-ion-segment-button-ios::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}/*!@:host(.segment-button-checked:hover) .button-native*/.segment-button-checked.sc-ion-segment-button-ios-h:hover .button-native.sc-ion-segment-button-ios{color:var(--color-checked)}}/*!@::slotted(ion-icon)*/.sc-ion-segment-button-ios-s>ion-icon{flex-shrink:0;order:-1;pointer-events:none}/*!@::slotted(ion-label)*/.sc-ion-segment-button-ios-s>ion-label{display:block;align-self:center;line-height:22px;text-overflow:ellipsis;white-space:nowrap;box-sizing:border-box;pointer-events:none}/*!@:host(.segment-button-layout-icon-top) .button-native*/.segment-button-layout-icon-top.sc-ion-segment-button-ios-h .button-native.sc-ion-segment-button-ios{flex-direction:column}/*!@:host(.segment-button-layout-icon-start) .button-native*/.segment-button-layout-icon-start.sc-ion-segment-button-ios-h .button-native.sc-ion-segment-button-ios{flex-direction:row}/*!@:host(.segment-button-layout-icon-end) .button-native*/.segment-button-layout-icon-end.sc-ion-segment-button-ios-h .button-native.sc-ion-segment-button-ios{flex-direction:row-reverse}/*!@:host(.segment-button-layout-icon-bottom) .button-native*/.segment-button-layout-icon-bottom.sc-ion-segment-button-ios-h .button-native.sc-ion-segment-button-ios{flex-direction:column-reverse}/*!@:host(.segment-button-layout-icon-hide) ::slotted(ion-icon)*/.sc-ion-segment-button-ios-h.segment-button-layout-icon-hide .sc-ion-segment-button-ios-s>ion-icon{display:none}/*!@:host(.segment-button-layout-label-hide) ::slotted(ion-label)*/.sc-ion-segment-button-ios-h.segment-button-layout-label-hide .sc-ion-segment-button-ios-s>ion-label{display:none}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-segment-button-ios{color:var(--ripple-color, var(--color-checked))}/*!@.segment-button-indicator*/.segment-button-indicator.sc-ion-segment-button-ios{transform-origin:left;position:absolute;opacity:0;box-sizing:border-box;will-change:transform, opacity;pointer-events:none}/*!@.segment-button-indicator-background*/.segment-button-indicator-background.sc-ion-segment-button-ios{width:100%;height:var(--indicator-height);transform:var(--indicator-transform);box-shadow:var(--indicator-box-shadow);pointer-events:none}/*!@.segment-button-indicator-animated*/.segment-button-indicator-animated.sc-ion-segment-button-ios{transition:var(--indicator-transition)}/*!@:host(.segment-button-checked) .segment-button-indicator*/.segment-button-checked.sc-ion-segment-button-ios-h .segment-button-indicator.sc-ion-segment-button-ios{opacity:1}@media (prefers-reduced-motion: reduce){/*!@.segment-button-indicator-background*/.segment-button-indicator-background.sc-ion-segment-button-ios{transform:none}/*!@.segment-button-indicator-animated*/.segment-button-indicator-animated.sc-ion-segment-button-ios{transition:none}}/*!@:host*/.sc-ion-segment-button-ios-h{--background:none;--background-checked:none;--background-hover:none;--background-hover-opacity:0;--background-focused:none;--background-focused-opacity:0;--border-radius:7px;--border-width:1px;--border-color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.12);--border-style:solid;--indicator-box-shadow:0 0 5px rgba(0, 0, 0, 0.16);--indicator-color:var(--ion-color-step-350, var(--ion-background-color, #fff));--indicator-height:100%;--indicator-transition:transform 260ms cubic-bezier(0.4, 0, 0.2, 1);--indicator-transform:none;--transition:100ms all linear;--padding-top:0;--padding-end:13px;--padding-bottom:0;--padding-start:13px;margin-top:2px;margin-bottom:2px;position:relative;flex-basis:0;flex-direction:row;min-width:70px;min-height:28px;transform:translate3d(0, 0, 0);font-size:13px;font-weight:450;line-height:37px}/*!@:host::before*/.sc-ion-segment-button-ios-h::before{margin-left:0;margin-right:0;margin-top:5px;margin-bottom:5px;transition:160ms opacity ease-in-out;transition-delay:100ms;border-left:var(--border-width) var(--border-style) var(--border-color);content:"";opacity:1;will-change:opacity}/*!@:host(:first-of-type)::before*/.sc-ion-segment-button-ios-h:first-of-type::before{border-left-color:transparent}/*!@:host(.segment-button-disabled)*/.segment-button-disabled.sc-ion-segment-button-ios-h{opacity:0.3}/*!@::slotted(ion-icon)*/.sc-ion-segment-button-ios-s>ion-icon{font-size:24px}/*!@:host(.segment-button-layout-icon-start) ::slotted(ion-label)*/.sc-ion-segment-button-ios-h.segment-button-layout-icon-start .sc-ion-segment-button-ios-s>ion-label{margin-left:2px;margin-right:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.segment-button-layout-icon-start) ::slotted(ion-label)*/.sc-ion-segment-button-ios-h.segment-button-layout-icon-start .sc-ion-segment-button-ios-s>ion-label{margin-left:unset;margin-right:unset;-webkit-margin-start:2px;margin-inline-start:2px;-webkit-margin-end:0;margin-inline-end:0}}/*!@:host(.segment-button-layout-icon-end) ::slotted(ion-label)*/.sc-ion-segment-button-ios-h.segment-button-layout-icon-end .sc-ion-segment-button-ios-s>ion-label{margin-left:0;margin-right:2px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.segment-button-layout-icon-end) ::slotted(ion-label)*/.sc-ion-segment-button-ios-h.segment-button-layout-icon-end .sc-ion-segment-button-ios-s>ion-label{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:2px;margin-inline-end:2px}}/*!@.segment-button-indicator*/.segment-button-indicator.sc-ion-segment-button-ios{padding-left:2px;padding-right:2px;left:0;right:0;top:0;bottom:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.segment-button-indicator*/.segment-button-indicator.sc-ion-segment-button-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px}}/*!@.segment-button-indicator-background*/.segment-button-indicator-background.sc-ion-segment-button-ios{border-radius:var(--border-radius);background:var(--indicator-color)}/*!@.segment-button-indicator-background*/.segment-button-indicator-background.sc-ion-segment-button-ios{transition:var(--indicator-transition)}/*!@:host(.segment-button-checked)::before,\n:host(.segment-button-after-checked)::before*/.segment-button-checked.sc-ion-segment-button-ios-h::before,.segment-button-after-checked.sc-ion-segment-button-ios-h::before{opacity:0}/*!@:host(.segment-button-checked)*/.segment-button-checked.sc-ion-segment-button-ios-h{z-index:-1}/*!@:host(.segment-button-activated)*/.segment-button-activated.sc-ion-segment-button-ios-h{--indicator-transform:scale(0.95)}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-segment-button-ios-h .button-native.sc-ion-segment-button-ios{opacity:0.7}@media (any-hover: hover){/*!@:host(:hover) .button-native*/.sc-ion-segment-button-ios-h:hover .button-native.sc-ion-segment-button-ios{opacity:0.5}/*!@:host(.segment-button-checked:hover) .button-native*/.segment-button-checked.sc-ion-segment-button-ios-h:hover .button-native.sc-ion-segment-button-ios{opacity:1}}/*!@:host(.in-segment-color)*/.in-segment-color.sc-ion-segment-button-ios-h{background:none;color:var(--ion-text-color, #000)}/*!@:host(.in-segment-color) .segment-button-indicator-background*/.in-segment-color.sc-ion-segment-button-ios-h .segment-button-indicator-background.sc-ion-segment-button-ios{background:var(--ion-color-step-350, var(--ion-background-color, #fff))}@media (any-hover: hover){/*!@:host(.in-segment-color:hover) .button-native,\n:host(.in-segment-color.segment-button-checked:hover) .button-native*/.in-segment-color.sc-ion-segment-button-ios-h:hover .button-native.sc-ion-segment-button-ios,.in-segment-color.segment-button-checked.sc-ion-segment-button-ios-h:hover .button-native.sc-ion-segment-button-ios{color:var(--ion-text-color, #000)}}/*!@:host(.in-toolbar:not(.in-segment-color))*/.in-toolbar.sc-ion-segment-button-ios-h:not(.in-segment-color){--background-checked:var(--ion-toolbar-segment-background-checked, none);--color:var(--ion-toolbar-segment-color, var(--ion-toolbar-color), initial);--color-checked:var(--ion-toolbar-segment-color-checked, var(--ion-toolbar-color), initial);--indicator-color:var(--ion-toolbar-segment-indicator-color, var(--ion-color-step-350, var(--ion-background-color, #fff)))}/*!@:host(.in-toolbar-color) .segment-button-indicator-background*/.in-toolbar-color.sc-ion-segment-button-ios-h .segment-button-indicator-background.sc-ion-segment-button-ios{background:#fff}/*!@:host(.in-toolbar-color:not(.in-segment-color)) .button-native*/.in-toolbar-color.sc-ion-segment-button-ios-h:not(.in-segment-color) .button-native.sc-ion-segment-button-ios{color:var(--ion-color-contrast)}/*!@:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color)) .button-native*/.in-toolbar-color.segment-button-checked.sc-ion-segment-button-ios-h:not(.in-segment-color) .button-native.sc-ion-segment-button-ios{color:var(--ion-color-base)}@media (any-hover: hover){/*!@:host(.in-toolbar-color:not(.in-segment-color):hover) .button-native*/.in-toolbar-color.sc-ion-segment-button-ios-h:not(.in-segment-color):hover .button-native.sc-ion-segment-button-ios{color:var(--ion-color-contrast)}/*!@:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color):hover) .button-native*/.in-toolbar-color.segment-button-checked.sc-ion-segment-button-ios-h:not(.in-segment-color):hover .button-native.sc-ion-segment-button-ios{color:var(--ion-color-base)}}';

    const segmentButtonMdCss =
      '/*!@:host*/.sc-ion-segment-button-md-h{--color:initial;--color-hover:var(--color);--color-checked:var(--color);--color-disabled:var(--color);--padding-start:0;--padding-end:0;--padding-top:0;--padding-bottom:0;border-radius:var(--border-radius);display:flex;position:relative;flex:1 1 auto;flex-direction:column;height:auto;background:var(--background);color:var(--color);text-decoration:none;text-overflow:ellipsis;white-space:nowrap;font-kerning:none;cursor:pointer}/*!@.button-native*/.button-native.sc-ion-segment-button-md{border-radius:0;font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;margin-left:var(--margin-start);margin-right:var(--margin-end);margin-top:var(--margin-top);margin-bottom:var(--margin-bottom);padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);transform:translate3d(0,  0,  0);display:flex;position:relative;flex-direction:inherit;flex-grow:1;align-items:center;justify-content:center;width:100%;min-width:inherit;max-width:inherit;height:auto;min-height:inherit;max-height:inherit;transition:var(--transition);border:none;outline:none;background:transparent;contain:content;pointer-events:none;overflow:hidden;z-index:2}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-segment-button-md{margin-left:unset;margin-right:unset;-webkit-margin-start:var(--margin-start);margin-inline-start:var(--margin-start);-webkit-margin-end:var(--margin-end);margin-inline-end:var(--margin-end)}}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-segment-button-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.button-native::after*/.button-native.sc-ion-segment-button-md::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}/*!@.button-inner*/.button-inner.sc-ion-segment-button-md{display:flex;position:relative;flex-flow:inherit;align-items:center;justify-content:center;width:100%;height:100%;z-index:1}/*!@:host(.segment-button-checked)*/.segment-button-checked.sc-ion-segment-button-md-h{background:var(--background-checked);color:var(--color-checked)}/*!@:host(.segment-button-disabled)*/.segment-button-disabled.sc-ion-segment-button-md-h{cursor:default;pointer-events:none}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-segment-button-md-h .button-native.sc-ion-segment-button-md{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-segment-button-md-h .button-native.sc-ion-segment-button-md::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}/*!@:host(:focus)*/.sc-ion-segment-button-md-h:focus{outline:none}@media (any-hover: hover){/*!@:host(:hover) .button-native*/.sc-ion-segment-button-md-h:hover .button-native.sc-ion-segment-button-md{color:var(--color-hover)}/*!@:host(:hover) .button-native::after*/.sc-ion-segment-button-md-h:hover .button-native.sc-ion-segment-button-md::after{background:var(--background-hover);opacity:var(--background-hover-opacity)}/*!@:host(.segment-button-checked:hover) .button-native*/.segment-button-checked.sc-ion-segment-button-md-h:hover .button-native.sc-ion-segment-button-md{color:var(--color-checked)}}/*!@::slotted(ion-icon)*/.sc-ion-segment-button-md-s>ion-icon{flex-shrink:0;order:-1;pointer-events:none}/*!@::slotted(ion-label)*/.sc-ion-segment-button-md-s>ion-label{display:block;align-self:center;line-height:22px;text-overflow:ellipsis;white-space:nowrap;box-sizing:border-box;pointer-events:none}/*!@:host(.segment-button-layout-icon-top) .button-native*/.segment-button-layout-icon-top.sc-ion-segment-button-md-h .button-native.sc-ion-segment-button-md{flex-direction:column}/*!@:host(.segment-button-layout-icon-start) .button-native*/.segment-button-layout-icon-start.sc-ion-segment-button-md-h .button-native.sc-ion-segment-button-md{flex-direction:row}/*!@:host(.segment-button-layout-icon-end) .button-native*/.segment-button-layout-icon-end.sc-ion-segment-button-md-h .button-native.sc-ion-segment-button-md{flex-direction:row-reverse}/*!@:host(.segment-button-layout-icon-bottom) .button-native*/.segment-button-layout-icon-bottom.sc-ion-segment-button-md-h .button-native.sc-ion-segment-button-md{flex-direction:column-reverse}/*!@:host(.segment-button-layout-icon-hide) ::slotted(ion-icon)*/.sc-ion-segment-button-md-h.segment-button-layout-icon-hide .sc-ion-segment-button-md-s>ion-icon{display:none}/*!@:host(.segment-button-layout-label-hide) ::slotted(ion-label)*/.sc-ion-segment-button-md-h.segment-button-layout-label-hide .sc-ion-segment-button-md-s>ion-label{display:none}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-segment-button-md{color:var(--ripple-color, var(--color-checked))}/*!@.segment-button-indicator*/.segment-button-indicator.sc-ion-segment-button-md{transform-origin:left;position:absolute;opacity:0;box-sizing:border-box;will-change:transform, opacity;pointer-events:none}/*!@.segment-button-indicator-background*/.segment-button-indicator-background.sc-ion-segment-button-md{width:100%;height:var(--indicator-height);transform:var(--indicator-transform);box-shadow:var(--indicator-box-shadow);pointer-events:none}/*!@.segment-button-indicator-animated*/.segment-button-indicator-animated.sc-ion-segment-button-md{transition:var(--indicator-transition)}/*!@:host(.segment-button-checked) .segment-button-indicator*/.segment-button-checked.sc-ion-segment-button-md-h .segment-button-indicator.sc-ion-segment-button-md{opacity:1}@media (prefers-reduced-motion: reduce){/*!@.segment-button-indicator-background*/.segment-button-indicator-background.sc-ion-segment-button-md{transform:none}/*!@.segment-button-indicator-animated*/.segment-button-indicator-animated.sc-ion-segment-button-md{transition:none}}/*!@:host*/.sc-ion-segment-button-md-h{--background:none;--background-checked:none;--background-hover:var(--color-checked);--background-focused:var(--color-checked);--background-activated-opacity:0;--background-focused-opacity:.12;--background-hover-opacity:.04;--color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6);--color-checked:var(--ion-color-primary, #3880ff);--indicator-box-shadow:none;--indicator-color:var(--color-checked);--indicator-height:2px;--indicator-transition:transform 250ms cubic-bezier(0.4, 0, 0.2, 1);--indicator-transform:none;--padding-top:0;--padding-end:16px;--padding-bottom:0;--padding-start:16px;--transition:color 0.15s linear 0s, opacity 0.15s linear 0s;min-width:90px;max-width:360px;min-height:48px;border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);font-size:14px;font-weight:500;letter-spacing:0.06em;line-height:40px;text-transform:uppercase}/*!@:host(.segment-button-disabled)*/.segment-button-disabled.sc-ion-segment-button-md-h{opacity:0.3}/*!@:host(.in-segment-color)*/.in-segment-color.sc-ion-segment-button-md-h{background:none;color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6)}/*!@:host(.in-segment-color) ion-ripple-effect*/.in-segment-color.sc-ion-segment-button-md-h ion-ripple-effect.sc-ion-segment-button-md{color:var(--ion-color-base)}/*!@:host(.in-segment-color) .segment-button-indicator-background*/.in-segment-color.sc-ion-segment-button-md-h .segment-button-indicator-background.sc-ion-segment-button-md{background:var(--ion-color-base)}/*!@:host(.in-segment-color.segment-button-checked) .button-native*/.in-segment-color.segment-button-checked.sc-ion-segment-button-md-h .button-native.sc-ion-segment-button-md{color:var(--ion-color-base)}/*!@:host(.in-segment-color.ion-focused) .button-native::after*/.in-segment-color.ion-focused.sc-ion-segment-button-md-h .button-native.sc-ion-segment-button-md::after{background:var(--ion-color-base)}@media (any-hover: hover){/*!@:host(.in-segment-color:hover) .button-native*/.in-segment-color.sc-ion-segment-button-md-h:hover .button-native.sc-ion-segment-button-md{color:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6)}/*!@:host(.in-segment-color:hover) .button-native::after*/.in-segment-color.sc-ion-segment-button-md-h:hover .button-native.sc-ion-segment-button-md::after{background:var(--ion-color-base)}/*!@:host(.in-segment-color.segment-button-checked:hover) .button-native*/.in-segment-color.segment-button-checked.sc-ion-segment-button-md-h:hover .button-native.sc-ion-segment-button-md{color:var(--ion-color-base)}}/*!@:host(.in-toolbar:not(.in-segment-color))*/.in-toolbar.sc-ion-segment-button-md-h:not(.in-segment-color){--background:var(--ion-toolbar-segment-background, none);--background-checked:var(--ion-toolbar-segment-background-checked, none);--color:var(--ion-toolbar-segment-color, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6));--color-checked:var(--ion-toolbar-segment-color-checked, var(--ion-color-primary, #3880ff));--indicator-color:var(--ion-toolbar-segment-color-checked, var(--color-checked))}/*!@:host(.in-toolbar-color:not(.in-segment-color)) .button-native*/.in-toolbar-color.sc-ion-segment-button-md-h:not(.in-segment-color) .button-native.sc-ion-segment-button-md{color:rgba(var(--ion-color-contrast-rgb), 0.6)}/*!@:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color)) .button-native*/.in-toolbar-color.segment-button-checked.sc-ion-segment-button-md-h:not(.in-segment-color) .button-native.sc-ion-segment-button-md{color:var(--ion-color-contrast)}@media (any-hover: hover){/*!@:host(.in-toolbar-color:not(.in-segment-color)) .button-native::after*/.in-toolbar-color.sc-ion-segment-button-md-h:not(.in-segment-color) .button-native.sc-ion-segment-button-md::after{background:var(--ion-color-contrast)}}/*!@::slotted(ion-icon)*/.sc-ion-segment-button-md-s>ion-icon{margin-top:12px;margin-bottom:12px;font-size:24px}/*!@::slotted(ion-label)*/.sc-ion-segment-button-md-s>ion-label{margin-top:12px;margin-bottom:12px}/*!@:host(.segment-button-layout-icon-top) ::slotted(ion-label),\n:host(.segment-button-layout-icon-bottom) ::slotted(ion-icon)*/.sc-ion-segment-button-md-h.segment-button-layout-icon-top .sc-ion-segment-button-md-s>ion-label,.sc-ion-segment-button-md-h.segment-button-layout-icon-bottom .sc-ion-segment-button-md-s>ion-icon{margin-top:0}/*!@:host(.segment-button-layout-icon-top) ::slotted(ion-icon),\n:host(.segment-button-layout-icon-bottom) ::slotted(ion-label)*/.sc-ion-segment-button-md-h.segment-button-layout-icon-top .sc-ion-segment-button-md-s>ion-icon,.sc-ion-segment-button-md-h.segment-button-layout-icon-bottom .sc-ion-segment-button-md-s>ion-label{margin-bottom:0}/*!@:host(.segment-button-layout-icon-start) ::slotted(ion-label)*/.sc-ion-segment-button-md-h.segment-button-layout-icon-start .sc-ion-segment-button-md-s>ion-label{margin-left:8px;margin-right:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.segment-button-layout-icon-start) ::slotted(ion-label)*/.sc-ion-segment-button-md-h.segment-button-layout-icon-start .sc-ion-segment-button-md-s>ion-label{margin-left:unset;margin-right:unset;-webkit-margin-start:8px;margin-inline-start:8px;-webkit-margin-end:0;margin-inline-end:0}}/*!@:host(.segment-button-layout-icon-end) ::slotted(ion-label)*/.sc-ion-segment-button-md-h.segment-button-layout-icon-end .sc-ion-segment-button-md-s>ion-label{margin-left:0;margin-right:8px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.segment-button-layout-icon-end) ::slotted(ion-label)*/.sc-ion-segment-button-md-h.segment-button-layout-icon-end .sc-ion-segment-button-md-s>ion-label{margin-left:unset;margin-right:unset;-webkit-margin-start:0;margin-inline-start:0;-webkit-margin-end:8px;margin-inline-end:8px}}/*!@:host(.segment-button-has-icon-only) ::slotted(ion-icon)*/.sc-ion-segment-button-md-h.segment-button-has-icon-only .sc-ion-segment-button-md-s>ion-icon{margin-top:12px;margin-bottom:12px}/*!@:host(.segment-button-has-label-only) ::slotted(ion-label)*/.sc-ion-segment-button-md-h.segment-button-has-label-only .sc-ion-segment-button-md-s>ion-label{margin-top:12px;margin-bottom:12px}/*!@.segment-button-indicator*/.segment-button-indicator.sc-ion-segment-button-md{left:0;right:0;bottom:0}/*!@.segment-button-indicator-background*/.segment-button-indicator-background.sc-ion-segment-button-md{background:var(--indicator-color)}/*!@:host(.in-toolbar:not(.in-segment-color)) .segment-button-indicator-background*/.in-toolbar.sc-ion-segment-button-md-h:not(.in-segment-color) .segment-button-indicator-background.sc-ion-segment-button-md{background:var(--ion-toolbar-segment-indicator-color, var(--indicator-color))}/*!@:host(.in-toolbar-color:not(.in-segment-color)) .segment-button-indicator-background*/.in-toolbar-color.sc-ion-segment-button-md-h:not(.in-segment-color) .segment-button-indicator-background.sc-ion-segment-button-md{background:var(--ion-color-contrast)}';

    let ids = 0;
    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part native - The native HTML button element that wraps all child elements.
     * @part indicator - The indicator displayed on the checked segment button.
     * @part indicator-background - The background element for the indicator displayed on the checked segment button.
     */
    class SegmentButton {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.segmentEl = null;
        this.checked = false;
        /**
         * If `true`, the user cannot interact with the segment button.
         */
        this.disabled = false;
        /**
         * Set the layout of the text and icon in the segment.
         */
        this.layout = 'icon-top';
        /**
         * The type of the button.
         */
        this.type = 'button';
        /**
         * The value of the segment button.
         */
        this.value = 'ion-sb-' + ids++;
        this.updateStyle = () => {
          forceUpdate$1(this);
        };
        this.updateState = () => {
          if (this.segmentEl) {
            this.checked = this.segmentEl.value === this.value;
          }
        };
      }
      connectedCallback() {
        const segmentEl = (this.segmentEl = this.el.closest('ion-segment'));
        if (segmentEl) {
          this.updateState();
          addEventListener(segmentEl, 'ionSelect', this.updateState);
          addEventListener(segmentEl, 'ionStyle', this.updateStyle);
        }
      }
      disconnectedCallback() {
        const segmentEl = this.segmentEl;
        if (segmentEl) {
          removeEventListener(segmentEl, 'ionSelect', this.updateState);
          removeEventListener(segmentEl, 'ionStyle', this.updateStyle);
          this.segmentEl = null;
        }
      }
      get hasLabel() {
        return !!this.el.querySelector('ion-label');
      }
      get hasIcon() {
        return !!this.el.querySelector('ion-icon');
      }
      get tabIndex() {
        if (this.disabled) {
          return -1;
        }
        const hasTabIndex = this.el.hasAttribute('tabindex');
        if (hasTabIndex) {
          return this.el.getAttribute('tabindex');
        }
        return 0;
      }
      render() {
        const { checked, type, disabled, hasIcon, hasLabel, layout, segmentEl, tabIndex } = this;
        const mode = getIonMode$1(this);
        const hasSegmentColor = () => segmentEl !== null && segmentEl.color !== undefined;
        return hAsync(
          Host,
          {
            'role': 'tab',
            'aria-selected': checked ? 'true' : 'false',
            'aria-disabled': disabled ? 'true' : null,
            'tabIndex': tabIndex,
            'class': {
              [mode]: true,
              'in-toolbar': hostContext('ion-toolbar', this.el),
              'in-toolbar-color': hostContext('ion-toolbar[color]', this.el),
              'in-segment': hostContext('ion-segment', this.el),
              'in-segment-color': hasSegmentColor(),
              'segment-button-has-label': hasLabel,
              'segment-button-has-icon': hasIcon,
              'segment-button-has-label-only': hasLabel && !hasIcon,
              'segment-button-has-icon-only': hasIcon && !hasLabel,
              'segment-button-disabled': disabled,
              'segment-button-checked': checked,
              [`segment-button-layout-${layout}`]: true,
              'ion-activatable': true,
              'ion-activatable-instant': true,
              'ion-focusable': true,
            },
          },
          hAsync(
            'button',
            { type: type, tabIndex: -1, class: 'button-native', part: 'native', disabled: disabled },
            hAsync('span', { class: 'button-inner' }, hAsync('slot', null)),
            mode === 'md' && hAsync('ion-ripple-effect', null),
          ),
          hAsync(
            'div',
            {
              part: 'indicator',
              class: {
                'segment-button-indicator': true,
                'segment-button-indicator-animated': true,
              },
            },
            hAsync('div', { part: 'indicator-background', class: 'segment-button-indicator-background' }),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: segmentButtonIosCss,
          md: segmentButtonMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-segment-button',
          $members$: {
            disabled: [4],
            layout: [1],
            type: [1],
            value: [1],
            checked: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const watchForOptions = (containerEl, tagName, onChange) => {
      /* tslint:disable-next-line */
      if (typeof MutationObserver === 'undefined') {
        return;
      }
      const mutation = new MutationObserver(mutationList => {
        onChange(getSelectedOption(mutationList, tagName));
      });
      mutation.observe(containerEl, {
        childList: true,
        subtree: true,
      });
      return mutation;
    };
    const getSelectedOption = (mutationList, tagName) => {
      let newOption;
      mutationList.forEach(mut => {
        // tslint:disable-next-line: prefer-for-of
        for (let i = 0; i < mut.addedNodes.length; i++) {
          newOption = findCheckedOption(mut.addedNodes[i], tagName) || newOption;
        }
      });
      return newOption;
    };
    const findCheckedOption = (el, tagName) => {
      if (el.nodeType !== 1) {
        return undefined;
      }
      const options = el.tagName === tagName.toUpperCase() ? [el] : Array.from(el.querySelectorAll(tagName));
      return options.find(o => o.value === el.value);
    };

    const selectIosCss =
      '/*!@:host*/.sc-ion-select-ios-h{--placeholder-color:currentColor;--placeholder-opacity:0.33;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:flex;position:relative;align-items:center;font-family:var(--ion-font-family, inherit);overflow:hidden;z-index:2}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-select-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@:host(.in-item)*/.in-item.sc-ion-select-ios-h{position:static;max-width:45%}/*!@:host(.select-disabled)*/.select-disabled.sc-ion-select-ios-h{opacity:0.4;pointer-events:none}/*!@:host(.ion-focused) button*/.ion-focused.sc-ion-select-ios-h button.sc-ion-select-ios{border:2px solid #5e9ed6}/*!@.select-placeholder*/.select-placeholder.sc-ion-select-ios{color:var(--placeholder-color);opacity:var(--placeholder-opacity)}/*!@label*/label.sc-ion-select-ios{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;appearance:none;outline:none;display:flex;align-items:center;opacity:0}/*!@[dir=rtl] label, :host-context([dir=rtl]) label*/[dir=rtl].sc-ion-select-ios label.sc-ion-select-ios,[dir=rtl].sc-ion-select-ios-h label.sc-ion-select-ios,[dir=rtl] .sc-ion-select-ios-h label.sc-ion-select-ios{left:unset;right:unset;right:0}/*!@label::-moz-focus-inner*/label.sc-ion-select-ios::-moz-focus-inner{border:0}/*!@button*/button.sc-ion-select-ios{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}/*!@.select-icon*/.select-icon.sc-ion-select-ios{position:relative;opacity:0.33}/*!@.select-text*/.select-text.sc-ion-select-ios{flex:1;min-width:16px;font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}/*!@.select-icon-inner*/.select-icon-inner.sc-ion-select-ios{left:5px;top:50%;margin-top:-2px;position:absolute;width:0;height:0;border-top:5px solid;border-right:5px solid transparent;border-left:5px solid transparent;color:currentColor;pointer-events:none}/*!@[dir=rtl] .select-icon-inner, :host-context([dir=rtl]) .select-icon-inner*/[dir=rtl].sc-ion-select-ios .select-icon-inner.sc-ion-select-ios,[dir=rtl].sc-ion-select-ios-h .select-icon-inner.sc-ion-select-ios,[dir=rtl] .sc-ion-select-ios-h .select-icon-inner.sc-ion-select-ios{left:unset;right:unset;right:5px}/*!@:host*/.sc-ion-select-ios-h{--padding-top:10px;--padding-end:10px;--padding-bottom:10px;--padding-start:20px}/*!@.select-icon*/.select-icon.sc-ion-select-ios{width:12px;height:18px}';

    const selectMdCss =
      '/*!@:host*/.sc-ion-select-md-h{--placeholder-color:currentColor;--placeholder-opacity:0.33;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:flex;position:relative;align-items:center;font-family:var(--ion-font-family, inherit);overflow:hidden;z-index:2}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-select-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@:host(.in-item)*/.in-item.sc-ion-select-md-h{position:static;max-width:45%}/*!@:host(.select-disabled)*/.select-disabled.sc-ion-select-md-h{opacity:0.4;pointer-events:none}/*!@:host(.ion-focused) button*/.ion-focused.sc-ion-select-md-h button.sc-ion-select-md{border:2px solid #5e9ed6}/*!@.select-placeholder*/.select-placeholder.sc-ion-select-md{color:var(--placeholder-color);opacity:var(--placeholder-opacity)}/*!@label*/label.sc-ion-select-md{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;appearance:none;outline:none;display:flex;align-items:center;opacity:0}/*!@[dir=rtl] label, :host-context([dir=rtl]) label*/[dir=rtl].sc-ion-select-md label.sc-ion-select-md,[dir=rtl].sc-ion-select-md-h label.sc-ion-select-md,[dir=rtl] .sc-ion-select-md-h label.sc-ion-select-md{left:unset;right:unset;right:0}/*!@label::-moz-focus-inner*/label.sc-ion-select-md::-moz-focus-inner{border:0}/*!@button*/button.sc-ion-select-md{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}/*!@.select-icon*/.select-icon.sc-ion-select-md{position:relative;opacity:0.33}/*!@.select-text*/.select-text.sc-ion-select-md{flex:1;min-width:16px;font-size:inherit;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}/*!@.select-icon-inner*/.select-icon-inner.sc-ion-select-md{left:5px;top:50%;margin-top:-2px;position:absolute;width:0;height:0;border-top:5px solid;border-right:5px solid transparent;border-left:5px solid transparent;color:currentColor;pointer-events:none}/*!@[dir=rtl] .select-icon-inner, :host-context([dir=rtl]) .select-icon-inner*/[dir=rtl].sc-ion-select-md .select-icon-inner.sc-ion-select-md,[dir=rtl].sc-ion-select-md-h .select-icon-inner.sc-ion-select-md,[dir=rtl] .sc-ion-select-md-h .select-icon-inner.sc-ion-select-md{left:unset;right:unset;right:5px}/*!@:host*/.sc-ion-select-md-h{--padding-top:10px;--padding-end:0;--padding-bottom:10px;--padding-start:16px}/*!@.select-icon*/.select-icon.sc-ion-select-md{width:19px;height:19px}/*!@:host-context(.item-label-floating) .select-icon*/.item-label-floating.sc-ion-select-md-h .select-icon.sc-ion-select-md,.item-label-floating .sc-ion-select-md-h .select-icon.sc-ion-select-md{transform:translate3d(0,  -9px,  0)}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part placeholder - The text displayed in the select when there is no value.
     * @part text - The displayed value of the select.
     * @part icon - The select icon container.
     */
    class Select {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionChange = createEvent(this, 'ionChange', 7);
        this.ionCancel = createEvent(this, 'ionCancel', 7);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.inputId = `ion-sel-${selectIds++}`;
        this.didInit = false;
        this.isExpanded = false;
        /**
         * If `true`, the user cannot interact with the select.
         */
        this.disabled = false;
        /**
         * The text to display on the cancel button.
         */
        this.cancelText = 'Cancel';
        /**
         * The text to display on the ok button.
         */
        this.okText = 'OK';
        /**
         * The name of the control, which is submitted with the form data.
         */
        this.name = this.inputId;
        /**
         * If `true`, the select can accept multiple values.
         */
        this.multiple = false;
        /**
         * The interface the select should use: `action-sheet`, `popover` or `alert`.
         */
        this.interface = 'alert';
        /**
         * Any additional options that the `alert`, `action-sheet` or `popover` interface
         * can take. See the [ion-alert docs](../alert), the
         * [ion-action-sheet docs](../action-sheet) and the
         * [ion-popover docs](../popover) for the
         * create options for each interface.
         *
         * Note: `interfaceOptions` will not override `inputs` or `buttons` with the `alert` interface.
         */
        this.interfaceOptions = {};
        this.onClick = ev => {
          this.setFocus();
          this.open(ev);
        };
        this.onFocus = () => {
          this.ionFocus.emit();
        };
        this.onBlur = () => {
          this.ionBlur.emit();
        };
      }
      disabledChanged() {
        this.emitStyle();
      }
      valueChanged() {
        this.emitStyle();
        if (this.didInit) {
          this.ionChange.emit({
            value: this.value,
          });
        }
      }
      async connectedCallback() {
        this.updateOverlayOptions();
        this.emitStyle();
        this.mutationO = watchForOptions(this.el, 'ion-select-option', async () => {
          this.updateOverlayOptions();
        });
      }
      disconnectedCallback() {
        if (this.mutationO) {
          this.mutationO.disconnect();
          this.mutationO = undefined;
        }
      }
      componentDidLoad() {
        this.didInit = true;
      }
      /**
       * Open the select overlay. The overlay is either an alert, action sheet, or popover,
       * depending on the `interface` property on the `ion-select`.
       *
       * @param event The user interface event that called the open.
       */
      async open(event) {
        if (this.disabled || this.isExpanded) {
          return undefined;
        }
        const overlay = (this.overlay = await this.createOverlay(event));
        this.isExpanded = true;
        overlay.onDidDismiss().then(() => {
          this.overlay = undefined;
          this.isExpanded = false;
          this.setFocus();
        });
        await overlay.present();
        return overlay;
      }
      createOverlay(ev) {
        let selectInterface = this.interface;
        if ((selectInterface === 'action-sheet' || selectInterface === 'popover') && this.multiple) {
          console.warn(`Select interface cannot be "${selectInterface}" with a multi-value select. Using the "alert" interface instead.`);
          selectInterface = 'alert';
        }
        if (selectInterface === 'popover' && !ev) {
          console.warn('Select interface cannot be a "popover" without passing an event. Using the "alert" interface instead.');
          selectInterface = 'alert';
        }
        if (selectInterface === 'popover') {
          return this.openPopover(ev);
        }
        if (selectInterface === 'action-sheet') {
          return this.openActionSheet();
        }
        return this.openAlert();
      }
      updateOverlayOptions() {
        const overlay = this.overlay;
        if (!overlay) {
          return;
        }
        const childOpts = this.childOpts;
        const value = this.value;
        switch (this.interface) {
          case 'action-sheet':
            overlay.buttons = this.createActionSheetButtons(childOpts, value);
            break;
          case 'popover':
            const popover = overlay.querySelector('ion-select-popover');
            if (popover) {
              popover.options = this.createPopoverOptions(childOpts, value);
            }
            break;
          case 'alert':
            const inputType = this.multiple ? 'checkbox' : 'radio';
            overlay.inputs = this.createAlertInputs(childOpts, inputType, value);
            break;
        }
      }
      createActionSheetButtons(data, selectValue) {
        const actionSheetButtons = data.map(option => {
          const value = getOptionValue(option);
          // Remove hydrated before copying over classes
          const copyClasses = Array.from(option.classList)
            .filter(cls => cls !== 'hydrated')
            .join(' ');
          const optClass = `${OPTION_CLASS} ${copyClasses}`;
          return {
            role: isOptionSelected(value, selectValue, this.compareWith) ? 'selected' : '',
            text: option.textContent,
            cssClass: optClass,
            handler: () => {
              this.value = value;
            },
          };
        });
        // Add "cancel" button
        actionSheetButtons.push({
          text: this.cancelText,
          role: 'cancel',
          handler: () => {
            this.ionCancel.emit();
          },
        });
        return actionSheetButtons;
      }
      createAlertInputs(data, inputType, selectValue) {
        const alertInputs = data.map(option => {
          const value = getOptionValue(option);
          // Remove hydrated before copying over classes
          const copyClasses = Array.from(option.classList)
            .filter(cls => cls !== 'hydrated')
            .join(' ');
          const optClass = `${OPTION_CLASS} ${copyClasses}`;
          return {
            type: inputType,
            cssClass: optClass,
            label: option.textContent || '',
            value,
            checked: isOptionSelected(value, selectValue, this.compareWith),
            disabled: option.disabled,
          };
        });
        return alertInputs;
      }
      createPopoverOptions(data, selectValue) {
        const popoverOptions = data.map(option => {
          const value = getOptionValue(option);
          // Remove hydrated before copying over classes
          const copyClasses = Array.from(option.classList)
            .filter(cls => cls !== 'hydrated')
            .join(' ');
          const optClass = `${OPTION_CLASS} ${copyClasses}`;
          return {
            text: option.textContent || '',
            cssClass: optClass,
            value,
            checked: isOptionSelected(value, selectValue, this.compareWith),
            disabled: option.disabled,
            handler: () => {
              this.value = value;
              this.close();
            },
          };
        });
        return popoverOptions;
      }
      async openPopover(ev) {
        const interfaceOptions = this.interfaceOptions;
        const mode = getIonMode$1(this);
        const value = this.value;
        const popoverOpts = Object.assign(Object.assign({ mode }, interfaceOptions), {
          component: 'ion-select-popover',
          cssClass: ['select-popover', interfaceOptions.cssClass],
          event: ev,
          componentProps: {
            header: interfaceOptions.header,
            subHeader: interfaceOptions.subHeader,
            message: interfaceOptions.message,
            value,
            options: this.createPopoverOptions(this.childOpts, value),
          },
        });
        return popoverController.create(popoverOpts);
      }
      async openActionSheet() {
        const mode = getIonMode$1(this);
        const interfaceOptions = this.interfaceOptions;
        const actionSheetOpts = Object.assign(Object.assign({ mode }, interfaceOptions), {
          buttons: this.createActionSheetButtons(this.childOpts, this.value),
          cssClass: ['select-action-sheet', interfaceOptions.cssClass],
        });
        return actionSheetController.create(actionSheetOpts);
      }
      async openAlert() {
        const label = this.getLabel();
        const labelText = label ? label.textContent : null;
        const interfaceOptions = this.interfaceOptions;
        const inputType = this.multiple ? 'checkbox' : 'radio';
        const mode = getIonMode$1(this);
        const alertOpts = Object.assign(Object.assign({ mode }, interfaceOptions), {
          header: interfaceOptions.header ? interfaceOptions.header : labelText,
          inputs: this.createAlertInputs(this.childOpts, inputType, this.value),
          buttons: [
            {
              text: this.cancelText,
              role: 'cancel',
              handler: () => {
                this.ionCancel.emit();
              },
            },
            {
              text: this.okText,
              handler: selectedValues => {
                this.value = selectedValues;
              },
            },
          ],
          cssClass: ['select-alert', interfaceOptions.cssClass, this.multiple ? 'multiple-select-alert' : 'single-select-alert'],
        });
        return alertController.create(alertOpts);
      }
      /**
       * Close the select interface.
       */
      close() {
        // TODO check !this.overlay || !this.isFocus()
        if (!this.overlay) {
          return Promise.resolve(false);
        }
        return this.overlay.dismiss();
      }
      getLabel() {
        return findItemLabel(this.el);
      }
      hasValue() {
        return this.getText() !== '';
      }
      get childOpts() {
        return Array.from(this.el.querySelectorAll('ion-select-option'));
      }
      getText() {
        const selectedText = this.selectedText;
        if (selectedText != null && selectedText !== '') {
          return selectedText;
        }
        return generateText(this.childOpts, this.value, this.compareWith);
      }
      setFocus() {
        if (this.focusEl) {
          this.focusEl.focus();
        }
      }
      emitStyle() {
        this.ionStyle.emit({
          'interactive': true,
          'select': true,
          'has-placeholder': this.placeholder != null,
          'has-value': this.hasValue(),
          'interactive-disabled': this.disabled,
          'select-disabled': this.disabled,
        });
      }
      render() {
        const { disabled, el, inputId, isExpanded, name, placeholder, value } = this;
        const mode = getIonMode$1(this);
        const { labelText, labelId } = getAriaLabel(el, inputId);
        renderHiddenInput(true, el, name, parseValue(value), disabled);
        const displayValue = this.getText();
        let addPlaceholderClass = false;
        let selectText = displayValue;
        if (selectText === '' && placeholder != null) {
          selectText = placeholder;
          addPlaceholderClass = true;
        }
        const selectTextClasses = {
          'select-text': true,
          'select-placeholder': addPlaceholderClass,
        };
        const textPart = addPlaceholderClass ? 'placeholder' : 'text';
        // If there is a label then we need to concatenate it with the
        // current value (or placeholder) and a comma so it separates
        // nicely when the screen reader announces it, otherwise just
        // announce the value / placeholder
        const displayLabel = labelText !== undefined ? (selectText !== '' ? `${selectText}, ${labelText}` : labelText) : selectText;
        return hAsync(
          Host,
          {
            'onClick': this.onClick,
            'role': 'button',
            'aria-haspopup': 'listbox',
            'aria-disabled': disabled ? 'true' : null,
            'aria-label': displayLabel,
            'class': {
              [mode]: true,
              'in-item': hostContext('ion-item', el),
              'select-disabled': disabled,
              'select-expanded': isExpanded,
            },
          },
          hAsync('div', { 'aria-hidden': 'true', 'class': selectTextClasses, 'part': textPart }, selectText),
          hAsync('div', { class: 'select-icon', role: 'presentation', part: 'icon' }, hAsync('div', { class: 'select-icon-inner' })),
          hAsync('label', { id: labelId }, displayLabel),
          hAsync('button', {
            'type': 'button',
            'disabled': disabled,
            'id': inputId,
            'aria-labelledby': labelId,
            'aria-haspopup': 'listbox',
            'aria-expanded': `${isExpanded}`,
            'onFocus': this.onFocus,
            'onBlur': this.onBlur,
            'ref': focusEl => (this.focusEl = focusEl),
          }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          disabled: ['disabledChanged'],
          placeholder: ['disabledChanged'],
          value: ['valueChanged'],
        };
      }
      static get style() {
        return {
          ios: selectIosCss,
          md: selectMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-select',
          $members$: {
            disabled: [4],
            cancelText: [1, 'cancel-text'],
            okText: [1, 'ok-text'],
            placeholder: [1],
            name: [1],
            selectedText: [1, 'selected-text'],
            multiple: [4],
            interface: [1],
            interfaceOptions: [8, 'interface-options'],
            compareWith: [1, 'compare-with'],
            value: [1032],
            isExpanded: [32],
            open: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const isOptionSelected = (currentValue, compareValue, compareWith) => {
      if (currentValue === undefined) {
        return false;
      }
      if (Array.isArray(currentValue)) {
        return currentValue.some(val => compareOptions(val, compareValue, compareWith));
      } else {
        return compareOptions(currentValue, compareValue, compareWith);
      }
    };
    const getOptionValue = el => {
      const value = el.value;
      return value === undefined ? el.textContent || '' : value;
    };
    const parseValue = value => {
      if (value == null) {
        return undefined;
      }
      if (Array.isArray(value)) {
        return value.join(',');
      }
      return value.toString();
    };
    const compareOptions = (currentValue, compareValue, compareWith) => {
      if (typeof compareWith === 'function') {
        return compareWith(currentValue, compareValue);
      } else if (typeof compareWith === 'string') {
        return currentValue[compareWith] === compareValue[compareWith];
      } else {
        return Array.isArray(compareValue) ? compareValue.includes(currentValue) : currentValue === compareValue;
      }
    };
    const generateText = (opts, value, compareWith) => {
      if (value === undefined) {
        return '';
      }
      if (Array.isArray(value)) {
        return value
          .map(v => textForValue(opts, v, compareWith))
          .filter(opt => opt !== null)
          .join(', ');
      } else {
        return textForValue(opts, value, compareWith) || '';
      }
    };
    const textForValue = (opts, value, compareWith) => {
      const selectOpt = opts.find(opt => {
        return compareOptions(getOptionValue(opt), value, compareWith);
      });
      return selectOpt ? selectOpt.textContent : null;
    };
    let selectIds = 0;
    const OPTION_CLASS = 'select-interface-option';

    const selectOptionCss = '/*!@:host*/.sc-ion-select-option-h{display:none}';

    class SelectOption {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.inputId = `ion-selopt-${selectOptionIds++}`;
        /**
         * If `true`, the user cannot interact with the select option. This property does not apply when `interface="action-sheet"` as `ion-action-sheet` does not allow for disabled buttons.
         */
        this.disabled = false;
      }
      render() {
        return hAsync(Host, { role: 'option', id: this.inputId, class: getIonMode$1(this) });
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return selectOptionCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-select-option',
          $members$: {
            disabled: [4],
            value: [8],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    let selectOptionIds = 0;

    const selectPopoverCss =
      '.sc-ion-select-popover-h ion-list.sc-ion-select-popover{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}.sc-ion-select-popover-h ion-list-header.sc-ion-select-popover,.sc-ion-select-popover-h ion-label.sc-ion-select-popover{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}';

    /**
     * @internal
     */
    class SelectPopover {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /** Array of options for the popover */
        this.options = [];
      }
      onSelect(ev) {
        const option = this.options.find(o => o.value === ev.target.value);
        if (option) {
          safeCall(option.handler);
        }
      }
      render() {
        const checkedOption = this.options.find(o => o.checked);
        const checkedValue = checkedOption ? checkedOption.value : undefined;
        return hAsync(
          Host,
          { class: getIonMode$1(this) },
          hAsync(
            'ion-list',
            null,
            this.header !== undefined && hAsync('ion-list-header', null, this.header),
            (this.subHeader !== undefined || this.message !== undefined) &&
              hAsync(
                'ion-item',
                null,
                hAsync(
                  'ion-label',
                  { class: 'ion-text-wrap' },
                  this.subHeader !== undefined && hAsync('h3', null, this.subHeader),
                  this.message !== undefined && hAsync('p', null, this.message),
                ),
              ),
            hAsync(
              'ion-radio-group',
              { value: checkedValue },
              this.options.map(option =>
                hAsync(
                  'ion-item',
                  { class: getClassMap(option.cssClass) },
                  hAsync('ion-label', null, option.text),
                  hAsync('ion-radio', { value: option.value, disabled: option.disabled }),
                ),
              ),
            ),
          ),
        );
      }
      static get style() {
        return selectPopoverCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 2,
          $tagName$: 'ion-select-popover',
          $members$: {
            header: [1],
            subHeader: [1, 'sub-header'],
            message: [1],
            options: [16],
          },
          $listeners$: [[0, 'ionChange', 'onSelect']],
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const skeletonTextCss =
      '/*!@:host*/.sc-ion-skeleton-text-h{--background:rgba(var(--background-rgb, var(--ion-text-color-rgb, 0, 0, 0)), 0.065);border-radius:var(--border-radius, inherit);display:block;width:100%;height:inherit;margin-top:4px;margin-bottom:4px;background:var(--background);line-height:10px;user-select:none;pointer-events:none}/*!@span*/span.sc-ion-skeleton-text{display:inline-block}/*!@:host(.in-media)*/.in-media.sc-ion-skeleton-text-h{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;height:100%}/*!@:host(.skeleton-text-animated)*/.skeleton-text-animated.sc-ion-skeleton-text-h{position:relative;background:linear-gradient(to right, rgba(var(--background-rgb, var(--ion-text-color-rgb, 0, 0, 0)), 0.065) 8%, rgba(var(--background-rgb, var(--ion-text-color-rgb, 0, 0, 0)), 0.135) 18%, rgba(var(--background-rgb, var(--ion-text-color-rgb, 0, 0, 0)), 0.065) 33%);background-size:800px 104px;animation-duration:1s;animation-fill-mode:forwards;animation-iteration-count:infinite;animation-name:shimmer;animation-timing-function:linear}@keyframes shimmer{0%{background-position:-400px 0}100%{background-position:400px 0}}';

    class SkeletonText {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If `true`, the skeleton text will animate.
         */
        this.animated = false;
      }
      render() {
        const animated = this.animated && config$2.getBoolean('animated', true);
        const inMedia = hostContext('ion-avatar', this.el) || hostContext('ion-thumbnail', this.el);
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: {
              [mode]: true,
              'skeleton-text-animated': animated,
              'in-media': inMedia,
            },
          },
          hAsync('span', null, '\u00A0'),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return skeletonTextCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-skeleton-text',
          $members$: {
            animated: [4],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const slideCss =
      'ion-slide{display:block;width:100%;height:100%}.slide-zoom{display:block;width:100%;text-align:center}.swiper-slide{display:flex;position:relative;flex-shrink:0;align-items:center;justify-content:center;width:100%;height:100%;font-size:18px;text-align:center;box-sizing:border-box}.swiper-slide img{width:auto;max-width:100%;height:auto;max-height:100%}';

    class Slide {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(Host, {
          class: {
            [mode]: true,
            'swiper-slide': true,
            'swiper-zoom-container': true,
          },
        });
      }
      static get style() {
        return slideCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-slide',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const slidesIosCss =
      ".swiper-container{margin:0 auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-container-no-flexbox .swiper-slide{float:left}.swiper-container-vertical{height:100%}.swiper-container-vertical>.swiper-wrapper{-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;-o-transition-property:transform;transition-property:transform;transition-property:transform, -webkit-transform;-webkit-box-sizing:content-box;box-sizing:content-box}.swiper-container-android .swiper-slide,.swiper-wrapper{-webkit-transform:translate3d(0px, 0, 0);transform:translate3d(0px, 0, 0)}.swiper-container-multirow>.swiper-wrapper{-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.swiper-container-free-mode>.swiper-wrapper{-webkit-transition-timing-function:ease-out;-o-transition-timing-function:ease-out;transition-timing-function:ease-out;margin:0 auto}.swiper-slide{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;width:100%;height:100%;position:relative;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;-o-transition-property:transform;transition-property:transform;transition-property:transform, -webkit-transform}.swiper-invisible-blank-slide{visibility:hidden}.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide{height:auto}.swiper-container-autoheight .swiper-wrapper{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-transition-property:height, -webkit-transform;transition-property:height, -webkit-transform;-o-transition-property:transform, height;transition-property:transform, height;transition-property:transform, height, -webkit-transform}.swiper-container-3d{-webkit-perspective:1200px;perspective:1200px}.swiper-container-3d .swiper-wrapper,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-cube-shadow{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-slide-shadow-bottom{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-container-3d .swiper-slide-shadow-left{background-image:-webkit-gradient(linear, right top, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image:-webkit-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:-o-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-container-3d .swiper-slide-shadow-right{background-image:-webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image:-webkit-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:-o-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-container-3d .swiper-slide-shadow-top{background-image:-webkit-gradient(linear, left bottom, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image:-webkit-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:-o-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-container-3d .swiper-slide-shadow-bottom{background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image:-webkit-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:-o-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-container-wp8-horizontal,.swiper-container-wp8-horizontal>.swiper-wrapper{-ms-touch-action:pan-y;touch-action:pan-y}.swiper-container-wp8-vertical,.swiper-container-wp8-vertical>.swiper-wrapper{-ms-touch-action:pan-x;touch-action:pan-x}.swiper-button-prev,.swiper-button-next{position:absolute;top:50%;width:27px;height:44px;margin-top:-22px;z-index:10;cursor:pointer;background-size:27px 44px;background-position:center;background-repeat:no-repeat}.swiper-button-prev.swiper-button-disabled,.swiper-button-next.swiper-button-disabled{opacity:0.35;cursor:auto;pointer-events:none}.swiper-button-prev,.swiper-container-rtl .swiper-button-next{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");left:10px;right:auto}.swiper-button-next,.swiper-container-rtl .swiper-button-prev{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");right:10px;left:auto}.swiper-button-prev.swiper-button-white,.swiper-container-rtl .swiper-button-next.swiper-button-white{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-next.swiper-button-white,.swiper-container-rtl .swiper-button-prev.swiper-button-white{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-prev.swiper-button-black,.swiper-container-rtl .swiper-button-next.swiper-button-black{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-next.swiper-button-black,.swiper-container-rtl .swiper-button-prev.swiper-button-black{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;-webkit-transition:300ms opacity;-o-transition:300ms opacity;transition:300ms opacity;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-fraction,.swiper-pagination-custom,.swiper-container-horizontal>.swiper-pagination-bullets{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transform:scale(0.33);-ms-transform:scale(0.33);transform:scale(0.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{-webkit-transform:scale(0.66);-ms-transform:scale(0.66);transform:scale(0.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{-webkit-transform:scale(0.33);-ms-transform:scale(0.33);transform:scale(0.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{-webkit-transform:scale(0.66);-ms-transform:scale(0.66);transform:scale(0.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{-webkit-transform:scale(0.33);-ms-transform:scale(0.33);transform:scale(0.33)}.swiper-pagination-bullet{width:8px;height:8px;display:inline-block;border-radius:100%;background:#000;opacity:0.2}button.swiper-pagination-bullet{border:none;margin:0;padding:0;-webkit-box-shadow:none;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet-active{opacity:1;background:#007aff}.swiper-container-vertical>.swiper-pagination-bullets{right:10px;top:50%;-webkit-transform:translate3d(0px, -50%, 0);transform:translate3d(0px, -50%, 0)}.swiper-container-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:6px 0;display:block}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;-webkit-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);width:8px}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;-webkit-transition:200ms top, 200ms -webkit-transform;transition:200ms top, 200ms -webkit-transform;-o-transition:200ms transform, 200ms top;transition:200ms transform, 200ms top;transition:200ms transform, 200ms top, 200ms -webkit-transform}.swiper-container-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 4px}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translateX(-50%);white-space:nowrap}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transition:200ms left, 200ms -webkit-transform;transition:200ms left, 200ms -webkit-transform;-o-transition:200ms transform, 200ms left;transition:200ms transform, 200ms left;transition:200ms transform, 200ms left, 200ms -webkit-transform}.swiper-container-horizontal.swiper-container-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transition:200ms right, 200ms -webkit-transform;transition:200ms right, 200ms -webkit-transform;-o-transition:200ms transform, 200ms right;transition:200ms transform, 200ms right;transition:200ms transform, 200ms right, 200ms -webkit-transform}.swiper-pagination-progressbar{background:rgba(0, 0, 0, 0.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:#007aff;position:absolute;left:0;top:0;width:100%;height:100%;-webkit-transform:scale(0);-ms-transform:scale(0);transform:scale(0);-webkit-transform-origin:left top;-ms-transform-origin:left top;transform-origin:left top}.swiper-container-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{-webkit-transform-origin:right top;-ms-transform-origin:right top;transform-origin:right top}.swiper-container-horizontal>.swiper-pagination-progressbar,.swiper-container-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-container-vertical>.swiper-pagination-progressbar,.swiper-container-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:4px;height:100%;left:0;top:0}.swiper-pagination-white .swiper-pagination-bullet-active{background:#ffffff}.swiper-pagination-progressbar.swiper-pagination-white{background:rgba(255, 255, 255, 0.25)}.swiper-pagination-progressbar.swiper-pagination-white .swiper-pagination-progressbar-fill{background:#ffffff}.swiper-pagination-black .swiper-pagination-bullet-active{background:#000000}.swiper-pagination-progressbar.swiper-pagination-black{background:rgba(0, 0, 0, 0.25)}.swiper-pagination-progressbar.swiper-pagination-black .swiper-pagination-progressbar-fill{background:#000000}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0, 0, 0, 0.1)}.swiper-container-horizontal>.swiper-scrollbar{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-container-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0, 0, 0, 0.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;text-align:center}.swiper-zoom-container>img,.swiper-zoom-container>svg,.swiper-zoom-container>canvas{max-width:100%;max-height:100%;-o-object-fit:contain;object-fit:contain}.swiper-slide-zoomed{cursor:move}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;-webkit-transform-origin:50%;-ms-transform-origin:50%;transform-origin:50%;-webkit-animation:swiper-preloader-spin 1s steps(12, end) infinite;animation:swiper-preloader-spin 1s steps(12, end) infinite}.swiper-lazy-preloader:after{display:block;content:\"\";width:100%;height:100%;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20viewBox%3D'0%200%20120%20120'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20xmlns%3Axlink%3D'http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink'%3E%3Cdefs%3E%3Cline%20id%3D'l'%20x1%3D'60'%20x2%3D'60'%20y1%3D'7'%20y2%3D'27'%20stroke%3D'%236c6c6c'%20stroke-width%3D'11'%20stroke-linecap%3D'round'%2F%3E%3C%2Fdefs%3E%3Cg%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(30%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(60%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(90%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(120%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(150%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.37'%20transform%3D'rotate(180%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.46'%20transform%3D'rotate(210%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.56'%20transform%3D'rotate(240%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.66'%20transform%3D'rotate(270%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.75'%20transform%3D'rotate(300%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.85'%20transform%3D'rotate(330%2060%2C60)'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\");background-position:50%;background-size:100%;background-repeat:no-repeat}.swiper-lazy-preloader-white:after{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20viewBox%3D'0%200%20120%20120'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20xmlns%3Axlink%3D'http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink'%3E%3Cdefs%3E%3Cline%20id%3D'l'%20x1%3D'60'%20x2%3D'60'%20y1%3D'7'%20y2%3D'27'%20stroke%3D'%23fff'%20stroke-width%3D'11'%20stroke-linecap%3D'round'%2F%3E%3C%2Fdefs%3E%3Cg%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(30%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(60%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(90%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(120%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(150%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.37'%20transform%3D'rotate(180%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.46'%20transform%3D'rotate(210%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.56'%20transform%3D'rotate(240%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.66'%20transform%3D'rotate(270%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.75'%20transform%3D'rotate(300%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.85'%20transform%3D'rotate(330%2060%2C60)'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\")}@-webkit-keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-container-fade.swiper-container-free-mode .swiper-slide{-webkit-transition-timing-function:ease-out;-o-transition-timing-function:ease-out;transition-timing-function:ease-out}.swiper-container-fade .swiper-slide{pointer-events:none;-webkit-transition-property:opacity;-o-transition-property:opacity;transition-property:opacity}.swiper-container-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube{overflow:visible}.swiper-container-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;-webkit-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0;width:100%;height:100%}.swiper-container-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-cube.swiper-container-rtl .swiper-slide{-webkit-transform-origin:100% 0;-ms-transform-origin:100% 0;transform-origin:100% 0}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-prev,.swiper-container-cube .swiper-slide-next+.swiper-slide{pointer-events:auto;visibility:visible}.swiper-container-cube .swiper-slide-shadow-top,.swiper-container-cube .swiper-slide-shadow-bottom,.swiper-container-cube .swiper-slide-shadow-left,.swiper-container-cube .swiper-slide-shadow-right{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;background:#000;opacity:0.6;-webkit-filter:blur(50px);filter:blur(50px);z-index:0}.swiper-container-flip{overflow:visible}.swiper-container-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-container-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-flip .swiper-slide-active,.swiper-container-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-flip .swiper-slide-shadow-top,.swiper-container-flip .swiper-slide-shadow-bottom,.swiper-container-flip .swiper-slide-shadow-left,.swiper-container-flip .swiper-slide-shadow-right{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-coverflow .swiper-wrapper{-ms-perspective:1200px}ion-slides{display:block;user-select:none}.swiper-pagination-bullet{background:var(--bullet-background)}.swiper-pagination-bullet-active{background:var(--bullet-background-active)}.swiper-pagination-progressbar{background:var(--progress-bar-background)}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--progress-bar-background-active)}.swiper-scrollbar{background:var(--scroll-bar-background)}.swiper-scrollbar-drag{background:var(--scroll-bar-background-active)}.slides-ios{--bullet-background:var(--ion-color-step-200, #cccccc);--bullet-background-active:var(--ion-color-primary, #3880ff);--progress-bar-background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.25);--progress-bar-background-active:var(--ion-color-primary-shade, #3171e0);--scroll-bar-background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1);--scroll-bar-background-active:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.5)}";

    const slidesMdCss =
      ".swiper-container{margin:0 auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1}.swiper-container-no-flexbox .swiper-slide{float:left}.swiper-container-vertical{height:100%}.swiper-container-vertical>.swiper-wrapper{-webkit-box-orient:vertical;-webkit-box-direction:normal;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;-o-transition-property:transform;transition-property:transform;transition-property:transform, -webkit-transform;-webkit-box-sizing:content-box;box-sizing:content-box}.swiper-container-android .swiper-slide,.swiper-wrapper{-webkit-transform:translate3d(0px, 0, 0);transform:translate3d(0px, 0, 0)}.swiper-container-multirow>.swiper-wrapper{-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap}.swiper-container-free-mode>.swiper-wrapper{-webkit-transition-timing-function:ease-out;-o-transition-timing-function:ease-out;transition-timing-function:ease-out;margin:0 auto}.swiper-slide{-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;width:100%;height:100%;position:relative;-webkit-transition-property:-webkit-transform;transition-property:-webkit-transform;-o-transition-property:transform;transition-property:transform;transition-property:transform, -webkit-transform}.swiper-invisible-blank-slide{visibility:hidden}.swiper-container-autoheight,.swiper-container-autoheight .swiper-slide{height:auto}.swiper-container-autoheight .swiper-wrapper{-webkit-box-align:start;-webkit-align-items:flex-start;-ms-flex-align:start;align-items:flex-start;-webkit-transition-property:height, -webkit-transform;transition-property:height, -webkit-transform;-o-transition-property:transform, height;transition-property:transform, height;transition-property:transform, height, -webkit-transform}.swiper-container-3d{-webkit-perspective:1200px;perspective:1200px}.swiper-container-3d .swiper-wrapper,.swiper-container-3d .swiper-slide,.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-slide-shadow-bottom,.swiper-container-3d .swiper-cube-shadow{-webkit-transform-style:preserve-3d;transform-style:preserve-3d}.swiper-container-3d .swiper-slide-shadow-left,.swiper-container-3d .swiper-slide-shadow-right,.swiper-container-3d .swiper-slide-shadow-top,.swiper-container-3d .swiper-slide-shadow-bottom{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-container-3d .swiper-slide-shadow-left{background-image:-webkit-gradient(linear, right top, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image:-webkit-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:-o-linear-gradient(right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-container-3d .swiper-slide-shadow-right{background-image:-webkit-gradient(linear, left top, right top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image:-webkit-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:-o-linear-gradient(left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-container-3d .swiper-slide-shadow-top{background-image:-webkit-gradient(linear, left bottom, left top, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image:-webkit-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:-o-linear-gradient(bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-container-3d .swiper-slide-shadow-bottom{background-image:-webkit-gradient(linear, left top, left bottom, from(rgba(0, 0, 0, 0.5)), to(rgba(0, 0, 0, 0)));background-image:-webkit-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:-o-linear-gradient(top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));background-image:linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0))}.swiper-container-wp8-horizontal,.swiper-container-wp8-horizontal>.swiper-wrapper{-ms-touch-action:pan-y;touch-action:pan-y}.swiper-container-wp8-vertical,.swiper-container-wp8-vertical>.swiper-wrapper{-ms-touch-action:pan-x;touch-action:pan-x}.swiper-button-prev,.swiper-button-next{position:absolute;top:50%;width:27px;height:44px;margin-top:-22px;z-index:10;cursor:pointer;background-size:27px 44px;background-position:center;background-repeat:no-repeat}.swiper-button-prev.swiper-button-disabled,.swiper-button-next.swiper-button-disabled{opacity:0.35;cursor:auto;pointer-events:none}.swiper-button-prev,.swiper-container-rtl .swiper-button-next{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");left:10px;right:auto}.swiper-button-next,.swiper-container-rtl .swiper-button-prev{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23007aff'%2F%3E%3C%2Fsvg%3E\");right:10px;left:auto}.swiper-button-prev.swiper-button-white,.swiper-container-rtl .swiper-button-next.swiper-button-white{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-next.swiper-button-white,.swiper-container-rtl .swiper-button-prev.swiper-button-white{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23ffffff'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-prev.swiper-button-black,.swiper-container-rtl .swiper-button-next.swiper-button-black{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M0%2C22L22%2C0l2.1%2C2.1L4.2%2C22l19.9%2C19.9L22%2C44L0%2C22L0%2C22L0%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-next.swiper-button-black,.swiper-container-rtl .swiper-button-prev.swiper-button-black{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%2027%2044'%3E%3Cpath%20d%3D'M27%2C22L27%2C22L5%2C44l-2.1-2.1L22.8%2C22L2.9%2C2.1L5%2C0L27%2C22L27%2C22z'%20fill%3D'%23000000'%2F%3E%3C%2Fsvg%3E\")}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;-webkit-transition:300ms opacity;-o-transition:300ms opacity;transition:300ms opacity;-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-fraction,.swiper-pagination-custom,.swiper-container-horizontal>.swiper-pagination-bullets{bottom:10px;left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transform:scale(0.33);-ms-transform:scale(0.33);transform:scale(0.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{-webkit-transform:scale(0.66);-ms-transform:scale(0.66);transform:scale(0.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{-webkit-transform:scale(0.33);-ms-transform:scale(0.33);transform:scale(0.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{-webkit-transform:scale(0.66);-ms-transform:scale(0.66);transform:scale(0.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{-webkit-transform:scale(0.33);-ms-transform:scale(0.33);transform:scale(0.33)}.swiper-pagination-bullet{width:8px;height:8px;display:inline-block;border-radius:100%;background:#000;opacity:0.2}button.swiper-pagination-bullet{border:none;margin:0;padding:0;-webkit-box-shadow:none;box-shadow:none;-webkit-appearance:none;-moz-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet-active{opacity:1;background:#007aff}.swiper-container-vertical>.swiper-pagination-bullets{right:10px;top:50%;-webkit-transform:translate3d(0px, -50%, 0);transform:translate3d(0px, -50%, 0)}.swiper-container-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:6px 0;display:block}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;-webkit-transform:translateY(-50%);-ms-transform:translateY(-50%);transform:translateY(-50%);width:8px}.swiper-container-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;-webkit-transition:200ms top, 200ms -webkit-transform;transition:200ms top, 200ms -webkit-transform;-o-transition:200ms transform, 200ms top;transition:200ms transform, 200ms top;transition:200ms transform, 200ms top, 200ms -webkit-transform}.swiper-container-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 4px}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%);transform:translateX(-50%);white-space:nowrap}.swiper-container-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transition:200ms left, 200ms -webkit-transform;transition:200ms left, 200ms -webkit-transform;-o-transition:200ms transform, 200ms left;transition:200ms transform, 200ms left;transition:200ms transform, 200ms left, 200ms -webkit-transform}.swiper-container-horizontal.swiper-container-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{-webkit-transition:200ms right, 200ms -webkit-transform;transition:200ms right, 200ms -webkit-transform;-o-transition:200ms transform, 200ms right;transition:200ms transform, 200ms right;transition:200ms transform, 200ms right, 200ms -webkit-transform}.swiper-pagination-progressbar{background:rgba(0, 0, 0, 0.25);position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:#007aff;position:absolute;left:0;top:0;width:100%;height:100%;-webkit-transform:scale(0);-ms-transform:scale(0);transform:scale(0);-webkit-transform-origin:left top;-ms-transform-origin:left top;transform-origin:left top}.swiper-container-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{-webkit-transform-origin:right top;-ms-transform-origin:right top;transform-origin:right top}.swiper-container-horizontal>.swiper-pagination-progressbar,.swiper-container-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:4px;left:0;top:0}.swiper-container-vertical>.swiper-pagination-progressbar,.swiper-container-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:4px;height:100%;left:0;top:0}.swiper-pagination-white .swiper-pagination-bullet-active{background:#ffffff}.swiper-pagination-progressbar.swiper-pagination-white{background:rgba(255, 255, 255, 0.25)}.swiper-pagination-progressbar.swiper-pagination-white .swiper-pagination-progressbar-fill{background:#ffffff}.swiper-pagination-black .swiper-pagination-bullet-active{background:#000000}.swiper-pagination-progressbar.swiper-pagination-black{background:rgba(0, 0, 0, 0.25)}.swiper-pagination-progressbar.swiper-pagination-black .swiper-pagination-progressbar-fill{background:#000000}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:10px;position:relative;-ms-touch-action:none;background:rgba(0, 0, 0, 0.1)}.swiper-container-horizontal>.swiper-scrollbar{position:absolute;left:1%;bottom:3px;z-index:50;height:5px;width:98%}.swiper-container-vertical>.swiper-scrollbar{position:absolute;right:3px;top:1%;z-index:50;width:5px;height:98%}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:rgba(0, 0, 0, 0.5);border-radius:10px;left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-webkit-justify-content:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-webkit-align-items:center;-ms-flex-align:center;align-items:center;text-align:center}.swiper-zoom-container>img,.swiper-zoom-container>svg,.swiper-zoom-container>canvas{max-width:100%;max-height:100%;-o-object-fit:contain;object-fit:contain}.swiper-slide-zoomed{cursor:move}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;-webkit-transform-origin:50%;-ms-transform-origin:50%;transform-origin:50%;-webkit-animation:swiper-preloader-spin 1s steps(12, end) infinite;animation:swiper-preloader-spin 1s steps(12, end) infinite}.swiper-lazy-preloader:after{display:block;content:\"\";width:100%;height:100%;background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20viewBox%3D'0%200%20120%20120'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20xmlns%3Axlink%3D'http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink'%3E%3Cdefs%3E%3Cline%20id%3D'l'%20x1%3D'60'%20x2%3D'60'%20y1%3D'7'%20y2%3D'27'%20stroke%3D'%236c6c6c'%20stroke-width%3D'11'%20stroke-linecap%3D'round'%2F%3E%3C%2Fdefs%3E%3Cg%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(30%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(60%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(90%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(120%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(150%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.37'%20transform%3D'rotate(180%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.46'%20transform%3D'rotate(210%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.56'%20transform%3D'rotate(240%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.66'%20transform%3D'rotate(270%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.75'%20transform%3D'rotate(300%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.85'%20transform%3D'rotate(330%2060%2C60)'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\");background-position:50%;background-size:100%;background-repeat:no-repeat}.swiper-lazy-preloader-white:after{background-image:url(\"data:image/svg+xml;charset=utf-8,%3Csvg%20viewBox%3D'0%200%20120%20120'%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20xmlns%3Axlink%3D'http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink'%3E%3Cdefs%3E%3Cline%20id%3D'l'%20x1%3D'60'%20x2%3D'60'%20y1%3D'7'%20y2%3D'27'%20stroke%3D'%23fff'%20stroke-width%3D'11'%20stroke-linecap%3D'round'%2F%3E%3C%2Fdefs%3E%3Cg%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(30%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(60%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(90%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(120%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.27'%20transform%3D'rotate(150%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.37'%20transform%3D'rotate(180%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.46'%20transform%3D'rotate(210%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.56'%20transform%3D'rotate(240%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.66'%20transform%3D'rotate(270%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.75'%20transform%3D'rotate(300%2060%2C60)'%2F%3E%3Cuse%20xlink%3Ahref%3D'%23l'%20opacity%3D'.85'%20transform%3D'rotate(330%2060%2C60)'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E\")}@-webkit-keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes swiper-preloader-spin{100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.swiper-container .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-container-fade.swiper-container-free-mode .swiper-slide{-webkit-transition-timing-function:ease-out;-o-transition-timing-function:ease-out;transition-timing-function:ease-out}.swiper-container-fade .swiper-slide{pointer-events:none;-webkit-transition-property:opacity;-o-transition-property:opacity;transition-property:opacity}.swiper-container-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-fade .swiper-slide-active,.swiper-container-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube{overflow:visible}.swiper-container-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;-webkit-transform-origin:0 0;-ms-transform-origin:0 0;transform-origin:0 0;width:100%;height:100%}.swiper-container-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-cube.swiper-container-rtl .swiper-slide{-webkit-transform-origin:100% 0;-ms-transform-origin:100% 0;transform-origin:100% 0}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-cube .swiper-slide-active,.swiper-container-cube .swiper-slide-next,.swiper-container-cube .swiper-slide-prev,.swiper-container-cube .swiper-slide-next+.swiper-slide{pointer-events:auto;visibility:visible}.swiper-container-cube .swiper-slide-shadow-top,.swiper-container-cube .swiper-slide-shadow-bottom,.swiper-container-cube .swiper-slide-shadow-left,.swiper-container-cube .swiper-slide-shadow-right{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;background:#000;opacity:0.6;-webkit-filter:blur(50px);filter:blur(50px);z-index:0}.swiper-container-flip{overflow:visible}.swiper-container-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-container-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-container-flip .swiper-slide-active,.swiper-container-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-container-flip .swiper-slide-shadow-top,.swiper-container-flip .swiper-slide-shadow-bottom,.swiper-container-flip .swiper-slide-shadow-left,.swiper-container-flip .swiper-slide-shadow-right{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-container-coverflow .swiper-wrapper{-ms-perspective:1200px}ion-slides{display:block;user-select:none}.swiper-pagination-bullet{background:var(--bullet-background)}.swiper-pagination-bullet-active{background:var(--bullet-background-active)}.swiper-pagination-progressbar{background:var(--progress-bar-background)}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--progress-bar-background-active)}.swiper-scrollbar{background:var(--scroll-bar-background)}.swiper-scrollbar-drag{background:var(--scroll-bar-background-active)}.slides-md{--bullet-background:var(--ion-color-step-200, #cccccc);--bullet-background-active:var(--ion-color-primary, #3880ff);--progress-bar-background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.25);--progress-bar-background-active:var(--ion-color-primary-shade, #3171e0);--scroll-bar-background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.1);--scroll-bar-background-active:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.5)}";

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Slides {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionSlidesDidLoad = createEvent(this, 'ionSlidesDidLoad', 7);
        this.ionSlideTap = createEvent(this, 'ionSlideTap', 7);
        this.ionSlideDoubleTap = createEvent(this, 'ionSlideDoubleTap', 7);
        this.ionSlideWillChange = createEvent(this, 'ionSlideWillChange', 7);
        this.ionSlideDidChange = createEvent(this, 'ionSlideDidChange', 7);
        this.ionSlideNextStart = createEvent(this, 'ionSlideNextStart', 7);
        this.ionSlidePrevStart = createEvent(this, 'ionSlidePrevStart', 7);
        this.ionSlideNextEnd = createEvent(this, 'ionSlideNextEnd', 7);
        this.ionSlidePrevEnd = createEvent(this, 'ionSlidePrevEnd', 7);
        this.ionSlideTransitionStart = createEvent(this, 'ionSlideTransitionStart', 7);
        this.ionSlideTransitionEnd = createEvent(this, 'ionSlideTransitionEnd', 7);
        this.ionSlideDrag = createEvent(this, 'ionSlideDrag', 7);
        this.ionSlideReachStart = createEvent(this, 'ionSlideReachStart', 7);
        this.ionSlideReachEnd = createEvent(this, 'ionSlideReachEnd', 7);
        this.ionSlideTouchStart = createEvent(this, 'ionSlideTouchStart', 7);
        this.ionSlideTouchEnd = createEvent(this, 'ionSlideTouchEnd', 7);
        this.swiperReady = false;
        this.swiper = new Promise(resolve => {
          this.readySwiper = resolve;
        });
        this.didInit = false;
        /**
         * Options to pass to the swiper instance.
         * See http://idangero.us/swiper/api/ for valid options
         */
        this.options = {}; // SwiperOptions;  // TODO
        /**
         * If `true`, show the pagination.
         */
        this.pager = false;
        /**
         * If `true`, show the scrollbar.
         */
        this.scrollbar = false;
      }
      async optionsChanged() {
        if (this.swiperReady) {
          const swiper = await this.getSwiper();
          if (swiper === null || swiper === void 0 ? void 0 : swiper.params) {
            Object.assign(swiper.params, this.options);
            await this.update();
          }
        }
      }
      componentWillLoad() {
        console.warn(
          `[Deprecation Warning]: ion-slides has been deprecated and will be removed in Ionic Framework v7.0. We recommend using the framework-specific integrations that Swiper.js provides, allowing for faster bug fixes and an improved developer experience. See https://ionicframework.com/docs/api/slides#migration for more information including migration steps.`,
        );
      }
      connectedCallback() {
        // tslint:disable-next-line: strict-type-predicates
        if (typeof MutationObserver !== 'undefined') {
          const mut = (this.mutationO = new MutationObserver(() => {
            if (this.swiperReady) {
              this.update();
            }
          }));
          mut.observe(this.el, {
            childList: true,
            subtree: true,
          });
          componentOnReady(this.el, () => {
            if (!this.didInit) {
              this.didInit = true;
              this.initSwiper();
            }
          });
        }
      }
      disconnectedCallback() {
        if (this.mutationO) {
          this.mutationO.disconnect();
          this.mutationO = undefined;
        }
        /**
         * We need to synchronously destroy
         * swiper otherwise it is possible
         * that it will be left in a
         * destroyed state if connectedCallback
         * is called multiple times
         */
        const swiper = this.syncSwiper;
        if (swiper !== undefined) {
          swiper.destroy(true, true);
          this.swiper = new Promise(resolve => {
            this.readySwiper = resolve;
          });
          this.swiperReady = false;
          this.syncSwiper = undefined;
        }
        this.didInit = false;
      }
      /**
       * Update the underlying slider implementation. Call this if you've added or removed
       * child slides.
       */
      async update() {
        const [swiper] = await Promise.all([this.getSwiper(), waitForSlides(this.el)]);
        swiper.update();
      }
      /**
       * Force swiper to update its height (when autoHeight is enabled) for the duration
       * equal to 'speed' parameter.
       *
       * @param speed The transition duration (in ms).
       */
      async updateAutoHeight(speed) {
        const swiper = await this.getSwiper();
        swiper.updateAutoHeight(speed);
      }
      /**
       * Transition to the specified slide.
       *
       * @param index The index of the slide to transition to.
       * @param speed The transition duration (in ms).
       * @param runCallbacks If true, the transition will produce [Transition/SlideChange][Start/End] transition events.
       */
      async slideTo(index, speed, runCallbacks) {
        const swiper = await this.getSwiper();
        swiper.slideTo(index, speed, runCallbacks);
      }
      /**
       * Transition to the next slide.
       *
       * @param speed The transition duration (in ms).
       * @param runCallbacks If true, the transition will produce [Transition/SlideChange][Start/End] transition events.
       */
      async slideNext(speed, runCallbacks) {
        const swiper = await this.getSwiper();
        swiper.slideNext(speed, runCallbacks);
      }
      /**
       * Transition to the previous slide.
       *
       * @param speed The transition duration (in ms).
       * @param runCallbacks If true, the transition will produce the [Transition/SlideChange][Start/End] transition events.
       */
      async slidePrev(speed, runCallbacks) {
        const swiper = await this.getSwiper();
        swiper.slidePrev(speed, runCallbacks);
      }
      /**
       * Get the index of the active slide.
       */
      async getActiveIndex() {
        const swiper = await this.getSwiper();
        return swiper.activeIndex;
      }
      /**
       * Get the index of the previous slide.
       */
      async getPreviousIndex() {
        const swiper = await this.getSwiper();
        return swiper.previousIndex;
      }
      /**
       * Get the total number of slides.
       */
      async length() {
        const swiper = await this.getSwiper();
        return swiper.slides.length;
      }
      /**
       * Get whether or not the current slide is the last slide.
       */
      async isEnd() {
        const swiper = await this.getSwiper();
        return swiper.isEnd;
      }
      /**
       * Get whether or not the current slide is the first slide.
       */
      async isBeginning() {
        const swiper = await this.getSwiper();
        return swiper.isBeginning;
      }
      /**
       * Start auto play.
       */
      async startAutoplay() {
        const swiper = await this.getSwiper();
        if (swiper.autoplay) {
          swiper.autoplay.start();
        }
      }
      /**
       * Stop auto play.
       */
      async stopAutoplay() {
        const swiper = await this.getSwiper();
        if (swiper.autoplay) {
          swiper.autoplay.stop();
        }
      }
      /**
       * Lock or unlock the ability to slide to the next slide.
       *
       * @param lock If `true`, disable swiping to the next slide.
       */
      async lockSwipeToNext(lock) {
        const swiper = await this.getSwiper();
        swiper.allowSlideNext = !lock;
      }
      /**
       * Lock or unlock the ability to slide to the previous slide.
       *
       * @param lock If `true`, disable swiping to the previous slide.
       */
      async lockSwipeToPrev(lock) {
        const swiper = await this.getSwiper();
        swiper.allowSlidePrev = !lock;
      }
      /**
       * Lock or unlock the ability to slide to the next or previous slide.
       *
       * @param lock If `true`, disable swiping to the next and previous slide.
       */
      async lockSwipes(lock) {
        const swiper = await this.getSwiper();
        swiper.allowSlideNext = !lock;
        swiper.allowSlidePrev = !lock;
        swiper.allowTouchMove = !lock;
      }
      /**
       * Get the Swiper instance.
       * Use this to access the full Swiper API.
       * See https://idangero.us/swiper/api/ for all API options.
       */
      async getSwiper() {
        return this.swiper;
      }
      async initSwiper() {
        const finalOptions = this.normalizeOptions();
        // init swiper core
        // @ts-ignore
        const { Swiper } = await Promise.resolve().then(function () {
          return swiper_bundle;
        });
        await waitForSlides(this.el);
        const swiper = new Swiper(this.el, finalOptions);
        this.swiperReady = true;
        this.syncSwiper = swiper;
        this.readySwiper(swiper);
      }
      normalizeOptions() {
        // Base options, can be changed
        // TODO Add interface SwiperOptions
        const swiperOptions = {
          effect: undefined,
          direction: 'horizontal',
          initialSlide: 0,
          loop: false,
          parallax: false,
          slidesPerView: 1,
          spaceBetween: 0,
          speed: 300,
          slidesPerColumn: 1,
          slidesPerColumnFill: 'column',
          slidesPerGroup: 1,
          centeredSlides: false,
          slidesOffsetBefore: 0,
          slidesOffsetAfter: 0,
          touchEventsTarget: 'container',
          autoplay: false,
          freeMode: false,
          freeModeMomentum: true,
          freeModeMomentumRatio: 1,
          freeModeMomentumBounce: true,
          freeModeMomentumBounceRatio: 1,
          freeModeMomentumVelocityRatio: 1,
          freeModeSticky: false,
          freeModeMinimumVelocity: 0.02,
          autoHeight: false,
          setWrapperSize: false,
          zoom: {
            maxRatio: 3,
            minRatio: 1,
            toggle: false,
          },
          touchRatio: 1,
          touchAngle: 45,
          simulateTouch: true,
          touchStartPreventDefault: false,
          shortSwipes: true,
          longSwipes: true,
          longSwipesRatio: 0.5,
          longSwipesMs: 300,
          followFinger: true,
          threshold: 0,
          touchMoveStopPropagation: true,
          touchReleaseOnEdges: false,
          iOSEdgeSwipeDetection: false,
          iOSEdgeSwipeThreshold: 20,
          resistance: true,
          resistanceRatio: 0.85,
          watchSlidesProgress: false,
          watchSlidesVisibility: false,
          preventClicks: true,
          preventClicksPropagation: true,
          slideToClickedSlide: false,
          loopAdditionalSlides: 0,
          noSwiping: true,
          runCallbacksOnInit: true,
          coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            modifier: 1,
            slideShadows: true,
          },
          flipEffect: {
            slideShadows: true,
            limitRotation: true,
          },
          cubeEffect: {
            slideShadows: true,
            shadow: true,
            shadowOffset: 20,
            shadowScale: 0.94,
          },
          fadeEffect: {
            crossFade: false,
          },
          a11y: {
            prevSlideMessage: 'Previous slide',
            nextSlideMessage: 'Next slide',
            firstSlideMessage: 'This is the first slide',
            lastSlideMessage: 'This is the last slide',
          },
        };
        if (this.pager) {
          swiperOptions.pagination = {
            el: this.paginationEl,
            type: 'bullets',
            clickable: false,
            hideOnClick: false,
          };
        }
        if (this.scrollbar) {
          swiperOptions.scrollbar = {
            el: this.scrollbarEl,
            hide: true,
          };
        }
        // Keep the event options separate, we dont want users
        // overwriting these
        const eventOptions = {
          on: {
            init: () => {
              setTimeout(() => {
                this.ionSlidesDidLoad.emit();
              }, 20);
            },
            slideChangeTransitionStart: this.ionSlideWillChange.emit,
            slideChangeTransitionEnd: this.ionSlideDidChange.emit,
            slideNextTransitionStart: this.ionSlideNextStart.emit,
            slidePrevTransitionStart: this.ionSlidePrevStart.emit,
            slideNextTransitionEnd: this.ionSlideNextEnd.emit,
            slidePrevTransitionEnd: this.ionSlidePrevEnd.emit,
            transitionStart: this.ionSlideTransitionStart.emit,
            transitionEnd: this.ionSlideTransitionEnd.emit,
            sliderMove: this.ionSlideDrag.emit,
            reachBeginning: this.ionSlideReachStart.emit,
            reachEnd: this.ionSlideReachEnd.emit,
            touchStart: this.ionSlideTouchStart.emit,
            touchEnd: this.ionSlideTouchEnd.emit,
            tap: this.ionSlideTap.emit,
            doubleTap: this.ionSlideDoubleTap.emit,
          },
        };
        const customEvents = !!this.options && !!this.options.on ? this.options.on : {};
        // merge "on" event listeners, while giving our event listeners priority
        const mergedEventOptions = { on: Object.assign(Object.assign({}, customEvents), eventOptions.on) };
        // Merge the base, user options, and events together then pas to swiper
        return Object.assign(Object.assign(Object.assign({}, swiperOptions), this.options), mergedEventOptions);
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: {
              [`${mode}`]: true,
              // Used internally for styling
              [`slides-${mode}`]: true,
              'swiper-container': true,
            },
          },
          hAsync('div', { class: 'swiper-wrapper' }, hAsync('slot', null)),
          this.pager && hAsync('div', { class: 'swiper-pagination', ref: el => (this.paginationEl = el) }),
          this.scrollbar && hAsync('div', { class: 'swiper-scrollbar', ref: el => (this.scrollbarEl = el) }),
        );
      }
      static get assetsDirs() {
        return ['swiper'];
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          options: ['optionsChanged'],
        };
      }
      static get style() {
        return {
          ios: slidesIosCss,
          md: slidesMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 36,
          $tagName$: 'ion-slides',
          $members$: {
            options: [8],
            pager: [4],
            scrollbar: [4],
            update: [64],
            updateAutoHeight: [64],
            slideTo: [64],
            slideNext: [64],
            slidePrev: [64],
            getActiveIndex: [64],
            getPreviousIndex: [64],
            length: [64],
            isEnd: [64],
            isBeginning: [64],
            startAutoplay: [64],
            stopAutoplay: [64],
            lockSwipeToNext: [64],
            lockSwipeToPrev: [64],
            lockSwipes: [64],
            getSwiper: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const waitForSlides = el => {
      return Promise.all(Array.from(el.querySelectorAll('ion-slide')).map(s => new Promise(resolve => componentOnReady(s, resolve))));
    };

    const spinnerCss =
      '/*!@:host*/.sc-ion-spinner-h{display:inline-block;position:relative;width:28px;height:28px;color:var(--color);user-select:none}/*!@:host(.ion-color)*/.ion-color.sc-ion-spinner-h{color:var(--ion-color-base)}/*!@svg*/svg.sc-ion-spinner{left:0;top:0;transform-origin:center;position:absolute;width:100%;height:100%;transform:translateZ(0)}/*!@[dir=rtl] svg, :host-context([dir=rtl]) svg*/[dir=rtl].sc-ion-spinner svg.sc-ion-spinner,[dir=rtl].sc-ion-spinner-h svg.sc-ion-spinner,[dir=rtl] .sc-ion-spinner-h svg.sc-ion-spinner{left:unset;right:unset;right:0}/*!@[dir=rtl] svg, :host-context([dir=rtl]) svg*/[dir=rtl].sc-ion-spinner svg.sc-ion-spinner,[dir=rtl].sc-ion-spinner-h svg.sc-ion-spinner,[dir=rtl] .sc-ion-spinner-h svg.sc-ion-spinner{transform-origin:calc(100% - center)}/*!@:host(.spinner-lines) line,\n:host(.spinner-lines-small) line*/.spinner-lines.sc-ion-spinner-h line.sc-ion-spinner,.spinner-lines-small.sc-ion-spinner-h line.sc-ion-spinner{stroke-width:4px;stroke-linecap:round;stroke:currentColor}/*!@:host(.spinner-lines) svg,\n:host(.spinner-lines-small) svg*/.spinner-lines.sc-ion-spinner-h svg.sc-ion-spinner,.spinner-lines-small.sc-ion-spinner-h svg.sc-ion-spinner{animation:spinner-fade-out 1s linear infinite}/*!@:host(.spinner-bubbles) svg*/.spinner-bubbles.sc-ion-spinner-h svg.sc-ion-spinner{animation:spinner-scale-out 1s linear infinite;fill:currentColor}/*!@:host(.spinner-circles) svg*/.spinner-circles.sc-ion-spinner-h svg.sc-ion-spinner{animation:spinner-fade-out 1s linear infinite;fill:currentColor}/*!@:host(.spinner-crescent) circle*/.spinner-crescent.sc-ion-spinner-h circle.sc-ion-spinner{fill:transparent;stroke-width:4px;stroke-dasharray:128px;stroke-dashoffset:82px;stroke:currentColor}/*!@:host(.spinner-crescent) svg*/.spinner-crescent.sc-ion-spinner-h svg.sc-ion-spinner{animation:spinner-rotate 1s linear infinite}/*!@:host(.spinner-dots) circle*/.spinner-dots.sc-ion-spinner-h circle.sc-ion-spinner{stroke-width:0;fill:currentColor}/*!@:host(.spinner-dots) svg*/.spinner-dots.sc-ion-spinner-h svg.sc-ion-spinner{animation:spinner-dots 1s linear infinite}/*!@:host(.spinner-circular)*/.spinner-circular.sc-ion-spinner-h{animation:spinner-circular linear infinite}/*!@:host(.spinner-circular) circle*/.spinner-circular.sc-ion-spinner-h circle.sc-ion-spinner{animation:spinner-circular-inner ease-in-out infinite;stroke:currentColor;stroke-dasharray:80px, 200px;stroke-dashoffset:0px;stroke-width:5.6;fill:none}/*!@:host(.spinner-paused),\n:host(.spinner-paused) svg,\n:host(.spinner-paused) circle*/.spinner-paused.sc-ion-spinner-h,.spinner-paused.sc-ion-spinner-h svg.sc-ion-spinner,.spinner-paused.sc-ion-spinner-h circle.sc-ion-spinner{animation-play-state:paused}@keyframes spinner-fade-out{0%{opacity:1}100%{opacity:0}}@keyframes spinner-scale-out{0%{transform:scale(1, 1)}100%{transform:scale(0, 0)}}@keyframes spinner-rotate{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes spinner-dots{0%{transform:scale(1, 1);opacity:0.9}50%{transform:scale(0.4, 0.4);opacity:0.3}100%{transform:scale(1, 1);opacity:0.9}}@keyframes spinner-circular{100%{transform:rotate(360deg)}}@keyframes spinner-circular-inner{0%{stroke-dasharray:1px, 200px;stroke-dashoffset:0px}50%{stroke-dasharray:100px, 200px;stroke-dashoffset:-15px}100%{stroke-dasharray:100px, 200px;stroke-dashoffset:-125px}}';

    class Spinner {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        /**
         * If `true`, the spinner's animation will be paused.
         */
        this.paused = false;
      }
      getName() {
        const spinnerName = this.name || config$2.get('spinner');
        const mode = getIonMode$1(this);
        if (spinnerName) {
          return spinnerName;
        }
        return mode === 'ios' ? 'lines' : 'circular';
      }
      render() {
        const self = this;
        const mode = getIonMode$1(self);
        const spinnerName = self.getName();
        const spinner = SPINNERS[spinnerName] || SPINNERS['lines'];
        const duration = typeof self.duration === 'number' && self.duration > 10 ? self.duration : spinner.dur;
        const svgs = [];
        if (spinner.circles !== undefined) {
          for (let i = 0; i < spinner.circles; i++) {
            svgs.push(buildCircle(spinner, duration, i, spinner.circles));
          }
        } else if (spinner.lines !== undefined) {
          for (let i = 0; i < spinner.lines; i++) {
            svgs.push(buildLine(spinner, duration, i, spinner.lines));
          }
        }
        return hAsync(
          Host,
          {
            class: createColorClasses$1(self.color, {
              [mode]: true,
              [`spinner-${spinnerName}`]: true,
              'spinner-paused': !!self.paused || config$2.getBoolean('_testing'),
            }),
            role: 'progressbar',
            style: spinner.elmDuration ? { animationDuration: duration + 'ms' } : {},
          },
          svgs,
        );
      }
      static get style() {
        return spinnerCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-spinner',
          $members$: {
            color: [513],
            duration: [2],
            name: [1],
            paused: [4],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }
    const buildCircle = (spinner, duration, index, total) => {
      const data = spinner.fn(duration, index, total);
      data.style['animation-duration'] = duration + 'ms';
      return hAsync(
        'svg',
        { viewBox: data.viewBox || '0 0 64 64', style: data.style },
        hAsync('circle', {
          transform: data.transform || 'translate(32,32)',
          cx: data.cx,
          cy: data.cy,
          r: data.r,
          style: spinner.elmDuration ? { animationDuration: duration + 'ms' } : {},
        }),
      );
    };
    const buildLine = (spinner, duration, index, total) => {
      const data = spinner.fn(duration, index, total);
      data.style['animation-duration'] = duration + 'ms';
      return hAsync('svg', { viewBox: data.viewBox || '0 0 64 64', style: data.style }, hAsync('line', { transform: 'translate(32,32)', y1: data.y1, y2: data.y2 }));
    };

    const splitPaneIosCss =
      '/*!@:host*/.sc-ion-split-pane-ios-h{--side-width:100%;left:0;right:0;top:0;bottom:0;display:flex;position:absolute;flex-direction:row;flex-wrap:nowrap;contain:strict}/*!@::slotted(ion-menu.menu-pane-visible)*/.sc-ion-split-pane-ios-s>ion-menu.menu-pane-visible{flex:0 1 auto;width:var(--side-width);min-width:var(--side-min-width);max-width:var(--side-max-width)}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side),\n:host(.split-pane-visible) ::slotted(.split-pane-main)*/.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>.split-pane-side,.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>.split-pane-main{left:0;right:0;top:0;bottom:0;position:relative;box-shadow:none !important;z-index:0}/*!@:host(.split-pane-visible) ::slotted(.split-pane-main)*/.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>.split-pane-main{flex:1}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side:not(ion-menu)),\n:host(.split-pane-visible) ::slotted(ion-menu.split-pane-side.menu-enabled)*/.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>.split-pane-side:not(ion-menu),.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>ion-menu.split-pane-side.menu-enabled{display:flex;flex-shrink:0}/*!@::slotted(.split-pane-side:not(ion-menu))*/.sc-ion-split-pane-ios-s>.split-pane-side:not(ion-menu){display:none}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side)*/.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>.split-pane-side{order:-1}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side[side=end])*/.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>.split-pane-side[side=end]{order:1}/*!@:host*/.sc-ion-split-pane-ios-h{--border:0.55px solid var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-250, #c8c7cc)));--side-min-width:270px;--side-max-width:28%}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side)*/.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>.split-pane-side{border-left:0;border-right:var(--border);border-top:0;border-bottom:0;min-width:var(--side-min-width);max-width:var(--side-max-width)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.split-pane-visible) ::slotted(.split-pane-side)*/.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>.split-pane-side{border-left:unset;border-right:unset;-webkit-border-start:0;border-inline-start:0;-webkit-border-end:var(--border);border-inline-end:var(--border)}}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side[side=end])*/.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>.split-pane-side[side=end]{border-left:var(--border);border-right:0;border-top:0;border-bottom:0;min-width:var(--side-min-width);max-width:var(--side-max-width)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.split-pane-visible) ::slotted(.split-pane-side[side=end])*/.sc-ion-split-pane-ios-h.split-pane-visible .sc-ion-split-pane-ios-s>.split-pane-side[side=end]{border-left:unset;border-right:unset;-webkit-border-start:var(--border);border-inline-start:var(--border);-webkit-border-end:0;border-inline-end:0}}';

    const splitPaneMdCss =
      '/*!@:host*/.sc-ion-split-pane-md-h{--side-width:100%;left:0;right:0;top:0;bottom:0;display:flex;position:absolute;flex-direction:row;flex-wrap:nowrap;contain:strict}/*!@::slotted(ion-menu.menu-pane-visible)*/.sc-ion-split-pane-md-s>ion-menu.menu-pane-visible{flex:0 1 auto;width:var(--side-width);min-width:var(--side-min-width);max-width:var(--side-max-width)}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side),\n:host(.split-pane-visible) ::slotted(.split-pane-main)*/.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>.split-pane-side,.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>.split-pane-main{left:0;right:0;top:0;bottom:0;position:relative;box-shadow:none !important;z-index:0}/*!@:host(.split-pane-visible) ::slotted(.split-pane-main)*/.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>.split-pane-main{flex:1}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side:not(ion-menu)),\n:host(.split-pane-visible) ::slotted(ion-menu.split-pane-side.menu-enabled)*/.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>.split-pane-side:not(ion-menu),.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>ion-menu.split-pane-side.menu-enabled{display:flex;flex-shrink:0}/*!@::slotted(.split-pane-side:not(ion-menu))*/.sc-ion-split-pane-md-s>.split-pane-side:not(ion-menu){display:none}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side)*/.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>.split-pane-side{order:-1}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side[side=end])*/.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>.split-pane-side[side=end]{order:1}/*!@:host*/.sc-ion-split-pane-md-h{--border:1px solid var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));--side-min-width:270px;--side-max-width:28%}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side)*/.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>.split-pane-side{border-left:0;border-right:var(--border);border-top:0;border-bottom:0;min-width:var(--side-min-width);max-width:var(--side-max-width)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.split-pane-visible) ::slotted(.split-pane-side)*/.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>.split-pane-side{border-left:unset;border-right:unset;-webkit-border-start:0;border-inline-start:0;-webkit-border-end:var(--border);border-inline-end:var(--border)}}/*!@:host(.split-pane-visible) ::slotted(.split-pane-side[side=end])*/.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>.split-pane-side[side=end]{border-left:var(--border);border-right:0;border-top:0;border-bottom:0;min-width:var(--side-min-width);max-width:var(--side-max-width)}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.split-pane-visible) ::slotted(.split-pane-side[side=end])*/.sc-ion-split-pane-md-h.split-pane-visible .sc-ion-split-pane-md-s>.split-pane-side[side=end]{border-left:unset;border-right:unset;-webkit-border-start:var(--border);border-inline-start:var(--border);-webkit-border-end:0;border-inline-end:0}}';

    const SPLIT_PANE_SIDE = 'split-pane-side';
    const QUERY = {
      xs: '(min-width: 0px)',
      sm: '(min-width: 576px)',
      md: '(min-width: 768px)',
      lg: '(min-width: 992px)',
      xl: '(min-width: 1200px)',
      never: '',
    };
    class SplitPane {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionSplitPaneVisible = createEvent(this, 'ionSplitPaneVisible', 7);
        this.visible = false;
        /**
         * If `true`, the split pane will be hidden.
         */
        this.disabled = false;
        /**
         * When the split-pane should be shown.
         * Can be a CSS media query expression, or a shortcut expression.
         * Can also be a boolean expression.
         */
        this.when = QUERY['lg'];
      }
      visibleChanged(visible) {
        const detail = { visible, isPane: this.isPane.bind(this) };
        this.ionSplitPaneVisible.emit(detail);
      }
      connectedCallback() {
        this.styleChildren();
        this.updateState();
      }
      disconnectedCallback() {
        if (this.rmL) {
          this.rmL();
          this.rmL = undefined;
        }
      }
      updateState() {
        {
          return;
        }
      }
      isPane(element) {
        if (!this.visible) {
          return false;
        }
        return element.parentElement === this.el && element.classList.contains(SPLIT_PANE_SIDE);
      }
      styleChildren() {
        {
          return;
        }
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: {
              [mode]: true,
              // Used internally for styling
              [`split-pane-${mode}`]: true,
              'split-pane-visible': this.visible,
            },
          },
          hAsync('slot', null),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          visible: ['visibleChanged'],
          disabled: ['updateState'],
          when: ['updateState'],
        };
      }
      static get style() {
        return {
          ios: splitPaneIosCss,
          md: splitPaneMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-split-pane',
          $members$: {
            contentId: [513, 'content-id'],
            disabled: [4],
            when: [8],
            visible: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['contentId', 'content-id']],
        };
      }
    }

    const tabCss = '/*!@:host(.tab-hidden)*/.tab-hidden.sc-ion-tab-h{display:none !important}';

    class Tab {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.loaded = false;
        /** @internal */
        this.active = false;
      }
      async componentWillLoad() {
        if (this.active) {
          await this.setActive();
        }
      }
      /** Set the active component for the tab */
      async setActive() {
        await this.prepareLazyLoaded();
        this.active = true;
      }
      changeActive(isActive) {
        if (isActive) {
          this.prepareLazyLoaded();
        }
      }
      prepareLazyLoaded() {
        if (!this.loaded && this.component != null) {
          this.loaded = true;
          try {
            return attachComponent(this.delegate, this.el, this.component, ['ion-page']);
          } catch (e) {
            console.error(e);
          }
        }
        return Promise.resolve(undefined);
      }
      render() {
        const { tab, active, component } = this;
        return hAsync(
          Host,
          {
            'role': 'tabpanel',
            'aria-hidden': !active ? 'true' : null,
            'aria-labelledby': `tab-button-${tab}`,
            'class': {
              'ion-page': component === undefined,
              'tab-hidden': !active,
            },
          },
          hAsync('slot', null),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          active: ['changeActive'],
        };
      }
      static get style() {
        return tabCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-tab',
          $members$: {
            active: [1028],
            delegate: [16],
            tab: [1],
            component: [1],
            setActive: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const tabBarIosCss =
      '/*!@:host*/.sc-ion-tab-bar-ios-h{padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:flex;align-items:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;user-select:none;z-index:10;box-sizing:content-box !important}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-tab-bar-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}/*!@:host(.ion-color) ::slotted(ion-tab-button)*/.sc-ion-tab-bar-ios-h.ion-color .sc-ion-tab-bar-ios-s>ion-tab-button{--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}/*!@:host(.ion-color) ::slotted(.tab-selected)*/.sc-ion-tab-bar-ios-h.ion-color .sc-ion-tab-bar-ios-s>.tab-selected{color:var(--ion-color-contrast)}/*!@:host(.ion-color),\n:host(.ion-color) ::slotted(ion-tab-button)*/.ion-color.sc-ion-tab-bar-ios-h,.sc-ion-tab-bar-ios-h.ion-color .sc-ion-tab-bar-ios-s>ion-tab-button{color:rgba(var(--ion-color-contrast-rgb), 0.7)}/*!@:host(.ion-color),\n:host(.ion-color) ::slotted(ion-tab-button)*/.ion-color.sc-ion-tab-bar-ios-h,.sc-ion-tab-bar-ios-h.ion-color .sc-ion-tab-bar-ios-s>ion-tab-button{background:var(--ion-color-base)}/*!@:host(.ion-color) ::slotted(ion-tab-button.ion-focused),\n:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused)*/.sc-ion-tab-bar-ios-h.ion-color .sc-ion-tab-bar-ios-s>ion-tab-button.ion-focused,.sc-ion-tab-bar-ios-h.tab-bar-translucent .sc-ion-tab-bar-ios-s>ion-tab-button.ion-focused{background:var(--background-focused)}/*!@:host(.tab-bar-translucent) ::slotted(ion-tab-button)*/.sc-ion-tab-bar-ios-h.tab-bar-translucent .sc-ion-tab-bar-ios-s>ion-tab-button{background:transparent}/*!@:host([slot=top])*/[slot=top].sc-ion-tab-bar-ios-h{padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}/*!@:host(.tab-bar-hidden)*/.tab-bar-hidden.sc-ion-tab-bar-ios-h{display:none !important}/*!@:host*/.sc-ion-tab-bar-ios-h{--background:var(--ion-tab-bar-background, var(--ion-background-color, #fff));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:0.55px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--color:var(--ion-tab-bar-color, var(--ion-color-step-400, #999999));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:50px}@supports (backdrop-filter: blur(0)){/*!@:host(.tab-bar-translucent)*/.tab-bar-translucent.sc-ion-tab-bar-ios-h{--background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);backdrop-filter:saturate(210%) blur(20px)}/*!@:host(.ion-color.tab-bar-translucent)*/.ion-color.tab-bar-translucent.sc-ion-tab-bar-ios-h{background:rgba(var(--ion-color-base-rgb), 0.8)}/*!@:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused)*/.sc-ion-tab-bar-ios-h.tab-bar-translucent .sc-ion-tab-bar-ios-s>ion-tab-button.ion-focused{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.6)}}';

    const tabBarMdCss =
      '/*!@:host*/.sc-ion-tab-bar-md-h{padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:flex;align-items:center;justify-content:center;width:auto;padding-bottom:var(--ion-safe-area-bottom, 0);border-top:var(--border);background:var(--background);color:var(--color);text-align:center;contain:strict;user-select:none;z-index:10;box-sizing:content-box !important}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-tab-bar-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}/*!@:host(.ion-color) ::slotted(ion-tab-button)*/.sc-ion-tab-bar-md-h.ion-color .sc-ion-tab-bar-md-s>ion-tab-button{--background-focused:var(--ion-color-shade);--color-selected:var(--ion-color-contrast)}/*!@:host(.ion-color) ::slotted(.tab-selected)*/.sc-ion-tab-bar-md-h.ion-color .sc-ion-tab-bar-md-s>.tab-selected{color:var(--ion-color-contrast)}/*!@:host(.ion-color),\n:host(.ion-color) ::slotted(ion-tab-button)*/.ion-color.sc-ion-tab-bar-md-h,.sc-ion-tab-bar-md-h.ion-color .sc-ion-tab-bar-md-s>ion-tab-button{color:rgba(var(--ion-color-contrast-rgb), 0.7)}/*!@:host(.ion-color),\n:host(.ion-color) ::slotted(ion-tab-button)*/.ion-color.sc-ion-tab-bar-md-h,.sc-ion-tab-bar-md-h.ion-color .sc-ion-tab-bar-md-s>ion-tab-button{background:var(--ion-color-base)}/*!@:host(.ion-color) ::slotted(ion-tab-button.ion-focused),\n:host(.tab-bar-translucent) ::slotted(ion-tab-button.ion-focused)*/.sc-ion-tab-bar-md-h.ion-color .sc-ion-tab-bar-md-s>ion-tab-button.ion-focused,.sc-ion-tab-bar-md-h.tab-bar-translucent .sc-ion-tab-bar-md-s>ion-tab-button.ion-focused{background:var(--background-focused)}/*!@:host(.tab-bar-translucent) ::slotted(ion-tab-button)*/.sc-ion-tab-bar-md-h.tab-bar-translucent .sc-ion-tab-bar-md-s>ion-tab-button{background:transparent}/*!@:host([slot=top])*/[slot=top].sc-ion-tab-bar-md-h{padding-top:var(--ion-safe-area-top, 0);padding-bottom:0;border-top:0;border-bottom:var(--border)}/*!@:host(.tab-bar-hidden)*/.tab-bar-hidden.sc-ion-tab-bar-md-h{display:none !important}/*!@:host*/.sc-ion-tab-bar-md-h{--background:var(--ion-tab-bar-background, var(--ion-background-color, #fff));--background-focused:var(--ion-tab-bar-background-focused, #e0e0e0);--border:1px solid var(--ion-tab-bar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.07))));--color:var(--ion-tab-bar-color, var(--ion-color-step-600, #666666));--color-selected:var(--ion-tab-bar-color-selected, var(--ion-color-primary, #3880ff));height:56px}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class TabBar {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionTabBarChanged = createEvent(this, 'ionTabBarChanged', 7);
        this.keyboardVisible = false;
        /**
         * If `true`, the tab bar will be translucent.
         * Only applies when the mode is `"ios"` and the device supports
         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
         */
        this.translucent = false;
      }
      selectedTabChanged() {
        if (this.selectedTab !== undefined) {
          this.ionTabBarChanged.emit({
            tab: this.selectedTab,
          });
        }
      }
      componentWillLoad() {
        this.selectedTabChanged();
      }
      connectedCallback() {
        if (typeof window !== 'undefined') {
          this.keyboardWillShowHandler = () => {
            if (this.el.getAttribute('slot') !== 'top') {
              this.keyboardVisible = true;
            }
          };
          this.keyboardWillHideHandler = () => {
            setTimeout(() => (this.keyboardVisible = false), 50);
          };
          window.addEventListener('keyboardWillShow', this.keyboardWillShowHandler);
          window.addEventListener('keyboardWillHide', this.keyboardWillHideHandler);
        }
      }
      disconnectedCallback() {
        if (typeof window !== 'undefined') {
          window.removeEventListener('keyboardWillShow', this.keyboardWillShowHandler);
          window.removeEventListener('keyboardWillHide', this.keyboardWillHideHandler);
          this.keyboardWillShowHandler = this.keyboardWillHideHandler = undefined;
        }
      }
      render() {
        const { color, translucent, keyboardVisible } = this;
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            'role': 'tablist',
            'aria-hidden': keyboardVisible ? 'true' : null,
            'class': createColorClasses$1(color, {
              [mode]: true,
              'tab-bar-translucent': translucent,
              'tab-bar-hidden': keyboardVisible,
            }),
          },
          hAsync('slot', null),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          selectedTab: ['selectedTabChanged'],
        };
      }
      static get style() {
        return {
          ios: tabBarIosCss,
          md: tabBarMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-tab-bar',
          $members$: {
            color: [513],
            selectedTab: [1, 'selected-tab'],
            translucent: [4],
            keyboardVisible: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const tabButtonIosCss =
      '/*!@:host*/.sc-ion-tab-button-ios-h{--ripple-color:var(--color-selected);--background-focused-opacity:1;flex:1;flex-direction:column;align-items:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}/*!@.button-native*/.button-native.sc-ion-tab-button-ios{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:flex;position:relative;flex-direction:inherit;align-items:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;box-sizing:border-box;-webkit-user-drag:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-tab-button-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.button-native::after*/.button-native.sc-ion-tab-button-ios::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}/*!@.button-inner*/.button-inner.sc-ion-tab-button-ios{display:flex;position:relative;flex-flow:inherit;align-items:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-tab-button-ios-h .button-native.sc-ion-tab-button-ios{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-tab-button-ios-h .button-native.sc-ion-tab-button-ios::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){/*!@a:hover*/a.sc-ion-tab-button-ios:hover{color:var(--color-selected)}}/*!@:host(.tab-selected)*/.tab-selected.sc-ion-tab-button-ios-h{color:var(--color-selected)}/*!@:host(.tab-hidden)*/.tab-hidden.sc-ion-tab-button-ios-h{display:none !important}/*!@:host(.tab-disabled)*/.tab-disabled.sc-ion-tab-button-ios-h{pointer-events:none;opacity:0.4}/*!@::slotted(ion-label),\n::slotted(ion-icon)*/.sc-ion-tab-button-ios-s>ion-label,.sc-ion-tab-button-ios-s>ion-icon{display:block;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;box-sizing:border-box}/*!@::slotted(ion-label)*/.sc-ion-tab-button-ios-s>ion-label{order:0}/*!@::slotted(ion-icon)*/.sc-ion-tab-button-ios-s>ion-icon{order:-1;height:1em}/*!@:host(.tab-has-label-only) ::slotted(ion-label)*/.sc-ion-tab-button-ios-h.tab-has-label-only .sc-ion-tab-button-ios-s>ion-label{white-space:normal}/*!@::slotted(ion-badge)*/.sc-ion-tab-button-ios-s>ion-badge{box-sizing:border-box;position:absolute;z-index:1}/*!@:host(.tab-layout-icon-start)*/.tab-layout-icon-start.sc-ion-tab-button-ios-h{flex-direction:row}/*!@:host(.tab-layout-icon-end)*/.tab-layout-icon-end.sc-ion-tab-button-ios-h{flex-direction:row-reverse}/*!@:host(.tab-layout-icon-bottom)*/.tab-layout-icon-bottom.sc-ion-tab-button-ios-h{flex-direction:column-reverse}/*!@:host(.tab-layout-icon-hide) ::slotted(ion-icon)*/.sc-ion-tab-button-ios-h.tab-layout-icon-hide .sc-ion-tab-button-ios-s>ion-icon{display:none}/*!@:host(.tab-layout-label-hide) ::slotted(ion-label)*/.sc-ion-tab-button-ios-h.tab-layout-label-hide .sc-ion-tab-button-ios-s>ion-label{display:none}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-tab-button-ios{color:var(--ripple-color)}/*!@:host*/.sc-ion-tab-button-ios-h{--padding-top:0;--padding-end:2px;--padding-bottom:0;--padding-start:2px;max-width:240px;font-size:10px}/*!@::slotted(ion-badge)*/.sc-ion-tab-button-ios-s>ion-badge{padding-left:6px;padding-right:6px;padding-top:1px;padding-bottom:1px;left:calc(50% + 6px);top:4px;height:auto;font-size:12px;line-height:16px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-badge)*/.sc-ion-tab-button-ios-s>ion-badge{padding-left:unset;padding-right:unset;-webkit-padding-start:6px;padding-inline-start:6px;-webkit-padding-end:6px;padding-inline-end:6px}}/*!@[dir=rtl] ::slotted(ion-badge), :host-context([dir=rtl]) ::slotted(ion-badge)*/[dir=rtl] .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h[dir=rtl] .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h .sc-ion-tab-button-ios-s>ion-badge{left:unset;right:unset;right:calc(50% + 6px)}/*!@::slotted(ion-icon)*/.sc-ion-tab-button-ios-s>ion-icon{margin-top:2px;margin-bottom:2px;font-size:30px}/*!@::slotted(ion-icon::before)*/.sc-ion-tab-button-ios-s>ion-icon::before{vertical-align:top}/*!@::slotted(ion-label)*/.sc-ion-tab-button-ios-s>ion-label{margin-top:0;margin-bottom:1px;min-height:11px;font-weight:500}/*!@:host(.tab-has-label-only) ::slotted(ion-label)*/.sc-ion-tab-button-ios-h.tab-has-label-only .sc-ion-tab-button-ios-s>ion-label{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;font-size:12px;font-size:14px;line-height:1.1}/*!@:host(.tab-layout-icon-end) ::slotted(ion-label),\n:host(.tab-layout-icon-start) ::slotted(ion-label),\n:host(.tab-layout-icon-hide) ::slotted(ion-label)*/.sc-ion-tab-button-ios-h.tab-layout-icon-end .sc-ion-tab-button-ios-s>ion-label,.sc-ion-tab-button-ios-h.tab-layout-icon-start .sc-ion-tab-button-ios-s>ion-label,.sc-ion-tab-button-ios-h.tab-layout-icon-hide .sc-ion-tab-button-ios-s>ion-label{margin-top:2px;margin-bottom:2px;font-size:14px;line-height:1.1}/*!@:host(.tab-layout-icon-end) ::slotted(ion-icon),\n:host(.tab-layout-icon-start) ::slotted(ion-icon)*/.sc-ion-tab-button-ios-h.tab-layout-icon-end .sc-ion-tab-button-ios-s>ion-icon,.sc-ion-tab-button-ios-h.tab-layout-icon-start .sc-ion-tab-button-ios-s>ion-icon{min-width:24px;height:26px;margin-top:2px;margin-bottom:1px;font-size:24px}/*!@:host(.tab-layout-icon-bottom) ::slotted(ion-badge)*/.sc-ion-tab-button-ios-h.tab-layout-icon-bottom .sc-ion-tab-button-ios-s>ion-badge{left:calc(50% + 12px)}/*!@:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge), :host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge)*/.sc-ion-tab-button-ios-h[dir=rtl].sc-ion-tab-button-ios-h.tab-layout-icon-bottom .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h.sc-ion-tab-button-ios-h.tab-layout-icon-bottom .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h[dir=rtl].tab-layout-icon-bottom .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h.tab-layout-icon-bottom .sc-ion-tab-button-ios-s>ion-badge{left:unset;right:unset;right:calc(50% + 12px)}/*!@:host(.tab-layout-icon-bottom) ::slotted(ion-icon)*/.sc-ion-tab-button-ios-h.tab-layout-icon-bottom .sc-ion-tab-button-ios-s>ion-icon{margin-top:0;margin-bottom:1px}/*!@:host(.tab-layout-icon-bottom) ::slotted(ion-label)*/.sc-ion-tab-button-ios-h.tab-layout-icon-bottom .sc-ion-tab-button-ios-s>ion-label{margin-top:4px}/*!@:host(.tab-layout-icon-start) ::slotted(ion-badge),\n:host(.tab-layout-icon-end) ::slotted(ion-badge)*/.sc-ion-tab-button-ios-h.tab-layout-icon-start .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h.tab-layout-icon-end .sc-ion-tab-button-ios-s>ion-badge{left:calc(50% + 35px);top:10px}/*!@:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge), :host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge), :host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge), :host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge)*/.sc-ion-tab-button-ios-h[dir=rtl].sc-ion-tab-button-ios-h.tab-layout-icon-start .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h.sc-ion-tab-button-ios-h.tab-layout-icon-start .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h[dir=rtl].tab-layout-icon-start .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h.tab-layout-icon-start .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h[dir=rtl].sc-ion-tab-button-ios-h.tab-layout-icon-end .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h.sc-ion-tab-button-ios-h.tab-layout-icon-end .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h[dir=rtl].tab-layout-icon-end .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h.tab-layout-icon-end .sc-ion-tab-button-ios-s>ion-badge{left:unset;right:unset;right:calc(50% + 35px)}/*!@:host(.tab-layout-icon-hide) ::slotted(ion-badge),\n:host(.tab-has-label-only) ::slotted(ion-badge)*/.sc-ion-tab-button-ios-h.tab-layout-icon-hide .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h.tab-has-label-only .sc-ion-tab-button-ios-s>ion-badge{left:calc(50% + 30px);top:10px}/*!@:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge), :host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge), :host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge), :host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge)*/.sc-ion-tab-button-ios-h[dir=rtl].sc-ion-tab-button-ios-h.tab-layout-icon-hide .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h.sc-ion-tab-button-ios-h.tab-layout-icon-hide .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h[dir=rtl].tab-layout-icon-hide .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h.tab-layout-icon-hide .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h[dir=rtl].sc-ion-tab-button-ios-h.tab-has-label-only .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h.sc-ion-tab-button-ios-h.tab-has-label-only .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h[dir=rtl].tab-has-label-only .sc-ion-tab-button-ios-s>ion-badge,[dir=rtl] .sc-ion-tab-button-ios-h.tab-has-label-only .sc-ion-tab-button-ios-s>ion-badge{left:unset;right:unset;right:calc(50% + 30px)}/*!@:host(.tab-layout-label-hide) ::slotted(ion-badge),\n:host(.tab-has-icon-only) ::slotted(ion-badge)*/.sc-ion-tab-button-ios-h.tab-layout-label-hide .sc-ion-tab-button-ios-s>ion-badge,.sc-ion-tab-button-ios-h.tab-has-icon-only .sc-ion-tab-button-ios-s>ion-badge{top:10px}/*!@:host(.tab-layout-label-hide) ::slotted(ion-icon)*/.sc-ion-tab-button-ios-h.tab-layout-label-hide .sc-ion-tab-button-ios-s>ion-icon{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0}';

    const tabButtonMdCss =
      '/*!@:host*/.sc-ion-tab-button-md-h{--ripple-color:var(--color-selected);--background-focused-opacity:1;flex:1;flex-direction:column;align-items:center;justify-content:center;height:100%;outline:none;background:var(--background);color:var(--color)}/*!@.button-native*/.button-native.sc-ion-tab-button-md{border-radius:inherit;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:flex;position:relative;flex-direction:inherit;align-items:inherit;justify-content:inherit;width:100%;height:100%;border:0;outline:none;background:transparent;text-decoration:none;cursor:pointer;overflow:hidden;box-sizing:border-box;-webkit-user-drag:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.button-native*/.button-native.sc-ion-tab-button-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.button-native::after*/.button-native.sc-ion-tab-button-md::after{left:0;right:0;top:0;bottom:0;position:absolute;content:"";opacity:0}/*!@.button-inner*/.button-inner.sc-ion-tab-button-md{display:flex;position:relative;flex-flow:inherit;align-items:inherit;justify-content:inherit;width:100%;height:100%;z-index:1}/*!@:host(.ion-focused) .button-native*/.ion-focused.sc-ion-tab-button-md-h .button-native.sc-ion-tab-button-md{color:var(--color-focused)}/*!@:host(.ion-focused) .button-native::after*/.ion-focused.sc-ion-tab-button-md-h .button-native.sc-ion-tab-button-md::after{background:var(--background-focused);opacity:var(--background-focused-opacity)}@media (any-hover: hover){/*!@a:hover*/a.sc-ion-tab-button-md:hover{color:var(--color-selected)}}/*!@:host(.tab-selected)*/.tab-selected.sc-ion-tab-button-md-h{color:var(--color-selected)}/*!@:host(.tab-hidden)*/.tab-hidden.sc-ion-tab-button-md-h{display:none !important}/*!@:host(.tab-disabled)*/.tab-disabled.sc-ion-tab-button-md-h{pointer-events:none;opacity:0.4}/*!@::slotted(ion-label),\n::slotted(ion-icon)*/.sc-ion-tab-button-md-s>ion-label,.sc-ion-tab-button-md-s>ion-icon{display:block;align-self:center;max-width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;box-sizing:border-box}/*!@::slotted(ion-label)*/.sc-ion-tab-button-md-s>ion-label{order:0}/*!@::slotted(ion-icon)*/.sc-ion-tab-button-md-s>ion-icon{order:-1;height:1em}/*!@:host(.tab-has-label-only) ::slotted(ion-label)*/.sc-ion-tab-button-md-h.tab-has-label-only .sc-ion-tab-button-md-s>ion-label{white-space:normal}/*!@::slotted(ion-badge)*/.sc-ion-tab-button-md-s>ion-badge{box-sizing:border-box;position:absolute;z-index:1}/*!@:host(.tab-layout-icon-start)*/.tab-layout-icon-start.sc-ion-tab-button-md-h{flex-direction:row}/*!@:host(.tab-layout-icon-end)*/.tab-layout-icon-end.sc-ion-tab-button-md-h{flex-direction:row-reverse}/*!@:host(.tab-layout-icon-bottom)*/.tab-layout-icon-bottom.sc-ion-tab-button-md-h{flex-direction:column-reverse}/*!@:host(.tab-layout-icon-hide) ::slotted(ion-icon)*/.sc-ion-tab-button-md-h.tab-layout-icon-hide .sc-ion-tab-button-md-s>ion-icon{display:none}/*!@:host(.tab-layout-label-hide) ::slotted(ion-label)*/.sc-ion-tab-button-md-h.tab-layout-label-hide .sc-ion-tab-button-md-s>ion-label{display:none}/*!@ion-ripple-effect*/ion-ripple-effect.sc-ion-tab-button-md{color:var(--ripple-color)}/*!@:host*/.sc-ion-tab-button-md-h{--padding-top:0;--padding-end:12px;--padding-bottom:0;--padding-start:12px;max-width:168px;font-size:12px;font-weight:normal;letter-spacing:0.03em}/*!@::slotted(ion-label)*/.sc-ion-tab-button-md-s>ion-label{margin-left:0;margin-right:0;margin-top:2px;margin-bottom:2px;text-transform:none}/*!@::slotted(ion-icon)*/.sc-ion-tab-button-md-s>ion-icon{margin-left:0;margin-right:0;margin-top:16px;margin-bottom:16px;transform-origin:center center;font-size:22px}/*!@[dir=rtl] ::slotted(ion-icon), :host-context([dir=rtl]) ::slotted(ion-icon)*/[dir=rtl] .sc-ion-tab-button-md-s>ion-icon,.sc-ion-tab-button-md-h[dir=rtl] .sc-ion-tab-button-md-s>ion-icon,[dir=rtl] .sc-ion-tab-button-md-h .sc-ion-tab-button-md-s>ion-icon{transform-origin:calc(100% - center) center}/*!@::slotted(ion-badge)*/.sc-ion-tab-button-md-s>ion-badge{border-radius:8px;padding-left:2px;padding-right:2px;padding-top:3px;padding-bottom:2px;left:calc(50% + 6px);top:8px;min-width:12px;font-size:8px;font-weight:normal}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(ion-badge)*/.sc-ion-tab-button-md-s>ion-badge{padding-left:unset;padding-right:unset;-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:2px;padding-inline-end:2px}}/*!@[dir=rtl] ::slotted(ion-badge), :host-context([dir=rtl]) ::slotted(ion-badge)*/[dir=rtl] .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h[dir=rtl] .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h .sc-ion-tab-button-md-s>ion-badge{left:unset;right:unset;right:calc(50% + 6px)}/*!@::slotted(ion-badge:empty)*/.sc-ion-tab-button-md-s>ion-badge:empty{display:block;min-width:8px;height:8px}/*!@:host(.tab-layout-icon-top) ::slotted(ion-icon)*/.sc-ion-tab-button-md-h.tab-layout-icon-top .sc-ion-tab-button-md-s>ion-icon{margin-top:6px;margin-bottom:2px}/*!@:host(.tab-layout-icon-top) ::slotted(ion-label)*/.sc-ion-tab-button-md-h.tab-layout-icon-top .sc-ion-tab-button-md-s>ion-label{margin-top:0;margin-bottom:6px}/*!@:host(.tab-layout-icon-bottom) ::slotted(ion-badge)*/.sc-ion-tab-button-md-h.tab-layout-icon-bottom .sc-ion-tab-button-md-s>ion-badge{left:70%;top:8px}/*!@:host-context([dir=rtl]):host(.tab-layout-icon-bottom) ::slotted(ion-badge), :host-context([dir=rtl]).tab-layout-icon-bottom ::slotted(ion-badge)*/.sc-ion-tab-button-md-h[dir=rtl].sc-ion-tab-button-md-h.tab-layout-icon-bottom .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h.sc-ion-tab-button-md-h.tab-layout-icon-bottom .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h[dir=rtl].tab-layout-icon-bottom .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h.tab-layout-icon-bottom .sc-ion-tab-button-md-s>ion-badge{left:unset;right:unset;right:70%}/*!@:host(.tab-layout-icon-bottom) ::slotted(ion-icon)*/.sc-ion-tab-button-md-h.tab-layout-icon-bottom .sc-ion-tab-button-md-s>ion-icon{margin-top:0;margin-bottom:6px}/*!@:host(.tab-layout-icon-bottom) ::slotted(ion-label)*/.sc-ion-tab-button-md-h.tab-layout-icon-bottom .sc-ion-tab-button-md-s>ion-label{margin-top:6px;margin-bottom:0}/*!@:host(.tab-layout-icon-start) ::slotted(ion-badge),\n:host(.tab-layout-icon-end) ::slotted(ion-badge)*/.sc-ion-tab-button-md-h.tab-layout-icon-start .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h.tab-layout-icon-end .sc-ion-tab-button-md-s>ion-badge{left:80%;top:16px}/*!@:host-context([dir=rtl]):host(.tab-layout-icon-start) ::slotted(ion-badge), :host-context([dir=rtl]).tab-layout-icon-start ::slotted(ion-badge), :host-context([dir=rtl]):host(.tab-layout-icon-end) ::slotted(ion-badge), :host-context([dir=rtl]).tab-layout-icon-end ::slotted(ion-badge)*/.sc-ion-tab-button-md-h[dir=rtl].sc-ion-tab-button-md-h.tab-layout-icon-start .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h.sc-ion-tab-button-md-h.tab-layout-icon-start .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h[dir=rtl].tab-layout-icon-start .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h.tab-layout-icon-start .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h[dir=rtl].sc-ion-tab-button-md-h.tab-layout-icon-end .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h.sc-ion-tab-button-md-h.tab-layout-icon-end .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h[dir=rtl].tab-layout-icon-end .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h.tab-layout-icon-end .sc-ion-tab-button-md-s>ion-badge{left:unset;right:unset;right:80%}/*!@:host(.tab-layout-icon-start) ::slotted(ion-icon)*/.sc-ion-tab-button-md-h.tab-layout-icon-start .sc-ion-tab-button-md-s>ion-icon{margin-right:6px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.tab-layout-icon-start) ::slotted(ion-icon)*/.sc-ion-tab-button-md-h.tab-layout-icon-start .sc-ion-tab-button-md-s>ion-icon{margin-right:unset;-webkit-margin-end:6px;margin-inline-end:6px}}/*!@:host(.tab-layout-icon-end) ::slotted(ion-icon)*/.sc-ion-tab-button-md-h.tab-layout-icon-end .sc-ion-tab-button-md-s>ion-icon{margin-left:6px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.tab-layout-icon-end) ::slotted(ion-icon)*/.sc-ion-tab-button-md-h.tab-layout-icon-end .sc-ion-tab-button-md-s>ion-icon{margin-left:unset;-webkit-margin-start:6px;margin-inline-start:6px}}/*!@:host(.tab-layout-icon-hide) ::slotted(ion-badge),\n:host(.tab-has-label-only) ::slotted(ion-badge)*/.sc-ion-tab-button-md-h.tab-layout-icon-hide .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h.tab-has-label-only .sc-ion-tab-button-md-s>ion-badge{left:70%;top:16px}/*!@:host-context([dir=rtl]):host(.tab-layout-icon-hide) ::slotted(ion-badge), :host-context([dir=rtl]).tab-layout-icon-hide ::slotted(ion-badge), :host-context([dir=rtl]):host(.tab-has-label-only) ::slotted(ion-badge), :host-context([dir=rtl]).tab-has-label-only ::slotted(ion-badge)*/.sc-ion-tab-button-md-h[dir=rtl].sc-ion-tab-button-md-h.tab-layout-icon-hide .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h.sc-ion-tab-button-md-h.tab-layout-icon-hide .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h[dir=rtl].tab-layout-icon-hide .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h.tab-layout-icon-hide .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h[dir=rtl].sc-ion-tab-button-md-h.tab-has-label-only .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h.sc-ion-tab-button-md-h.tab-has-label-only .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h[dir=rtl].tab-has-label-only .sc-ion-tab-button-md-s>ion-badge,[dir=rtl] .sc-ion-tab-button-md-h.tab-has-label-only .sc-ion-tab-button-md-s>ion-badge{left:unset;right:unset;right:70%}/*!@:host(.tab-layout-icon-hide) ::slotted(ion-label),\n:host(.tab-has-label-only) ::slotted(ion-label)*/.sc-ion-tab-button-md-h.tab-layout-icon-hide .sc-ion-tab-button-md-s>ion-label,.sc-ion-tab-button-md-h.tab-has-label-only .sc-ion-tab-button-md-s>ion-label{margin-top:0;margin-bottom:0}/*!@:host(.tab-layout-label-hide) ::slotted(ion-badge),\n:host(.tab-has-icon-only) ::slotted(ion-badge)*/.sc-ion-tab-button-md-h.tab-layout-label-hide .sc-ion-tab-button-md-s>ion-badge,.sc-ion-tab-button-md-h.tab-has-icon-only .sc-ion-tab-button-md-s>ion-badge{top:16px}/*!@:host(.tab-layout-label-hide) ::slotted(ion-icon),\n:host(.tab-has-icon-only) ::slotted(ion-icon)*/.sc-ion-tab-button-md-h.tab-layout-label-hide .sc-ion-tab-button-md-s>ion-icon,.sc-ion-tab-button-md-h.tab-has-icon-only .sc-ion-tab-button-md-s>ion-icon{margin-top:0;margin-bottom:0;font-size:24px}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part native - The native HTML anchor element that wraps all child elements.
     */
    class TabButton {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionTabButtonClick = createEvent(this, 'ionTabButtonClick', 7);
        /**
         * If `true`, the user cannot interact with the tab button.
         */
        this.disabled = false;
        /**
         * The selected tab component
         */
        this.selected = false;
        this.onKeyUp = ev => {
          if (ev.key === 'Enter' || ev.key === ' ') {
            this.selectTab(ev);
          }
        };
        this.onClick = ev => {
          this.selectTab(ev);
        };
      }
      onTabBarChanged(ev) {
        const dispatchedFrom = ev.target;
        const parent = this.el.parentElement;
        if ((ev.composedPath && ev.composedPath().includes(parent)) || (dispatchedFrom && dispatchedFrom.contains(this.el))) {
          this.selected = this.tab === ev.detail.tab;
        }
      }
      componentWillLoad() {
        if (this.layout === undefined) {
          this.layout = config$2.get('tabButtonLayout', 'icon-top');
        }
      }
      selectTab(ev) {
        if (this.tab !== undefined) {
          if (!this.disabled) {
            this.ionTabButtonClick.emit({
              tab: this.tab,
              href: this.href,
              selected: this.selected,
            });
          }
          ev.preventDefault();
        }
      }
      get hasLabel() {
        return !!this.el.querySelector('ion-label');
      }
      get hasIcon() {
        return !!this.el.querySelector('ion-icon');
      }
      get tabIndex() {
        if (this.disabled) {
          return -1;
        }
        const hasTabIndex = this.el.hasAttribute('tabindex');
        if (hasTabIndex) {
          return this.el.getAttribute('tabindex');
        }
        return 0;
      }
      render() {
        const { disabled, hasIcon, hasLabel, tabIndex, href, rel, target, layout, selected, tab } = this;
        const mode = getIonMode$1(this);
        const attrs = {
          download: this.download,
          href,
          rel,
          target,
        };
        return hAsync(
          Host,
          {
            'onClick': this.onClick,
            'onKeyup': this.onKeyUp,
            'role': 'tab',
            'tabindex': tabIndex,
            'aria-selected': selected ? 'true' : null,
            'id': tab !== undefined ? `tab-button-${tab}` : null,
            'class': {
              [mode]: true,
              'tab-selected': selected,
              'tab-disabled': disabled,
              'tab-has-label': hasLabel,
              'tab-has-icon': hasIcon,
              'tab-has-label-only': hasLabel && !hasIcon,
              'tab-has-icon-only': hasIcon && !hasLabel,
              [`tab-layout-${layout}`]: true,
              'ion-activatable': true,
              'ion-selectable': true,
              'ion-focusable': true,
            },
          },
          hAsync(
            'a',
            Object.assign({}, attrs, { tabIndex: -1, class: 'button-native', part: 'native' }),
            hAsync('span', { class: 'button-inner' }, hAsync('slot', null)),
            mode === 'md' && hAsync('ion-ripple-effect', { type: 'unbounded' }),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: tabButtonIosCss,
          md: tabButtonMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-tab-button',
          $members$: {
            disabled: [4],
            download: [1],
            href: [1],
            rel: [1],
            layout: [1025],
            selected: [1028],
            tab: [1],
            target: [1],
          },
          $listeners$: [[8, 'ionTabBarChanged', 'onTabBarChanged']],
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    const tabsCss =
      '/*!@:host*/.sc-ion-tabs-h{left:0;right:0;top:0;bottom:0;display:flex;position:absolute;flex-direction:column;width:100%;height:100%;contain:layout size style;z-index:0}/*!@.tabs-inner*/.tabs-inner.sc-ion-tabs{position:relative;flex:1;contain:layout size style}';

    /**
     * @slot - Content is placed between the named slots if provided without a slot.
     * @slot top - Content is placed at the top of the screen.
     * @slot bottom - Content is placed at the bottom of the screen.
     */
    class Tabs {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionNavWillLoad = createEvent(this, 'ionNavWillLoad', 7);
        this.ionTabsWillChange = createEvent(this, 'ionTabsWillChange', 3);
        this.ionTabsDidChange = createEvent(this, 'ionTabsDidChange', 3);
        this.transitioning = false;
        /** @internal */
        this.useRouter = false;
        this.onTabClicked = ev => {
          const { href, tab } = ev.detail;
          if (this.useRouter && href !== undefined) {
            const router = document.querySelector('ion-router');
            if (router) {
              router.push(href);
            }
          } else {
            this.select(tab);
          }
        };
      }
      async componentWillLoad() {
        if (!this.useRouter) {
          this.useRouter = !!document.querySelector('ion-router') && !this.el.closest('[no-router]');
        }
        if (!this.useRouter) {
          const tabs = this.tabs;
          if (tabs.length > 0) {
            await this.select(tabs[0]);
          }
        }
        this.ionNavWillLoad.emit();
      }
      componentWillRender() {
        const tabBar = this.el.querySelector('ion-tab-bar');
        if (tabBar) {
          const tab = this.selectedTab ? this.selectedTab.tab : undefined;
          tabBar.selectedTab = tab;
        }
      }
      /**
       * Select a tab by the value of its `tab` property or an element reference.
       *
       * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.
       */
      async select(tab) {
        const selectedTab = getTab(this.tabs, tab);
        if (!this.shouldSwitch(selectedTab)) {
          return false;
        }
        await this.setActive(selectedTab);
        await this.notifyRouter();
        this.tabSwitch();
        return true;
      }
      /**
       * Get a specific tab by the value of its `tab` property or an element reference.
       *
       * @param tab The tab instance to select. If passed a string, it should be the value of the tab's `tab` property.
       */
      async getTab(tab) {
        return getTab(this.tabs, tab);
      }
      /**
       * Get the currently selected tab.
       */
      getSelected() {
        return Promise.resolve(this.selectedTab ? this.selectedTab.tab : undefined);
      }
      /** @internal */
      async setRouteId(id) {
        const selectedTab = getTab(this.tabs, id);
        if (!this.shouldSwitch(selectedTab)) {
          return { changed: false, element: this.selectedTab };
        }
        await this.setActive(selectedTab);
        return {
          changed: true,
          element: this.selectedTab,
          markVisible: () => this.tabSwitch(),
        };
      }
      /** @internal */
      async getRouteId() {
        const tabId = this.selectedTab && this.selectedTab.tab;
        return tabId !== undefined ? { id: tabId, element: this.selectedTab } : undefined;
      }
      setActive(selectedTab) {
        if (this.transitioning) {
          return Promise.reject('transitioning already happening');
        }
        this.transitioning = true;
        this.leavingTab = this.selectedTab;
        this.selectedTab = selectedTab;
        this.ionTabsWillChange.emit({ tab: selectedTab.tab });
        selectedTab.active = true;
        return Promise.resolve();
      }
      tabSwitch() {
        const selectedTab = this.selectedTab;
        const leavingTab = this.leavingTab;
        this.leavingTab = undefined;
        this.transitioning = false;
        if (!selectedTab) {
          return;
        }
        if (leavingTab !== selectedTab) {
          if (leavingTab) {
            leavingTab.active = false;
          }
          this.ionTabsDidChange.emit({ tab: selectedTab.tab });
        }
      }
      notifyRouter() {
        if (this.useRouter) {
          const router = document.querySelector('ion-router');
          if (router) {
            return router.navChanged('forward');
          }
        }
        return Promise.resolve(false);
      }
      shouldSwitch(selectedTab) {
        const leavingTab = this.selectedTab;
        return selectedTab !== undefined && selectedTab !== leavingTab && !this.transitioning;
      }
      get tabs() {
        return Array.from(this.el.querySelectorAll('ion-tab'));
      }
      render() {
        return hAsync(
          Host,
          { onIonTabButtonClick: this.onTabClicked },
          hAsync('slot', { name: 'top' }),
          hAsync('div', { class: 'tabs-inner' }, hAsync('slot', null)),
          hAsync('slot', { name: 'bottom' }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return tabsCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-tabs',
          $members$: {
            useRouter: [1028, 'use-router'],
            selectedTab: [32],
            select: [64],
            getTab: [64],
            getSelected: [64],
            setRouteId: [64],
            getRouteId: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const getTab = (tabs, tab) => {
      const tabEl = typeof tab === 'string' ? tabs.find(t => t.tab === tab) : tab;
      if (!tabEl) {
        console.error(`tab with id: "${tabEl}" does not exist`);
      }
      return tabEl;
    };

    const textCss = '/*!@:host(.ion-color)*/.ion-color.sc-ion-text-h{color:var(--ion-color-base)}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Text {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        const mode = getIonMode$1(this);
        return hAsync(
          Host,
          {
            class: createColorClasses$1(this.color, {
              [mode]: true,
            }),
          },
          hAsync('slot', null),
        );
      }
      static get style() {
        return textCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-text',
          $members$: {
            color: [513],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const textareaIosCss =
      '.sc-ion-textarea-ios-h{--background:initial;--color:initial;--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:.5;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--border-radius:0;display:block;position:relative;flex:1;width:100%;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);white-space:pre-wrap;z-index:2;box-sizing:border-box}.ion-color.sc-ion-textarea-ios-h{background:initial}.ion-color.sc-ion-textarea-ios-h{color:var(--ion-color-base)}ion-item.sc-ion-textarea-ios-h,ion-item .sc-ion-textarea-ios-h{align-self:baseline}ion-item.sc-ion-textarea-ios-h:not(.item-label),ion-item:not(.item-label) .sc-ion-textarea-ios-h{--padding-start:0}.textarea-wrapper.sc-ion-textarea-ios{min-width:inherit;max-width:inherit;min-height:inherit;max-height:inherit}.native-textarea.sc-ion-textarea-ios{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;box-sizing:border-box;resize:none;appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.native-textarea.sc-ion-textarea-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.native-textarea.sc-ion-textarea-ios::placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea[disabled].sc-ion-textarea-ios{opacity:0.4}.cloned-input.sc-ion-textarea-ios{left:0;top:0;position:absolute;pointer-events:none}[dir=rtl].sc-ion-textarea-ios .cloned-input.sc-ion-textarea-ios,[dir=rtl].sc-ion-textarea-ios-h .cloned-input.sc-ion-textarea-ios,[dir=rtl] .sc-ion-textarea-ios-h .cloned-input.sc-ion-textarea-ios{left:unset;right:unset;right:0}.item-label-floating.item-has-placeholder.sc-ion-textarea-ios-h:not(.item-has-value),.item-label-floating.item-has-placeholder:not(.item-has-value) .sc-ion-textarea-ios-h{opacity:0}.item-label-floating.item-has-placeholder.sc-ion-textarea-ios-h:not(.item-has-value).item-has-focus,.item-label-floating.item-has-placeholder:not(.item-has-value).item-has-focus .sc-ion-textarea-ios-h{transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);opacity:1}.sc-ion-textarea-ios-h{--padding-top:10px;--padding-end:10px;--padding-bottom:10px;--padding-start:0;font-size:inherit}.item-label-stacked.sc-ion-textarea-ios-h,.item-label-stacked .sc-ion-textarea-ios-h,.item-label-floating.sc-ion-textarea-ios-h,.item-label-floating .sc-ion-textarea-ios-h{--padding-top:8px;--padding-bottom:8px;--padding-start:0px}';

    const textareaMdCss =
      '.sc-ion-textarea-md-h{--background:initial;--color:initial;--placeholder-color:initial;--placeholder-font-style:initial;--placeholder-font-weight:initial;--placeholder-opacity:.5;--padding-top:0;--padding-end:0;--padding-bottom:0;--padding-start:0;--border-radius:0;display:block;position:relative;flex:1;width:100%;background:var(--background);color:var(--color);font-family:var(--ion-font-family, inherit);white-space:pre-wrap;z-index:2;box-sizing:border-box}.ion-color.sc-ion-textarea-md-h{background:initial}.ion-color.sc-ion-textarea-md-h{color:var(--ion-color-base)}ion-item.sc-ion-textarea-md-h,ion-item .sc-ion-textarea-md-h{align-self:baseline}ion-item.sc-ion-textarea-md-h:not(.item-label),ion-item:not(.item-label) .sc-ion-textarea-md-h{--padding-start:0}.textarea-wrapper.sc-ion-textarea-md{min-width:inherit;max-width:inherit;min-height:inherit;max-height:inherit}.native-textarea.sc-ion-textarea-md{border-radius:var(--border-radius);margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit;display:block;width:100%;max-width:100%;max-height:100%;border:0;outline:none;background:transparent;box-sizing:border-box;resize:none;appearance:none}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){.native-textarea.sc-ion-textarea-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}.native-textarea.sc-ion-textarea-md::placeholder{padding-left:0;padding-right:0;padding-top:0;padding-bottom:0;color:var(--placeholder-color);font-family:inherit;font-style:var(--placeholder-font-style);font-weight:var(--placeholder-font-weight);opacity:var(--placeholder-opacity)}.native-textarea[disabled].sc-ion-textarea-md{opacity:0.4}.cloned-input.sc-ion-textarea-md{left:0;top:0;position:absolute;pointer-events:none}[dir=rtl].sc-ion-textarea-md .cloned-input.sc-ion-textarea-md,[dir=rtl].sc-ion-textarea-md-h .cloned-input.sc-ion-textarea-md,[dir=rtl] .sc-ion-textarea-md-h .cloned-input.sc-ion-textarea-md{left:unset;right:unset;right:0}.item-label-floating.item-has-placeholder.sc-ion-textarea-md-h:not(.item-has-value),.item-label-floating.item-has-placeholder:not(.item-has-value) .sc-ion-textarea-md-h{opacity:0}.item-label-floating.item-has-placeholder.sc-ion-textarea-md-h:not(.item-has-value).item-has-focus,.item-label-floating.item-has-placeholder:not(.item-has-value).item-has-focus .sc-ion-textarea-md-h{transition:opacity 0.15s cubic-bezier(0.4, 0, 0.2, 1);opacity:1}.sc-ion-textarea-md-h{--padding-top:10px;--padding-end:0;--padding-bottom:11px;--padding-start:8px;margin-left:0;margin-right:0;margin-top:8px;margin-bottom:0;font-size:inherit}.item-label-stacked.sc-ion-textarea-md-h,.item-label-stacked .sc-ion-textarea-md-h,.item-label-floating.sc-ion-textarea-md-h,.item-label-floating .sc-ion-textarea-md-h{--padding-top:8px;--padding-bottom:8px;--padding-start:0}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     */
    class Textarea {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionChange = createEvent(this, 'ionChange', 7);
        this.ionInput = createEvent(this, 'ionInput', 7);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.inputId = `ion-textarea-${textareaIds++}`;
        this.didBlurAfterEdit = false;
        this.inheritedAttributes = {};
        /**
         * This is required for a WebKit bug which requires us to
         * blur and focus an input to properly focus the input in
         * an item with delegatesFocus. It will no longer be needed
         * with iOS 14.
         *
         * @internal
         */
        this.fireFocusEvents = true;
        this.hasFocus = false;
        /**
         * Indicates whether and how the text value should be automatically capitalized as it is entered/edited by the user.
         */
        this.autocapitalize = 'none';
        /**
         * This Boolean attribute lets you specify that a form control should have input focus when the page loads.
         */
        this.autofocus = false;
        /**
         * If `true`, the value will be cleared after focus upon edit. Defaults to `true` when `type` is `"password"`, `false` for all other types.
         */
        this.clearOnEdit = false;
        /**
         * Set the amount of time, in milliseconds, to wait to trigger the `ionChange` event after each keystroke. This also impacts form bindings such as `ngModel` or `v-model`.
         */
        this.debounce = 0;
        /**
         * If `true`, the user cannot interact with the textarea.
         */
        this.disabled = false;
        /**
         * The name of the control, which is submitted with the form data.
         */
        this.name = this.inputId;
        /**
         * If `true`, the user cannot modify the value.
         */
        this.readonly = false;
        /**
         * If `true`, the user must fill in a value before submitting a form.
         */
        this.required = false;
        /**
         * If `true`, the element will have its spelling and grammar checked.
         */
        this.spellcheck = false;
        /**
         * If `true`, the element height will increase based on the value.
         */
        this.autoGrow = false;
        /**
         * The value of the textarea.
         */
        this.value = '';
        this.onInput = ev => {
          if (this.nativeInput) {
            this.value = this.nativeInput.value;
          }
          this.emitStyle();
          this.ionInput.emit(ev);
        };
        this.onFocus = ev => {
          this.hasFocus = true;
          this.focusChange();
          if (this.fireFocusEvents) {
            this.ionFocus.emit(ev);
          }
        };
        this.onBlur = ev => {
          this.hasFocus = false;
          this.focusChange();
          if (this.fireFocusEvents) {
            this.ionBlur.emit(ev);
          }
        };
        this.onKeyDown = () => {
          this.checkClearOnEdit();
        };
      }
      debounceChanged() {
        this.ionChange = debounceEvent(this.ionChange, this.debounce);
      }
      disabledChanged() {
        this.emitStyle();
      }
      /**
       * Update the native input element when the value changes
       */
      valueChanged() {
        const nativeInput = this.nativeInput;
        const value = this.getValue();
        if (nativeInput && nativeInput.value !== value) {
          nativeInput.value = value;
        }
        this.runAutoGrow();
        this.emitStyle();
        this.ionChange.emit({ value });
      }
      connectedCallback() {
        this.emitStyle();
        this.debounceChanged();
      }
      disconnectedCallback() {}
      componentWillLoad() {
        this.inheritedAttributes = inheritAttributes(this.el, ['title']);
      }
      componentDidLoad() {
        raf(() => this.runAutoGrow());
      }
      runAutoGrow() {
        const nativeInput = this.nativeInput;
        if (nativeInput && this.autoGrow) {
          readTask(() => {
            nativeInput.style.height = 'auto';
            nativeInput.style.height = nativeInput.scrollHeight + 'px';
            if (this.textareaWrapper) {
              this.textareaWrapper.style.height = nativeInput.scrollHeight + 'px';
            }
          });
        }
      }
      /**
       * Sets focus on the native `textarea` in `ion-textarea`. Use this method instead of the global
       * `textarea.focus()`.
       */
      async setFocus() {
        if (this.nativeInput) {
          this.nativeInput.focus();
        }
      }
      /**
       * Sets blur on the native `textarea` in `ion-textarea`. Use this method instead of the global
       * `textarea.blur()`.
       * @internal
       */
      async setBlur() {
        if (this.nativeInput) {
          this.nativeInput.blur();
        }
      }
      /**
       * Returns the native `<textarea>` element used under the hood.
       */
      getInputElement() {
        return Promise.resolve(this.nativeInput);
      }
      emitStyle() {
        this.ionStyle.emit({
          'interactive': true,
          'textarea': true,
          'input': true,
          'interactive-disabled': this.disabled,
          'has-placeholder': this.placeholder != null,
          'has-value': this.hasValue(),
          'has-focus': this.hasFocus,
        });
      }
      /**
       * Check if we need to clear the text input if clearOnEdit is enabled
       */
      checkClearOnEdit() {
        if (!this.clearOnEdit) {
          return;
        }
        // Did the input value change after it was blurred and edited?
        if (this.didBlurAfterEdit && this.hasValue()) {
          // Clear the input
          this.value = '';
        }
        // Reset the flag
        this.didBlurAfterEdit = false;
      }
      focusChange() {
        // If clearOnEdit is enabled and the input blurred but has a value, set a flag
        if (this.clearOnEdit && !this.hasFocus && this.hasValue()) {
          this.didBlurAfterEdit = true;
        }
        this.emitStyle();
      }
      hasValue() {
        return this.getValue() !== '';
      }
      getValue() {
        return this.value || '';
      }
      render() {
        const mode = getIonMode$1(this);
        const value = this.getValue();
        const labelId = this.inputId + '-lbl';
        const label = findItemLabel(this.el);
        if (label) {
          label.id = labelId;
        }
        return hAsync(
          Host,
          {
            'aria-disabled': this.disabled ? 'true' : null,
            'class': createColorClasses$1(this.color, {
              [mode]: true,
            }),
          },
          hAsync(
            'div',
            { class: 'textarea-wrapper', ref: el => (this.textareaWrapper = el) },
            hAsync(
              'textarea',
              Object.assign(
                {
                  'class': 'native-textarea',
                  'aria-labelledby': label ? labelId : null,
                  'ref': el => (this.nativeInput = el),
                  'autoCapitalize': this.autocapitalize,
                  'autoFocus': this.autofocus,
                  'enterKeyHint': this.enterkeyhint,
                  'inputMode': this.inputmode,
                  'disabled': this.disabled,
                  'maxLength': this.maxlength,
                  'minLength': this.minlength,
                  'name': this.name,
                  'placeholder': this.placeholder || '',
                  'readOnly': this.readonly,
                  'required': this.required,
                  'spellcheck': this.spellcheck,
                  'cols': this.cols,
                  'rows': this.rows,
                  'wrap': this.wrap,
                  'onInput': this.onInput,
                  'onBlur': this.onBlur,
                  'onFocus': this.onFocus,
                  'onKeyDown': this.onKeyDown,
                },
                this.inheritedAttributes,
              ),
              value,
            ),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          debounce: ['debounceChanged'],
          disabled: ['disabledChanged'],
          value: ['valueChanged'],
        };
      }
      static get style() {
        return {
          ios: textareaIosCss,
          md: textareaMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 34,
          $tagName$: 'ion-textarea',
          $members$: {
            fireFocusEvents: [4, 'fire-focus-events'],
            color: [513],
            autocapitalize: [1],
            autofocus: [4],
            clearOnEdit: [1028, 'clear-on-edit'],
            debounce: [2],
            disabled: [4],
            inputmode: [1],
            enterkeyhint: [1],
            maxlength: [2],
            minlength: [2],
            name: [1],
            placeholder: [1],
            readonly: [4],
            required: [4],
            spellcheck: [4],
            cols: [2],
            rows: [2],
            wrap: [1],
            autoGrow: [4, 'auto-grow'],
            value: [1025],
            hasFocus: [32],
            setFocus: [64],
            setBlur: [64],
            getInputElement: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }
    let textareaIds = 0;

    const thumbnailCss =
      '/*!@:host*/.sc-ion-thumbnail-h{--size:48px;--border-radius:0;border-radius:var(--border-radius);display:block;width:var(--size);height:var(--size)}/*!@::slotted(ion-img),\n::slotted(img)*/.sc-ion-thumbnail-s>ion-img,.sc-ion-thumbnail-s>img{border-radius:var(--border-radius);width:100%;height:100%;object-fit:cover;overflow:hidden}';

    class Thumbnail {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      render() {
        return hAsync(Host, { class: getIonMode$1(this) }, hAsync('slot', null));
      }
      static get style() {
        return thumbnailCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 9,
          $tagName$: 'ion-thumbnail',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    /**
     * iOS Toast Enter Animation
     */
    const iosEnterAnimation = (baseEl, position) => {
      const baseAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      const hostEl = baseEl.host || baseEl;
      const wrapperEl = baseEl.querySelector('.toast-wrapper');
      const bottom = `calc(-10px - var(--ion-safe-area-bottom, 0px))`;
      const top = `calc(10px + var(--ion-safe-area-top, 0px))`;
      wrapperAnimation.addElement(wrapperEl);
      switch (position) {
        case 'top':
          wrapperAnimation.fromTo('transform', 'translateY(-100%)', `translateY(${top})`);
          break;
        case 'middle':
          const topPosition = Math.floor(hostEl.clientHeight / 2 - wrapperEl.clientHeight / 2);
          wrapperEl.style.top = `${topPosition}px`;
          wrapperAnimation.fromTo('opacity', 0.01, 1);
          break;
        default:
          wrapperAnimation.fromTo('transform', 'translateY(100%)', `translateY(${bottom})`);
          break;
      }
      return baseAnimation.addElement(hostEl).easing('cubic-bezier(.155,1.105,.295,1.12)').duration(400).addAnimation(wrapperAnimation);
    };

    /**
     * iOS Toast Leave Animation
     */
    const iosLeaveAnimation = (baseEl, position) => {
      const baseAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      const hostEl = baseEl.host || baseEl;
      const wrapperEl = baseEl.querySelector('.toast-wrapper');
      const bottom = `calc(-10px - var(--ion-safe-area-bottom, 0px))`;
      const top = `calc(10px + var(--ion-safe-area-top, 0px))`;
      wrapperAnimation.addElement(wrapperEl);
      switch (position) {
        case 'top':
          wrapperAnimation.fromTo('transform', `translateY(${top})`, 'translateY(-100%)');
          break;
        case 'middle':
          wrapperAnimation.fromTo('opacity', 0.99, 0);
          break;
        default:
          wrapperAnimation.fromTo('transform', `translateY(${bottom})`, 'translateY(100%)');
          break;
      }
      return baseAnimation.addElement(hostEl).easing('cubic-bezier(.36,.66,.04,1)').duration(300).addAnimation(wrapperAnimation);
    };

    /**
     * MD Toast Enter Animation
     */
    const mdEnterAnimation = (baseEl, position) => {
      const baseAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      const hostEl = baseEl.host || baseEl;
      const wrapperEl = baseEl.querySelector('.toast-wrapper');
      const bottom = `calc(8px + var(--ion-safe-area-bottom, 0px))`;
      const top = `calc(8px + var(--ion-safe-area-top, 0px))`;
      wrapperAnimation.addElement(wrapperEl);
      switch (position) {
        case 'top':
          wrapperEl.style.top = top;
          wrapperAnimation.fromTo('opacity', 0.01, 1);
          break;
        case 'middle':
          const topPosition = Math.floor(hostEl.clientHeight / 2 - wrapperEl.clientHeight / 2);
          wrapperEl.style.top = `${topPosition}px`;
          wrapperAnimation.fromTo('opacity', 0.01, 1);
          break;
        default:
          wrapperEl.style.bottom = bottom;
          wrapperAnimation.fromTo('opacity', 0.01, 1);
          break;
      }
      return baseAnimation.addElement(hostEl).easing('cubic-bezier(.36,.66,.04,1)').duration(400).addAnimation(wrapperAnimation);
    };

    /**
     * md Toast Leave Animation
     */
    const mdLeaveAnimation = baseEl => {
      const baseAnimation = createAnimation();
      const wrapperAnimation = createAnimation();
      const hostEl = baseEl.host || baseEl;
      const wrapperEl = baseEl.querySelector('.toast-wrapper');
      wrapperAnimation.addElement(wrapperEl).fromTo('opacity', 0.99, 0);
      return baseAnimation.addElement(hostEl).easing('cubic-bezier(.36,.66,.04,1)').duration(300).addAnimation(wrapperAnimation);
    };

    const toastIosCss =
      '/*!@:host*/.sc-ion-toast-ios-h{--border-width:0;--border-style:none;--border-color:initial;--box-shadow:none;--min-width:auto;--width:auto;--min-height:auto;--height:auto;--max-height:auto;--white-space:pre-wrap;left:0;top:0;display:block;position:absolute;width:100%;height:100%;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);contain:strict;z-index:1001;pointer-events:none}/*!@:host-context([dir=rtl])*/[dir=rtl].sc-ion-toast-ios-h,[dir=rtl] .sc-ion-toast-ios-h{left:unset;right:unset;right:0}/*!@:host(.overlay-hidden)*/.overlay-hidden.sc-ion-toast-ios-h{display:none}/*!@:host(.ion-color)*/.ion-color.sc-ion-toast-ios-h{--button-color:inherit;color:var(--ion-color-contrast)}/*!@:host(.ion-color) .toast-button-cancel*/.ion-color.sc-ion-toast-ios-h .toast-button-cancel.sc-ion-toast-ios{color:inherit}/*!@:host(.ion-color) .toast-wrapper*/.ion-color.sc-ion-toast-ios-h .toast-wrapper.sc-ion-toast-ios{background:var(--ion-color-base)}/*!@.toast-wrapper*/.toast-wrapper.sc-ion-toast-ios{border-radius:var(--border-radius);left:var(--start);right:var(--end);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);box-shadow:var(--box-shadow)}/*!@[dir=rtl] .toast-wrapper, :host-context([dir=rtl]) .toast-wrapper*/[dir=rtl].sc-ion-toast-ios .toast-wrapper.sc-ion-toast-ios,[dir=rtl].sc-ion-toast-ios-h .toast-wrapper.sc-ion-toast-ios,[dir=rtl] .sc-ion-toast-ios-h .toast-wrapper.sc-ion-toast-ios{left:unset;right:unset;left:var(--end);right:var(--start)}/*!@.toast-container*/.toast-container.sc-ion-toast-ios{display:flex;align-items:center;pointer-events:auto;height:inherit;min-height:inherit;max-height:inherit;contain:content}/*!@.toast-content*/.toast-content.sc-ion-toast-ios{display:flex;flex:1;flex-direction:column;justify-content:center}/*!@.toast-message*/.toast-message.sc-ion-toast-ios{flex:1;white-space:var(--white-space)}/*!@.toast-button-group*/.toast-button-group.sc-ion-toast-ios{display:flex}/*!@.toast-button*/.toast-button.sc-ion-toast-ios{border:0;outline:none;color:var(--button-color);z-index:0}/*!@.toast-icon*/.toast-icon.sc-ion-toast-ios{font-size:1.4em}/*!@.toast-button-inner*/.toast-button-inner.sc-ion-toast-ios{display:flex;align-items:center}@media (any-hover: hover){/*!@.toast-button:hover*/.toast-button.sc-ion-toast-ios:hover{cursor:pointer}}/*!@:host*/.sc-ion-toast-ios-h{--background:var(--ion-color-step-50, #f2f2f2);--border-radius:14px;--button-color:var(--ion-color-primary, #3880ff);--color:var(--ion-color-step-850, #262626);--max-width:700px;--start:10px;--end:10px;font-size:14px}/*!@.toast-wrapper*/.toast-wrapper.sc-ion-toast-ios{margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;display:block;position:absolute;z-index:10}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toast-wrapper*/.toast-wrapper.sc-ion-toast-ios{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}@supports (backdrop-filter: blur(0)){/*!@:host(.toast-translucent) .toast-wrapper*/.toast-translucent.sc-ion-toast-ios-h .toast-wrapper.sc-ion-toast-ios{background:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.8);backdrop-filter:saturate(180%) blur(20px)}}/*!@.toast-wrapper.toast-top*/.toast-wrapper.toast-top.sc-ion-toast-ios{transform:translate3d(0,  -100%,  0);top:0}/*!@.toast-wrapper.toast-middle*/.toast-wrapper.toast-middle.sc-ion-toast-ios{opacity:0.01}/*!@.toast-wrapper.toast-bottom*/.toast-wrapper.toast-bottom.sc-ion-toast-ios{transform:translate3d(0,  100%,  0);bottom:0}/*!@.toast-content*/.toast-content.sc-ion-toast-ios{padding-left:15px;padding-right:15px;padding-top:15px;padding-bottom:15px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toast-content*/.toast-content.sc-ion-toast-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:15px;padding-inline-start:15px;-webkit-padding-end:15px;padding-inline-end:15px}}/*!@.toast-header*/.toast-header.sc-ion-toast-ios{margin-bottom:2px;font-weight:500}/*!@.toast-button*/.toast-button.sc-ion-toast-ios{padding-left:15px;padding-right:15px;padding-top:10px;padding-bottom:10px;height:44px;transition:background-color, opacity 100ms linear;border:0;background-color:transparent;font-family:var(--ion-font-family);font-size:17px;font-weight:500;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toast-button*/.toast-button.sc-ion-toast-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:15px;padding-inline-start:15px;-webkit-padding-end:15px;padding-inline-end:15px}}/*!@.toast-button.ion-activated*/.toast-button.ion-activated.sc-ion-toast-ios{opacity:0.4}@media (any-hover: hover){/*!@.toast-button:hover*/.toast-button.sc-ion-toast-ios:hover{opacity:0.6}}';

    const toastMdCss =
      '/*!@:host*/.sc-ion-toast-md-h{--border-width:0;--border-style:none;--border-color:initial;--box-shadow:none;--min-width:auto;--width:auto;--min-height:auto;--height:auto;--max-height:auto;--white-space:pre-wrap;left:0;top:0;display:block;position:absolute;width:100%;height:100%;outline:none;color:var(--color);font-family:var(--ion-font-family, inherit);contain:strict;z-index:1001;pointer-events:none}/*!@:host-context([dir=rtl])*/[dir=rtl].sc-ion-toast-md-h,[dir=rtl] .sc-ion-toast-md-h{left:unset;right:unset;right:0}/*!@:host(.overlay-hidden)*/.overlay-hidden.sc-ion-toast-md-h{display:none}/*!@:host(.ion-color)*/.ion-color.sc-ion-toast-md-h{--button-color:inherit;color:var(--ion-color-contrast)}/*!@:host(.ion-color) .toast-button-cancel*/.ion-color.sc-ion-toast-md-h .toast-button-cancel.sc-ion-toast-md{color:inherit}/*!@:host(.ion-color) .toast-wrapper*/.ion-color.sc-ion-toast-md-h .toast-wrapper.sc-ion-toast-md{background:var(--ion-color-base)}/*!@.toast-wrapper*/.toast-wrapper.sc-ion-toast-md{border-radius:var(--border-radius);left:var(--start);right:var(--end);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);box-shadow:var(--box-shadow)}/*!@[dir=rtl] .toast-wrapper, :host-context([dir=rtl]) .toast-wrapper*/[dir=rtl].sc-ion-toast-md .toast-wrapper.sc-ion-toast-md,[dir=rtl].sc-ion-toast-md-h .toast-wrapper.sc-ion-toast-md,[dir=rtl] .sc-ion-toast-md-h .toast-wrapper.sc-ion-toast-md{left:unset;right:unset;left:var(--end);right:var(--start)}/*!@.toast-container*/.toast-container.sc-ion-toast-md{display:flex;align-items:center;pointer-events:auto;height:inherit;min-height:inherit;max-height:inherit;contain:content}/*!@.toast-content*/.toast-content.sc-ion-toast-md{display:flex;flex:1;flex-direction:column;justify-content:center}/*!@.toast-message*/.toast-message.sc-ion-toast-md{flex:1;white-space:var(--white-space)}/*!@.toast-button-group*/.toast-button-group.sc-ion-toast-md{display:flex}/*!@.toast-button*/.toast-button.sc-ion-toast-md{border:0;outline:none;color:var(--button-color);z-index:0}/*!@.toast-icon*/.toast-icon.sc-ion-toast-md{font-size:1.4em}/*!@.toast-button-inner*/.toast-button-inner.sc-ion-toast-md{display:flex;align-items:center}@media (any-hover: hover){/*!@.toast-button:hover*/.toast-button.sc-ion-toast-md:hover{cursor:pointer}}/*!@:host*/.sc-ion-toast-md-h{--background:var(--ion-color-step-800, #333333);--border-radius:4px;--box-shadow:0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12);--button-color:var(--ion-color-primary, #3880ff);--color:var(--ion-color-step-50, #f2f2f2);--max-width:700px;--start:8px;--end:8px;font-size:14px}/*!@.toast-wrapper*/.toast-wrapper.sc-ion-toast-md{margin-left:auto;margin-right:auto;margin-top:auto;margin-bottom:auto;display:block;position:absolute;opacity:0.01;z-index:10}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toast-wrapper*/.toast-wrapper.sc-ion-toast-md{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}/*!@.toast-content*/.toast-content.sc-ion-toast-md{padding-left:16px;padding-right:16px;padding-top:14px;padding-bottom:14px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toast-content*/.toast-content.sc-ion-toast-md{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}/*!@.toast-header*/.toast-header.sc-ion-toast-md{margin-bottom:2px;font-weight:500;line-height:20px}/*!@.toast-message*/.toast-message.sc-ion-toast-md{line-height:20px}/*!@.toast-button-group-start*/.toast-button-group-start.sc-ion-toast-md{margin-left:8px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toast-button-group-start*/.toast-button-group-start.sc-ion-toast-md{margin-left:unset;-webkit-margin-start:8px;margin-inline-start:8px}}/*!@.toast-button-group-end*/.toast-button-group-end.sc-ion-toast-md{margin-right:8px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toast-button-group-end*/.toast-button-group-end.sc-ion-toast-md{margin-right:unset;-webkit-margin-end:8px;margin-inline-end:8px}}/*!@.toast-button*/.toast-button.sc-ion-toast-md{padding-left:15px;padding-right:15px;padding-top:10px;padding-bottom:10px;position:relative;background-color:transparent;font-family:var(--ion-font-family);font-size:14px;font-weight:500;letter-spacing:0.84px;text-transform:uppercase;overflow:hidden}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toast-button*/.toast-button.sc-ion-toast-md{padding-left:unset;padding-right:unset;-webkit-padding-start:15px;padding-inline-start:15px;-webkit-padding-end:15px;padding-inline-end:15px}}/*!@.toast-button-cancel*/.toast-button-cancel.sc-ion-toast-md{color:var(--ion-color-step-100, #e6e6e6)}/*!@.toast-button-icon-only*/.toast-button-icon-only.sc-ion-toast-md{border-radius:50%;padding-left:9px;padding-right:9px;padding-top:9px;padding-bottom:9px;width:36px;height:36px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toast-button-icon-only*/.toast-button-icon-only.sc-ion-toast-md{padding-left:unset;padding-right:unset;-webkit-padding-start:9px;padding-inline-start:9px;-webkit-padding-end:9px;padding-inline-end:9px}}@media (any-hover: hover){/*!@.toast-button:hover*/.toast-button.sc-ion-toast-md:hover{background-color:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.08)}/*!@.toast-button-cancel:hover*/.toast-button-cancel.sc-ion-toast-md:hover{background-color:rgba(var(--ion-background-color-rgb, 255, 255, 255), 0.08)}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part button - Any button element that is displayed inside of the toast.
     * @part container - The element that wraps all child elements.
     * @part header - The header text of the toast.
     * @part message - The body text of the toast.
     */
    class Toast {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.didPresent = createEvent(this, 'ionToastDidPresent', 7);
        this.willPresent = createEvent(this, 'ionToastWillPresent', 7);
        this.willDismiss = createEvent(this, 'ionToastWillDismiss', 7);
        this.didDismiss = createEvent(this, 'ionToastDidDismiss', 7);
        this.presented = false;
        /**
         * How many milliseconds to wait before hiding the toast. By default, it will show
         * until `dismiss()` is called.
         */
        this.duration = 0;
        /**
         * If `true`, the keyboard will be automatically dismissed when the overlay is presented.
         */
        this.keyboardClose = false;
        /**
         * The position of the toast on the screen.
         */
        this.position = 'bottom';
        /**
         * If `true`, the toast will be translucent.
         * Only applies when the mode is `"ios"` and the device supports
         * [`backdrop-filter`](https://developer.mozilla.org/en-US/docs/Web/CSS/backdrop-filter#Browser_compatibility).
         */
        this.translucent = false;
        /**
         * If `true`, the toast will animate.
         */
        this.animated = true;
        this.dispatchCancelHandler = ev => {
          const role = ev.detail.role;
          if (isCancel(role)) {
            const cancelButton = this.getButtons().find(b => b.role === 'cancel');
            this.callButtonHandler(cancelButton);
          }
        };
      }
      connectedCallback() {
        prepareOverlay(this.el);
      }
      /**
       * Present the toast overlay after it has been created.
       */
      async present() {
        await present(this, 'toastEnter', iosEnterAnimation, mdEnterAnimation, this.position);
        if (this.duration > 0) {
          this.durationTimeout = setTimeout(() => this.dismiss(undefined, 'timeout'), this.duration);
        }
      }
      /**
       * Dismiss the toast overlay after it has been presented.
       *
       * @param data Any data to emit in the dismiss events.
       * @param role The role of the element that is dismissing the toast.
       * This can be useful in a button handler for determining which button was
       * clicked to dismiss the toast.
       * Some examples include: ``"cancel"`, `"destructive"`, "selected"`, and `"backdrop"`.
       */
      dismiss(data, role) {
        if (this.durationTimeout) {
          clearTimeout(this.durationTimeout);
        }
        return dismiss(this, data, role, 'toastLeave', iosLeaveAnimation, mdLeaveAnimation, this.position);
      }
      /**
       * Returns a promise that resolves when the toast did dismiss.
       */
      onDidDismiss() {
        return eventMethod(this.el, 'ionToastDidDismiss');
      }
      /**
       * Returns a promise that resolves when the toast will dismiss.
       */
      onWillDismiss() {
        return eventMethod(this.el, 'ionToastWillDismiss');
      }
      getButtons() {
        const buttons = this.buttons
          ? this.buttons.map(b => {
              return typeof b === 'string' ? { text: b } : b;
            })
          : [];
        return buttons;
      }
      async buttonClick(button) {
        const role = button.role;
        if (isCancel(role)) {
          return this.dismiss(undefined, role);
        }
        const shouldDismiss = await this.callButtonHandler(button);
        if (shouldDismiss) {
          return this.dismiss(undefined, role);
        }
        return Promise.resolve();
      }
      async callButtonHandler(button) {
        if (button && button.handler) {
          // a handler has been provided, execute it
          // pass the handler the values from the inputs
          try {
            const rtn = await safeCall(button.handler);
            if (rtn === false) {
              // if the return value of the handler is false then do not dismiss
              return false;
            }
          } catch (e) {
            console.error(e);
          }
        }
        return true;
      }
      renderButtons(buttons, side) {
        if (buttons.length === 0) {
          return;
        }
        const mode = getIonMode$1(this);
        const buttonGroupsClasses = {
          'toast-button-group': true,
          [`toast-button-group-${side}`]: true,
        };
        return hAsync(
          'div',
          { class: buttonGroupsClasses },
          buttons.map(b =>
            hAsync(
              'button',
              { type: 'button', class: buttonClass(b), tabIndex: 0, onClick: () => this.buttonClick(b), part: 'button' },
              hAsync(
                'div',
                { class: 'toast-button-inner' },
                b.icon && hAsync('ion-icon', { icon: b.icon, slot: b.text === undefined ? 'icon-only' : undefined, class: 'toast-icon' }),
                b.text,
              ),
              mode === 'md' && hAsync('ion-ripple-effect', { type: b.icon !== undefined && b.text === undefined ? 'unbounded' : 'bounded' }),
            ),
          ),
        );
      }
      render() {
        const allButtons = this.getButtons();
        const startButtons = allButtons.filter(b => b.side === 'start');
        const endButtons = allButtons.filter(b => b.side !== 'start');
        const mode = getIonMode$1(this);
        const wrapperClass = {
          'toast-wrapper': true,
          [`toast-${this.position}`]: true,
        };
        const role = allButtons.length > 0 ? 'dialog' : 'status';
        return hAsync(
          Host,
          Object.assign({ role: role, tabindex: '-1' }, this.htmlAttributes, {
            style: {
              zIndex: `${60000 + this.overlayIndex}`,
            },
            class: createColorClasses$1(this.color, Object.assign(Object.assign({ [mode]: true }, getClassMap(this.cssClass)), { 'toast-translucent': this.translucent })),
            onIonToastWillDismiss: this.dispatchCancelHandler,
          }),
          hAsync(
            'div',
            { class: wrapperClass },
            hAsync(
              'div',
              { class: 'toast-container', part: 'container' },
              this.renderButtons(startButtons, 'start'),
              hAsync(
                'div',
                { class: 'toast-content' },
                this.header !== undefined && hAsync('div', { class: 'toast-header', part: 'header' }, this.header),
                this.message !== undefined && hAsync('div', { class: 'toast-message', part: 'message', innerHTML: sanitizeDOMString(this.message) }),
              ),
              this.renderButtons(endButtons, 'end'),
            ),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: toastIosCss,
          md: toastMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-toast',
          $members$: {
            overlayIndex: [2, 'overlay-index'],
            color: [513],
            enterAnimation: [16],
            leaveAnimation: [16],
            cssClass: [1, 'css-class'],
            duration: [2],
            header: [1],
            message: [1],
            keyboardClose: [4, 'keyboard-close'],
            position: [1],
            buttons: [16],
            translucent: [4],
            animated: [4],
            htmlAttributes: [16],
            present: [64],
            dismiss: [64],
            onDidDismiss: [64],
            onWillDismiss: [64],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }
    const buttonClass = button => {
      return Object.assign(
        {
          'toast-button': true,
          'toast-button-icon-only': button.icon !== undefined && button.text === undefined,
          [`toast-button-${button.role}`]: button.role !== undefined,
          'ion-focusable': true,
          'ion-activatable': true,
        },
        getClassMap(button.cssClass),
      );
    };

    const toggleIosCss =
      '/*!@:host*/.sc-ion-toggle-ios-h{box-sizing:content-box !important;display:inline-block;position:relative;outline:none;contain:content;cursor:pointer;touch-action:none;user-select:none;z-index:2}/*!@:host(.ion-focused) input*/.ion-focused.sc-ion-toggle-ios-h input.sc-ion-toggle-ios{border:2px solid #5e9ed6}/*!@:host(.toggle-disabled)*/.toggle-disabled.sc-ion-toggle-ios-h{pointer-events:none}/*!@label*/label.sc-ion-toggle-ios{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;appearance:none;outline:none;display:flex;align-items:center;opacity:0;pointer-events:none}/*!@[dir=rtl] label, :host-context([dir=rtl]) label*/[dir=rtl].sc-ion-toggle-ios label.sc-ion-toggle-ios,[dir=rtl].sc-ion-toggle-ios-h label.sc-ion-toggle-ios,[dir=rtl] .sc-ion-toggle-ios-h label.sc-ion-toggle-ios{left:unset;right:unset;right:0}/*!@label::-moz-focus-inner*/label.sc-ion-toggle-ios::-moz-focus-inner{border:0}/*!@input*/input.sc-ion-toggle-ios{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}/*!@.toggle-icon-wrapper*/.toggle-icon-wrapper.sc-ion-toggle-ios{display:flex;position:relative;align-items:center;width:100%;height:100%;transition:var(--handle-transition);will-change:transform}/*!@.toggle-icon*/.toggle-icon.sc-ion-toggle-ios{border-radius:var(--border-radius);display:block;position:relative;width:100%;height:100%;background:var(--background);pointer-events:none;overflow:inherit}/*!@:host(.toggle-checked) .toggle-icon*/.toggle-checked.sc-ion-toggle-ios-h .toggle-icon.sc-ion-toggle-ios{background:var(--background-checked)}/*!@.toggle-inner*/.toggle-inner.sc-ion-toggle-ios{left:var(--handle-spacing);border-radius:var(--handle-border-radius);position:absolute;width:var(--handle-width);height:var(--handle-height);max-height:var(--handle-max-height);transition:var(--handle-transition);background:var(--handle-background);box-shadow:var(--handle-box-shadow);contain:strict}/*!@[dir=rtl] .toggle-inner, :host-context([dir=rtl]) .toggle-inner*/[dir=rtl].sc-ion-toggle-ios .toggle-inner.sc-ion-toggle-ios,[dir=rtl].sc-ion-toggle-ios-h .toggle-inner.sc-ion-toggle-ios,[dir=rtl] .sc-ion-toggle-ios-h .toggle-inner.sc-ion-toggle-ios{left:unset;right:unset;right:var(--handle-spacing)}/*!@:host(.toggle-checked) .toggle-icon-wrapper*/.toggle-checked.sc-ion-toggle-ios-h .toggle-icon-wrapper.sc-ion-toggle-ios{transform:translate3d(calc(100% - var(--handle-width)), 0, 0)}/*!@:host-context([dir=rtl]):host(.toggle-checked) .toggle-icon-wrapper, :host-context([dir=rtl]).toggle-checked .toggle-icon-wrapper*/[dir=rtl].sc-ion-toggle-ios-h -no-combinator.toggle-checked.sc-ion-toggle-ios-h .toggle-icon-wrapper.sc-ion-toggle-ios,[dir=rtl] .sc-ion-toggle-ios-h -no-combinator.toggle-checked.sc-ion-toggle-ios-h .toggle-icon-wrapper.sc-ion-toggle-ios,[dir=rtl].toggle-checked.sc-ion-toggle-ios-h .toggle-icon-wrapper.sc-ion-toggle-ios,[dir=rtl] .toggle-checked.sc-ion-toggle-ios-h .toggle-icon-wrapper.sc-ion-toggle-ios{transform:translate3d(calc(-100% + var(--handle-width)), 0, 0)}/*!@:host(.toggle-checked) .toggle-inner*/.toggle-checked.sc-ion-toggle-ios-h .toggle-inner.sc-ion-toggle-ios{transform:translate3d(calc(var(--handle-spacing) * -2), 0, 0);background:var(--handle-background-checked)}/*!@:host-context([dir=rtl]):host(.toggle-checked) .toggle-inner, :host-context([dir=rtl]).toggle-checked .toggle-inner*/[dir=rtl].sc-ion-toggle-ios-h -no-combinator.toggle-checked.sc-ion-toggle-ios-h .toggle-inner.sc-ion-toggle-ios,[dir=rtl] .sc-ion-toggle-ios-h -no-combinator.toggle-checked.sc-ion-toggle-ios-h .toggle-inner.sc-ion-toggle-ios,[dir=rtl].toggle-checked.sc-ion-toggle-ios-h .toggle-inner.sc-ion-toggle-ios,[dir=rtl] .toggle-checked.sc-ion-toggle-ios-h .toggle-inner.sc-ion-toggle-ios{transform:translate3d(calc(var(--handle-spacing) * 2), 0, 0)}/*!@:host*/.sc-ion-toggle-ios-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.088);--background-checked:var(--ion-color-primary, #3880ff);--border-radius:16px;--handle-background:#ffffff;--handle-background-checked:#ffffff;--handle-border-radius:25.5px;--handle-box-shadow:0 3px 12px rgba(0, 0, 0, 0.16), 0 3px 1px rgba(0, 0, 0, 0.1);--handle-height:calc(32px - (2px * 2));--handle-max-height:calc(100% - (var(--handle-spacing) * 2));--handle-width:calc(32px - (2px * 2));--handle-spacing:2px;--handle-transition:transform 300ms, width 120ms ease-in-out 80ms, left 110ms ease-in-out 80ms, right 110ms ease-in-out 80ms;width:51px;height:32px;contain:strict;overflow:hidden}/*!@:host(.ion-color.toggle-checked) .toggle-icon*/.ion-color.toggle-checked.sc-ion-toggle-ios-h .toggle-icon.sc-ion-toggle-ios{background:var(--ion-color-base)}/*!@.toggle-icon*/.toggle-icon.sc-ion-toggle-ios{transform:translate3d(0, 0, 0);transition:background-color 300ms}/*!@.toggle-inner*/.toggle-inner.sc-ion-toggle-ios{will-change:transform}/*!@:host(.toggle-activated) .toggle-icon::before,\n:host(.toggle-checked) .toggle-icon::before*/.toggle-activated.sc-ion-toggle-ios-h .toggle-icon.sc-ion-toggle-ios::before,.toggle-checked.sc-ion-toggle-ios-h .toggle-icon.sc-ion-toggle-ios::before{transform:scale3d(0, 0, 0)}/*!@:host(.toggle-activated.toggle-checked) .toggle-inner::before*/.toggle-activated.toggle-checked.sc-ion-toggle-ios-h .toggle-inner.sc-ion-toggle-ios::before{transform:scale3d(0, 0, 0)}/*!@:host(.toggle-activated) .toggle-inner*/.toggle-activated.sc-ion-toggle-ios-h .toggle-inner.sc-ion-toggle-ios{width:calc(var(--handle-width) + 6px)}/*!@:host(.toggle-activated.toggle-checked) .toggle-icon-wrapper*/.toggle-activated.toggle-checked.sc-ion-toggle-ios-h .toggle-icon-wrapper.sc-ion-toggle-ios{transform:translate3d(calc(100% - var(--handle-width) - 6px), 0, 0)}/*!@:host-context([dir=rtl]):host(.toggle-activated.toggle-checked) .toggle-icon-wrapper, :host-context([dir=rtl]).toggle-activated.toggle-checked .toggle-icon-wrapper*/[dir=rtl].sc-ion-toggle-ios-h -no-combinator.toggle-activated.toggle-checked.sc-ion-toggle-ios-h .toggle-icon-wrapper.sc-ion-toggle-ios,[dir=rtl] .sc-ion-toggle-ios-h -no-combinator.toggle-activated.toggle-checked.sc-ion-toggle-ios-h .toggle-icon-wrapper.sc-ion-toggle-ios,[dir=rtl].toggle-activated.toggle-checked.sc-ion-toggle-ios-h .toggle-icon-wrapper.sc-ion-toggle-ios,[dir=rtl] .toggle-activated.toggle-checked.sc-ion-toggle-ios-h .toggle-icon-wrapper.sc-ion-toggle-ios{transform:translate3d(calc(-100% + var(--handle-width) + 6px), 0, 0)}/*!@:host(.toggle-disabled)*/.toggle-disabled.sc-ion-toggle-ios-h{opacity:0.3}/*!@:host(.in-item[slot])*/.in-item[slot].sc-ion-toggle-ios-h{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:20px;padding-right:10px;padding-top:6px;padding-bottom:5px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-item[slot])*/.in-item[slot].sc-ion-toggle-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:10px;padding-inline-end:10px}}/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-toggle-ios-h{padding-left:0;padding-right:16px;padding-top:6px;padding-bottom:5px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-toggle-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:0;padding-inline-start:0;-webkit-padding-end:16px;padding-inline-end:16px}}';

    const toggleMdCss =
      '/*!@:host*/.sc-ion-toggle-md-h{box-sizing:content-box !important;display:inline-block;position:relative;outline:none;contain:content;cursor:pointer;touch-action:none;user-select:none;z-index:2}/*!@:host(.ion-focused) input*/.ion-focused.sc-ion-toggle-md-h input.sc-ion-toggle-md{border:2px solid #5e9ed6}/*!@:host(.toggle-disabled)*/.toggle-disabled.sc-ion-toggle-md-h{pointer-events:none}/*!@label*/label.sc-ion-toggle-md{left:0;top:0;margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;position:absolute;width:100%;height:100%;border:0;background:transparent;cursor:pointer;appearance:none;outline:none;display:flex;align-items:center;opacity:0;pointer-events:none}/*!@[dir=rtl] label, :host-context([dir=rtl]) label*/[dir=rtl].sc-ion-toggle-md label.sc-ion-toggle-md,[dir=rtl].sc-ion-toggle-md-h label.sc-ion-toggle-md,[dir=rtl] .sc-ion-toggle-md-h label.sc-ion-toggle-md{left:unset;right:unset;right:0}/*!@label::-moz-focus-inner*/label.sc-ion-toggle-md::-moz-focus-inner{border:0}/*!@input*/input.sc-ion-toggle-md{position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;margin:0;padding:0;border:0;outline:0;clip:rect(0 0 0 0);opacity:0;overflow:hidden;-webkit-appearance:none;-moz-appearance:none}/*!@.toggle-icon-wrapper*/.toggle-icon-wrapper.sc-ion-toggle-md{display:flex;position:relative;align-items:center;width:100%;height:100%;transition:var(--handle-transition);will-change:transform}/*!@.toggle-icon*/.toggle-icon.sc-ion-toggle-md{border-radius:var(--border-radius);display:block;position:relative;width:100%;height:100%;background:var(--background);pointer-events:none;overflow:inherit}/*!@:host(.toggle-checked) .toggle-icon*/.toggle-checked.sc-ion-toggle-md-h .toggle-icon.sc-ion-toggle-md{background:var(--background-checked)}/*!@.toggle-inner*/.toggle-inner.sc-ion-toggle-md{left:var(--handle-spacing);border-radius:var(--handle-border-radius);position:absolute;width:var(--handle-width);height:var(--handle-height);max-height:var(--handle-max-height);transition:var(--handle-transition);background:var(--handle-background);box-shadow:var(--handle-box-shadow);contain:strict}/*!@[dir=rtl] .toggle-inner, :host-context([dir=rtl]) .toggle-inner*/[dir=rtl].sc-ion-toggle-md .toggle-inner.sc-ion-toggle-md,[dir=rtl].sc-ion-toggle-md-h .toggle-inner.sc-ion-toggle-md,[dir=rtl] .sc-ion-toggle-md-h .toggle-inner.sc-ion-toggle-md{left:unset;right:unset;right:var(--handle-spacing)}/*!@:host(.toggle-checked) .toggle-icon-wrapper*/.toggle-checked.sc-ion-toggle-md-h .toggle-icon-wrapper.sc-ion-toggle-md{transform:translate3d(calc(100% - var(--handle-width)), 0, 0)}/*!@:host-context([dir=rtl]):host(.toggle-checked) .toggle-icon-wrapper, :host-context([dir=rtl]).toggle-checked .toggle-icon-wrapper*/[dir=rtl].sc-ion-toggle-md-h -no-combinator.toggle-checked.sc-ion-toggle-md-h .toggle-icon-wrapper.sc-ion-toggle-md,[dir=rtl] .sc-ion-toggle-md-h -no-combinator.toggle-checked.sc-ion-toggle-md-h .toggle-icon-wrapper.sc-ion-toggle-md,[dir=rtl].toggle-checked.sc-ion-toggle-md-h .toggle-icon-wrapper.sc-ion-toggle-md,[dir=rtl] .toggle-checked.sc-ion-toggle-md-h .toggle-icon-wrapper.sc-ion-toggle-md{transform:translate3d(calc(-100% + var(--handle-width)), 0, 0)}/*!@:host(.toggle-checked) .toggle-inner*/.toggle-checked.sc-ion-toggle-md-h .toggle-inner.sc-ion-toggle-md{transform:translate3d(calc(var(--handle-spacing) * -2), 0, 0);background:var(--handle-background-checked)}/*!@:host-context([dir=rtl]):host(.toggle-checked) .toggle-inner, :host-context([dir=rtl]).toggle-checked .toggle-inner*/[dir=rtl].sc-ion-toggle-md-h -no-combinator.toggle-checked.sc-ion-toggle-md-h .toggle-inner.sc-ion-toggle-md,[dir=rtl] .sc-ion-toggle-md-h -no-combinator.toggle-checked.sc-ion-toggle-md-h .toggle-inner.sc-ion-toggle-md,[dir=rtl].toggle-checked.sc-ion-toggle-md-h .toggle-inner.sc-ion-toggle-md,[dir=rtl] .toggle-checked.sc-ion-toggle-md-h .toggle-inner.sc-ion-toggle-md{transform:translate3d(calc(var(--handle-spacing) * 2), 0, 0)}/*!@:host*/.sc-ion-toggle-md-h{--background:rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.39);--background-checked:rgba(var(--ion-color-primary-rgb, 56, 128, 255), 0.5);--border-radius:14px;--handle-background:#ffffff;--handle-background-checked:var(--ion-color-primary, #3880ff);--handle-border-radius:50%;--handle-box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);--handle-width:20px;--handle-height:20px;--handle-max-height:calc(100% + 6px);--handle-spacing:0;--handle-transition:transform 160ms cubic-bezier(0.4, 0, 0.2, 1), background-color 160ms cubic-bezier(0.4, 0, 0.2, 1);padding-left:12px;padding-right:12px;padding-top:12px;padding-bottom:12px;width:36px;height:14px;contain:strict}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-toggle-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:12px;padding-inline-start:12px;-webkit-padding-end:12px;padding-inline-end:12px}}/*!@:host(.ion-color.toggle-checked) .toggle-icon*/.ion-color.toggle-checked.sc-ion-toggle-md-h .toggle-icon.sc-ion-toggle-md{background:rgba(var(--ion-color-base-rgb), 0.5)}/*!@:host(.ion-color.toggle-checked) .toggle-inner*/.ion-color.toggle-checked.sc-ion-toggle-md-h .toggle-inner.sc-ion-toggle-md{background:var(--ion-color-base)}/*!@.toggle-icon*/.toggle-icon.sc-ion-toggle-md{transition:background-color 160ms}/*!@.toggle-inner*/.toggle-inner.sc-ion-toggle-md{will-change:background-color, transform}/*!@:host(.toggle-disabled)*/.toggle-disabled.sc-ion-toggle-md-h{opacity:0.3}/*!@:host(.in-item[slot])*/.in-item[slot].sc-ion-toggle-md-h{margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;padding-left:16px;padding-right:0;padding-top:12px;padding-bottom:12px;cursor:pointer}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-item[slot])*/.in-item[slot].sc-ion-toggle-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:0;padding-inline-end:0}}/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-toggle-md-h{padding-left:2px;padding-right:18px;padding-top:12px;padding-bottom:12px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.in-item[slot=start])*/.in-item[slot=start].sc-ion-toggle-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:2px;padding-inline-start:2px;-webkit-padding-end:18px;padding-inline-end:18px}}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @part track - The background track of the toggle.
     * @part handle - The toggle handle, or knob, used to change the checked state.
     */
    class Toggle {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionChange = createEvent(this, 'ionChange', 7);
        this.ionFocus = createEvent(this, 'ionFocus', 7);
        this.ionBlur = createEvent(this, 'ionBlur', 7);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
        this.inputId = `ion-tg-${toggleIds++}`;
        this.lastDrag = 0;
        this.activated = false;
        /**
         * The name of the control, which is submitted with the form data.
         */
        this.name = this.inputId;
        /**
         * If `true`, the toggle is selected.
         */
        this.checked = false;
        /**
         * If `true`, the user cannot interact with the toggle.
         */
        this.disabled = false;
        /**
         * The value of the toggle does not mean if it's checked or not, use the `checked`
         * property for that.
         *
         * The value of a toggle is analogous to the value of a `<input type="checkbox">`,
         * it's only used when the toggle participates in a native `<form>`.
         */
        this.value = 'on';
        this.onClick = ev => {
          ev.preventDefault();
          if (this.lastDrag + 300 < Date.now()) {
            this.checked = !this.checked;
          }
        };
        this.onFocus = () => {
          this.ionFocus.emit();
        };
        this.onBlur = () => {
          this.ionBlur.emit();
        };
      }
      checkedChanged(isChecked) {
        this.ionChange.emit({
          checked: isChecked,
          value: this.value,
        });
      }
      disabledChanged() {
        this.emitStyle();
        if (this.gesture) {
          this.gesture.enable(!this.disabled);
        }
      }
      async connectedCallback() {
        this.gesture = (
          await Promise.resolve().then(function () {
            return index$2;
          })
        ).createGesture({
          el: this.el,
          gestureName: 'toggle',
          gesturePriority: 100,
          threshold: 5,
          passive: false,
          onStart: () => this.onStart(),
          onMove: ev => this.onMove(ev),
          onEnd: ev => this.onEnd(ev),
        });
        this.disabledChanged();
      }
      disconnectedCallback() {
        if (this.gesture) {
          this.gesture.destroy();
          this.gesture = undefined;
        }
      }
      componentWillLoad() {
        this.emitStyle();
      }
      emitStyle() {
        this.ionStyle.emit({
          'interactive-disabled': this.disabled,
        });
      }
      onStart() {
        this.activated = true;
        // touch-action does not work in iOS
        this.setFocus();
      }
      onMove(detail) {
        if (shouldToggle(document, this.checked, detail.deltaX, -10)) {
          this.checked = !this.checked;
          hapticSelection();
        }
      }
      onEnd(ev) {
        this.activated = false;
        this.lastDrag = Date.now();
        ev.event.preventDefault();
        ev.event.stopImmediatePropagation();
      }
      getValue() {
        return this.value || '';
      }
      setFocus() {
        if (this.focusEl) {
          this.focusEl.focus();
        }
      }
      render() {
        const { activated, color, checked, disabled, el, inputId, name } = this;
        const mode = getIonMode$1(this);
        const { label, labelId, labelText } = getAriaLabel(el, inputId);
        const value = this.getValue();
        renderHiddenInput(true, el, name, checked ? value : '', disabled);
        return hAsync(
          Host,
          {
            'onClick': this.onClick,
            'aria-labelledby': label ? labelId : null,
            'aria-checked': `${checked}`,
            'aria-hidden': disabled ? 'true' : null,
            'role': 'switch',
            'class': createColorClasses$1(color, {
              [mode]: true,
              'in-item': hostContext('ion-item', el),
              'toggle-activated': activated,
              'toggle-checked': checked,
              'toggle-disabled': disabled,
              'interactive': true,
            }),
          },
          hAsync('div', { class: 'toggle-icon', part: 'track' }, hAsync('div', { class: 'toggle-icon-wrapper' }, hAsync('div', { class: 'toggle-inner', part: 'handle' }))),
          hAsync('label', { htmlFor: inputId }, labelText),
          hAsync('input', {
            'type': 'checkbox',
            'role': 'switch',
            'aria-checked': `${checked}`,
            'disabled': disabled,
            'id': inputId,
            'onFocus': () => this.onFocus(),
            'onBlur': () => this.onBlur(),
            'ref': focusEl => (this.focusEl = focusEl),
          }),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          checked: ['checkedChanged'],
          disabled: ['disabledChanged'],
        };
      }
      static get style() {
        return {
          ios: toggleIosCss,
          md: toggleMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-toggle',
          $members$: {
            color: [513],
            name: [1],
            checked: [1028],
            disabled: [4],
            value: [1],
            activated: [32],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }
    const shouldToggle = (doc, checked, deltaX, margin) => {
      const isRTL = doc.dir === 'rtl';
      if (checked) {
        return (!isRTL && margin > deltaX) || (isRTL && -margin < deltaX);
      } else {
        return (!isRTL && -margin < deltaX) || (isRTL && margin > deltaX);
      }
    };
    let toggleIds = 0;

    const toolbarIosCss =
      '/*!@:host*/.sc-ion-toolbar-ios-h{--border-width:0;--border-style:solid;--opacity:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:block;position:relative;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-toolbar-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}/*!@:host(.ion-color)*/.ion-color.sc-ion-toolbar-ios-h{color:var(--ion-color-contrast)}/*!@:host(.ion-color) .toolbar-background*/.ion-color.sc-ion-toolbar-ios-h .toolbar-background.sc-ion-toolbar-ios{background:var(--ion-color-base)}/*!@.toolbar-container*/.toolbar-container.sc-ion-toolbar-ios{padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:flex;position:relative;flex-direction:row;align-items:center;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toolbar-container*/.toolbar-container.sc-ion-toolbar-ios{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.toolbar-background*/.toolbar-background.sc-ion-toolbar-ios{left:0;right:0;top:0;bottom:0;position:absolute;transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:var(--opacity);z-index:-1;pointer-events:none}/*!@::slotted(ion-progress-bar)*/.sc-ion-toolbar-ios-s>ion-progress-bar{left:0;right:0;bottom:0;position:absolute}/*!@:host*/.sc-ion-toolbar-ios-h{--background:var(--ion-toolbar-background, var(--ion-color-step-50, #fff));--color:var(--ion-toolbar-color, var(--ion-text-color, #000));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.2))));--padding-top:3px;--padding-bottom:3px;--padding-start:4px;--padding-end:4px;--min-height:44px}/*!@.toolbar-content*/.toolbar-content.sc-ion-toolbar-ios{flex:1;order:4;min-width:0}/*!@:host(.toolbar-segment) .toolbar-content*/.toolbar-segment.sc-ion-toolbar-ios-h .toolbar-content.sc-ion-toolbar-ios{display:inline-flex}/*!@:host(.toolbar-searchbar) .toolbar-container*/.toolbar-searchbar.sc-ion-toolbar-ios-h .toolbar-container.sc-ion-toolbar-ios{padding-top:0;padding-bottom:0}/*!@:host(.toolbar-searchbar) ::slotted(*)*/.sc-ion-toolbar-ios-h.toolbar-searchbar .sc-ion-toolbar-ios-s>*{align-self:start}/*!@:host(.toolbar-searchbar) ::slotted(ion-chip)*/.sc-ion-toolbar-ios-h.toolbar-searchbar .sc-ion-toolbar-ios-s>ion-chip{margin-top:3px}/*!@:host(.toolbar-searchbar) ::slotted(ion-back-button)*/.sc-ion-toolbar-ios-h.toolbar-searchbar .sc-ion-toolbar-ios-s>ion-back-button{height:38px}/*!@::slotted(ion-buttons)*/.sc-ion-toolbar-ios-s>ion-buttons{min-height:38px}/*!@::slotted([slot=start])*/.sc-ion-toolbar-ios-s>[slot=start]{order:2}/*!@::slotted([slot=secondary])*/.sc-ion-toolbar-ios-s>[slot=secondary]{order:3}/*!@::slotted([slot=primary])*/.sc-ion-toolbar-ios-s>[slot=primary]{order:5;text-align:end}/*!@::slotted([slot=end])*/.sc-ion-toolbar-ios-s>[slot=end]{order:6;text-align:end}/*!@:host(.toolbar-title-large) .toolbar-container*/.toolbar-title-large.sc-ion-toolbar-ios-h .toolbar-container.sc-ion-toolbar-ios{flex-wrap:wrap;align-items:flex-start}/*!@:host(.toolbar-title-large) .toolbar-content ion-title*/.toolbar-title-large.sc-ion-toolbar-ios-h .toolbar-content.sc-ion-toolbar-ios ion-title.sc-ion-toolbar-ios{flex:1;order:8;min-width:100%}';

    const toolbarMdCss =
      '/*!@:host*/.sc-ion-toolbar-md-h{--border-width:0;--border-style:solid;--opacity:1;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;padding-left:var(--ion-safe-area-left);padding-right:var(--ion-safe-area-right);display:block;position:relative;width:100%;color:var(--color);font-family:var(--ion-font-family, inherit);contain:content;z-index:10;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-toolbar-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--ion-safe-area-left);padding-inline-start:var(--ion-safe-area-left);-webkit-padding-end:var(--ion-safe-area-right);padding-inline-end:var(--ion-safe-area-right)}}/*!@:host(.ion-color)*/.ion-color.sc-ion-toolbar-md-h{color:var(--ion-color-contrast)}/*!@:host(.ion-color) .toolbar-background*/.ion-color.sc-ion-toolbar-md-h .toolbar-background.sc-ion-toolbar-md{background:var(--ion-color-base)}/*!@.toolbar-container*/.toolbar-container.sc-ion-toolbar-md{padding-left:var(--padding-start);padding-right:var(--padding-end);padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);display:flex;position:relative;flex-direction:row;align-items:center;justify-content:space-between;width:100%;min-height:var(--min-height);contain:content;overflow:hidden;z-index:10;box-sizing:border-box}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@.toolbar-container*/.toolbar-container.sc-ion-toolbar-md{padding-left:unset;padding-right:unset;-webkit-padding-start:var(--padding-start);padding-inline-start:var(--padding-start);-webkit-padding-end:var(--padding-end);padding-inline-end:var(--padding-end)}}/*!@.toolbar-background*/.toolbar-background.sc-ion-toolbar-md{left:0;right:0;top:0;bottom:0;position:absolute;transform:translateZ(0);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);contain:strict;opacity:var(--opacity);z-index:-1;pointer-events:none}/*!@::slotted(ion-progress-bar)*/.sc-ion-toolbar-md-s>ion-progress-bar{left:0;right:0;bottom:0;position:absolute}/*!@:host*/.sc-ion-toolbar-md-h{--background:var(--ion-toolbar-background, var(--ion-background-color, #fff));--color:var(--ion-toolbar-color, var(--ion-text-color, #424242));--border-color:var(--ion-toolbar-border-color, var(--ion-border-color, var(--ion-color-step-150, #c1c4cd)));--padding-top:0;--padding-bottom:0;--padding-start:0;--padding-end:0;--min-height:56px}/*!@.toolbar-content*/.toolbar-content.sc-ion-toolbar-md{flex:1;order:3;min-width:0;max-width:100%}/*!@::slotted(ion-segment)*/.sc-ion-toolbar-md-s>ion-segment{min-height:var(--min-height)}/*!@::slotted(.buttons-first-slot)*/.sc-ion-toolbar-md-s>.buttons-first-slot{margin-left:4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(.buttons-first-slot)*/.sc-ion-toolbar-md-s>.buttons-first-slot{margin-left:unset;-webkit-margin-start:4px;margin-inline-start:4px}}/*!@::slotted(.buttons-last-slot)*/.sc-ion-toolbar-md-s>.buttons-last-slot{margin-right:4px}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@::slotted(.buttons-last-slot)*/.sc-ion-toolbar-md-s>.buttons-last-slot{margin-right:unset;-webkit-margin-end:4px;margin-inline-end:4px}}/*!@::slotted([slot=start])*/.sc-ion-toolbar-md-s>[slot=start]{order:2}/*!@::slotted([slot=secondary])*/.sc-ion-toolbar-md-s>[slot=secondary]{order:4}/*!@::slotted([slot=primary])*/.sc-ion-toolbar-md-s>[slot=primary]{order:5;text-align:end}/*!@::slotted([slot=end])*/.sc-ion-toolbar-md-s>[slot=end]{order:6;text-align:end}';

    /**
     * @virtualProp {"ios" | "md"} mode - The mode determines which platform styles to use.
     *
     * @slot - Content is placed between the named slots if provided without a slot.
     * @slot start - Content is placed to the left of the toolbar text in LTR, and to the right in RTL.
     * @slot secondary - Content is placed to the left of the toolbar text in `ios` mode, and directly to the right in `md` mode.
     * @slot primary - Content is placed to the right of the toolbar text in `ios` mode, and to the far right in `md` mode.
     * @slot end - Content is placed to the right of the toolbar text in LTR, and to the left in RTL.
     */
    class Toolbar {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.childrenStyles = new Map();
      }
      componentWillLoad() {
        const buttons = Array.from(this.el.querySelectorAll('ion-buttons'));
        const firstButtons = buttons.find(button => {
          return button.slot === 'start';
        });
        if (firstButtons) {
          firstButtons.classList.add('buttons-first-slot');
        }
        const buttonsReversed = buttons.reverse();
        const lastButtons =
          buttonsReversed.find(button => button.slot === 'end') ||
          buttonsReversed.find(button => button.slot === 'primary') ||
          buttonsReversed.find(button => button.slot === 'secondary');
        if (lastButtons) {
          lastButtons.classList.add('buttons-last-slot');
        }
      }
      childrenStyle(ev) {
        ev.stopPropagation();
        const tagName = ev.target.tagName;
        const updatedStyles = ev.detail;
        const newStyles = {};
        const childStyles = this.childrenStyles.get(tagName) || {};
        let hasStyleChange = false;
        Object.keys(updatedStyles).forEach(key => {
          const childKey = `toolbar-${key}`;
          const newValue = updatedStyles[key];
          if (newValue !== childStyles[childKey]) {
            hasStyleChange = true;
          }
          if (newValue) {
            newStyles[childKey] = true;
          }
        });
        if (hasStyleChange) {
          this.childrenStyles.set(tagName, newStyles);
          forceUpdate$1(this);
        }
      }
      render() {
        const mode = getIonMode$1(this);
        const childStyles = {};
        this.childrenStyles.forEach(value => {
          Object.assign(childStyles, value);
        });
        return hAsync(
          Host,
          {
            class: Object.assign(
              Object.assign({}, childStyles),
              createColorClasses$1(this.color, {
                [mode]: true,
                'in-toolbar': hostContext('ion-toolbar', this.el),
              }),
            ),
          },
          hAsync('div', { class: 'toolbar-background' }),
          hAsync(
            'div',
            { class: 'toolbar-container' },
            hAsync('slot', { name: 'start' }),
            hAsync('slot', { name: 'secondary' }),
            hAsync('div', { class: 'toolbar-content' }, hAsync('slot', null)),
            hAsync('slot', { name: 'primary' }),
            hAsync('slot', { name: 'end' }),
          ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get style() {
        return {
          ios: toolbarIosCss,
          md: toolbarMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-toolbar',
          $members$: {
            color: [513],
          },
          $listeners$: [[0, 'ionStyle', 'childrenStyle']],
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const titleIosCss =
      '/*!@:host*/.sc-ion-title-ios-h{--color:initial;display:flex;flex:1;align-items:center;transform:translateZ(0);color:var(--color)}/*!@:host(.ion-color)*/.ion-color.sc-ion-title-ios-h{color:var(--ion-color-base)}/*!@.toolbar-title*/.toolbar-title.sc-ion-title-ios{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}/*!@:host(.title-small) .toolbar-title*/.title-small.sc-ion-title-ios-h .toolbar-title.sc-ion-title-ios{white-space:normal}/*!@:host*/.sc-ion-title-ios-h{left:0;top:0;padding-left:90px;padding-right:90px;padding-top:var(--padding-top);padding-bottom:var(--padding-bottom);position:absolute;width:100%;height:100%;transform:translateZ(0);font-size:17px;font-weight:600;text-align:center;box-sizing:border-box;pointer-events:none}/*!@:host-context([dir=rtl])*/[dir=rtl].sc-ion-title-ios-h,[dir=rtl] .sc-ion-title-ios-h{left:unset;right:unset;right:0}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-title-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:90px;padding-inline-start:90px;-webkit-padding-end:90px;padding-inline-end:90px}}/*!@:host(.title-small)*/.title-small.sc-ion-title-ios-h{padding-left:9px;padding-right:9px;padding-top:6px;padding-bottom:16px;position:relative;font-size:13px;font-weight:normal}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.title-small)*/.title-small.sc-ion-title-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:9px;padding-inline-start:9px;-webkit-padding-end:9px;padding-inline-end:9px}}/*!@:host(.title-large)*/.title-large.sc-ion-title-ios-h{padding-left:16px;padding-right:16px;padding-top:0;padding-bottom:0;transform-origin:left center;bottom:0;align-items:flex-end;min-width:100%;padding-bottom:6px;font-size:34px;font-weight:700;text-align:start}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host(.title-large)*/.title-large.sc-ion-title-ios-h{padding-left:unset;padding-right:unset;-webkit-padding-start:16px;padding-inline-start:16px;-webkit-padding-end:16px;padding-inline-end:16px}}/*!@:host(.title-large.title-rtl)*/.title-large.title-rtl.sc-ion-title-ios-h{transform-origin:right center}/*!@:host(.title-large.ion-cloned-element)*/.title-large.ion-cloned-element.sc-ion-title-ios-h{--color:var(--ion-text-color, #000)}/*!@:host(.title-large) .toolbar-title*/.title-large.sc-ion-title-ios-h .toolbar-title.sc-ion-title-ios{transform-origin:inherit}/*!@:host-context([dir=rtl]):host(.title-large) .toolbar-title, :host-context([dir=rtl]).title-large .toolbar-title*/[dir=rtl].sc-ion-title-ios-h -no-combinator.title-large.sc-ion-title-ios-h .toolbar-title.sc-ion-title-ios,[dir=rtl] .sc-ion-title-ios-h -no-combinator.title-large.sc-ion-title-ios-h .toolbar-title.sc-ion-title-ios,[dir=rtl].title-large.sc-ion-title-ios-h .toolbar-title.sc-ion-title-ios,[dir=rtl] .title-large.sc-ion-title-ios-h .toolbar-title.sc-ion-title-ios{transform-origin:calc(100% - inherit)}';

    const titleMdCss =
      '/*!@:host*/.sc-ion-title-md-h{--color:initial;display:flex;flex:1;align-items:center;transform:translateZ(0);color:var(--color)}/*!@:host(.ion-color)*/.ion-color.sc-ion-title-md-h{color:var(--ion-color-base)}/*!@.toolbar-title*/.toolbar-title.sc-ion-title-md{display:block;width:100%;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;pointer-events:auto}/*!@:host(.title-small) .toolbar-title*/.title-small.sc-ion-title-md-h .toolbar-title.sc-ion-title-md{white-space:normal}/*!@:host*/.sc-ion-title-md-h{padding-left:20px;padding-right:20px;padding-top:0;padding-bottom:0;font-size:20px;font-weight:500;letter-spacing:0.0125em}@supports (margin-inline-start: 0) or (-webkit-margin-start: 0){/*!@:host*/.sc-ion-title-md-h{padding-left:unset;padding-right:unset;-webkit-padding-start:20px;padding-inline-start:20px;-webkit-padding-end:20px;padding-inline-end:20px}}/*!@:host(.title-small)*/.title-small.sc-ion-title-md-h{width:100%;height:100%;font-size:15px;font-weight:normal}';

    class ToolbarTitle {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.ionStyle = createEvent(this, 'ionStyle', 7);
      }
      sizeChanged() {
        this.emitStyle();
      }
      connectedCallback() {
        this.emitStyle();
      }
      emitStyle() {
        const size = this.getSize();
        this.ionStyle.emit({
          [`title-${size}`]: true,
        });
      }
      getSize() {
        return this.size !== undefined ? this.size : 'default';
      }
      render() {
        const mode = getIonMode$1(this);
        const size = this.getSize();
        return hAsync(
          Host,
          {
            class: createColorClasses$1(this.color, {
              [mode]: true,
              [`title-${size}`]: true,
              'title-rtl': document.dir === 'rtl',
            }),
          },
          hAsync('div', { class: 'toolbar-title' }, hAsync('slot', null)),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          size: ['sizeChanged'],
        };
      }
      static get style() {
        return {
          ios: titleIosCss,
          md: titleMdCss,
        };
      }
      static get cmpMeta() {
        return {
          $flags$: 41,
          $tagName$: 'ion-title',
          $members$: {
            color: [513],
            size: [1],
          },
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [['color', 'color']],
        };
      }
    }

    const CELL_TYPE_ITEM = 'item';
    const CELL_TYPE_HEADER = 'header';
    const CELL_TYPE_FOOTER = 'footer';
    const NODE_CHANGE_NONE = 0;
    const NODE_CHANGE_POSITION = 1;
    const NODE_CHANGE_CELL = 2;

    const MIN_READS = 2;
    const updateVDom = (dom, heightIndex, cells, range) => {
      // reset dom
      for (const node of dom) {
        node.change = NODE_CHANGE_NONE;
        node.d = true;
      }
      // try to match into exisiting dom
      const toMutate = [];
      const end = range.offset + range.length;
      for (let i = range.offset; i < end; i++) {
        const cell = cells[i];
        const node = dom.find(n => n.d && n.cell === cell);
        if (node) {
          const top = heightIndex[i];
          if (top !== node.top) {
            node.top = top;
            node.change = NODE_CHANGE_POSITION;
          }
          node.d = false;
        } else {
          toMutate.push(cell);
        }
      }
      // needs to append
      const pool = dom.filter(n => n.d);
      for (const cell of toMutate) {
        const node = pool.find(n => n.d && n.cell.type === cell.type);
        const index = cell.i;
        if (node) {
          node.d = false;
          node.change = NODE_CHANGE_CELL;
          node.cell = cell;
          node.top = heightIndex[index];
        } else {
          dom.push({
            d: false,
            cell,
            visible: true,
            change: NODE_CHANGE_CELL,
            top: heightIndex[index],
          });
        }
      }
      dom
        .filter(n => n.d && n.top !== -9999)
        .forEach(n => {
          n.change = NODE_CHANGE_POSITION;
          n.top = -9999;
        });
    };
    const doRender = (el, nodeRender, dom, updateCellHeight) => {
      const children = Array.from(el.children).filter(n => n.tagName !== 'TEMPLATE');
      const childrenNu = children.length;
      let child;
      for (let i = 0; i < dom.length; i++) {
        const node = dom[i];
        const cell = node.cell;
        // the cell change, the content must be updated
        if (node.change === NODE_CHANGE_CELL) {
          if (i < childrenNu) {
            child = children[i];
            nodeRender(child, cell, i);
          } else {
            const newChild = createNode(el, cell.type);
            child = nodeRender(newChild, cell, i) || newChild;
            child.classList.add('virtual-item');
            el.appendChild(child);
          }
          child['$ionCell'] = cell;
        } else {
          child = children[i];
        }
        // only update position when it changes
        if (node.change !== NODE_CHANGE_NONE) {
          child.style.transform = `translate3d(0,${node.top}px,0)`;
        }
        // update visibility
        const visible = cell.visible;
        if (node.visible !== visible) {
          if (visible) {
            child.classList.remove('virtual-loading');
          } else {
            child.classList.add('virtual-loading');
          }
          node.visible = visible;
        }
        // dynamic height
        if (cell.reads > 0) {
          updateCellHeight(cell, child);
          cell.reads--;
        }
      }
    };
    const createNode = (el, type) => {
      const template = getTemplate(el, type);
      if (template && el.ownerDocument) {
        return el.ownerDocument.importNode(template.content, true).children[0];
      }
      return null;
    };
    const getTemplate = (el, type) => {
      switch (type) {
        case CELL_TYPE_ITEM:
          return el.querySelector('template:not([name])');
        case CELL_TYPE_HEADER:
          return el.querySelector('template[name=header]');
        case CELL_TYPE_FOOTER:
          return el.querySelector('template[name=footer]');
      }
    };
    const getViewport = (scrollTop, vierportHeight, margin) => {
      return {
        top: Math.max(scrollTop - margin, 0),
        bottom: scrollTop + vierportHeight + margin,
      };
    };
    const getRange = (heightIndex, viewport, buffer) => {
      const topPos = viewport.top;
      const bottomPos = viewport.bottom;
      // find top index
      let i = 0;
      for (; i < heightIndex.length; i++) {
        if (heightIndex[i] > topPos) {
          break;
        }
      }
      const offset = Math.max(i - buffer - 1, 0);
      // find bottom index
      for (; i < heightIndex.length; i++) {
        if (heightIndex[i] >= bottomPos) {
          break;
        }
      }
      const end = Math.min(i + buffer, heightIndex.length);
      const length = end - offset;
      return { offset, length };
    };
    const getShouldUpdate = (dirtyIndex, currentRange, range) => {
      const end = range.offset + range.length;
      return dirtyIndex <= end || currentRange.offset !== range.offset || currentRange.length !== range.length;
    };
    const findCellIndex = (cells, index) => {
      const max = cells.length > 0 ? cells[cells.length - 1].index : 0;
      if (index === 0) {
        return 0;
      } else if (index === max + 1) {
        return cells.length;
      } else {
        return cells.findIndex(c => c.index === index);
      }
    };
    const inplaceUpdate = (dst, src, offset) => {
      if (offset === 0 && src.length >= dst.length) {
        return src;
      }
      for (let i = 0; i < src.length; i++) {
        dst[i + offset] = src[i];
      }
      return dst;
    };
    const calcCells = (items, itemHeight, headerHeight, footerHeight, headerFn, footerFn, approxHeaderHeight, approxFooterHeight, approxItemHeight, j, offset, len) => {
      const cells = [];
      const end = len + offset;
      for (let i = offset; i < end; i++) {
        const item = items[i];
        if (headerFn) {
          const value = headerFn(item, i, items);
          if (value != null) {
            cells.push({
              i: j++,
              type: CELL_TYPE_HEADER,
              value,
              index: i,
              height: headerHeight ? headerHeight(value, i) : approxHeaderHeight,
              reads: headerHeight ? 0 : MIN_READS,
              visible: !!headerHeight,
            });
          }
        }
        cells.push({
          i: j++,
          type: CELL_TYPE_ITEM,
          value: item,
          index: i,
          height: itemHeight ? itemHeight(item, i) : approxItemHeight,
          reads: itemHeight ? 0 : MIN_READS,
          visible: !!itemHeight,
        });
        if (footerFn) {
          const value = footerFn(item, i, items);
          if (value != null) {
            cells.push({
              i: j++,
              type: CELL_TYPE_FOOTER,
              value,
              index: i,
              height: footerHeight ? footerHeight(value, i) : approxFooterHeight,
              reads: footerHeight ? 0 : MIN_READS,
              visible: !!footerHeight,
            });
          }
        }
      }
      return cells;
    };
    const calcHeightIndex = (buf, cells, index) => {
      let acum = buf[index];
      for (let i = index; i < buf.length; i++) {
        buf[i] = acum;
        acum += cells[i].height;
      }
      return acum;
    };
    const resizeBuffer = (buf, len) => {
      if (!buf) {
        return new Uint32Array(len);
      }
      if (buf.length === len) {
        return buf;
      } else if (len > buf.length) {
        const newBuf = new Uint32Array(len);
        newBuf.set(buf);
        return newBuf;
      } else {
        return buf.subarray(0, len);
      }
    };
    const positionForIndex = (index, cells, heightIndex) => {
      const cell = cells.find(c => c.type === CELL_TYPE_ITEM && c.index === index);
      if (cell) {
        return heightIndex[cell.i];
      }
      return -1;
    };

    const virtualScrollCss =
      'ion-virtual-scroll{display:block;position:relative;width:100%;contain:strict;user-select:none}ion-virtual-scroll>.virtual-loading{opacity:0}ion-virtual-scroll>.virtual-item{position:absolute !important;top:0 !important;right:0 !important;left:0 !important;transition-duration:0ms;will-change:transform}';

    class VirtualScroll {
      constructor(hostRef) {
        registerInstance(this, hostRef);
        this.range = { offset: 0, length: 0 };
        this.viewportHeight = 0;
        this.cells = [];
        this.virtualDom = [];
        this.isEnabled = false;
        this.viewportOffset = 0;
        this.currentScrollTop = 0;
        this.indexDirty = 0;
        this.lastItemLen = 0;
        this.totalHeight = 0;
        /**
         * It is important to provide this
         * if virtual item height will be significantly larger than the default
         * The approximate height of each virtual item template's cell.
         * This dimension is used to help determine how many cells should
         * be created when initialized, and to help calculate the height of
         * the scrollable area. This height value can only use `px` units.
         * Note that the actual rendered size of each cell comes from the
         * app's CSS, whereas this approximation is used to help calculate
         * initial dimensions before the item has been rendered.
         */
        this.approxItemHeight = 45;
        /**
         * The approximate height of each header template's cell.
         * This dimension is used to help determine how many cells should
         * be created when initialized, and to help calculate the height of
         * the scrollable area. This height value can only use `px` units.
         * Note that the actual rendered size of each cell comes from the
         * app's CSS, whereas this approximation is used to help calculate
         * initial dimensions before the item has been rendered.
         */
        this.approxHeaderHeight = 30;
        /**
         * The approximate width of each footer template's cell.
         * This dimension is used to help determine how many cells should
         * be created when initialized, and to help calculate the height of
         * the scrollable area. This height value can only use `px` units.
         * Note that the actual rendered size of each cell comes from the
         * app's CSS, whereas this approximation is used to help calculate
         * initial dimensions before the item has been rendered.
         */
        this.approxFooterHeight = 30;
        this.onScroll = () => {
          this.updateVirtualScroll();
        };
      }
      itemsChanged() {
        this.calcCells();
        this.updateVirtualScroll();
      }
      componentWillLoad() {
        console.warn(
          `[Deprecation Warning]: ion-virtual-scroll has been deprecated and will be removed in Ionic Framework v7.0. See https://ionicframework.com/docs/angular/virtual-scroll for migration steps.`,
        );
      }
      async connectedCallback() {
        const contentEl = this.el.closest('ion-content');
        if (!contentEl) {
          console.error('<ion-virtual-scroll> must be used inside an <ion-content>');
          return;
        }
        this.scrollEl = await contentEl.getScrollElement();
        this.contentEl = contentEl;
        this.calcCells();
        this.updateState();
      }
      componentDidUpdate() {
        this.updateState();
      }
      disconnectedCallback() {
        this.scrollEl = undefined;
      }
      onResize() {
        this.calcCells();
        this.updateVirtualScroll();
      }
      /**
       * Returns the position of the virtual item at the given index.
       */
      positionForItem(index) {
        return Promise.resolve(positionForIndex(index, this.cells, this.getHeightIndex()));
      }
      /**
       * This method marks a subset of items as dirty, so they can be re-rendered. Items should be marked as
       * dirty any time the content or their style changes.
       *
       * The subset of items to be updated can are specifing by an offset and a length.
       */
      async checkRange(offset, len = -1) {
        // TODO: kind of hacky how we do in-place updated of the cells
        // array. this part needs a complete refactor
        if (!this.items) {
          return;
        }
        const length = len === -1 ? this.items.length - offset : len;
        const cellIndex = findCellIndex(this.cells, offset);
        const cells = calcCells(
          this.items,
          this.itemHeight,
          this.headerHeight,
          this.footerHeight,
          this.headerFn,
          this.footerFn,
          this.approxHeaderHeight,
          this.approxFooterHeight,
          this.approxItemHeight,
          cellIndex,
          offset,
          length,
        );
        this.cells = inplaceUpdate(this.cells, cells, cellIndex);
        this.lastItemLen = this.items.length;
        this.indexDirty = Math.max(offset - 1, 0);
        this.scheduleUpdate();
      }
      /**
       * This method marks the tail the items array as dirty, so they can be re-rendered.
       *
       * It's equivalent to calling:
       *
       * ```js
       * virtualScroll.checkRange(lastItemLen);
       * ```
       */
      async checkEnd() {
        if (this.items) {
          this.checkRange(this.lastItemLen);
        }
      }
      updateVirtualScroll() {
        // do nothing if virtual-scroll is disabled
        if (!this.isEnabled || !this.scrollEl) {
          return;
        }
        // unschedule future updates
        if (this.timerUpdate) {
          clearTimeout(this.timerUpdate);
          this.timerUpdate = undefined;
        }
        // schedule DOM operations into the stencil queue
        readTask(this.readVS.bind(this));
        writeTask(this.writeVS.bind(this));
      }
      readVS() {
        const { contentEl, scrollEl, el } = this;
        let topOffset = 0;
        let node = el;
        while (node && node !== contentEl) {
          topOffset += node.offsetTop;
          node = node.offsetParent;
        }
        this.viewportOffset = topOffset;
        if (scrollEl) {
          this.viewportHeight = scrollEl.offsetHeight;
          this.currentScrollTop = scrollEl.scrollTop;
        }
      }
      writeVS() {
        const dirtyIndex = this.indexDirty;
        // get visible viewport
        const scrollTop = this.currentScrollTop - this.viewportOffset;
        const viewport = getViewport(scrollTop, this.viewportHeight, 100);
        // compute lazily the height index
        const heightIndex = this.getHeightIndex();
        // get array bounds of visible cells base in the viewport
        const range = getRange(heightIndex, viewport, 2);
        // fast path, do nothing
        const shouldUpdate = getShouldUpdate(dirtyIndex, this.range, range);
        if (!shouldUpdate) {
          return;
        }
        this.range = range;
        // in place mutation of the virtual DOM
        updateVDom(this.virtualDom, heightIndex, this.cells, range);
        // Write DOM
        // Different code paths taken depending of the render API used
        if (this.nodeRender) {
          doRender(this.el, this.nodeRender, this.virtualDom, this.updateCellHeight.bind(this));
        } else if (this.domRender) {
          this.domRender(this.virtualDom);
        } else if (this.renderItem) {
          forceUpdate$1(this);
        }
      }
      updateCellHeight(cell, node) {
        const update = () => {
          if (node['$ionCell'] === cell) {
            const style = window.getComputedStyle(node);
            const height = node.offsetHeight + parseFloat(style.getPropertyValue('margin-bottom'));
            this.setCellHeight(cell, height);
          }
        };
        if (node) {
          componentOnReady(node, update);
        } else {
          update();
        }
      }
      setCellHeight(cell, height) {
        const index = cell.i;
        // the cell might changed since the height update was scheduled
        if (cell !== this.cells[index]) {
          return;
        }
        if (cell.height !== height || cell.visible !== true) {
          cell.visible = true;
          cell.height = height;
          this.indexDirty = Math.min(this.indexDirty, index);
          this.scheduleUpdate();
        }
      }
      scheduleUpdate() {
        clearTimeout(this.timerUpdate);
        this.timerUpdate = setTimeout(() => this.updateVirtualScroll(), 100);
      }
      updateState() {
        const shouldEnable = !!(this.scrollEl && this.cells);
        if (shouldEnable !== this.isEnabled) {
          this.enableScrollEvents(shouldEnable);
          if (shouldEnable) {
            this.updateVirtualScroll();
          }
        }
      }
      calcCells() {
        if (!this.items) {
          return;
        }
        this.lastItemLen = this.items.length;
        this.cells = calcCells(
          this.items,
          this.itemHeight,
          this.headerHeight,
          this.footerHeight,
          this.headerFn,
          this.footerFn,
          this.approxHeaderHeight,
          this.approxFooterHeight,
          this.approxItemHeight,
          0,
          0,
          this.lastItemLen,
        );
        this.indexDirty = 0;
      }
      getHeightIndex() {
        if (this.indexDirty !== Infinity) {
          this.calcHeightIndex(this.indexDirty);
        }
        return this.heightIndex;
      }
      calcHeightIndex(index = 0) {
        // TODO: optimize, we don't need to calculate all the cells
        this.heightIndex = resizeBuffer(this.heightIndex, this.cells.length);
        this.totalHeight = calcHeightIndex(this.heightIndex, this.cells, index);
        this.indexDirty = Infinity;
      }
      enableScrollEvents(shouldListen) {
        if (this.rmEvent) {
          this.rmEvent();
          this.rmEvent = undefined;
        }
        const scrollEl = this.scrollEl;
        if (scrollEl) {
          this.isEnabled = shouldListen;
          scrollEl.addEventListener('scroll', this.onScroll);
          this.rmEvent = () => {
            scrollEl.removeEventListener('scroll', this.onScroll);
          };
        }
      }
      renderVirtualNode(node) {
        const { type, value, index } = node.cell;
        switch (type) {
          case CELL_TYPE_ITEM:
            return this.renderItem(value, index);
          case CELL_TYPE_HEADER:
            return this.renderHeader(value, index);
          case CELL_TYPE_FOOTER:
            return this.renderFooter(value, index);
        }
      }
      render() {
        return hAsync(
          Host,
          {
            style: {
              height: `${this.totalHeight}px`,
            },
          },
          this.renderItem &&
            hAsync(
              VirtualProxy,
              { dom: this.virtualDom },
              this.virtualDom.map(node => this.renderVirtualNode(node)),
            ),
        );
      }
      get el() {
        return getElement(this);
      }
      static get watchers() {
        return {
          itemHeight: ['itemsChanged'],
          headerHeight: ['itemsChanged'],
          footerHeight: ['itemsChanged'],
          items: ['itemsChanged'],
        };
      }
      static get style() {
        return virtualScrollCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ion-virtual-scroll',
          $members$: {
            approxItemHeight: [2, 'approx-item-height'],
            approxHeaderHeight: [2, 'approx-header-height'],
            approxFooterHeight: [2, 'approx-footer-height'],
            headerFn: [16],
            footerFn: [16],
            items: [16],
            itemHeight: [16],
            headerHeight: [16],
            footerHeight: [16],
            renderItem: [16],
            renderHeader: [16],
            renderFooter: [16],
            nodeRender: [16],
            domRender: [16],
            totalHeight: [32],
            positionForItem: [64],
            checkRange: [64],
            checkEnd: [64],
          },
          $listeners$: [[9, 'resize', 'onResize']],
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }
    const VirtualProxy = ({ dom }, children, utils) => {
      return utils.map(children, (child, i) => {
        const node = dom[i];
        const vattrs = child.vattrs || {};
        let classes = vattrs.class || '';
        classes += 'virtual-item ';
        if (!node.visible) {
          classes += 'virtual-loading';
        }
        return Object.assign(Object.assign({}, child), {
          vattrs: Object.assign(Object.assign({}, vattrs), {
            class: classes,
            style: Object.assign(Object.assign({}, vattrs.style), { transform: `translate3d(0,${node.top}px,0)` }),
          }),
        });
      });
    };

    const ffspbRootComponentCss =
      ':root{--content-width:1280px;--min-content-width:800px}h2{font-weight:700;font-size:28px !important;width:100%;max-width:var(--content-width);padding:0;margin:0 auto !important;color:white;text-transform:uppercase}.mobile h2{margin-left:22px !important;font-size:24px !important}ion-nav,ion-content{--background:#414141}button{height:52px;padding:0 38px;font-weight:700;font-size:16px;border-radius:5px !important;transition:all 0.2s ease-in-out;background-size:200%;background-position:left}button:hover{background-position:right}button.steel{color:#343434;background-image:linear-gradient(111.34deg, #c9c9c9 0%, #fefefe 24%, #c9c9c9 50%, #d4d4d4 50%, #696969 220%)}button.black{color:white;background-image:linear-gradient(96.33deg, #737373 0.77%, #424242 27%, #4d4d4d 50%, #272727 50%, #272727)}button.outline{color:#c9c9c9;box-shadow:0 0 0 2px #c9c9c9;background:transparent;position:relative;height:48px;z-index:1}button.outline:before{position:absolute;top:0;left:0;height:100%;width:100%;content:" ";display:block;z-index:-1;background:linear-gradient(111.34deg, #c9c9c9 0%, #fefefe 24%, #c9c9c9 50%, #d4d4d4 50%, #696969 220%);border-radius:5px;transition:opacity 0.2s ease-in-out;opacity:0}button.outline:hover{color:#343434}button.outline:hover:before{opacity:1}@media only screen and (max-width: 1150px){button{height:42px}button.outline{height:38px}}.mobile button{height:45px;padding:0 38px}';

    class ffspbRoot {
      constructor(hostRef) {
        registerInstance(this, hostRef);
      }
      componentWillLoad() {
        dist.envState.apiHost = environment.apiHost;
        dist.envState.graphqlHost = environment.graphqlHost;
        dist.envState.imgHost = environment.imgHost;
        function getViewportSize() {
          const object = 'innerWidth' in window ? window : document.documentElement || document.body;
          const prefix = 'innerWidth' in window ? 'inner' : 'client';
          return { width: object[prefix + 'Width'], height: object[prefix + 'Height'] };
        }
        dist.envState.platform = getViewportSize().width > 800 ? 'web' : 'ios';
        const vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
        fromEvent(window, 'resize').subscribe(() => {
          dist.envState.platform = getViewportSize().width > 800 ? 'web' : 'ios';
          const vh = window.innerHeight * 0.01;
          document.documentElement.style.setProperty('--vh', `${vh}px`);
        });
      }
      render() {
        return hAsync(
          'ion-app',
          { class: dist.envState.platform == 'web' ? 'desktop' : 'mobile' },
          hAsync('ffspb-side-menu', null),
          hAsync(
            'div',
            { class: 'ion-page', id: 'main-content' },
            hAsync(
              'ion-router',
              { useHash: false },
              hAsync('ion-route', { url: routes.home, component: 'ffspb-welcome-page' }),
              hAsync('ion-route', { url: routes.license_agreement, component: 'ffspb-license-agreement-page' }),
              hAsync('ion-route', { url: routes.cookie_policy, component: 'ffspb-cookie-policy-page' }),
              hAsync('ion-route', { url: routes.healthcheck, component: 'ffspb-healthcheck-page' }),
              hAsync('ion-route', { url: routes.team, component: 'ffspb-team-page' }),
              hAsync('ion-route', { url: routes.team_games, component: 'ffspb-team-games-page' }),
              hAsync('ion-route', { url: routes.team_players_stats, component: 'ffspb-team-players-stats-page' }),
              hAsync('ion-route', { url: routes.team_transfers, component: 'ffspb-team-transfers-page' }),
              hAsync('ion-route', { url: routes.player, component: 'ffspb-player-page' }),
              hAsync('ion-route', { url: routes.player_games, component: 'ffspb-player-games-page' }),
              hAsync('ion-route', { url: routes.season, component: 'ffspb-season-page' }),
              hAsync('ion-route', { url: routes.season_calendar, component: 'ffspb-season-calendar-page' }),
              hAsync('ion-route', { url: routes.season_players, component: 'ffspb-season-players-page' }),
              hAsync('ion-route', { url: routes.season_stadiums, component: 'ffspb-season-stadiums-page' }),
              hAsync('ion-route', { url: routes.season_staff, component: 'ffspb-season-staff-page' }),
              hAsync('ion-route', { url: routes.stadiums, component: 'ffspb-stadium-page' }),
              hAsync('ion-route', { url: routes.stadium, component: 'ffspb-stadium-page' }),
              hAsync('ion-route', { url: routes.referees, component: 'ffspb-referees-page' }),
              hAsync('ion-route', { url: routes.referee, component: 'ffspb-referee-page' }),
              hAsync('ion-route', { url: routes.game, component: 'ffspb-game-page' }),
              hAsync('ion-route', { url: routes.news, component: 'ffspb-news-page' }),
              hAsync('ion-route', { url: routes.post, component: 'ffspb-post-page' }),
            ),
            hAsync('ion-nav', { animated: false }),
          ),
        );
      }
      static get style() {
        return ffspbRootComponentCss;
      }
      static get cmpMeta() {
        return {
          $flags$: 0,
          $tagName$: 'ffspb-root',
          $members$: undefined,
          $listeners$: undefined,
          $lazyBundleId$: '-',
          $attrsToReflect$: [],
        };
      }
    }

    registerComponents([
      ActionSheet,
      Alert,
      App,
      Avatar,
      BackButton,
      Backdrop,
      Badge,
      Button,
      Buttons,
      Card,
      CardContent,
      CardHeader,
      CardSubtitle,
      CardTitle,
      Checkbox,
      Chip,
      Col,
      Content,
      Datetime,
      Fab,
      FabButton,
      FabList,
      FfspbContent,
      FfspbContentInner,
      FfspbCookiePolicyPage,
      FfspbFooter,
      FfspbGanePage,
      FfspbHeader,
      FfspbHealthcheckPage,
      FfspbLicenseAgreementPage,
      FfspbNews,
      FfspbNewsPage,
      FfspbPlayerGamesPage,
      FfspbPlayerPage,
      FfspbPostPage,
      FfspbRefereePage,
      FfspbRefereesPage,
      FfspbSeasonCalendarPage,
      FfspbSeasonPage,
      FfspbSeasonPlayersPage,
      FfspbSeasonStadiumsPage,
      FfspbSeasonStaffPage,
      FfspbSideMenu,
      FfspbStadiumPage,
      FfspbStadiumsPage,
      FfspbTeamGamesPage,
      FfspbTeamPage,
      FfspbTeamPlayersStatsPage,
      FfspbTeamTransfersPage,
      FfspbWelcomeBanner,
      FfspbWelcomeBanners,
      FfspbWelcomeMaterials,
      FfspbWelcomeNews,
      FfspbWelcomePage,
      FfspbWelcomePartners,
      FfspbWelcomeTournaments,
      Footer,
      Grid,
      Header,
      Icon,
      Img,
      InfiniteScroll,
      InfiniteScrollContent,
      Input,
      Item,
      ItemDivider,
      ItemGroup,
      ItemOption,
      ItemOptions,
      ItemSliding,
      Label,
      List,
      ListHeader,
      Loading,
      Menu,
      MenuButton,
      MenuToggle,
      Modal,
      Nav,
      NavLink,
      Note,
      Picker,
      PickerColumnCmp,
      Popover,
      ProgressBar,
      Radio,
      RadioGroup,
      Range,
      Refresher,
      RefresherContent,
      Reorder,
      ReorderGroup,
      RippleEffect,
      Route,
      RouteRedirect,
      Router,
      RouterLink,
      RouterOutlet,
      Row,
      Searchbar,
      Segment,
      SegmentButton,
      Select,
      SelectOption,
      SelectPopover,
      SkeletonText,
      Slide,
      Slides,
      Spinner,
      SplitPane,
      Tab,
      TabBar,
      TabButton,
      Tabs,
      Text,
      Textarea,
      Thumbnail,
      Toast,
      Toggle,
      Toolbar,
      ToolbarTitle,
      VirtualScroll,
      ffspbRoot,
    ]);

    class StorageWeb extends WebPlugin {
      constructor() {
        super(...arguments);
        this.group = 'CapacitorStorage';
      }
      async configure({ group }) {
        if (typeof group === 'string') {
          this.group = group;
        }
      }
      async get(options) {
        const value = this.impl.getItem(this.applyPrefix(options.key));
        return { value };
      }
      async set(options) {
        this.impl.setItem(this.applyPrefix(options.key), options.value);
      }
      async remove(options) {
        this.impl.removeItem(this.applyPrefix(options.key));
      }
      async keys() {
        const keys = this.rawKeys().map(k => k.substring(this.prefix.length));
        return { keys };
      }
      async clear() {
        for (const key of this.rawKeys()) {
          this.impl.removeItem(key);
        }
      }
      async migrate() {
        var _a;
        const migrated = [];
        const existing = [];
        const oldprefix = '_cap_';
        const keys = Object.keys(this.impl).filter(k => k.indexOf(oldprefix) === 0);
        for (const oldkey of keys) {
          const key = oldkey.substring(oldprefix.length);
          const value = (_a = this.impl.getItem(oldkey)) !== null && _a !== void 0 ? _a : '';
          const { value: currentValue } = await this.get({ key });
          if (typeof currentValue === 'string') {
            existing.push(key);
          } else {
            await this.set({ key, value });
            migrated.push(key);
          }
        }
        return { migrated, existing };
      }
      async removeOld() {
        const oldprefix = '_cap_';
        const keys = Object.keys(this.impl).filter(k => k.indexOf(oldprefix) === 0);
        for (const oldkey of keys) {
          this.impl.removeItem(oldkey);
        }
      }
      get impl() {
        return window.localStorage;
      }
      get prefix() {
        return this.group === 'NativeStorage' ? '' : `${this.group}.`;
      }
      rawKeys() {
        return Object.keys(this.impl).filter(k => k.indexOf(this.prefix) === 0);
      }
      applyPrefix(key) {
        return this.prefix + key;
      }
    }

    var web$1 = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      StorageWeb: StorageWeb,
    });

    const appleSignInWeb = async () => {
      var _a;
      const provider = new firebase.auth.OAuthProvider('apple.com');
      firebase.auth().useDeviceLanguage();
      const userCredential = await firebase.auth().signInWithPopup(provider);
      const credential = userCredential === null || userCredential === void 0 ? void 0 : userCredential.credential;
      return new AppleSignInResult(credential.idToken, '', credential.accessToken, (_a = credential.secret) !== null && _a !== void 0 ? _a : '');
    };

    const facebookSignInWeb = async () => {
      const provider = new firebase.auth.FacebookAuthProvider();
      firebase.auth().useDeviceLanguage();
      const userCredential = await firebase.auth().signInWithPopup(provider);
      const credential = userCredential === null || userCredential === void 0 ? void 0 : userCredential.credential;
      return new FacebookSignInResult(credential === null || credential === void 0 ? void 0 : credential.accessToken);
    };

    const googleSignInWeb = async () => {
      const provider = new firebase.auth.GoogleAuthProvider();
      firebase.auth().useDeviceLanguage();
      const userCredential = await firebase.auth().signInWithPopup(provider);
      const credential = userCredential === null || userCredential === void 0 ? void 0 : userCredential.credential;
      return new GoogleSignInResult(credential.idToken);
    };

    const phoneSignInWeb = async options => {
      var _a, _b, _c, _d;
      firebase.auth().useDeviceLanguage();
      const code = (_a = options.data) === null || _a === void 0 ? void 0 : _a.verificationCode;
      const verifier = new firebase.auth.RecaptchaVerifier((_b = options.data) === null || _b === void 0 ? void 0 : _b.container);
      const userCredential = await firebase.auth().signInWithPhoneNumber((_c = options.data) === null || _c === void 0 ? void 0 : _c.phone, verifier);
      const confirmation = await userCredential.confirm(code);
      const idToken = await ((_d = confirmation.user) === null || _d === void 0 ? void 0 : _d.getIdToken());
      return new PhoneSignInResult(idToken, code);
    };

    const twitterSignInWeb = async () => {
      const provider = new firebase.auth.TwitterAuthProvider();
      firebase.auth().useDeviceLanguage();
      const userCredential = await firebase.auth().signInWithPopup(provider);
      const credential = userCredential === null || userCredential === void 0 ? void 0 : userCredential.credential;
      return new TwitterSignInResult(credential.accessToken, credential.secret);
    };

    class CapacitorFirebaseAuthWeb extends WebPlugin {
      constructor() {
        super();
      }
      async signIn(options) {
        const appleProvider = 'apple.com';
        const googleProvider = new firebase.auth.GoogleAuthProvider().providerId;
        const facebookProvider = new firebase.auth.FacebookAuthProvider().providerId;
        const twitterProvider = new firebase.auth.TwitterAuthProvider().providerId;
        const phoneProvider = new firebase.auth.PhoneAuthProvider().providerId;
        switch (options.providerId) {
          case appleProvider:
            return appleSignInWeb();
          case googleProvider:
            return googleSignInWeb();
          case twitterProvider:
            return twitterSignInWeb();
          case facebookProvider:
            return facebookSignInWeb();
          case phoneProvider:
            return phoneSignInWeb(options);
        }
        return Promise.reject(`The '${options.providerId}' provider was not supported`);
      }
      async signOut(options) {
        console.log(options);
        return firebase.auth().signOut();
      }
    }

    var web = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      CapacitorFirebaseAuthWeb: CapacitorFirebaseAuthWeb,
    });

    const createSwipeBackGesture = (el, canStartHandler, onStartHandler, onMoveHandler, onEndHandler) => {
      const win = el.ownerDocument.defaultView;
      const canStart = detail => {
        return detail.startX <= 50 && canStartHandler();
      };
      const onMove = detail => {
        // set the transition animation's progress
        const delta = detail.deltaX;
        const stepValue = delta / win.innerWidth;
        onMoveHandler(stepValue);
      };
      const onEnd = detail => {
        // the swipe back gesture has ended
        const delta = detail.deltaX;
        const width = win.innerWidth;
        const stepValue = delta / width;
        const velocity = detail.velocityX;
        const z = width / 2.0;
        const shouldComplete = velocity >= 0 && (velocity > 0.2 || detail.deltaX > z);
        const missing = shouldComplete ? 1 - stepValue : stepValue;
        const missingDistance = missing * width;
        let realDur = 0;
        if (missingDistance > 5) {
          const dur = missingDistance / Math.abs(velocity);
          realDur = Math.min(dur, 540);
        }
        /**
         * TODO: stepValue can sometimes return negative values
         * or values greater than 1 which should not be possible.
         * Need to investigate more to find where the issue is.
         */
        onEndHandler(shouldComplete, stepValue <= 0 ? 0.01 : clamp(0, stepValue, 0.9999), realDur);
      };
      return createGesture({
        el,
        gestureName: 'goback-swipe',
        gesturePriority: 40,
        threshold: 10,
        canStart,
        onStart: onStartHandler,
        onMove,
        onEnd,
      });
    };

    var swipeBack = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      createSwipeBackGesture: createSwipeBackGesture,
    });

    /**
     * SSR Window 2.0.0
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: May 12, 2020
     */
    /* eslint-disable no-param-reassign */
    function isObject(obj) {
      return obj !== null && typeof obj === 'object' && 'constructor' in obj && obj.constructor === Object;
    }
    function extend(target, src) {
      if (target === void 0) {
        target = {};
      }
      if (src === void 0) {
        src = {};
      }
      Object.keys(src).forEach(function (key) {
        if (typeof target[key] === 'undefined') target[key] = src[key];
        else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
          extend(target[key], src[key]);
        }
      });
    }

    var doc = typeof document !== 'undefined' ? document : {};
    var ssrDocument = {
      body: {},
      addEventListener: function () {},
      removeEventListener: function () {},
      activeElement: {
        blur: function () {},
        nodeName: '',
      },
      querySelector: function () {
        return null;
      },
      querySelectorAll: function () {
        return [];
      },
      getElementById: function () {
        return null;
      },
      createEvent: function () {
        return {
          initEvent: function () {},
        };
      },
      createElement: function () {
        return {
          children: [],
          childNodes: [],
          style: {},
          setAttribute: function () {},
          getElementsByTagName: function () {
            return [];
          },
        };
      },
      createElementNS: function () {
        return {};
      },
      importNode: function () {
        return null;
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
      },
    };
    extend(doc, ssrDocument);

    var win = typeof window !== 'undefined' ? window : {};
    var ssrWindow = {
      document: ssrDocument,
      navigator: {
        userAgent: '',
      },
      location: {
        hash: '',
        host: '',
        hostname: '',
        href: '',
        origin: '',
        pathname: '',
        protocol: '',
        search: '',
      },
      history: {
        replaceState: function () {},
        pushState: function () {},
        go: function () {},
        back: function () {},
      },
      CustomEvent: function CustomEvent() {
        return this;
      },
      addEventListener: function () {},
      removeEventListener: function () {},
      getComputedStyle: function () {
        return {
          getPropertyValue: function () {
            return '';
          },
        };
      },
      Image: function () {},
      Date: function () {},
      screen: {},
      setTimeout: function () {},
      clearTimeout: function () {},
      matchMedia: function () {
        return {};
      },
    };
    extend(win, ssrWindow);

    /**
     * Dom7 2.1.5
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * http://framework7.io/docs/dom.html
     *
     * Copyright 2020, Vladimir Kharlampidi
     * The iDangero.us
     * http://www.idangero.us/
     *
     * Licensed under MIT
     *
     * Released on: May 15, 2020
     */

    class Dom7 {
      constructor(arr) {
        const self = this;
        // Create array-like object
        for (let i = 0; i < arr.length; i += 1) {
          self[i] = arr[i];
        }
        self.length = arr.length;
        // Return collection with methods
        return this;
      }
    }

    function $(selector, context) {
      const arr = [];
      let i = 0;
      if (selector && !context) {
        if (selector instanceof Dom7) {
          return selector;
        }
      }
      if (selector) {
        // String
        if (typeof selector === 'string') {
          let els;
          let tempParent;
          const html = selector.trim();
          if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
            let toCreate = 'div';
            if (html.indexOf('<li') === 0) toCreate = 'ul';
            if (html.indexOf('<tr') === 0) toCreate = 'tbody';
            if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
            if (html.indexOf('<tbody') === 0) toCreate = 'table';
            if (html.indexOf('<option') === 0) toCreate = 'select';
            tempParent = doc.createElement(toCreate);
            tempParent.innerHTML = html;
            for (i = 0; i < tempParent.childNodes.length; i += 1) {
              arr.push(tempParent.childNodes[i]);
            }
          } else {
            if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
              // Pure ID selector
              els = [doc.getElementById(selector.trim().split('#')[1])];
            } else {
              // Other selectors
              els = (context || doc).querySelectorAll(selector.trim());
            }
            for (i = 0; i < els.length; i += 1) {
              if (els[i]) arr.push(els[i]);
            }
          }
        } else if (selector.nodeType || selector === win || selector === doc) {
          // Node/element
          arr.push(selector);
        } else if (selector.length > 0 && selector[0].nodeType) {
          // Array of elements or instance of Dom
          for (i = 0; i < selector.length; i += 1) {
            arr.push(selector[i]);
          }
        }
      }
      return new Dom7(arr);
    }

    $.fn = Dom7.prototype;
    $.Class = Dom7;
    $.Dom7 = Dom7;

    function unique(arr) {
      const uniqueArray = [];
      for (let i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }
      return uniqueArray;
    }

    // Classes and attributes
    function addClass(className) {
      if (typeof className === 'undefined') {
        return this;
      }
      const classes = className.split(' ');
      for (let i = 0; i < classes.length; i += 1) {
        for (let j = 0; j < this.length; j += 1) {
          if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
        }
      }
      return this;
    }
    function removeClass(className) {
      const classes = className.split(' ');
      for (let i = 0; i < classes.length; i += 1) {
        for (let j = 0; j < this.length; j += 1) {
          if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
        }
      }
      return this;
    }
    function hasClass(className) {
      if (!this[0]) return false;
      return this[0].classList.contains(className);
    }
    function toggleClass(className) {
      const classes = className.split(' ');
      for (let i = 0; i < classes.length; i += 1) {
        for (let j = 0; j < this.length; j += 1) {
          if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
        }
      }
      return this;
    }
    function attr(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      }

      // Set attrs
      for (let i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          // eslint-disable-next-line
          for (const attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }
      return this;
    }
    // eslint-disable-next-line
    function removeAttr(attr) {
      for (let i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }
      return this;
    }
    function data(key, value) {
      let el;
      if (typeof value === 'undefined') {
        el = this[0];
        // Get value
        if (el) {
          if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
            return el.dom7ElementDataStorage[key];
          }

          const dataKey = el.getAttribute(`data-${key}`);
          if (dataKey) {
            return dataKey;
          }
          return undefined;
        }
        return undefined;
      }

      // Set value
      for (let i = 0; i < this.length; i += 1) {
        el = this[i];
        if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
        el.dom7ElementDataStorage[key] = value;
      }
      return this;
    }
    // Transforms
    // eslint-disable-next-line
    function transform(transform) {
      for (let i = 0; i < this.length; i += 1) {
        const elStyle = this[i].style;
        elStyle.webkitTransform = transform;
        elStyle.transform = transform;
      }
      return this;
    }
    function transition(duration) {
      if (typeof duration !== 'string') {
        duration = `${duration}ms`; // eslint-disable-line
      }
      for (let i = 0; i < this.length; i += 1) {
        const elStyle = this[i].style;
        elStyle.webkitTransitionDuration = duration;
        elStyle.transitionDuration = duration;
      }
      return this;
    }
    // Events
    function on(...args) {
      let [eventType, targetSelector, listener, capture] = args;
      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }
      if (!capture) capture = false;

      function handleLiveEvent(e) {
        const target = e.target;
        if (!target) return;
        const eventData = e.target.dom7EventData || [];
        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }
        if ($(target).is(targetSelector)) listener.apply(target, eventData);
        else {
          const parents = $(target).parents(); // eslint-disable-line
          for (let k = 0; k < parents.length; k += 1) {
            if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
          }
        }
      }
      function handleEvent(e) {
        const eventData = e && e.target ? e.target.dom7EventData || [] : [];
        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }
        listener.apply(this, eventData);
      }
      const events = eventType.split(' ');
      let j;
      for (let i = 0; i < this.length; i += 1) {
        const el = this[i];
        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener,
              proxyListener: handleEvent,
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            const event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
            el.dom7LiveListeners[event].push({
              listener,
              proxyListener: handleLiveEvent,
            });
            el.addEventListener(event, handleLiveEvent, capture);
          }
        }
      }
      return this;
    }
    function off(...args) {
      let [eventType, targetSelector, listener, capture] = args;
      if (typeof args[1] === 'function') {
        [eventType, listener, capture] = args;
        targetSelector = undefined;
      }
      if (!capture) capture = false;

      const events = eventType.split(' ');
      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];
        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];
          let handlers;
          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }
          if (handlers && handlers.length) {
            for (let k = handlers.length - 1; k >= 0; k -= 1) {
              const handler = handlers[k];
              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }
      return this;
    }
    function trigger(...args) {
      const events = args[0].split(' ');
      const eventData = args[1];
      for (let i = 0; i < events.length; i += 1) {
        const event = events[i];
        for (let j = 0; j < this.length; j += 1) {
          const el = this[j];
          let evt;
          try {
            evt = new win.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true,
            });
          } catch (e) {
            evt = doc.createEvent('Event');
            evt.initEvent(event, true, true);
            evt.detail = eventData;
          }
          // eslint-disable-next-line
          el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
          el.dispatchEvent(evt);
          el.dom7EventData = [];
          delete el.dom7EventData;
        }
      }
      return this;
    }
    function transitionEnd(callback) {
      const events = ['webkitTransitionEnd', 'transitionend'];
      const dom = this;
      let i;
      function fireCallBack(e) {
        /* jshint validthis:true */
        if (e.target !== this) return;
        callback.call(this, e);
        for (i = 0; i < events.length; i += 1) {
          dom.off(events[i], fireCallBack);
        }
      }
      if (callback) {
        for (i = 0; i < events.length; i += 1) {
          dom.on(events[i], fireCallBack);
        }
      }
      return this;
    }
    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          // eslint-disable-next-line
          const styles = this.styles();
          return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
        }
        return this[0].offsetWidth;
      }
      return null;
    }
    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          // eslint-disable-next-line
          const styles = this.styles();
          return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
        }
        return this[0].offsetHeight;
      }
      return null;
    }
    function offset() {
      if (this.length > 0) {
        const el = this[0];
        const box = el.getBoundingClientRect();
        const body = doc.body;
        const clientTop = el.clientTop || body.clientTop || 0;
        const clientLeft = el.clientLeft || body.clientLeft || 0;
        const scrollTop = el === win ? win.scrollY : el.scrollTop;
        const scrollLeft = el === win ? win.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft,
        };
      }

      return null;
    }
    function styles() {
      if (this[0]) return win.getComputedStyle(this[0], null);
      return {};
    }
    function css(props, value) {
      let i;
      if (arguments.length === 1) {
        if (typeof props === 'string') {
          if (this[0]) return win.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          for (i = 0; i < this.length; i += 1) {
            // eslint-disable-next-line
            for (let prop in props) {
              this[i].style[prop] = props[prop];
            }
          }
          return this;
        }
      }
      if (arguments.length === 2 && typeof props === 'string') {
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }
        return this;
      }
      return this;
    }
    // Iterate over the collection passing elements to `callback`
    function each(callback) {
      // Don't bother continuing without a callback
      if (!callback) return this;
      // Iterate over the current collection
      for (let i = 0; i < this.length; i += 1) {
        // If the callback returns false
        if (callback.call(this[i], i, this[i]) === false) {
          // End the loop early
          return this;
        }
      }
      // Return `this` to allow chained DOM operations
      return this;
    }
    function filter(callback) {
      const matchedItems = [];
      const dom = this;
      for (let i = 0; i < dom.length; i += 1) {
        if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);
      }
      return new Dom7(matchedItems);
    }
    // eslint-disable-next-line
    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : undefined;
      }

      for (let i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }
      return this;
    }
    // eslint-disable-next-line
    function text(text) {
      if (typeof text === 'undefined') {
        if (this[0]) {
          return this[0].textContent.trim();
        }
        return null;
      }

      for (let i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }
      return this;
    }
    function is(selector) {
      const el = this[0];
      let compareWith;
      let i;
      if (!el || typeof selector === 'undefined') return false;
      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        else if (el.msMatchesSelector) return el.msMatchesSelector(selector);

        compareWith = $(selector);
        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }
        return false;
      } else if (selector === doc) return el === doc;
      else if (selector === win) return el === win;

      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;
        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }
        return false;
      }
      return false;
    }
    function index() {
      let child = this[0];
      let i;
      if (child) {
        i = 0;
        // eslint-disable-next-line
        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }
        return i;
      }
      return undefined;
    }
    // eslint-disable-next-line
    function eq(index) {
      if (typeof index === 'undefined') return this;
      const length = this.length;
      let returnIndex;
      if (index > length - 1) {
        return new Dom7([]);
      }
      if (index < 0) {
        returnIndex = length + index;
        if (returnIndex < 0) return new Dom7([]);
        return new Dom7([this[returnIndex]]);
      }
      return new Dom7([this[index]]);
    }
    function append(...args) {
      let newChild;

      for (let k = 0; k < args.length; k += 1) {
        newChild = args[k];
        for (let i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            const tempDiv = doc.createElement('div');
            tempDiv.innerHTML = newChild;
            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (let j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }

      return this;
    }
    function prepend(newChild) {
      let i;
      let j;
      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          const tempDiv = doc.createElement('div');
          tempDiv.innerHTML = newChild;
          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }
      return this;
    }
    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return new Dom7([this[0].nextElementSibling]);
          }
          return new Dom7([]);
        }

        if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
        return new Dom7([]);
      }
      return new Dom7([]);
    }
    function nextAll(selector) {
      const nextEls = [];
      let el = this[0];
      if (!el) return new Dom7([]);
      while (el.nextElementSibling) {
        const next = el.nextElementSibling; // eslint-disable-line
        if (selector) {
          if ($(next).is(selector)) nextEls.push(next);
        } else nextEls.push(next);
        el = next;
      }
      return new Dom7(nextEls);
    }
    function prev(selector) {
      if (this.length > 0) {
        const el = this[0];
        if (selector) {
          if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
            return new Dom7([el.previousElementSibling]);
          }
          return new Dom7([]);
        }

        if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
        return new Dom7([]);
      }
      return new Dom7([]);
    }
    function prevAll(selector) {
      const prevEls = [];
      let el = this[0];
      if (!el) return new Dom7([]);
      while (el.previousElementSibling) {
        const prev = el.previousElementSibling; // eslint-disable-line
        if (selector) {
          if ($(prev).is(selector)) prevEls.push(prev);
        } else prevEls.push(prev);
        el = prev;
      }
      return new Dom7(prevEls);
    }
    function parent(selector) {
      const parents = []; // eslint-disable-line
      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }
      return $(unique(parents));
    }
    function parents(selector) {
      const parents = []; // eslint-disable-line
      for (let i = 0; i < this.length; i += 1) {
        let parent = this[i].parentNode; // eslint-disable-line
        while (parent) {
          if (selector) {
            if ($(parent).is(selector)) parents.push(parent);
          } else {
            parents.push(parent);
          }
          parent = parent.parentNode;
        }
      }
      return $(unique(parents));
    }
    function closest(selector) {
      let closest = this; // eslint-disable-line
      if (typeof selector === 'undefined') {
        return new Dom7([]);
      }
      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }
      return closest;
    }
    function find(selector) {
      const foundElements = [];
      for (let i = 0; i < this.length; i += 1) {
        const found = this[i].querySelectorAll(selector);
        for (let j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }
      return new Dom7(foundElements);
    }
    function children(selector) {
      const children = []; // eslint-disable-line
      for (let i = 0; i < this.length; i += 1) {
        const childNodes = this[i].childNodes;

        for (let j = 0; j < childNodes.length; j += 1) {
          if (!selector) {
            if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
          } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }
      return new Dom7(unique(children));
    }
    function remove() {
      for (let i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }
      return this;
    }
    function add(...args) {
      const dom = this;
      let i;
      let j;
      for (i = 0; i < args.length; i += 1) {
        const toAdd = $(args[i]);
        for (j = 0; j < toAdd.length; j += 1) {
          dom[dom.length] = toAdd[j];
          dom.length += 1;
        }
      }
      return dom;
    }

    /**
     * Swiper 5.4.1
     * Most modern mobile touch slider and framework with hardware accelerated transitions
     * http://swiperjs.com
     *
     * Copyright 2014-2020 Vladimir Kharlampidi
     *
     * Released under the MIT License
     *
     * Released on: May 20, 2020
     */

    const Methods = {
      addClass,
      removeClass,
      hasClass,
      toggleClass,
      attr,
      removeAttr,
      data,
      transform,
      transition: transition,
      on,
      off,
      trigger,
      transitionEnd: transitionEnd,
      outerWidth,
      outerHeight,
      offset,
      css,
      each,
      html,
      text,
      is,
      index,
      eq,
      append,
      prepend,
      next,
      nextAll,
      prev,
      prevAll,
      parent,
      parents,
      closest,
      find,
      children,
      filter,
      remove,
      add,
      styles,
    };

    Object.keys(Methods).forEach(methodName => {
      $.fn[methodName] = $.fn[methodName] || Methods[methodName];
    });

    const Utils = {
      deleteProps(obj) {
        const object = obj;
        Object.keys(object).forEach(key => {
          try {
            object[key] = null;
          } catch (e) {
            // no getter for object
          }
          try {
            delete object[key];
          } catch (e) {
            // something got wrong
          }
        });
      },
      nextTick(callback, delay = 0) {
        return setTimeout(callback, delay);
      },
      now() {
        return Date.now();
      },
      getTranslate(el, axis = 'x') {
        let matrix;
        let curTransform;
        let transformMatrix;

        const curStyle = win.getComputedStyle(el, null);

        if (win.WebKitCSSMatrix) {
          curTransform = curStyle.transform || curStyle.webkitTransform;
          if (curTransform.split(',').length > 6) {
            curTransform = curTransform
              .split(', ')
              .map(a => a.replace(',', '.'))
              .join(', ');
          }
          // Some old versions of Webkit choke when 'none' is passed; pass
          // empty string instead in this case
          transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
        } else {
          transformMatrix =
            curStyle.MozTransform ||
            curStyle.OTransform ||
            curStyle.MsTransform ||
            curStyle.msTransform ||
            curStyle.transform ||
            curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
          matrix = transformMatrix.toString().split(',');
        }

        if (axis === 'x') {
          // Latest Chrome and webkits Fix
          if (win.WebKitCSSMatrix) curTransform = transformMatrix.m41;
          // Crazy IE10 Matrix
          else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
          // Normal Browsers
          else curTransform = parseFloat(matrix[4]);
        }
        if (axis === 'y') {
          // Latest Chrome and webkits Fix
          if (win.WebKitCSSMatrix) curTransform = transformMatrix.m42;
          // Crazy IE10 Matrix
          else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
          // Normal Browsers
          else curTransform = parseFloat(matrix[5]);
        }
        return curTransform || 0;
      },
      parseUrlQuery(url) {
        const query = {};
        let urlToParse = url || win.location.href;
        let i;
        let params;
        let param;
        let length;
        if (typeof urlToParse === 'string' && urlToParse.length) {
          urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
          params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');
          length = params.length;

          for (i = 0; i < length; i += 1) {
            param = params[i].replace(/#\S+/g, '').split('=');
            query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
          }
        }
        return query;
      },
      isObject(o) {
        return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
      },
      extend(...args) {
        const to = Object(args[0]);
        const noExtend = ['__proto__', 'constructor', 'prototype'];
        for (let i = 1; i < args.length; i += 1) {
          const nextSource = args[i];
          if (nextSource !== undefined && nextSource !== null) {
            const keysArray = Object.keys(Object(nextSource)).filter(key => noExtend.indexOf(key) < 0);
            for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
              const nextKey = keysArray[nextIndex];
              const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
              if (desc !== undefined && desc.enumerable) {
                if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                  Utils.extend(to[nextKey], nextSource[nextKey]);
                } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                  to[nextKey] = {};
                  Utils.extend(to[nextKey], nextSource[nextKey]);
                } else {
                  to[nextKey] = nextSource[nextKey];
                }
              }
            }
          }
        }
        return to;
      },
    };

    const Support = (function Support() {
      return {
        touch: !!('ontouchstart' in win || (win.DocumentTouch && doc instanceof win.DocumentTouch)),

        pointerEvents: !!win.PointerEvent && 'maxTouchPoints' in win.navigator && win.navigator.maxTouchPoints >= 0,

        observer: (function checkObserver() {
          return 'MutationObserver' in win || 'WebkitMutationObserver' in win;
        })(),

        passiveListener: (function checkPassiveListener() {
          let supportsPassive = false;
          try {
            const opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get() {
                supportsPassive = true;
              },
            });
            win.addEventListener('testPassiveListener', null, opts);
          } catch (e) {
            // No support
          }
          return supportsPassive;
        })(),

        gestures: (function checkGestures() {
          return 'ongesturestart' in win;
        })(),
      };
    })();

    class SwiperClass {
      constructor(params = {}) {
        const self = this;
        self.params = params;

        // Events
        self.eventsListeners = {};

        if (self.params && self.params.on) {
          Object.keys(self.params.on).forEach(eventName => {
            self.on(eventName, self.params.on[eventName]);
          });
        }
      }

      on(events, handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;
        const method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(event => {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      }

      once(events, handler, priority) {
        const self = this;
        if (typeof handler !== 'function') return self;
        function onceHandler(...args) {
          self.off(events, onceHandler);
          if (onceHandler.f7proxy) {
            delete onceHandler.f7proxy;
          }
          handler.apply(self, args);
        }
        onceHandler.f7proxy = handler;
        return self.on(events, onceHandler, priority);
      }

      off(events, handler) {
        const self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(event => {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
            self.eventsListeners[event].forEach((eventHandler, index) => {
              if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      }

      emit(...args) {
        const self = this;
        if (!self.eventsListeners) return self;
        let events;
        let data;
        let context;
        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }
        const eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(event => {
          if (self.eventsListeners && self.eventsListeners[event]) {
            const handlers = [];
            self.eventsListeners[event].forEach(eventHandler => {
              handlers.push(eventHandler);
            });
            handlers.forEach(eventHandler => {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      }

      useModulesParams(instanceParams) {
        const instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(moduleName => {
          const module = instance.modules[moduleName];
          // Extend params
          if (module.params) {
            Utils.extend(instanceParams, module.params);
          }
        });
      }

      useModules(modulesParams = {}) {
        const instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(moduleName => {
          const module = instance.modules[moduleName];
          const moduleParams = modulesParams[moduleName] || {};
          // Extend instance methods and props
          if (module.instance) {
            Object.keys(module.instance).forEach(modulePropName => {
              const moduleProp = module.instance[modulePropName];
              if (typeof moduleProp === 'function') {
                instance[modulePropName] = moduleProp.bind(instance);
              } else {
                instance[modulePropName] = moduleProp;
              }
            });
          }
          // Add event listeners
          if (module.on && instance.on) {
            Object.keys(module.on).forEach(moduleEventName => {
              instance.on(moduleEventName, module.on[moduleEventName]);
            });
          }

          // Module create callback
          if (module.create) {
            module.create.bind(instance)(moduleParams);
          }
        });
      }

      static set components(components) {
        const Class = this;
        if (!Class.use) return;
        Class.use(components);
      }

      static installModule(module, ...params) {
        const Class = this;
        if (!Class.prototype.modules) Class.prototype.modules = {};
        const name = module.name || `${Object.keys(Class.prototype.modules).length}_${Utils.now()}`;
        Class.prototype.modules[name] = module;
        // Prototype
        if (module.proto) {
          Object.keys(module.proto).forEach(key => {
            Class.prototype[key] = module.proto[key];
          });
        }
        // Class
        if (module.static) {
          Object.keys(module.static).forEach(key => {
            Class[key] = module.static[key];
          });
        }
        // Callback
        if (module.install) {
          module.install.apply(Class, params);
        }
        return Class;
      }

      static use(module, ...params) {
        const Class = this;
        if (Array.isArray(module)) {
          module.forEach(m => Class.installModule(m));
          return Class;
        }
        return Class.installModule(module, ...params);
      }
    }

    function updateSize() {
      const swiper = this;
      let width;
      let height;
      const $el = swiper.$el;
      if (typeof swiper.params.width !== 'undefined') {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }
      if (typeof swiper.params.height !== 'undefined') {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }
      if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
        return;
      }

      // Subtract paddings
      width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
      height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

      Utils.extend(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height,
      });
    }

    function updateSlides() {
      const swiper = this;
      const params = swiper.params;

      const { $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;
      const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
      const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      let snapGrid = [];
      const slidesGrid = [];
      const slidesSizesGrid = [];

      function slidesForMargin(slideIndex) {
        if (!params.cssMode) return true;
        if (slideIndex === slides.length - 1) {
          return false;
        }
        return true;
      }

      let offsetBefore = params.slidesOffsetBefore;
      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }

      let offsetAfter = params.slidesOffsetAfter;
      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }

      const previousSnapGridLength = swiper.snapGrid.length;
      const previousSlidesGridLength = swiper.snapGrid.length;

      let spaceBetween = params.spaceBetween;
      let slidePosition = -offsetBefore;
      let prevSlideSize = 0;
      let index = 0;
      if (typeof swiperSize === 'undefined') {
        return;
      }
      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
      }

      swiper.virtualSize = -spaceBetween;

      // reset margins
      if (rtl) slides.css({ marginLeft: '', marginTop: '' });
      else slides.css({ marginRight: '', marginBottom: '' });

      let slidesNumberEvenToRows;
      if (params.slidesPerColumn > 1) {
        if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
          slidesNumberEvenToRows = slidesLength;
        } else {
          slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
        }
        if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
        }
      }

      // Calc slides
      let slideSize;
      const slidesPerColumn = params.slidesPerColumn;
      const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
      const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
      for (let i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        const slide = slides.eq(i);
        if (params.slidesPerColumn > 1) {
          // Set slides order
          let newSlideOrderIndex;
          let column;
          let row;
          if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
            const groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
            const slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
            const columnsInGroup =
              groupIndex === 0
                ? params.slidesPerGroup
                : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
            row = Math.floor(slideIndexInGroup / columnsInGroup);
            column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;

            newSlideOrderIndex = column + (row * slidesNumberEvenToRows) / slidesPerColumn;
            slide.css({
              '-webkit-box-ordinal-group': newSlideOrderIndex,
              '-moz-box-ordinal-group': newSlideOrderIndex,
              '-ms-flex-order': newSlideOrderIndex,
              '-webkit-order': newSlideOrderIndex,
              'order': newSlideOrderIndex,
            });
          } else if (params.slidesPerColumnFill === 'column') {
            column = Math.floor(i / slidesPerColumn);
            row = i - column * slidesPerColumn;
            if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
              row += 1;
              if (row >= slidesPerColumn) {
                row = 0;
                column += 1;
              }
            }
          } else {
            row = Math.floor(i / slidesPerRow);
            column = i - row * slidesPerRow;
          }
          slide.css(`margin-${swiper.isHorizontal() ? 'top' : 'left'}`, row !== 0 && params.spaceBetween && `${params.spaceBetween}px`);
        }
        if (slide.css('display') === 'none') continue; // eslint-disable-line

        if (params.slidesPerView === 'auto') {
          const slideStyles = win.getComputedStyle(slide[0], null);
          const currentTransform = slide[0].style.transform;
          const currentWebKitTransform = slide[0].style.webkitTransform;
          if (currentTransform) {
            slide[0].style.transform = 'none';
          }
          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = 'none';
          }
          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            if (swiper.isHorizontal()) {
              const width = parseFloat(slideStyles.getPropertyValue('width'));
              const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
              const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
              const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
              const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
              const boxSizing = slideStyles.getPropertyValue('box-sizing');
              if (boxSizing && boxSizing === 'border-box') {
                slideSize = width + marginLeft + marginRight;
              } else {
                slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
              }
            } else {
              const height = parseFloat(slideStyles.getPropertyValue('height'));
              const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
              const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
              const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
              const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
              const boxSizing = slideStyles.getPropertyValue('box-sizing');
              if (boxSizing && boxSizing === 'border-box') {
                slideSize = height + marginTop + marginBottom;
              } else {
                slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
              }
            }
          }
          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }
          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }
          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);

          if (slides[i]) {
            if (swiper.isHorizontal()) {
              slides[i].style.width = `${slideSize}px`;
            } else {
              slides[i].style.height = `${slideSize}px`;
            }
          }
        }
        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }
        slidesSizesGrid.push(slideSize);

        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }

        swiper.virtualSize += slideSize + spaceBetween;

        prevSlideSize = slideSize;

        index += 1;
      }
      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
      let newSlidesGrid;

      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
      }
      if (params.setWrapperSize) {
        if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
        else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
      }

      if (params.slidesPerColumn > 1) {
        swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
        if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
        else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
        if (params.centeredSlides) {
          newSlidesGrid = [];
          for (let i = 0; i < snapGrid.length; i += 1) {
            let slidesGridItem = snapGrid[i];
            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
          }
          snapGrid = newSlidesGrid;
        }
      }

      // Remove last grid elements depending on width
      if (!params.centeredSlides) {
        newSlidesGrid = [];
        for (let i = 0; i < snapGrid.length; i += 1) {
          let slidesGridItem = snapGrid[i];
          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
          if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(slidesGridItem);
          }
        }
        snapGrid = newSlidesGrid;
        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }
      if (snapGrid.length === 0) snapGrid = [0];

      if (params.spaceBetween !== 0) {
        if (swiper.isHorizontal()) {
          if (rtl) slides.filter(slidesForMargin).css({ marginLeft: `${spaceBetween}px` });
          else slides.filter(slidesForMargin).css({ marginRight: `${spaceBetween}px` });
        } else slides.filter(slidesForMargin).css({ marginBottom: `${spaceBetween}px` });
      }

      if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach(slideSizeValue => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        const maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(snap => {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }

      if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach(slideSizeValue => {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        if (allSlidesSize < swiperSize) {
          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
          snapGrid.forEach((snap, snapIndex) => {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach((snap, snapIndex) => {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }

      Utils.extend(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid,
      });

      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }
      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }
      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }

      if (params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateSlidesOffset();
      }
    }

    function updateAutoHeight(speed) {
      const swiper = this;
      const activeSlides = [];
      let newHeight = 0;
      let i;
      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }
      // Find slides currently in view
      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          swiper.visibleSlides.each((index, slide) => {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            const index = swiper.activeIndex + i;
            if (index > swiper.slides.length) break;
            activeSlides.push(swiper.slides.eq(index)[0]);
          }
        }
      } else {
        activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
      }

      // Find new height from highest slide in view
      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          const height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      }

      // Update Height
      if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
    }

    function updateSlidesOffset() {
      const swiper = this;
      const slides = swiper.slides;
      for (let i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
      }
    }

    function updateSlidesProgress(translate = (this && this.translate) || 0) {
      const swiper = this;
      const params = swiper.params;

      const { slides, rtlTranslate: rtl } = swiper;

      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();

      let offsetCenter = -translate;
      if (rtl) offsetCenter = translate;

      // Visible Slides
      slides.removeClass(params.slideVisibleClass);

      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];

      for (let i = 0; i < slides.length; i += 1) {
        const slide = slides[i];
        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);
        if (params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) {
          const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
          const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
          const isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1) || (slideAfter > 1 && slideAfter <= swiper.size) || (slideBefore <= 0 && slideAfter >= swiper.size);
          if (isVisible) {
            swiper.visibleSlides.push(slide);
            swiper.visibleSlidesIndexes.push(i);
            slides.eq(i).addClass(params.slideVisibleClass);
          }
        }
        slide.progress = rtl ? -slideProgress : slideProgress;
      }
      swiper.visibleSlides = $(swiper.visibleSlides);
    }

    function updateProgress(translate) {
      const swiper = this;
      if (typeof translate === 'undefined') {
        const multiplier = swiper.rtlTranslate ? -1 : 1;
        // eslint-disable-next-line
        translate = (swiper && swiper.translate && swiper.translate * multiplier) || 0;
      }
      const params = swiper.params;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      let { progress, isBeginning, isEnd } = swiper;
      const wasBeginning = isBeginning;
      const wasEnd = isEnd;
      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }
      Utils.extend(swiper, {
        progress,
        isBeginning,
        isEnd,
      });

      if (params.watchSlidesProgress || params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) swiper.updateSlidesProgress(translate);

      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }
      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }
      if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
        swiper.emit('fromEdge');
      }

      swiper.emit('progress', progress);
    }

    function updateSlidesClasses() {
      const swiper = this;

      const { slides, params, $wrapperEl, activeIndex, realIndex } = swiper;
      const isVirtual = swiper.virtual && params.virtual.enabled;

      slides.removeClass(
        `${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`,
      );

      let activeSlide;
      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
      } else {
        activeSlide = slides.eq(activeIndex);
      }

      // Active classes
      activeSlide.addClass(params.slideActiveClass);

      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`).addClass(params.slideDuplicateActiveClass);
        }
      }
      // Next Slide
      let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      }
      // Prev Slide
      let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }
      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl
            .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
            .addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl
            .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
            .addClass(params.slideDuplicateNextClass);
        }
        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl
            .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
            .addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl
            .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
            .addClass(params.slideDuplicatePrevClass);
        }
      }
    }

    function updateActiveIndex(newActiveIndex) {
      const swiper = this;
      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      const { slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex } = swiper;
      let activeIndex = newActiveIndex;
      let snapIndex;
      if (typeof activeIndex === 'undefined') {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        }
        // Normalize slideIndex
        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }
      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }
        return;
      }

      // Get real index
      const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

      Utils.extend(swiper, {
        snapIndex,
        realIndex,
        previousIndex,
        activeIndex,
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');
      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }
      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }

    function updateClickedSlide(e) {
      const swiper = this;
      const params = swiper.params;
      const slide = $(e.target).closest(`.${params.slideClass}`)[0];
      let slideFound = false;
      if (slide) {
        for (let i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) slideFound = true;
        }
      }

      if (slide && slideFound) {
        swiper.clickedSlide = slide;
        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = $(slide).index();
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }
      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }

    var update = {
      updateSize,
      updateSlides,
      updateAutoHeight,
      updateSlidesOffset,
      updateSlidesProgress,
      updateProgress,
      updateSlidesClasses,
      updateActiveIndex,
      updateClickedSlide,
    };

    function getTranslate(axis = this.isHorizontal() ? 'x' : 'y') {
      const swiper = this;

      const { params, rtlTranslate: rtl, translate, $wrapperEl } = swiper;

      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }
      if (params.cssMode) {
        return translate;
      }

      let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;

      return currentTranslate || 0;
    }

    function setTranslate(translate, byController) {
      const swiper = this;
      const { rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress } = swiper;
      let x = 0;
      let y = 0;
      const z = 0;

      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }

      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }

      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
      }
      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y;

      // Check if we need to update progress
      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }
      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }

      swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate() {
      return -this.snapGrid[0];
    }

    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }

    function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
      const swiper = this;

      const { params, wrapperEl } = swiper;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }

      const minTranslate = swiper.minTranslate();
      const maxTranslate = swiper.maxTranslate();
      let newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
      else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
      else newTranslate = translate;

      // Update progress
      swiper.updateProgress(newTranslate);

      if (params.cssMode) {
        const isH = swiper.isHorizontal();
        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          // eslint-disable-next-line
          if (wrapperEl.scrollTo) {
            wrapperEl.scrollTo({
              [isH ? 'left' : 'top']: -newTranslate,
              behavior: 'smooth',
            });
          } else {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
          }
        }
        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }
        if (!swiper.animating) {
          swiper.animating = true;
          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;
              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }
          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
        }
      }

      return true;
    }

    var translate = {
      getTranslate,
      setTranslate,
      minTranslate,
      maxTranslate,
      translateTo,
    };

    function setTransition(duration, byController) {
      const swiper = this;

      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }

      swiper.emit('setTransition', duration, byController);
    }

    function transitionStart(runCallbacks = true, direction) {
      const swiper = this;
      const { activeIndex, params, previousIndex } = swiper;
      if (params.cssMode) return;
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      let dir = direction;
      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';
        else if (activeIndex < previousIndex) dir = 'prev';
        else dir = 'reset';
      }

      swiper.emit('transitionStart');

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit('slideResetTransitionStart');
          return;
        }
        swiper.emit('slideChangeTransitionStart');
        if (dir === 'next') {
          swiper.emit('slideNextTransitionStart');
        } else {
          swiper.emit('slidePrevTransitionStart');
        }
      }
    }

    function transitionEnd$1(runCallbacks = true, direction) {
      const swiper = this;
      const { activeIndex, previousIndex, params } = swiper;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);

      let dir = direction;
      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';
        else if (activeIndex < previousIndex) dir = 'prev';
        else dir = 'reset';
      }

      swiper.emit('transitionEnd');

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit('slideResetTransitionEnd');
          return;
        }
        swiper.emit('slideChangeTransitionEnd');
        if (dir === 'next') {
          swiper.emit('slideNextTransitionEnd');
        } else {
          swiper.emit('slidePrevTransitionEnd');
        }
      }
    }

    var transition$1 = {
      setTransition,
      transitionStart,
      transitionEnd: transitionEnd$1,
    };

    function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      let slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;

      const { params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl } = swiper;
      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }

      const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }

      const translate = -snapGrid[snapIndex];

      // Update progress
      swiper.updateProgress(translate);

      // Normalize slideIndex
      if (params.normalizeSlideIndex) {
        for (let i = 0; i < slidesGrid.length; i += 1) {
          if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
            slideIndex = i;
          }
        }
      }
      // Directions locks
      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
          return false;
        }
        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }

      let direction;
      if (slideIndex > activeIndex) direction = 'next';
      else if (slideIndex < activeIndex) direction = 'prev';
      else direction = 'reset';

      // Update Index
      if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
        swiper.updateActiveIndex(slideIndex);
        // Update Height
        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }
        swiper.updateSlidesClasses();
        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }
        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }
        return false;
      }
      if (params.cssMode) {
        const isH = swiper.isHorizontal();
        let t = -translate;
        if (rtl) {
          t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
        }
        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        } else {
          // eslint-disable-next-line
          if (wrapperEl.scrollTo) {
            wrapperEl.scrollTo({
              [isH ? 'left' : 'top']: t,
              behavior: 'smooth',
            });
          } else {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
          }
        }
        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        if (!swiper.animating) {
          swiper.animating = true;
          if (!swiper.onSlideToWrapperTransitionEnd) {
            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
              swiper.onSlideToWrapperTransitionEnd = null;
              delete swiper.onSlideToWrapperTransitionEnd;
              swiper.transitionEnd(runCallbacks, direction);
            };
          }
          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        }
      }

      return true;
    }

    function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      let newIndex = index;
      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }

      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      const { params, animating } = swiper;
      const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
      if (params.loop) {
        if (animating) return false;
        swiper.loopFix();
        // eslint-disable-next-line
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }
      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      const { params, animating, snapGrid, slidesGrid, rtlTranslate } = swiper;

      if (params.loop) {
        if (animating) return false;
        swiper.loopFix();
        // eslint-disable-next-line
        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }
      const translate = rtlTranslate ? swiper.translate : -swiper.translate;
      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }
      const normalizedTranslate = normalize(translate);
      const normalizedSnapGrid = snapGrid.map(val => normalize(val));
      slidesGrid.map(val => normalize(val));

      snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
      if (typeof prevSnap === 'undefined' && params.cssMode) {
        snapGrid.forEach(snap => {
          if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
        });
      }
      let prevIndex;
      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
      }
      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
      const swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
      const swiper = this;
      let index = swiper.activeIndex;
      const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);

      const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        const currentSnap = swiper.snapGrid[snapIndex];
        const nextSnap = swiper.snapGrid[snapIndex + 1];
        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        const prevSnap = swiper.snapGrid[snapIndex - 1];
        const currentSnap = swiper.snapGrid[snapIndex];
        if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }
      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);

      return swiper.slideTo(index, speed, runCallbacks, internal);
    }

    function slideToClickedSlide() {
      const swiper = this;
      const { params, $wrapperEl } = swiper;

      const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      let slideToIndex = swiper.clickedIndex;
      let realIndex;
      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();

            Utils.nextTick(() => {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`).eq(0).index();

          Utils.nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }

    var slide = {
      slideTo,
      slideToLoop,
      slideNext,
      slidePrev,
      slideReset,
      slideToClosest,
      slideToClickedSlide,
    };

    function loopCreate() {
      const swiper = this;
      const { params, $wrapperEl } = swiper;
      // Remove duplicated slides
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();

      let slides = $wrapperEl.children(`.${params.slideClass}`);

      if (params.loopFillGroupWithBlank) {
        const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
        if (blankSlidesNum !== params.slidesPerGroup) {
          for (let i = 0; i < blankSlidesNum; i += 1) {
            const blankNode = $(doc.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
            $wrapperEl.append(blankNode);
          }
          slides = $wrapperEl.children(`.${params.slideClass}`);
        }
      }

      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;

      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;
      if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
      }

      const prependSlides = [];
      const appendSlides = [];
      slides.each((index, el) => {
        const slide = $(el);
        if (index < swiper.loopedSlides) appendSlides.push(el);
        if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);
        slide.attr('data-swiper-slide-index', index);
      });
      for (let i = 0; i < appendSlides.length; i += 1) {
        $wrapperEl.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
      for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
        $wrapperEl.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }

    function loopFix() {
      const swiper = this;

      swiper.emit('beforeLoopFix');

      const { activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl } = swiper;
      let newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;

      const snapTranslate = -snapGrid[activeIndex];
      const diff = snapTranslate - swiper.getTranslate();

      // Fix For Negative Oversliding
      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;
        const slideChanged = swiper.slideTo(newIndex, 0, false, true);
        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;

      swiper.emit('loopFix');
    }

    function loopDestroy() {
      const swiper = this;
      const { $wrapperEl, params, slides } = swiper;
      $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
      slides.removeAttr('data-swiper-slide-index');
    }

    var loop = {
      loopCreate,
      loopFix,
      loopDestroy,
    };

    function setGrabCursor(moving) {
      const swiper = this;
      if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
      const el = swiper.el;
      el.style.cursor = 'move';
      el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
      el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor() {
      const swiper = this;
      if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
      swiper.el.style.cursor = '';
    }

    var grabCursor = {
      setGrabCursor,
      unsetGrabCursor,
    };

    function appendSlide(slides) {
      const swiper = this;
      const { $wrapperEl, params } = swiper;
      if (params.loop) {
        swiper.loopDestroy();
      }
      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }
      } else {
        $wrapperEl.append(slides);
      }
      if (params.loop) {
        swiper.loopCreate();
      }
      if (!(params.observer && Support.observer)) {
        swiper.update();
      }
    }

    function prependSlide(slides) {
      const swiper = this;
      const { params, $wrapperEl, activeIndex } = swiper;

      if (params.loop) {
        swiper.loopDestroy();
      }
      let newActiveIndex = activeIndex + 1;
      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.prepend(slides[i]);
        }
        newActiveIndex = activeIndex + slides.length;
      } else {
        $wrapperEl.prepend(slides);
      }
      if (params.loop) {
        swiper.loopCreate();
      }
      if (!(params.observer && Support.observer)) {
        swiper.update();
      }
      swiper.slideTo(newActiveIndex, 0, false);
    }

    function addSlide(index, slides) {
      const swiper = this;
      const { $wrapperEl, params, activeIndex } = swiper;
      let activeIndexBuffer = activeIndex;
      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
      }
      const baseLength = swiper.slides.length;
      if (index <= 0) {
        swiper.prependSlide(slides);
        return;
      }
      if (index >= baseLength) {
        swiper.appendSlide(slides);
        return;
      }
      let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;

      const slidesBuffer = [];
      for (let i = baseLength - 1; i >= index; i -= 1) {
        const currentSlide = swiper.slides.eq(i);
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }
        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
      } else {
        $wrapperEl.append(slides);
      }

      for (let i = 0; i < slidesBuffer.length; i += 1) {
        $wrapperEl.append(slidesBuffer[i]);
      }

      if (params.loop) {
        swiper.loopCreate();
      }
      if (!(params.observer && Support.observer)) {
        swiper.update();
      }
      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeSlide(slidesIndexes) {
      const swiper = this;
      const { params, $wrapperEl, activeIndex } = swiper;

      let activeIndexBuffer = activeIndex;
      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
      }
      let newActiveIndex = activeIndexBuffer;
      let indexToRemove;

      if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
        for (let i = 0; i < slidesIndexes.length; i += 1) {
          indexToRemove = slidesIndexes[i];
          if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }
        newActiveIndex = Math.max(newActiveIndex, 0);
      } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && Support.observer)) {
        swiper.update();
      }
      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeAllSlides() {
      const swiper = this;

      const slidesIndexes = [];
      for (let i = 0; i < swiper.slides.length; i += 1) {
        slidesIndexes.push(i);
      }
      swiper.removeSlide(slidesIndexes);
    }

    var manipulation = {
      appendSlide,
      prependSlide,
      addSlide,
      removeSlide,
      removeAllSlides,
    };

    const Device = (function Device() {
      const platform = win.navigator.platform;
      const ua = win.navigator.userAgent;

      const device = {
        ios: false,
        android: false,
        androidChrome: false,
        desktop: false,
        iphone: false,
        ipod: false,
        ipad: false,
        edge: false,
        ie: false,
        firefox: false,
        macos: false,
        windows: false,
        cordova: !!(win.cordova || win.phonegap),
        phonegap: !!(win.cordova || win.phonegap),
        electron: false,
      };

      const screenWidth = win.screen.width;
      const screenHeight = win.screen.height;

      const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
      let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      const ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
      const edge = ua.indexOf('Edge/') >= 0;
      const firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
      const windows = platform === 'Win32';
      const electron = ua.toLowerCase().indexOf('electron') >= 0;
      let macos = platform === 'MacIntel';

      // iPadOs 13 fix
      if (
        !ipad &&
        macos &&
        Support.touch &&
        ((screenWidth === 1024 && screenHeight === 1366) || // Pro 12.9
          (screenWidth === 834 && screenHeight === 1194) || // Pro 11
          (screenWidth === 834 && screenHeight === 1112) || // Pro 10.5
          (screenWidth === 768 && screenHeight === 1024)) // other
      ) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        macos = false;
      }

      device.ie = ie;
      device.edge = edge;
      device.firefox = firefox;

      // Android
      if (android && !windows) {
        device.os = 'android';
        device.osVersion = android[2];
        device.android = true;
        device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
      }
      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      }
      // iOS
      if (iphone && !ipod) {
        device.osVersion = iphone[2].replace(/_/g, '.');
        device.iphone = true;
      }
      if (ipad) {
        device.osVersion = ipad[2].replace(/_/g, '.');
        device.ipad = true;
      }
      if (ipod) {
        device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
        device.ipod = true;
      }
      // iOS 8+ changed UA
      if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
        if (device.osVersion.split('.')[0] === '10') {
          device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
        }
      }

      // Webview
      device.webView =
        !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || win.navigator.standalone)) ||
        (win.matchMedia && win.matchMedia('(display-mode: standalone)').matches);
      device.webview = device.webView;
      device.standalone = device.webView;

      // Desktop
      device.desktop = !(device.ios || device.android) || electron;
      if (device.desktop) {
        device.electron = electron;
        device.macos = macos;
        device.windows = windows;
        if (device.macos) {
          device.os = 'macos';
        }
        if (device.windows) {
          device.os = 'windows';
        }
      }

      // Pixel Ratio
      device.pixelRatio = win.devicePixelRatio || 1;

      // Export object
      return device;
    })();

    function onTouchStart(event) {
      const swiper = this;
      const data = swiper.touchEventsData;
      const { params, touches } = swiper;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }
      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      const $targetEl = $(e.target);

      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }
      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return;
      if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {
        swiper.allowClick = true;
        return;
      }
      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }

      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      const startX = touches.currentX;
      const startY = touches.currentY;

      // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= win.screen.width - edgeSwipeThreshold)) {
        return;
      }

      Utils.extend(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined,
      });

      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = Utils.now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;
      if (e.type !== 'touchstart') {
        let preventDefault = true;
        if ($targetEl.is(data.formElements)) preventDefault = false;
        if (doc.activeElement && $(doc.activeElement).is(data.formElements) && doc.activeElement !== $targetEl[0]) {
          doc.activeElement.blur();
        }

        const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
        if (params.touchStartForcePreventDefault || shouldPreventDefault) {
          e.preventDefault();
        }
      }
      swiper.emit('touchStart', e);
    }

    function onTouchMove(event) {
      const swiper = this;
      const data = swiper.touchEventsData;
      const { params, touches, rtlTranslate: rtl } = swiper;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }
        return;
      }
      if (data.isTouchEvent && e.type !== 'touchmove') return;
      const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }
      if (!swiper.allowTouchMove) {
        // isMoved = true;
        swiper.allowClick = false;
        if (data.isTouched) {
          Utils.extend(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY,
          });
          data.touchStartTime = Utils.now();
        }
        return;
      }
      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if ((pageY < touches.startY && swiper.translate <= swiper.maxTranslate()) || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if ((pageX < touches.startX && swiper.translate <= swiper.maxTranslate()) || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())) {
          return;
        }
      }
      if (data.isTouchEvent && doc.activeElement) {
        if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }
      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }
      if (e.targetTouches && e.targetTouches.length > 1) return;

      touches.currentX = pageX;
      touches.currentY = pageY;

      const diffX = touches.currentX - touches.startX;
      const diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;

      if (typeof data.isScrolling === 'undefined') {
        let touchAngle;
        if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }
      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }
      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }
      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }
      if (!data.startMoving) {
        return;
      }
      swiper.allowClick = false;
      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }
      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }

      if (!data.isMoved) {
        if (params.loop) {
          swiper.loopFix();
        }
        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);
        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }
        data.allowMomentumBounce = false;
        // Grab Cursor
        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }
        swiper.emit('sliderFirstMove', e);
      }
      swiper.emit('sliderMove', e);
      data.isMoved = true;

      let diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;

      diff *= params.touchRatio;
      if (rtl) diff = -diff;

      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;

      let disableParentSwiper = true;
      let resistanceRatio = params.resistanceRatio;
      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }
      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }

      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      }

      // Directions locks
      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }
      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      // Threshold
      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }

      if (!params.followFinger || params.cssMode) return;

      // Update active index in free mode
      if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      if (params.freeMode) {
        // Velocity
        if (data.velocities.length === 0) {
          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
            time: data.touchStartTime,
          });
        }
        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
          time: Utils.now(),
        });
      }
      // Update progress
      swiper.updateProgress(data.currentTranslate);
      // Update translate
      swiper.setTranslate(data.currentTranslate);
    }

    function onTouchEnd(event) {
      const swiper = this;
      const data = swiper.touchEventsData;

      const { params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid } = swiper;
      let e = event;
      if (e.originalEvent) e = e.originalEvent;
      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }
      data.allowTouchCallbacks = false;
      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }
        data.isMoved = false;
        data.startMoving = false;
        return;
      }
      // Return Grab Cursor
      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      }

      // Time diff
      const touchEndTime = Utils.now();
      const timeDiff = touchEndTime - data.touchStartTime;

      // Tap, doubleTap, Click
      if (swiper.allowClick) {
        swiper.updateClickedSlide(e);
        swiper.emit('tap click', e);
        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }

      data.lastClickTime = Utils.now();
      Utils.nextTick(() => {
        if (!swiper.destroyed) swiper.allowClick = true;
      });

      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;

      let currentPos;
      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }

      if (params.cssMode) {
        return;
      }

      if (params.freeMode) {
        if (currentPos < -swiper.minTranslate()) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        if (currentPos > -swiper.maxTranslate()) {
          if (swiper.slides.length < snapGrid.length) {
            swiper.slideTo(snapGrid.length - 1);
          } else {
            swiper.slideTo(swiper.slides.length - 1);
          }
          return;
        }

        if (params.freeModeMomentum) {
          if (data.velocities.length > 1) {
            const lastMoveEvent = data.velocities.pop();
            const velocityEvent = data.velocities.pop();

            const distance = lastMoveEvent.position - velocityEvent.position;
            const time = lastMoveEvent.time - velocityEvent.time;
            swiper.velocity = distance / time;
            swiper.velocity /= 2;
            if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
              swiper.velocity = 0;
            }
            // this implies that the user stopped moving a finger then released.
            // There would be no events with distance zero, so the last event is stale.
            if (time > 150 || Utils.now() - lastMoveEvent.time > 300) {
              swiper.velocity = 0;
            }
          } else {
            swiper.velocity = 0;
          }
          swiper.velocity *= params.freeModeMomentumVelocityRatio;

          data.velocities.length = 0;
          let momentumDuration = 1000 * params.freeModeMomentumRatio;
          const momentumDistance = swiper.velocity * momentumDuration;

          let newPosition = swiper.translate + momentumDistance;
          if (rtl) newPosition = -newPosition;

          let doBounce = false;
          let afterBouncePosition;
          const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
          let needsLoopFix;
          if (newPosition < swiper.maxTranslate()) {
            if (params.freeModeMomentumBounce) {
              if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                newPosition = swiper.maxTranslate() - bounceAmount;
              }
              afterBouncePosition = swiper.maxTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.maxTranslate();
            }
            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (newPosition > swiper.minTranslate()) {
            if (params.freeModeMomentumBounce) {
              if (newPosition - swiper.minTranslate() > bounceAmount) {
                newPosition = swiper.minTranslate() + bounceAmount;
              }
              afterBouncePosition = swiper.minTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.minTranslate();
            }
            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (params.freeModeSticky) {
            let nextSlide;
            for (let j = 0; j < snapGrid.length; j += 1) {
              if (snapGrid[j] > -newPosition) {
                nextSlide = j;
                break;
              }
            }

            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
              newPosition = snapGrid[nextSlide];
            } else {
              newPosition = snapGrid[nextSlide - 1];
            }
            newPosition = -newPosition;
          }
          if (needsLoopFix) {
            swiper.once('transitionEnd', () => {
              swiper.loopFix();
            });
          }
          // Fix duration
          if (swiper.velocity !== 0) {
            if (rtl) {
              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
            } else {
              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
            }
            if (params.freeModeSticky) {
              // If freeModeSticky is active and the user ends a swipe with a slow-velocity
              // event, then durations can be 20+ seconds to slide one (or zero!) slides.
              // It's easy to see this when simulating touch with mouse events. To fix this,
              // limit single-slide swipes to the default slide duration. This also has the
              // nice side effect of matching slide speed if the user stopped moving before
              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
              // For faster swipes, also apply limits (albeit higher ones).
              const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
              const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
              if (moveDistance < currentSlideSize) {
                momentumDuration = params.speed;
              } else if (moveDistance < 2 * currentSlideSize) {
                momentumDuration = params.speed * 1.5;
              } else {
                momentumDuration = params.speed * 2.5;
              }
            }
          } else if (params.freeModeSticky) {
            swiper.slideToClosest();
            return;
          }

          if (params.freeModeMomentumBounce && doBounce) {
            swiper.updateProgress(afterBouncePosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            swiper.animating = true;
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
              swiper.emit('momentumBounce');
              swiper.setTransition(params.speed);
              setTimeout(() => {
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(() => {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }, 0);
            });
          } else if (swiper.velocity) {
            swiper.updateProgress(newPosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            if (!swiper.animating) {
              swiper.animating = true;
              $wrapperEl.transitionEnd(() => {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }
          } else {
            swiper.updateProgress(newPosition);
          }

          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        } else if (params.freeModeSticky) {
          swiper.slideToClosest();
          return;
        }

        if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }
        return;
      }

      // Find current slide
      let stopIndex = 0;
      let groupSize = swiper.slidesSizesGrid[0];
      for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (typeof slidesGrid[i + increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      }

      // Find current slide size
      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
          else swiper.slideTo(stopIndex);
        }
        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
          else swiper.slideTo(stopIndex);
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }
        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(stopIndex + increment);
          }
          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }

    function onResize() {
      const swiper = this;

      const { params, el } = swiper;

      if (el && el.offsetWidth === 0) return;

      // Breakpoints
      if (params.breakpoints) {
        swiper.setBreakpoint();
      }

      // Save locks
      const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;

      // Disable locks on resize
      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;

      swiper.updateSize();
      swiper.updateSlides();

      swiper.updateSlidesClasses();
      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      }
      // Return locks after resize
      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;

      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }

    function onClick(e) {
      const swiper = this;
      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();
        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }

    function onScroll() {
      const swiper = this;
      const { wrapperEl, rtlTranslate } = swiper;
      swiper.previousTranslate = swiper.translate;
      if (swiper.isHorizontal()) {
        if (rtlTranslate) {
          swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
        } else {
          swiper.translate = -wrapperEl.scrollLeft;
        }
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      }
      // eslint-disable-next-line
      if (swiper.translate === -0) swiper.translate = 0;

      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();

      let newProgress;
      const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }
      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }

      swiper.emit('setTranslate', swiper.translate, false);
    }

    let dummyEventAttached = false;
    function dummyEventListener() {}

    function attachEvents() {
      const swiper = this;
      const { params, touchEvents, el, wrapperEl } = swiper;

      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);
      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }

      swiper.onClick = onClick.bind(swiper);

      const capture = !!params.nested;

      // Touch Events
      if (!Support.touch && Support.pointerEvents) {
        el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
        doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
        doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (Support.touch) {
          const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
          el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          el.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture } : capture);
          el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
          if (touchEvents.cancel) {
            el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
          }
          if (!dummyEventAttached) {
            doc.addEventListener('touchstart', dummyEventListener);
            dummyEventAttached = true;
          }
        }
        if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
          el.addEventListener('mousedown', swiper.onTouchStart, false);
          doc.addEventListener('mousemove', swiper.onTouchMove, capture);
          doc.addEventListener('mouseup', swiper.onTouchEnd, false);
        }
      }
      // Prevent Links Clicks
      if (params.preventClicks || params.preventClicksPropagation) {
        el.addEventListener('click', swiper.onClick, true);
      }
      if (params.cssMode) {
        wrapperEl.addEventListener('scroll', swiper.onScroll);
      }

      // Resize handler
      if (params.updateOnWindowResize) {
        swiper.on(Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
      } else {
        swiper.on('observerUpdate', onResize, true);
      }
    }

    function detachEvents() {
      const swiper = this;

      const { params, touchEvents, el, wrapperEl } = swiper;

      const capture = !!params.nested;

      // Touch Events
      if (!Support.touch && Support.pointerEvents) {
        el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
        doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (Support.touch) {
          const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
          el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
          el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
          if (touchEvents.cancel) {
            el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
          }
        }
        if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
          el.removeEventListener('mousedown', swiper.onTouchStart, false);
          doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
          doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
        }
      }
      // Prevent Links Clicks
      if (params.preventClicks || params.preventClicksPropagation) {
        el.removeEventListener('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl.removeEventListener('scroll', swiper.onScroll);
      }

      // Resize handler
      swiper.off(Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
    }

    var events = {
      attachEvents,
      detachEvents,
    };

    function setBreakpoint() {
      const swiper = this;
      const { activeIndex, initialized, loopedSlides = 0, params, $el } = swiper;
      const breakpoints = params.breakpoints;
      if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;

      // Get breakpoint for window width and update parameters
      const breakpoint = swiper.getBreakpoint(breakpoints);

      if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
        const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
        if (breakpointOnlyParams) {
          ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(param => {
            const paramValue = breakpointOnlyParams[param];
            if (typeof paramValue === 'undefined') return;
            if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
              breakpointOnlyParams[param] = 'auto';
            } else if (param === 'slidesPerView') {
              breakpointOnlyParams[param] = parseFloat(paramValue);
            } else {
              breakpointOnlyParams[param] = parseInt(paramValue, 10);
            }
          });
        }

        const breakpointParams = breakpointOnlyParams || swiper.originalParams;
        const wasMultiRow = params.slidesPerColumn > 1;
        const isMultiRow = breakpointParams.slidesPerColumn > 1;
        if (wasMultiRow && !isMultiRow) {
          $el.removeClass(`${params.containerModifierClass}multirow ${params.containerModifierClass}multirow-column`);
        } else if (!wasMultiRow && isMultiRow) {
          $el.addClass(`${params.containerModifierClass}multirow`);
          if (breakpointParams.slidesPerColumnFill === 'column') {
            $el.addClass(`${params.containerModifierClass}multirow-column`);
          }
        }

        const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
        const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

        if (directionChanged && initialized) {
          swiper.changeDirection();
        }

        Utils.extend(swiper.params, breakpointParams);

        Utils.extend(swiper, {
          allowTouchMove: swiper.params.allowTouchMove,
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
        });

        swiper.currentBreakpoint = breakpoint;

        if (needsReLoop && initialized) {
          swiper.loopDestroy();
          swiper.loopCreate();
          swiper.updateSlides();
          swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
        }

        swiper.emit('breakpoint', breakpointParams);
      }
    }

    function getBreakpoint(breakpoints) {
      // Get breakpoint for window width
      if (!breakpoints) return undefined;
      let breakpoint = false;

      const points = Object.keys(breakpoints).map(point => {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          const minRatio = parseFloat(point.substr(1));
          const value = win.innerHeight * minRatio;
          return { value, point };
        }
        return { value: point, point };
      });

      points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
      for (let i = 0; i < points.length; i += 1) {
        const { point, value } = points[i];
        if (value <= win.innerWidth) {
          breakpoint = point;
        }
      }
      return breakpoint || 'max';
    }

    var breakpoints = { setBreakpoint, getBreakpoint };

    function addClasses() {
      const swiper = this;
      const { classNames, params, rtl, $el } = swiper;
      const suffixes = [];

      suffixes.push('initialized');
      suffixes.push(params.direction);

      if (params.freeMode) {
        suffixes.push('free-mode');
      }
      if (params.autoHeight) {
        suffixes.push('autoheight');
      }
      if (rtl) {
        suffixes.push('rtl');
      }
      if (params.slidesPerColumn > 1) {
        suffixes.push('multirow');
        if (params.slidesPerColumnFill === 'column') {
          suffixes.push('multirow-column');
        }
      }
      if (Device.android) {
        suffixes.push('android');
      }
      if (Device.ios) {
        suffixes.push('ios');
      }

      if (params.cssMode) {
        suffixes.push('css-mode');
      }

      suffixes.forEach(suffix => {
        classNames.push(params.containerModifierClass + suffix);
      });

      $el.addClass(classNames.join(' '));
    }

    function removeClasses() {
      const swiper = this;
      const { $el, classNames } = swiper;

      $el.removeClass(classNames.join(' '));
    }

    var classes = { addClasses, removeClasses };

    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
      let image;
      function onReady() {
        if (callback) callback();
      }
      const isPicture = $(imageEl).parent('picture')[0];

      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new win.Image();
          image.onload = onReady;
          image.onerror = onReady;
          if (sizes) {
            image.sizes = sizes;
          }
          if (srcset) {
            image.srcset = srcset;
          }
          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }

    function preloadImages() {
      const swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');
      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }
      for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
        const imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(
          imageEl,
          imageEl.currentSrc || imageEl.getAttribute('src'),
          imageEl.srcset || imageEl.getAttribute('srcset'),
          imageEl.sizes || imageEl.getAttribute('sizes'),
          true,
          onReady,
        );
      }
    }

    var images = {
      loadImage,
      preloadImages,
    };

    function checkOverflow() {
      const swiper = this;
      const params = swiper.params;
      const wasLocked = swiper.isLocked;
      const lastSlidePosition =
        swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

      if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
        swiper.isLocked = lastSlidePosition <= swiper.size;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }

      swiper.allowSlideNext = !swiper.isLocked;
      swiper.allowSlidePrev = !swiper.isLocked;

      // events
      if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
        swiper.navigation.update();
      }
    }

    var checkOverflow$1 = { checkOverflow };

    var defaults = {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'container',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      //
      preventInteractionOnTransition: false,

      // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,

      // Free mode
      freeMode: false,
      freeModeMomentum: true,
      freeModeMomentumRatio: 1,
      freeModeMomentumBounce: true,
      freeModeMomentumBounceRatio: 1,
      freeModeMomentumVelocityRatio: 1,
      freeModeSticky: false,
      freeModeMinimumVelocity: 0.02,

      // Autoheight
      autoHeight: false,

      // Set wrapper width
      setWrapperSize: false,

      // Virtual Translate
      virtualTranslate: false,

      // Effects
      effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

      // Breakpoints
      breakpoints: undefined,

      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerColumn: 1,
      slidesPerColumnFill: 'column',
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0, // in px
      slidesOffsetAfter: 0, // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,

      // Disable swiper and hide navigation when container not overflow
      watchOverflow: false,

      // Round length
      roundLengths: false,

      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,

      // Unique Navigation Elements
      uniqueNavElements: true,

      // Resistance
      resistance: true,
      resistanceRatio: 0.85,

      // Progress
      watchSlidesProgress: false,
      watchSlidesVisibility: false,

      // Cursor
      grabCursor: false,

      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,

      // Images
      preloadImages: true,
      updateOnImagesReady: true,

      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: false,

      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null, // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,

      // Passive Listeners
      passiveListeners: true,

      // NS
      containerModifierClass: 'swiper-container-', // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',

      // Callbacks
      runCallbacksOnInit: true,
    };

    /* eslint no-param-reassign: "off" */

    const prototypes = {
      update,
      translate,
      transition: transition$1,
      slide,
      loop,
      grabCursor,
      manipulation,
      events,
      breakpoints,
      checkOverflow: checkOverflow$1,
      classes,
      images,
    };

    const extendedDefaults = {};

    class Swiper extends SwiperClass {
      constructor(...args) {
        let el;
        let params;
        if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
          params = args[0];
        } else {
          [el, params] = args;
        }
        if (!params) params = {};

        params = Utils.extend({}, params);
        if (el && !params.el) params.el = el;

        super(params);

        Object.keys(prototypes).forEach(prototypeGroup => {
          Object.keys(prototypes[prototypeGroup]).forEach(protoMethod => {
            if (!Swiper.prototype[protoMethod]) {
              Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
            }
          });
        });

        // Swiper Instance
        const swiper = this;
        if (typeof swiper.modules === 'undefined') {
          swiper.modules = {};
        }
        Object.keys(swiper.modules).forEach(moduleName => {
          const module = swiper.modules[moduleName];
          if (module.params) {
            const moduleParamName = Object.keys(module.params)[0];
            const moduleParams = module.params[moduleParamName];
            if (typeof moduleParams !== 'object' || moduleParams === null) return;
            if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
            if (params[moduleParamName] === true) {
              params[moduleParamName] = { enabled: true };
            }
            if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
              params[moduleParamName].enabled = true;
            }
            if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };
          }
        });

        // Extend defaults with modules params
        const swiperParams = Utils.extend({}, defaults);
        swiper.useModulesParams(swiperParams);

        // Extend defaults with passed params
        swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = Utils.extend({}, swiper.params);
        swiper.passedParams = Utils.extend({}, params);

        // Save Dom lib
        swiper.$ = $;

        // Find el
        const $el = $(swiper.params.el);
        el = $el[0];

        if (!el) {
          return undefined;
        }

        if ($el.length > 1) {
          const swipers = [];
          $el.each((index, containerEl) => {
            const newParams = Utils.extend({}, params, { el: containerEl });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        }

        el.swiper = swiper;
        $el.data('swiper', swiper);

        // Find Wrapper
        let $wrapperEl;
        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
          $wrapperEl = $(el.shadowRoot.querySelector(`.${swiper.params.wrapperClass}`));
          // Children needs to return slot items
          $wrapperEl.children = options => $el.children(options);
        } else {
          $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);
        }
        // Extend Swiper
        Utils.extend(swiper, {
          $el,
          el,
          $wrapperEl,
          wrapperEl: $wrapperEl[0],

          // Classes
          classNames: [],

          // Slides
          slides: $(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],

          // isDirection
          isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },
          isVertical() {
            return swiper.params.direction === 'vertical';
          },
          // RTL
          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
          wrongRTL: $wrapperEl.css('display') === '-webkit-box',

          // Indexes
          activeIndex: 0,
          realIndex: 0,

          //
          isBeginning: true,
          isEnd: false,

          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,

          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,

          // Touch Events
          touchEvents: (function touchEvents() {
            const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            let desktop = ['mousedown', 'mousemove', 'mouseup'];
            if (Support.pointerEvents) {
              desktop = ['pointerdown', 'pointermove', 'pointerup'];
            }
            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3],
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2],
            };
            return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          })(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            formElements: 'input, select, option, textarea, button, video, label',
            // Last click time
            lastClickTime: Utils.now(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined,
          },

          // Clicks
          allowClick: true,

          // Touches
          allowTouchMove: swiper.params.allowTouchMove,

          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0,
          },

          // Images
          imagesToLoad: [],
          imagesLoaded: 0,
        });

        // Install Modules
        swiper.useModules();

        // Init
        if (swiper.params.init) {
          swiper.init();
        }

        // Return app instance
        return swiper;
      }

      slidesPerViewDynamic() {
        const swiper = this;
        const { params, slides, slidesGrid, size: swiperSize, activeIndex } = swiper;
        let spv = 1;
        if (params.centeredSlides) {
          let slideSize = slides[activeIndex].swiperSlideSize;
          let breakLoop;
          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
          for (let i = activeIndex - 1; i >= 0; i -= 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
        } else {
          for (let i = activeIndex + 1; i < slides.length; i += 1) {
            if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
              spv += 1;
            }
          }
        }
        return spv;
      }

      update() {
        const swiper = this;
        if (!swiper || swiper.destroyed) return;
        const { snapGrid, params } = swiper;
        // Breakpoints
        if (params.breakpoints) {
          swiper.setBreakpoint();
        }
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        function setTranslate() {
          const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }
        let translated;
        if (swiper.params.freeMode) {
          setTranslate();
          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }
          if (!translated) {
            setTranslate();
          }
        }
        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }
        swiper.emit('update');
      }

      changeDirection(newDirection, needUpdate = true) {
        const swiper = this;
        const currentDirection = swiper.params.direction;
        if (!newDirection) {
          // eslint-disable-next-line
          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }
        if (newDirection === currentDirection || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
          return swiper;
        }

        swiper.$el.removeClass(`${swiper.params.containerModifierClass}${currentDirection}`).addClass(`${swiper.params.containerModifierClass}${newDirection}`);

        swiper.params.direction = newDirection;

        swiper.slides.each((slideIndex, slideEl) => {
          if (newDirection === 'vertical') {
            slideEl.style.width = '';
          } else {
            slideEl.style.height = '';
          }
        });

        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();

        return swiper;
      }

      init() {
        const swiper = this;
        if (swiper.initialized) return;

        swiper.emit('beforeInit');

        // Set breakpoint
        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        }

        // Add Classes
        swiper.addClasses();

        // Create loop
        if (swiper.params.loop) {
          swiper.loopCreate();
        }

        // Update size
        swiper.updateSize();

        // Update slides
        swiper.updateSlides();

        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        }

        // Set Grab Cursor
        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }

        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        }

        // Slide To Initial Slide
        if (swiper.params.loop) {
          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
        }

        // Attach events
        swiper.attachEvents();

        // Init Flag
        swiper.initialized = true;

        // Emit
        swiper.emit('init');
      }

      destroy(deleteInstance = true, cleanStyles = true) {
        const swiper = this;
        const { params, $el, $wrapperEl, slides } = swiper;

        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
          return null;
        }

        swiper.emit('beforeDestroy');

        // Init Flag
        swiper.initialized = false;

        // Detach events
        swiper.detachEvents();

        // Destroy loop
        if (params.loop) {
          swiper.loopDestroy();
        }

        // Cleanup styles
        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr('style');
          $wrapperEl.removeAttr('style');
          if (slides && slides.length) {
            slides
              .removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' '))
              .removeAttr('style')
              .removeAttr('data-swiper-slide-index');
          }
        }

        swiper.emit('destroy');

        // Detach emitter events
        Object.keys(swiper.eventsListeners).forEach(eventName => {
          swiper.off(eventName);
        });

        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          swiper.$el.data('swiper', null);
          Utils.deleteProps(swiper);
        }
        swiper.destroyed = true;

        return null;
      }

      static extendDefaults(newDefaults) {
        Utils.extend(extendedDefaults, newDefaults);
      }

      static get extendedDefaults() {
        return extendedDefaults;
      }

      static get defaults() {
        return defaults;
      }

      static get Class() {
        return SwiperClass;
      }

      static get $() {
        return $;
      }
    }

    var Device$1 = {
      name: 'device',
      proto: {
        device: Device,
      },
      static: {
        device: Device,
      },
    };

    var Support$1 = {
      name: 'support',
      proto: {
        support: Support,
      },
      static: {
        support: Support,
      },
    };

    const Browser = (function Browser() {
      function isSafari() {
        const ua = win.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }
      return {
        isEdge: !!win.navigator.userAgent.match(/Edge/g),
        isSafari: isSafari(),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),
      };
    })();

    var Browser$1 = {
      name: 'browser',
      proto: {
        browser: Browser,
      },
      static: {
        browser: Browser,
      },
    };

    var Resize = {
      name: 'resize',
      create() {
        const swiper = this;
        Utils.extend(swiper, {
          resize: {
            resizeHandler() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.emit('beforeResize');
              swiper.emit('resize');
            },
            orientationChangeHandler() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.emit('orientationchange');
            },
          },
        });
      },
      on: {
        init() {
          const swiper = this;
          // Emit resize
          win.addEventListener('resize', swiper.resize.resizeHandler);

          // Emit orientationchange
          win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
        },
        destroy() {
          const swiper = this;
          win.removeEventListener('resize', swiper.resize.resizeHandler);
          win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
        },
      },
    };

    const Observer = {
      func: win.MutationObserver || win.WebkitMutationObserver,
      attach(target, options = {}) {
        const swiper = this;

        const ObserverFunc = Observer.func;
        const observer = new ObserverFunc(mutations => {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            swiper.emit('observerUpdate', mutations[0]);
            return;
          }
          const observerUpdate = function observerUpdate() {
            swiper.emit('observerUpdate', mutations[0]);
          };

          if (win.requestAnimationFrame) {
            win.requestAnimationFrame(observerUpdate);
          } else {
            win.setTimeout(observerUpdate, 0);
          }
        });

        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
        });

        swiper.observer.observers.push(observer);
      },
      init() {
        const swiper = this;
        if (!Support.observer || !swiper.params.observer) return;
        if (swiper.params.observeParents) {
          const containerParents = swiper.$el.parents();
          for (let i = 0; i < containerParents.length; i += 1) {
            swiper.observer.attach(containerParents[i]);
          }
        }
        // Observe container
        swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });

        // Observe wrapper
        swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
      },
      destroy() {
        const swiper = this;
        swiper.observer.observers.forEach(observer => {
          observer.disconnect();
        });
        swiper.observer.observers = [];
      },
    };

    var Observer$1 = {
      name: 'observer',
      params: {
        observer: false,
        observeParents: false,
        observeSlideChildren: false,
      },
      create() {
        const swiper = this;
        Utils.extend(swiper, {
          observer: {
            init: Observer.init.bind(swiper),
            attach: Observer.attach.bind(swiper),
            destroy: Observer.destroy.bind(swiper),
            observers: [],
          },
        });
      },
      on: {
        init() {
          const swiper = this;
          swiper.observer.init();
        },
        destroy() {
          const swiper = this;
          swiper.observer.destroy();
        },
      },
    };

    const Keyboard = {
      handle(event) {
        const swiper = this;
        const { rtlTranslate: rtl } = swiper;
        let e = event;
        if (e.originalEvent) e = e.originalEvent; // jquery fix
        const kc = e.keyCode || e.charCode;
        // Directions locks
        if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40) || kc === 34)) {
          return false;
        }
        if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38) || kc === 33)) {
          return false;
        }
        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
          return undefined;
        }
        if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
          return undefined;
        }
        if (swiper.params.keyboard.onlyInViewport && (kc === 33 || kc === 34 || kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
          let inView = false;
          // Check that swiper should be inside of visible area of window
          if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
            return undefined;
          }
          const windowWidth = win.innerWidth;
          const windowHeight = win.innerHeight;
          const swiperOffset = swiper.$el.offset();
          if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
          const swiperCoord = [
            [swiperOffset.left, swiperOffset.top],
            [swiperOffset.left + swiper.width, swiperOffset.top],
            [swiperOffset.left, swiperOffset.top + swiper.height],
            [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],
          ];
          for (let i = 0; i < swiperCoord.length; i += 1) {
            const point = swiperCoord[i];
            if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
              inView = true;
            }
          }
          if (!inView) return undefined;
        }
        if (swiper.isHorizontal()) {
          if (kc === 33 || kc === 34 || kc === 37 || kc === 39) {
            if (e.preventDefault) e.preventDefault();
            else e.returnValue = false;
          }
          if (((kc === 34 || kc === 39) && !rtl) || ((kc === 33 || kc === 37) && rtl)) swiper.slideNext();
          if (((kc === 33 || kc === 37) && !rtl) || ((kc === 34 || kc === 39) && rtl)) swiper.slidePrev();
        } else {
          if (kc === 33 || kc === 34 || kc === 38 || kc === 40) {
            if (e.preventDefault) e.preventDefault();
            else e.returnValue = false;
          }
          if (kc === 34 || kc === 40) swiper.slideNext();
          if (kc === 33 || kc === 38) swiper.slidePrev();
        }
        swiper.emit('keyPress', kc);
        return undefined;
      },
      enable() {
        const swiper = this;
        if (swiper.keyboard.enabled) return;
        $(doc).on('keydown', swiper.keyboard.handle);
        swiper.keyboard.enabled = true;
      },
      disable() {
        const swiper = this;
        if (!swiper.keyboard.enabled) return;
        $(doc).off('keydown', swiper.keyboard.handle);
        swiper.keyboard.enabled = false;
      },
    };

    var keyboard = {
      name: 'keyboard',
      params: {
        keyboard: {
          enabled: false,
          onlyInViewport: true,
        },
      },
      create() {
        const swiper = this;
        Utils.extend(swiper, {
          keyboard: {
            enabled: false,
            enable: Keyboard.enable.bind(swiper),
            disable: Keyboard.disable.bind(swiper),
            handle: Keyboard.handle.bind(swiper),
          },
        });
      },
      on: {
        init() {
          const swiper = this;
          if (swiper.params.keyboard.enabled) {
            swiper.keyboard.enable();
          }
        },
        destroy() {
          const swiper = this;
          if (swiper.keyboard.enabled) {
            swiper.keyboard.disable();
          }
        },
      },
    };

    function isEventSupported() {
      const eventName = 'onwheel';
      let isSupported = eventName in doc;

      if (!isSupported) {
        const element = doc.createElement('div');
        element.setAttribute(eventName, 'return;');
        isSupported = typeof element[eventName] === 'function';
      }

      if (
        !isSupported &&
        doc.implementation &&
        doc.implementation.hasFeature &&
        // always returns true in newer browsers as per the standard.
        // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
        doc.implementation.hasFeature('', '') !== true
      ) {
        // This is the only way to test support for the `wheel` event in IE9+.
        isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
      }

      return isSupported;
    }
    const Mousewheel = {
      lastScrollTime: Utils.now(),
      lastEventBeforeSnap: undefined,
      recentWheelEvents: [],
      event() {
        if (win.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
        return isEventSupported() ? 'wheel' : 'mousewheel';
      },
      normalize(e) {
        // Reasonable defaults
        const PIXEL_STEP = 10;
        const LINE_HEIGHT = 40;
        const PAGE_HEIGHT = 800;

        let sX = 0;
        let sY = 0; // spinX, spinY
        let pX = 0;
        let pY = 0; // pixelX, pixelY

        // Legacy
        if ('detail' in e) {
          sY = e.detail;
        }
        if ('wheelDelta' in e) {
          sY = -e.wheelDelta / 120;
        }
        if ('wheelDeltaY' in e) {
          sY = -e.wheelDeltaY / 120;
        }
        if ('wheelDeltaX' in e) {
          sX = -e.wheelDeltaX / 120;
        }

        // side scrolling on FF with DOMMouseScroll
        if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
          sX = sY;
          sY = 0;
        }

        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;

        if ('deltaY' in e) {
          pY = e.deltaY;
        }
        if ('deltaX' in e) {
          pX = e.deltaX;
        }

        if (e.shiftKey && !pX) {
          // if user scrolls with shift he wants horizontal scroll
          pX = pY;
          pY = 0;
        }

        if ((pX || pY) && e.deltaMode) {
          if (e.deltaMode === 1) {
            // delta in LINE units
            pX *= LINE_HEIGHT;
            pY *= LINE_HEIGHT;
          } else {
            // delta in PAGE units
            pX *= PAGE_HEIGHT;
            pY *= PAGE_HEIGHT;
          }
        }

        // Fall-back if spin cannot be determined
        if (pX && !sX) {
          sX = pX < 1 ? -1 : 1;
        }
        if (pY && !sY) {
          sY = pY < 1 ? -1 : 1;
        }

        return {
          spinX: sX,
          spinY: sY,
          pixelX: pX,
          pixelY: pY,
        };
      },
      handleMouseEnter() {
        const swiper = this;
        swiper.mouseEntered = true;
      },
      handleMouseLeave() {
        const swiper = this;
        swiper.mouseEntered = false;
      },
      handle(event) {
        let e = event;
        const swiper = this;
        const params = swiper.params.mousewheel;

        if (swiper.params.cssMode) {
          e.preventDefault();
        }

        let target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarged !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarged);
        }
        if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;

        if (e.originalEvent) e = e.originalEvent; // jquery fix
        let delta = 0;
        const rtlFactor = swiper.rtlTranslate ? -1 : 1;

        const data = Mousewheel.normalize(e);

        if (params.forceToAxis) {
          if (swiper.isHorizontal()) {
            if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;
            else return true;
          } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;
          else return true;
        } else {
          delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
        }

        if (delta === 0) return true;

        if (params.invert) delta = -delta;

        if (!swiper.params.freeMode) {
          // Register the new event in a variable which stores the relevant data
          const newEvent = {
            time: Utils.now(),
            delta: Math.abs(delta),
            direction: Math.sign(delta),
            raw: event,
          };

          // Keep the most recent events
          const recentWheelEvents = swiper.mousewheel.recentWheelEvents;
          if (recentWheelEvents.length >= 2) {
            recentWheelEvents.shift(); // only store the last N events
          }
          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
          recentWheelEvents.push(newEvent);

          // If there is at least one previous recorded event:
          //   If direction has changed or
          //   if the scroll is quicker than the previous one:
          //     Animate the slider.
          // Else (this is the first time the wheel is moved):
          //     Animate the slider.
          if (prevEvent) {
            if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
              swiper.mousewheel.animateSlider(newEvent);
            }
          } else {
            swiper.mousewheel.animateSlider(newEvent);
          }

          // If it's time to release the scroll:
          //   Return now so you don't hit the preventDefault.
          if (swiper.mousewheel.releaseScroll(newEvent)) {
            return true;
          }
        } else {
          // Freemode or scrollContainer:

          // If we recently snapped after a momentum scroll, then ignore wheel events
          // to give time for the deceleration to finish. Stop ignoring after 500 msecs
          // or if it's a new scroll (larger delta or inverse sign as last event before
          // an end-of-momentum snap).
          const newEvent = { time: Utils.now(), delta: Math.abs(delta), direction: Math.sign(delta) };
          const { lastEventBeforeSnap } = swiper.mousewheel;
          const ignoreWheelEvents =
            lastEventBeforeSnap &&
            newEvent.time < lastEventBeforeSnap.time + 500 &&
            newEvent.delta <= lastEventBeforeSnap.delta &&
            newEvent.direction === lastEventBeforeSnap.direction;
          if (!ignoreWheelEvents) {
            swiper.mousewheel.lastEventBeforeSnap = undefined;

            if (swiper.params.loop) {
              swiper.loopFix();
            }
            let position = swiper.getTranslate() + delta * params.sensitivity;
            const wasBeginning = swiper.isBeginning;
            const wasEnd = swiper.isEnd;

            if (position >= swiper.minTranslate()) position = swiper.minTranslate();
            if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();

            swiper.setTransition(0);
            swiper.setTranslate(position);
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();

            if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
              swiper.updateSlidesClasses();
            }

            if (swiper.params.freeModeSticky) {
              // When wheel scrolling starts with sticky (aka snap) enabled, then detect
              // the end of a momentum scroll by storing recent (N=15?) wheel events.
              // 1. do all N events have decreasing or same (absolute value) delta?
              // 2. did all N events arrive in the last M (M=500?) msecs?
              // 3. does the earliest event have an (absolute value) delta that's
              //    at least P (P=1?) larger than the most recent event's delta?
              // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
              // If 1-4 are "yes" then we're near the end of a momuntum scroll deceleration.
              // Snap immediately and ignore remaining wheel events in this scroll.
              // See comment above for "remaining wheel events in this scroll" determination.
              // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
              clearTimeout(swiper.mousewheel.timeout);
              swiper.mousewheel.timeout = undefined;
              const recentWheelEvents = swiper.mousewheel.recentWheelEvents;
              if (recentWheelEvents.length >= 15) {
                recentWheelEvents.shift(); // only store the last N events
              }
              const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
              const firstEvent = recentWheelEvents[0];
              recentWheelEvents.push(newEvent);
              if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                recentWheelEvents.splice(0);
              } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                // We're at the end of the deceleration of a momentum scroll, so there's no need
                // to wait for more events. Snap ASAP on the next tick.
                // Also, because there's some remaining momentum we'll bias the snap in the
                // direction of the ongoing scroll because it's better UX for the scroll to snap
                // in the same direction as the scroll instead of reversing to snap.  Therefore,
                // if it's already scrolled more than 20% in the current direction, keep going.
                const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                swiper.mousewheel.lastEventBeforeSnap = newEvent;
                recentWheelEvents.splice(0);
                swiper.mousewheel.timeout = Utils.nextTick(() => {
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 0); // no delay; move on next tick
              }
              if (!swiper.mousewheel.timeout) {
                // if we get here, then we haven't detected the end of a momentum scroll, so
                // we'll consider a scroll "complete" when there haven't been any wheel events
                // for 500ms.
                swiper.mousewheel.timeout = Utils.nextTick(() => {
                  const snapToThreshold = 0.5;
                  swiper.mousewheel.lastEventBeforeSnap = newEvent;
                  recentWheelEvents.splice(0);
                  swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
                }, 500);
              }
            }

            // Emit event
            if (!ignoreWheelEvents) swiper.emit('scroll', e);

            // Stop autoplay
            if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
            // Return page scroll on edge positions
            if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
          }
        }

        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        return false;
      },
      animateSlider(newEvent) {
        const swiper = this;
        // If the movement is NOT big enough and
        // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
        //   Don't go any further (avoid insignificant scroll movement).
        if (newEvent.delta >= 6 && Utils.now() - swiper.mousewheel.lastScrollTime < 60) {
          // Return false as a default
          return true;
        }
        // If user is scrolling towards the end:
        //   If the slider hasn't hit the latest slide or
        //   if the slider is a loop and
        //   if the slider isn't moving right now:
        //     Go to next slide and
        //     emit a scroll event.
        // Else (the user is scrolling towards the beginning) and
        // if the slider hasn't hit the first slide or
        // if the slider is a loop and
        // if the slider isn't moving right now:
        //   Go to prev slide and
        //   emit a scroll event.
        if (newEvent.direction < 0) {
          if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
            swiper.slideNext();
            swiper.emit('scroll', newEvent.raw);
          }
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
          swiper.slidePrev();
          swiper.emit('scroll', newEvent.raw);
        }
        // If you got here is because an animation has been triggered so store the current time
        swiper.mousewheel.lastScrollTime = new win.Date().getTime();
        // Return false as a default
        return false;
      },
      releaseScroll(newEvent) {
        const swiper = this;
        const params = swiper.params.mousewheel;
        if (newEvent.direction < 0) {
          if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
            // Return true to animate scroll on edges
            return true;
          }
        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
          // Return true to animate scroll on edges
          return true;
        }
        return false;
      },
      enable() {
        const swiper = this;
        const event = Mousewheel.event();
        if (swiper.params.cssMode) {
          swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
          return true;
        }
        if (!event) return false;
        if (swiper.mousewheel.enabled) return false;
        let target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarged !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarged);
        }
        target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
        target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
        target.on(event, swiper.mousewheel.handle);
        swiper.mousewheel.enabled = true;
        return true;
      },
      disable() {
        const swiper = this;
        const event = Mousewheel.event();
        if (swiper.params.cssMode) {
          swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
          return true;
        }
        if (!event) return false;
        if (!swiper.mousewheel.enabled) return false;
        let target = swiper.$el;
        if (swiper.params.mousewheel.eventsTarged !== 'container') {
          target = $(swiper.params.mousewheel.eventsTarged);
        }
        target.off(event, swiper.mousewheel.handle);
        swiper.mousewheel.enabled = false;
        return true;
      },
    };

    const Pagination = {
      update() {
        // Render || Update Pagination bullets/items
        const swiper = this;
        const rtl = swiper.rtl;
        const params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const $el = swiper.pagination.$el;
        // Current/Total
        let current;
        const total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        if (swiper.params.loop) {
          current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
          if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
            current -= slidesLength - swiper.loopedSlides * 2;
          }
          if (current > total - 1) current -= total;
          if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
        } else if (typeof swiper.snapIndex !== 'undefined') {
          current = swiper.snapIndex;
        } else {
          current = swiper.activeIndex || 0;
        }
        // Types
        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
          const bullets = swiper.pagination.bullets;
          let firstIndex;
          let lastIndex;
          let midIndex;
          if (params.dynamicBullets) {
            swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
            $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);
            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
              swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;
              if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
                swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (swiper.pagination.dynamicBulletIndex < 0) {
                swiper.pagination.dynamicBulletIndex = 0;
              }
            }
            firstIndex = current - swiper.pagination.dynamicBulletIndex;
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }
          bullets.removeClass(
            `${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`,
          );
          if ($el.length > 1) {
            bullets.each((index, bullet) => {
              const $bullet = $(bullet);
              const bulletIndex = $bullet.index();
              if (bulletIndex === current) {
                $bullet.addClass(params.bulletActiveClass);
              }
              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  $bullet.addClass(`${params.bulletActiveClass}-main`);
                }
                if (bulletIndex === firstIndex) {
                  $bullet.prev().addClass(`${params.bulletActiveClass}-prev`).prev().addClass(`${params.bulletActiveClass}-prev-prev`);
                }
                if (bulletIndex === lastIndex) {
                  $bullet.next().addClass(`${params.bulletActiveClass}-next`).next().addClass(`${params.bulletActiveClass}-next-next`);
                }
              }
            });
          } else {
            const $bullet = bullets.eq(current);
            const bulletIndex = $bullet.index();
            $bullet.addClass(params.bulletActiveClass);
            if (params.dynamicBullets) {
              const $firstDisplayedBullet = bullets.eq(firstIndex);
              const $lastDisplayedBullet = bullets.eq(lastIndex);
              for (let i = firstIndex; i <= lastIndex; i += 1) {
                bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
              }
              if (swiper.params.loop) {
                if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                  for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                    bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                  }
                  bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
                } else {
                  $firstDisplayedBullet.prev().addClass(`${params.bulletActiveClass}-prev`).prev().addClass(`${params.bulletActiveClass}-prev-prev`);
                  $lastDisplayedBullet.next().addClass(`${params.bulletActiveClass}-next`).next().addClass(`${params.bulletActiveClass}-next-next`);
                }
              } else {
                $firstDisplayedBullet.prev().addClass(`${params.bulletActiveClass}-prev`).prev().addClass(`${params.bulletActiveClass}-prev-prev`);
                $lastDisplayedBullet.next().addClass(`${params.bulletActiveClass}-next`).next().addClass(`${params.bulletActiveClass}-next-next`);
              }
            }
          }
          if (params.dynamicBullets) {
            const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            const bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
            const offsetProp = rtl ? 'right' : 'left';
            bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
          }
        }
        if (params.type === 'fraction') {
          $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));
          $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));
        }
        if (params.type === 'progressbar') {
          let progressbarDirection;
          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }
          const scale = (current + 1) / total;
          let scaleX = 1;
          let scaleY = 1;
          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }
          $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
        }
        if (params.type === 'custom' && params.renderCustom) {
          $el.html(params.renderCustom(swiper, current + 1, total));
          swiper.emit('paginationRender', swiper, $el[0]);
        } else {
          swiper.emit('paginationUpdate', swiper, $el[0]);
        }
        $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      },
      render() {
        // Render Container
        const swiper = this;
        const params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

        const $el = swiper.pagination.$el;
        let paginationHTML = '';
        if (params.type === 'bullets') {
          const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
          for (let i = 0; i < numberOfBullets; i += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
            } else {
              paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
            }
          }
          $el.html(paginationHTML);
          swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
        }
        if (params.type === 'fraction') {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
          } else {
            paginationHTML = `<span class="${params.currentClass}"></span>` + ' / ' + `<span class="${params.totalClass}"></span>`;
          }
          $el.html(paginationHTML);
        }
        if (params.type === 'progressbar') {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
          } else {
            paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
          }
          $el.html(paginationHTML);
        }
        if (params.type !== 'custom') {
          swiper.emit('paginationRender', swiper.pagination.$el[0]);
        }
      },
      init() {
        const swiper = this;
        const params = swiper.params.pagination;
        if (!params.el) return;

        let $el = $(params.el);
        if ($el.length === 0) return;

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && swiper.$el.find(params.el).length === 1) {
          $el = swiper.$el.find(params.el);
        }

        if (params.type === 'bullets' && params.clickable) {
          $el.addClass(params.clickableClass);
        }

        $el.addClass(params.modifierClass + params.type);

        if (params.type === 'bullets' && params.dynamicBullets) {
          $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
          swiper.pagination.dynamicBulletIndex = 0;
          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }
        if (params.type === 'progressbar' && params.progressbarOpposite) {
          $el.addClass(params.progressbarOppositeClass);
        }

        if (params.clickable) {
          $el.on('click', `.${params.bulletClass}`, function onClick(e) {
            e.preventDefault();
            let index = $(this).index() * swiper.params.slidesPerGroup;
            if (swiper.params.loop) index += swiper.loopedSlides;
            swiper.slideTo(index);
          });
        }

        Utils.extend(swiper.pagination, {
          $el,
          el: $el[0],
        });
      },
      destroy() {
        const swiper = this;
        const params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        const $el = swiper.pagination.$el;

        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
        if (params.clickable) {
          $el.off('click', `.${params.bulletClass}`);
        }
      },
    };

    var pagination = {
      name: 'pagination',
      params: {
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: number => number,
          formatFractionTotal: number => number,
          bulletClass: 'swiper-pagination-bullet',
          bulletActiveClass: 'swiper-pagination-bullet-active',
          modifierClass: 'swiper-pagination-', // NEW
          currentClass: 'swiper-pagination-current',
          totalClass: 'swiper-pagination-total',
          hiddenClass: 'swiper-pagination-hidden',
          progressbarFillClass: 'swiper-pagination-progressbar-fill',
          progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
          clickableClass: 'swiper-pagination-clickable', // NEW
          lockClass: 'swiper-pagination-lock',
        },
      },
      create() {
        const swiper = this;
        Utils.extend(swiper, {
          pagination: {
            init: Pagination.init.bind(swiper),
            render: Pagination.render.bind(swiper),
            update: Pagination.update.bind(swiper),
            destroy: Pagination.destroy.bind(swiper),
            dynamicBulletIndex: 0,
          },
        });
      },
      on: {
        init() {
          const swiper = this;
          swiper.pagination.init();
          swiper.pagination.render();
          swiper.pagination.update();
        },
        activeIndexChange() {
          const swiper = this;
          if (swiper.params.loop) {
            swiper.pagination.update();
          } else if (typeof swiper.snapIndex === 'undefined') {
            swiper.pagination.update();
          }
        },
        snapIndexChange() {
          const swiper = this;
          if (!swiper.params.loop) {
            swiper.pagination.update();
          }
        },
        slidesLengthChange() {
          const swiper = this;
          if (swiper.params.loop) {
            swiper.pagination.render();
            swiper.pagination.update();
          }
        },
        snapGridLengthChange() {
          const swiper = this;
          if (!swiper.params.loop) {
            swiper.pagination.render();
            swiper.pagination.update();
          }
        },
        destroy() {
          const swiper = this;
          swiper.pagination.destroy();
        },
        click(e) {
          const swiper = this;
          if (
            swiper.params.pagination.el &&
            swiper.params.pagination.hideOnClick &&
            swiper.pagination.$el.length > 0 &&
            !$(e.target).hasClass(swiper.params.pagination.bulletClass)
          ) {
            const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
            if (isHidden === true) {
              swiper.emit('paginationShow', swiper);
            } else {
              swiper.emit('paginationHide', swiper);
            }
            swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
          }
        },
      },
    };

    const Scrollbar = {
      setTranslate() {
        const swiper = this;
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const { scrollbar, rtlTranslate: rtl, progress } = swiper;
        const { dragSize, trackSize, $dragEl, $el } = scrollbar;
        const params = swiper.params.scrollbar;

        let newSize = dragSize;
        let newPos = (trackSize - dragSize) * progress;
        if (rtl) {
          newPos = -newPos;
          if (newPos > 0) {
            newSize = dragSize - newPos;
            newPos = 0;
          } else if (-newPos + dragSize > trackSize) {
            newSize = trackSize + newPos;
          }
        } else if (newPos < 0) {
          newSize = dragSize + newPos;
          newPos = 0;
        } else if (newPos + dragSize > trackSize) {
          newSize = trackSize - newPos;
        }
        if (swiper.isHorizontal()) {
          $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
          $dragEl[0].style.width = `${newSize}px`;
        } else {
          $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
          $dragEl[0].style.height = `${newSize}px`;
        }
        if (params.hide) {
          clearTimeout(swiper.scrollbar.timeout);
          $el[0].style.opacity = 1;
          swiper.scrollbar.timeout = setTimeout(() => {
            $el[0].style.opacity = 0;
            $el.transition(400);
          }, 1000);
        }
      },
      setTransition(duration) {
        const swiper = this;
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.$dragEl.transition(duration);
      },
      updateSize() {
        const swiper = this;
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;

        const { scrollbar } = swiper;
        const { $dragEl, $el } = scrollbar;

        $dragEl[0].style.width = '';
        $dragEl[0].style.height = '';
        const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

        const divider = swiper.size / swiper.virtualSize;
        const moveDivider = divider * (trackSize / swiper.size);
        let dragSize;
        if (swiper.params.scrollbar.dragSize === 'auto') {
          dragSize = trackSize * divider;
        } else {
          dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        }

        if (swiper.isHorizontal()) {
          $dragEl[0].style.width = `${dragSize}px`;
        } else {
          $dragEl[0].style.height = `${dragSize}px`;
        }

        if (divider >= 1) {
          $el[0].style.display = 'none';
        } else {
          $el[0].style.display = '';
        }
        if (swiper.params.scrollbar.hide) {
          $el[0].style.opacity = 0;
        }
        Utils.extend(scrollbar, {
          trackSize,
          divider,
          moveDivider,
          dragSize,
        });
        scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
      },
      getPointerPosition(e) {
        const swiper = this;
        if (swiper.isHorizontal()) {
          return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
        }
        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
      },
      setDragPosition(e) {
        const swiper = this;
        const { scrollbar, rtlTranslate: rtl } = swiper;
        const { $el, dragSize, trackSize, dragStartPos } = scrollbar;

        let positionRatio;
        positionRatio =
          (scrollbar.getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);
        if (rtl) {
          positionRatio = 1 - positionRatio;
        }

        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;

        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      },
      onDragStart(e) {
        const swiper = this;
        const params = swiper.params.scrollbar;
        const { scrollbar, $wrapperEl } = swiper;
        const { $el, $dragEl } = scrollbar;
        swiper.scrollbar.isTouched = true;
        swiper.scrollbar.dragStartPos =
          e.target === $dragEl[0] || e.target === $dragEl ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
        e.preventDefault();
        e.stopPropagation();

        $wrapperEl.transition(100);
        $dragEl.transition(100);
        scrollbar.setDragPosition(e);

        clearTimeout(swiper.scrollbar.dragTimeout);

        $el.transition(0);
        if (params.hide) {
          $el.css('opacity', 1);
        }
        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', 'none');
        }
        swiper.emit('scrollbarDragStart', e);
      },
      onDragMove(e) {
        const swiper = this;
        const { scrollbar, $wrapperEl } = swiper;
        const { $el, $dragEl } = scrollbar;

        if (!swiper.scrollbar.isTouched) return;
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        scrollbar.setDragPosition(e);
        $wrapperEl.transition(0);
        $el.transition(0);
        $dragEl.transition(0);
        swiper.emit('scrollbarDragMove', e);
      },
      onDragEnd(e) {
        const swiper = this;

        const params = swiper.params.scrollbar;
        const { scrollbar, $wrapperEl } = swiper;
        const { $el } = scrollbar;

        if (!swiper.scrollbar.isTouched) return;
        swiper.scrollbar.isTouched = false;
        if (swiper.params.cssMode) {
          swiper.$wrapperEl.css('scroll-snap-type', '');
          $wrapperEl.transition('');
        }
        if (params.hide) {
          clearTimeout(swiper.scrollbar.dragTimeout);
          swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
            $el.css('opacity', 0);
            $el.transition(400);
          }, 1000);
        }
        swiper.emit('scrollbarDragEnd', e);
        if (params.snapOnRelease) {
          swiper.slideToClosest();
        }
      },
      enableDraggable() {
        const swiper = this;
        if (!swiper.params.scrollbar.el) return;
        const { scrollbar, touchEventsTouch, touchEventsDesktop, params } = swiper;
        const $el = scrollbar.$el;
        const target = $el[0];
        const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
        const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        if (!Support.touch) {
          target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
          doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
          doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
        } else {
          target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
          target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
          target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
        }
      },
      disableDraggable() {
        const swiper = this;
        if (!swiper.params.scrollbar.el) return;
        const { scrollbar, touchEventsTouch, touchEventsDesktop, params } = swiper;
        const $el = scrollbar.$el;
        const target = $el[0];
        const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
        const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        if (!Support.touch) {
          target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
          doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
          doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
        } else {
          target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
          target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
          target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
        }
      },
      init() {
        const swiper = this;
        if (!swiper.params.scrollbar.el) return;
        const { scrollbar, $el: $swiperEl } = swiper;
        const params = swiper.params.scrollbar;

        let $el = $(params.el);
        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
          $el = $swiperEl.find(params.el);
        }

        let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
        if ($dragEl.length === 0) {
          $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
          $el.append($dragEl);
        }

        Utils.extend(scrollbar, {
          $el,
          el: $el[0],
          $dragEl,
          dragEl: $dragEl[0],
        });

        if (params.draggable) {
          scrollbar.enableDraggable();
        }
      },
      destroy() {
        const swiper = this;
        swiper.scrollbar.disableDraggable();
      },
    };

    var scrollbar = {
      name: 'scrollbar',
      params: {
        scrollbar: {
          el: null,
          dragSize: 'auto',
          hide: false,
          draggable: false,
          snapOnRelease: true,
          lockClass: 'swiper-scrollbar-lock',
          dragClass: 'swiper-scrollbar-drag',
        },
      },
      create() {
        const swiper = this;
        Utils.extend(swiper, {
          scrollbar: {
            init: Scrollbar.init.bind(swiper),
            destroy: Scrollbar.destroy.bind(swiper),
            updateSize: Scrollbar.updateSize.bind(swiper),
            setTranslate: Scrollbar.setTranslate.bind(swiper),
            setTransition: Scrollbar.setTransition.bind(swiper),
            enableDraggable: Scrollbar.enableDraggable.bind(swiper),
            disableDraggable: Scrollbar.disableDraggable.bind(swiper),
            setDragPosition: Scrollbar.setDragPosition.bind(swiper),
            getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
            onDragStart: Scrollbar.onDragStart.bind(swiper),
            onDragMove: Scrollbar.onDragMove.bind(swiper),
            onDragEnd: Scrollbar.onDragEnd.bind(swiper),
            isTouched: false,
            timeout: null,
            dragTimeout: null,
          },
        });
      },
      on: {
        init() {
          const swiper = this;
          swiper.scrollbar.init();
          swiper.scrollbar.updateSize();
          swiper.scrollbar.setTranslate();
        },
        update() {
          const swiper = this;
          swiper.scrollbar.updateSize();
        },
        resize() {
          const swiper = this;
          swiper.scrollbar.updateSize();
        },
        observerUpdate() {
          const swiper = this;
          swiper.scrollbar.updateSize();
        },
        setTranslate() {
          const swiper = this;
          swiper.scrollbar.setTranslate();
        },
        setTransition(duration) {
          const swiper = this;
          swiper.scrollbar.setTransition(duration);
        },
        destroy() {
          const swiper = this;
          swiper.scrollbar.destroy();
        },
      },
    };

    const Zoom = {
      // Calc Scale From Multi-touches
      getDistanceBetweenTouches(e) {
        if (e.targetTouches.length < 2) return 1;
        const x1 = e.targetTouches[0].pageX;
        const y1 = e.targetTouches[0].pageY;
        const x2 = e.targetTouches[1].pageX;
        const y2 = e.targetTouches[1].pageY;
        const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        return distance;
      },
      // Events
      onGestureStart(e) {
        const swiper = this;
        const params = swiper.params.zoom;
        const zoom = swiper.zoom;
        const { gesture } = zoom;
        zoom.fakeGestureTouched = false;
        zoom.fakeGestureMoved = false;
        if (!Support.gestures) {
          if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
            return;
          }
          zoom.fakeGestureTouched = true;
          gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
        }
        if (!gesture.$slideEl || !gesture.$slideEl.length) {
          gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
          if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
          gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
          gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
          gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
          if (gesture.$imageWrapEl.length === 0) {
            gesture.$imageEl = undefined;
            return;
          }
        }
        if (gesture.$imageEl) {
          gesture.$imageEl.transition(0);
        }
        swiper.zoom.isScaling = true;
      },
      onGestureChange(e) {
        const swiper = this;
        const params = swiper.params.zoom;
        const zoom = swiper.zoom;
        const { gesture } = zoom;
        if (!Support.gestures) {
          if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
            return;
          }
          zoom.fakeGestureMoved = true;
          gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (Support.gestures) {
          zoom.scale = e.scale * zoom.currentScale;
        } else {
          zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
        }
        if (zoom.scale > gesture.maxRatio) {
          zoom.scale = gesture.maxRatio - 1 + (zoom.scale - gesture.maxRatio + 1) ** 0.5;
        }
        if (zoom.scale < params.minRatio) {
          zoom.scale = params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
        }
        gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
      },
      onGestureEnd(e) {
        const swiper = this;
        const params = swiper.params.zoom;
        const zoom = swiper.zoom;
        const { gesture } = zoom;
        if (!Support.gestures) {
          if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
            return;
          }
          if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
            return;
          }
          zoom.fakeGestureTouched = false;
          zoom.fakeGestureMoved = false;
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
        gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
        zoom.currentScale = zoom.scale;
        zoom.isScaling = false;
        if (zoom.scale === 1) gesture.$slideEl = undefined;
      },
      onTouchStart(e) {
        const swiper = this;
        const zoom = swiper.zoom;
        const { gesture, image } = zoom;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (image.isTouched) return;
        if (Device.android && e.cancelable) e.preventDefault();
        image.isTouched = true;
        image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      },
      onTouchMove(e) {
        const swiper = this;
        const zoom = swiper.zoom;
        const { gesture, image, velocity } = zoom;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        swiper.allowClick = false;
        if (!image.isTouched || !gesture.$slideEl) return;

        if (!image.isMoved) {
          image.width = gesture.$imageEl[0].offsetWidth;
          image.height = gesture.$imageEl[0].offsetHeight;
          image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
          image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
          gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
          gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
          gesture.$imageWrapEl.transition(0);
          if (swiper.rtl) {
            image.startX = -image.startX;
            image.startY = -image.startY;
          }
        }
        // Define if we need image drag
        const scaledWidth = image.width * zoom.scale;
        const scaledHeight = image.height * zoom.scale;

        if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;

        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;

        image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

        if (!image.isMoved && !zoom.isScaling) {
          if (
            swiper.isHorizontal() &&
            ((Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x) ||
              (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x))
          ) {
            image.isTouched = false;
            return;
          }
          if (
            !swiper.isHorizontal() &&
            ((Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y) ||
              (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y))
          ) {
            image.isTouched = false;
            return;
          }
        }
        if (e.cancelable) {
          e.preventDefault();
        }
        e.stopPropagation();

        image.isMoved = true;
        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

        if (image.currentX < image.minX) {
          image.currentX = image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
        }
        if (image.currentX > image.maxX) {
          image.currentX = image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
        }

        if (image.currentY < image.minY) {
          image.currentY = image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
        }
        if (image.currentY > image.maxY) {
          image.currentY = image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
        }

        // Velocity
        if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
        if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
        if (!velocity.prevTime) velocity.prevTime = Date.now();
        velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
        velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
        velocity.prevPositionX = image.touchesCurrent.x;
        velocity.prevPositionY = image.touchesCurrent.y;
        velocity.prevTime = Date.now();

        gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
      },
      onTouchEnd() {
        const swiper = this;
        const zoom = swiper.zoom;
        const { gesture, image, velocity } = zoom;
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
        if (!image.isTouched || !image.isMoved) {
          image.isTouched = false;
          image.isMoved = false;
          return;
        }
        image.isTouched = false;
        image.isMoved = false;
        let momentumDurationX = 300;
        let momentumDurationY = 300;
        const momentumDistanceX = velocity.x * momentumDurationX;
        const newPositionX = image.currentX + momentumDistanceX;
        const momentumDistanceY = velocity.y * momentumDurationY;
        const newPositionY = image.currentY + momentumDistanceY;

        // Fix duration
        if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
        if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
        const momentumDuration = Math.max(momentumDurationX, momentumDurationY);

        image.currentX = newPositionX;
        image.currentY = newPositionY;

        // Define if we need image drag
        const scaledWidth = image.width * zoom.scale;
        const scaledHeight = image.height * zoom.scale;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

        gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
      },
      onTransitionEnd() {
        const swiper = this;
        const zoom = swiper.zoom;
        const { gesture } = zoom;
        if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
          if (gesture.$imageEl) {
            gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
          }
          if (gesture.$imageWrapEl) {
            gesture.$imageWrapEl.transform('translate3d(0,0,0)');
          }

          zoom.scale = 1;
          zoom.currentScale = 1;

          gesture.$slideEl = undefined;
          gesture.$imageEl = undefined;
          gesture.$imageWrapEl = undefined;
        }
      },
      // Toggle Zoom
      toggle(e) {
        const swiper = this;
        const zoom = swiper.zoom;

        if (zoom.scale && zoom.scale !== 1) {
          // Zoom Out
          zoom.out();
        } else {
          // Zoom In
          zoom.in(e);
        }
      },
      in(e) {
        const swiper = this;

        const zoom = swiper.zoom;
        const params = swiper.params.zoom;
        const { gesture, image } = zoom;

        if (!gesture.$slideEl) {
          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
            gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
          } else {
            gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
          }
          gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
          gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

        gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);

        let touchX;
        let touchY;
        let offsetX;
        let offsetY;
        let diffX;
        let diffY;
        let translateX;
        let translateY;
        let imageWidth;
        let imageHeight;
        let scaledWidth;
        let scaledHeight;
        let translateMinX;
        let translateMinY;
        let translateMaxX;
        let translateMaxY;
        let slideWidth;
        let slideHeight;

        if (typeof image.touchesStart.x === 'undefined' && e) {
          touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
          touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
        } else {
          touchX = image.touchesStart.x;
          touchY = image.touchesStart.y;
        }

        zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
        zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
        if (e) {
          slideWidth = gesture.$slideEl[0].offsetWidth;
          slideHeight = gesture.$slideEl[0].offsetHeight;
          offsetX = gesture.$slideEl.offset().left;
          offsetY = gesture.$slideEl.offset().top;
          diffX = offsetX + slideWidth / 2 - touchX;
          diffY = offsetY + slideHeight / 2 - touchY;

          imageWidth = gesture.$imageEl[0].offsetWidth;
          imageHeight = gesture.$imageEl[0].offsetHeight;
          scaledWidth = imageWidth * zoom.scale;
          scaledHeight = imageHeight * zoom.scale;

          translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
          translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
          translateMaxX = -translateMinX;
          translateMaxY = -translateMinY;

          translateX = diffX * zoom.scale;
          translateY = diffY * zoom.scale;

          if (translateX < translateMinX) {
            translateX = translateMinX;
          }
          if (translateX > translateMaxX) {
            translateX = translateMaxX;
          }

          if (translateY < translateMinY) {
            translateY = translateMinY;
          }
          if (translateY > translateMaxY) {
            translateY = translateMaxY;
          }
        } else {
          translateX = 0;
          translateY = 0;
        }
        gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
        gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
      },
      out() {
        const swiper = this;

        const zoom = swiper.zoom;
        const params = swiper.params.zoom;
        const { gesture } = zoom;

        if (!gesture.$slideEl) {
          if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
            gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
          } else {
            gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
          }
          gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
          gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
        }
        if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

        zoom.scale = 1;
        zoom.currentScale = 1;
        gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
        gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
        gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
        gesture.$slideEl = undefined;
      },
      // Attach/Detach Events
      enable() {
        const swiper = this;
        const zoom = swiper.zoom;
        if (zoom.enabled) return;
        zoom.enabled = true;

        const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
        const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

        const slideSelector = `.${swiper.params.slideClass}`;

        // Scale image
        if (Support.gestures) {
          swiper.$wrapperEl.on('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
          swiper.$wrapperEl.on('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
          swiper.$wrapperEl.on('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
        } else if (swiper.touchEvents.start === 'touchstart') {
          swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
          swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
          swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
          if (swiper.touchEvents.cancel) {
            swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
          }
        }

        // Move image
        swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);
      },
      disable() {
        const swiper = this;
        const zoom = swiper.zoom;
        if (!zoom.enabled) return;

        swiper.zoom.enabled = false;

        const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
        const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

        const slideSelector = `.${swiper.params.slideClass}`;

        // Scale image
        if (Support.gestures) {
          swiper.$wrapperEl.off('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
          swiper.$wrapperEl.off('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
          swiper.$wrapperEl.off('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
        } else if (swiper.touchEvents.start === 'touchstart') {
          swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
          swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
          swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
          if (swiper.touchEvents.cancel) {
            swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
          }
        }

        // Move image
        swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);
      },
    };

    var zoom = {
      name: 'zoom',
      params: {
        zoom: {
          enabled: false,
          maxRatio: 3,
          minRatio: 1,
          toggle: true,
          containerClass: 'swiper-zoom-container',
          zoomedSlideClass: 'swiper-slide-zoomed',
        },
      },
      create() {
        const swiper = this;
        const zoom = {
          enabled: false,
          scale: 1,
          currentScale: 1,
          isScaling: false,
          gesture: {
            $slideEl: undefined,
            slideWidth: undefined,
            slideHeight: undefined,
            $imageEl: undefined,
            $imageWrapEl: undefined,
            maxRatio: 3,
          },
          image: {
            isTouched: undefined,
            isMoved: undefined,
            currentX: undefined,
            currentY: undefined,
            minX: undefined,
            minY: undefined,
            maxX: undefined,
            maxY: undefined,
            width: undefined,
            height: undefined,
            startX: undefined,
            startY: undefined,
            touchesStart: {},
            touchesCurrent: {},
          },
          velocity: {
            x: undefined,
            y: undefined,
            prevPositionX: undefined,
            prevPositionY: undefined,
            prevTime: undefined,
          },
        };

        'onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out'.split(' ').forEach(methodName => {
          zoom[methodName] = Zoom[methodName].bind(swiper);
        });
        Utils.extend(swiper, {
          zoom,
        });

        let scale = 1;
        Object.defineProperty(swiper.zoom, 'scale', {
          get() {
            return scale;
          },
          set(value) {
            if (scale !== value) {
              const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
              const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
              swiper.emit('zoomChange', value, imageEl, slideEl);
            }
            scale = value;
          },
        });
      },
      on: {
        init() {
          const swiper = this;
          if (swiper.params.zoom.enabled) {
            swiper.zoom.enable();
          }
        },
        destroy() {
          const swiper = this;
          swiper.zoom.disable();
        },
        touchStart(e) {
          const swiper = this;
          if (!swiper.zoom.enabled) return;
          swiper.zoom.onTouchStart(e);
        },
        touchEnd(e) {
          const swiper = this;
          if (!swiper.zoom.enabled) return;
          swiper.zoom.onTouchEnd(e);
        },
        doubleTap(e) {
          const swiper = this;
          if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
            swiper.zoom.toggle(e);
          }
        },
        transitionEnd() {
          const swiper = this;
          if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
            swiper.zoom.onTransitionEnd();
          }
        },
        slideChange() {
          const swiper = this;
          if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
            swiper.zoom.onTransitionEnd();
          }
        },
      },
    };

    /* eslint no-underscore-dangle: "off" */

    const Autoplay = {
      run() {
        const swiper = this;
        const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
        let delay = swiper.params.autoplay.delay;
        if ($activeSlideEl.attr('data-swiper-autoplay')) {
          delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
        }
        clearTimeout(swiper.autoplay.timeout);
        swiper.autoplay.timeout = Utils.nextTick(() => {
          if (swiper.params.autoplay.reverseDirection) {
            if (swiper.params.loop) {
              swiper.loopFix();
              swiper.slidePrev(swiper.params.speed, true, true);
              swiper.emit('autoplay');
            } else if (!swiper.isBeginning) {
              swiper.slidePrev(swiper.params.speed, true, true);
              swiper.emit('autoplay');
            } else if (!swiper.params.autoplay.stopOnLastSlide) {
              swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
              swiper.emit('autoplay');
            } else {
              swiper.autoplay.stop();
            }
          } else if (swiper.params.loop) {
            swiper.loopFix();
            swiper.slideNext(swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else if (!swiper.isEnd) {
            swiper.slideNext(swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(0, swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else {
            swiper.autoplay.stop();
          }
          if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();
        }, delay);
      },
      start() {
        const swiper = this;
        if (typeof swiper.autoplay.timeout !== 'undefined') return false;
        if (swiper.autoplay.running) return false;
        swiper.autoplay.running = true;
        swiper.emit('autoplayStart');
        swiper.autoplay.run();
        return true;
      },
      stop() {
        const swiper = this;
        if (!swiper.autoplay.running) return false;
        if (typeof swiper.autoplay.timeout === 'undefined') return false;

        if (swiper.autoplay.timeout) {
          clearTimeout(swiper.autoplay.timeout);
          swiper.autoplay.timeout = undefined;
        }
        swiper.autoplay.running = false;
        swiper.emit('autoplayStop');
        return true;
      },
      pause(speed) {
        const swiper = this;
        if (!swiper.autoplay.running) return;
        if (swiper.autoplay.paused) return;
        if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
        swiper.autoplay.paused = true;
        if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
          swiper.autoplay.paused = false;
          swiper.autoplay.run();
        } else {
          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
        }
      },
    };

    var autoplay = {
      name: 'autoplay',
      params: {
        autoplay: {
          enabled: false,
          delay: 3000,
          waitForTransition: true,
          disableOnInteraction: true,
          stopOnLastSlide: false,
          reverseDirection: false,
        },
      },
      create() {
        const swiper = this;
        Utils.extend(swiper, {
          autoplay: {
            running: false,
            paused: false,
            run: Autoplay.run.bind(swiper),
            start: Autoplay.start.bind(swiper),
            stop: Autoplay.stop.bind(swiper),
            pause: Autoplay.pause.bind(swiper),
            onVisibilityChange() {
              if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
                swiper.autoplay.pause();
              }
              if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
                swiper.autoplay.run();
                swiper.autoplay.paused = false;
              }
            },
            onTransitionEnd(e) {
              if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
              swiper.autoplay.paused = false;
              if (!swiper.autoplay.running) {
                swiper.autoplay.stop();
              } else {
                swiper.autoplay.run();
              }
            },
          },
        });
      },
      on: {
        init() {
          const swiper = this;
          if (swiper.params.autoplay.enabled) {
            swiper.autoplay.start();
            document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
          }
        },
        beforeTransitionStart(speed, internal) {
          const swiper = this;
          if (swiper.autoplay.running) {
            if (internal || !swiper.params.autoplay.disableOnInteraction) {
              swiper.autoplay.pause(speed);
            } else {
              swiper.autoplay.stop();
            }
          }
        },
        sliderFirstMove() {
          const swiper = this;
          if (swiper.autoplay.running) {
            if (swiper.params.autoplay.disableOnInteraction) {
              swiper.autoplay.stop();
            } else {
              swiper.autoplay.pause();
            }
          }
        },
        touchEnd() {
          const swiper = this;
          if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.run();
          }
        },
        destroy() {
          const swiper = this;
          if (swiper.autoplay.running) {
            swiper.autoplay.stop();
          }
          document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
        },
      },
    };

    // Swiper Class

    const components = [Device$1, Support$1, Browser$1, Resize, Observer$1];

    if (typeof Swiper.use === 'undefined') {
      Swiper.use = Swiper.Class.use;
      Swiper.installModule = Swiper.Class.installModule;
    }

    Swiper.use(components);

    Swiper.use([pagination, scrollbar, autoplay, keyboard, zoom]);

    var swiper_bundle = /*#__PURE__*/ Object.freeze({
      __proto__: null,
      Swiper: Swiper,
    });

    exports.hydrateApp = hydrateApp;

    /*hydrateAppClosure end*/
    hydrateApp(window, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve);
  }

  hydrateAppClosure($stencilWindow);
}

function createWindowFromHtml(e, t) {
  let r = templateWindows.get(t);
  return null == r && ((r = new MockWindow(e)), templateWindows.set(t, r)), cloneWindow(r);
}

function normalizeHydrateOptions(e) {
  const t = Object.assign(
    {
      serializeToHtml: !1,
      destroyWindow: !1,
      destroyDocument: !1,
    },
    e || {},
  );
  return (
    'boolean' != typeof t.clientHydrateAnnotations && (t.clientHydrateAnnotations = !0),
    'boolean' != typeof t.constrainTimeouts && (t.constrainTimeouts = !0),
    'number' != typeof t.maxHydrateCount && (t.maxHydrateCount = 300),
    'boolean' != typeof t.runtimeLogging && (t.runtimeLogging = !1),
    'number' != typeof t.timeout && (t.timeout = 15e3),
    Array.isArray(t.excludeComponents) ? (t.excludeComponents = t.excludeComponents.filter(filterValidTags).map(mapValidTags)) : (t.excludeComponents = []),
    Array.isArray(t.staticComponents) ? (t.staticComponents = t.staticComponents.filter(filterValidTags).map(mapValidTags)) : (t.staticComponents = []),
    t
  );
}

function filterValidTags(e) {
  return 'string' == typeof e && e.includes('-');
}

function mapValidTags(e) {
  return e.trim().toLowerCase();
}

function generateHydrateResults(e) {
  'string' != typeof e.url && (e.url = 'https://hydrate.stenciljs.com/'), 'string' != typeof e.buildId && (e.buildId = createHydrateBuildId());
  const t = {
    buildId: e.buildId,
    diagnostics: [],
    url: e.url,
    host: null,
    hostname: null,
    href: null,
    pathname: null,
    port: null,
    search: null,
    hash: null,
    html: null,
    httpStatus: null,
    hydratedCount: 0,
    anchors: [],
    components: [],
    imgs: [],
    scripts: [],
    staticData: [],
    styles: [],
    title: null,
  };
  try {
    const r = new URL(e.url, 'https://hydrate.stenciljs.com/');
    (t.url = r.href), (t.host = r.host), (t.hostname = r.hostname), (t.href = r.href), (t.port = r.port), (t.pathname = r.pathname), (t.search = r.search), (t.hash = r.hash);
  } catch (e) {
    renderCatchError(t, e);
  }
  return t;
}

function renderBuildDiagnostic(e, t, r, s) {
  const n = {
    level: t,
    type: 'build',
    header: r,
    messageText: s,
    relFilePath: null,
    absFilePath: null,
    lines: [],
  };
  return e.pathname ? '/' !== e.pathname && (n.header += ': ' + e.pathname) : e.url && (n.header += ': ' + e.url), e.diagnostics.push(n), n;
}

function renderBuildError(e, t) {
  return renderBuildDiagnostic(e, 'error', 'Hydrate Error', t);
}

function renderCatchError(e, t) {
  const r = renderBuildError(e, null);
  return null != t && (null != t.stack ? (r.messageText = t.stack.toString()) : null != t.message ? (r.messageText = t.message.toString()) : (r.messageText = t.toString())), r;
}

function runtimeLog(e, t, r) {
  global.console[t].apply(global.console, [`[ ${e}  ${t} ] `, ...r]);
}

function inspectElement(e, t, r) {
  const s = t.children;
  for (let t = 0, n = s.length; t < n; t++) {
    const n = s[t],
      o = n.nodeName.toLowerCase();
    if (o.includes('-')) {
      const t = e.components.find(e => e.tag === o);
      null != t && (t.count++, r > t.depth && (t.depth = r));
    } else
      switch (o) {
        case 'a':
          const t = collectAttributes(n);
          (t.href = n.href), 'string' == typeof t.href && (e.anchors.some(e => e.href === t.href) || e.anchors.push(t));
          break;

        case 'img':
          const r = collectAttributes(n);
          (r.src = n.src), 'string' == typeof r.src && (e.imgs.some(e => e.src === r.src) || e.imgs.push(r));
          break;

        case 'link':
          const s = collectAttributes(n);
          (s.href = n.href),
            'string' == typeof s.rel &&
              'stylesheet' === s.rel.toLowerCase() &&
              'string' == typeof s.href &&
              (e.styles.some(e => e.link === s.href) || (delete s.rel, delete s.type, e.styles.push(s)));
          break;

        case 'script':
          const o = collectAttributes(n);
          if (n.hasAttribute('src')) (o.src = n.src), 'string' == typeof o.src && (e.scripts.some(e => e.src === o.src) || e.scripts.push(o));
          else {
            const t = n.getAttribute('data-stencil-static');
            t &&
              e.staticData.push({
                id: t,
                type: n.getAttribute('type'),
                content: n.textContent,
              });
          }
      }
    inspectElement(e, n, ++r);
  }
}

function collectAttributes(e) {
  const t = {},
    r = e.attributes;
  for (let e = 0, s = r.length; e < s; e++) {
    const s = r.item(e),
      n = s.nodeName.toLowerCase();
    if (SKIP_ATTRS.has(n)) continue;
    const o = s.nodeValue;
    ('class' === n && '' === o) || (t[n] = o);
  }
  return t;
}

function patchDomImplementation(e, t) {
  let r;
  if (
    (null != e.defaultView
      ? ((t.destroyWindow = !0), patchWindow(e.defaultView), (r = e.defaultView))
      : ((t.destroyWindow = !0), (t.destroyDocument = !1), (r = new MockWindow(!1))),
    r.document !== e && (r.document = e),
    e.defaultView !== r && (e.defaultView = r),
    'function' != typeof e.documentElement.constructor.prototype.getRootNode && (e.createElement('unknown-element').constructor.prototype.getRootNode = getRootNode),
    'function' == typeof e.createEvent)
  ) {
    const t = e.createEvent('CustomEvent').constructor;
    r.CustomEvent !== t && (r.CustomEvent = t);
  }
  try {
    e.baseURI;
  } catch (t) {
    Object.defineProperty(e, 'baseURI', {
      get() {
        const t = e.querySelector('base[href]');
        return t ? new URL(t.getAttribute('href'), r.location.href).href : r.location.href;
      },
    });
  }
  return r;
}

function getRootNode(e) {
  const t = null != e && !0 === e.composed;
  let r = this;
  for (; null != r.parentNode; ) (r = r.parentNode), !0 === t && null == r.parentNode && null != r.host && (r = r.host);
  return r;
}

function renderToString(e, t) {
  const r = normalizeHydrateOptions(t);
  return (
    (r.serializeToHtml = !0),
    new Promise(t => {
      let s;
      const n = generateHydrateResults(r);
      if (hasError(n.diagnostics)) t(n);
      else if ('string' == typeof e)
        try {
          (r.destroyWindow = !0), (r.destroyDocument = !0), (s = new MockWindow(e)), render(s, r, n, t);
        } catch (e) {
          s && s.close && s.close(), (s = null), renderCatchError(n, e), t(n);
        }
      else if (isValidDocument(e))
        try {
          (r.destroyDocument = !1), (s = patchDomImplementation(e, r)), render(s, r, n, t);
        } catch (e) {
          s && s.close && s.close(), (s = null), renderCatchError(n, e), t(n);
        }
      else renderBuildError(n, 'Invalid html or document. Must be either a valid "html" string, or DOM "document".'), t(n);
    })
  );
}

function hydrateDocument(e, t) {
  const r = normalizeHydrateOptions(t);
  return (
    (r.serializeToHtml = !1),
    new Promise(t => {
      let s;
      const n = generateHydrateResults(r);
      if (hasError(n.diagnostics)) t(n);
      else if ('string' == typeof e)
        try {
          (r.destroyWindow = !0), (r.destroyDocument = !0), (s = new MockWindow(e)), render(s, r, n, t);
        } catch (e) {
          s && s.close && s.close(), (s = null), renderCatchError(n, e), t(n);
        }
      else if (isValidDocument(e))
        try {
          (r.destroyDocument = !1), (s = patchDomImplementation(e, r)), render(s, r, n, t);
        } catch (e) {
          s && s.close && s.close(), (s = null), renderCatchError(n, e), t(n);
        }
      else renderBuildError(n, 'Invalid html or document. Must be either a valid "html" string, or DOM "document".'), t(n);
    })
  );
}

function render(e, t, r, s) {
  if (
    (process.__stencilErrors ||
      ((process.__stencilErrors = !0),
      process.on('unhandledRejection', e => {
        console.log('unhandledRejection', e);
      })),
    (function n(e, t, r, s) {
      try {
        e.location.href = r.url;
      } catch (e) {
        renderCatchError(s, e);
      }
      if ('string' == typeof r.userAgent)
        try {
          e.navigator.userAgent = r.userAgent;
        } catch (e) {}
      if ('string' == typeof r.cookie)
        try {
          t.cookie = r.cookie;
        } catch (e) {}
      if ('string' == typeof r.referrer)
        try {
          t.referrer = r.referrer;
        } catch (e) {}
      if ('string' == typeof r.direction)
        try {
          t.documentElement.setAttribute('dir', r.direction);
        } catch (e) {}
      if ('string' == typeof r.language)
        try {
          t.documentElement.setAttribute('lang', r.language);
        } catch (e) {}
      if ('string' == typeof r.buildId)
        try {
          t.documentElement.setAttribute('data-stencil-build', r.buildId);
        } catch (e) {}
      try {
        e.customElements = null;
      } catch (e) {}
      return (
        r.constrainTimeouts && constrainTimeouts(e),
        (function n(e, t, r) {
          try {
            const s = e.location.pathname;
            (e.console.error = (...e) => {
              const n = e
                .reduce((e, t) => {
                  if (t) {
                    if (null != t.stack) return e + ' ' + String(t.stack);
                    if (null != t.message) return e + ' ' + String(t.message);
                  }
                  return String(t);
                }, '')
                .trim();
              '' !== n && (renderCatchError(r, n), t.runtimeLogging && runtimeLog(s, 'error', [n]));
            }),
              (e.console.debug = (...e) => {
                renderBuildDiagnostic(r, 'debug', 'Hydrate Debug', [...e].join(', ')), t.runtimeLogging && runtimeLog(s, 'debug', e);
              }),
              t.runtimeLogging &&
                ['log', 'warn', 'assert', 'info', 'trace'].forEach(t => {
                  e.console[t] = (...e) => {
                    runtimeLog(s, t, e);
                  };
                });
          } catch (e) {
            renderCatchError(r, e);
          }
        })(e, r, s),
        e
      );
    })(e, e.document, t, r),
    'function' == typeof t.beforeHydrate)
  )
    try {
      const n = t.beforeHydrate(e.document);
      isPromise(n)
        ? n.then(() => {
            hydrateFactory(e, t, r, afterHydrate, s);
          })
        : hydrateFactory(e, t, r, afterHydrate, s);
    } catch (n) {
      renderCatchError(r, n), finalizeHydrate(e, e.document, t, r, s);
    }
  else hydrateFactory(e, t, r, afterHydrate, s);
}

function afterHydrate(e, t, r, s) {
  if ('function' == typeof t.afterHydrate)
    try {
      const n = t.afterHydrate(e.document);
      isPromise(n)
        ? n.then(() => {
            finalizeHydrate(e, e.document, t, r, s);
          })
        : finalizeHydrate(e, e.document, t, r, s);
    } catch (n) {
      renderCatchError(r, n), finalizeHydrate(e, e.document, t, r, s);
    }
  else finalizeHydrate(e, e.document, t, r, s);
}

function finalizeHydrate(e, t, r, s, n) {
  try {
    if ((inspectElement(s, t.documentElement, 0), !1 !== r.removeUnusedStyles))
      try {
        ((e, t) => {
          try {
            const r = e.head.querySelectorAll('style[data-styles]'),
              s = r.length;
            if (s > 0) {
              const n = (e => {
                const t = {
                  attrs: new Set(),
                  classNames: new Set(),
                  ids: new Set(),
                  tags: new Set(),
                };
                return collectUsedSelectors(t, e), t;
              })(e.documentElement);
              for (let e = 0; e < s; e++) removeUnusedStyleText(n, t, r[e]);
            }
          } catch (e) {
            ((e, t, r) => {
              const s = {
                level: 'error',
                type: 'build',
                header: 'Build Error',
                messageText: 'build error',
                relFilePath: null,
                absFilePath: null,
                lines: [],
              };
              null != t && (null != t.stack ? (s.messageText = t.stack.toString()) : null != t.message ? (s.messageText = t.message.toString()) : (s.messageText = t.toString())),
                null == e || shouldIgnoreError(s.messageText) || e.push(s);
            })(t, e);
          }
        })(t, s.diagnostics);
      } catch (e) {
        renderCatchError(s, e);
      }
    if ('string' == typeof r.title)
      try {
        t.title = r.title;
      } catch (e) {
        renderCatchError(s, e);
      }
    (s.title = t.title), r.removeScripts && removeScripts(t.documentElement);
    try {
      ((e, t) => {
        let r = e.head.querySelector('link[rel="canonical"]');
        'string' == typeof t
          ? (null == r && ((r = e.createElement('link')), r.setAttribute('rel', 'canonical'), e.head.appendChild(r)), r.setAttribute('href', t))
          : null != r && (r.getAttribute('href') || r.parentNode.removeChild(r));
      })(t, r.canonicalUrl);
    } catch (e) {
      renderCatchError(s, e);
    }
    try {
      (e => {
        const t = e.head;
        let r = t.querySelector('meta[charset]');
        null == r ? ((r = e.createElement('meta')), r.setAttribute('charset', 'utf-8')) : r.remove(), t.insertBefore(r, t.firstChild);
      })(t);
    } catch (e) {}
    hasError(s.diagnostics) || (s.httpStatus = 200);
    try {
      const e = t.head.querySelector('meta[http-equiv="status"]');
      if (null != e) {
        const t = e.getAttribute('content');
        t && t.length > 0 && (s.httpStatus = parseInt(t, 10));
      }
    } catch (e) {}
    r.clientHydrateAnnotations && t.documentElement.classList.add('hydrated'), r.serializeToHtml && (s.html = serializeDocumentToString(t, r));
  } catch (e) {
    renderCatchError(s, e);
  }
  if (r.destroyWindow)
    try {
      r.destroyDocument || ((e.document = null), (t.defaultView = null)), e.close && e.close();
    } catch (e) {
      renderCatchError(s, e);
    }
  n(s);
}

function serializeDocumentToString(e, t) {
  return serializeNodeToHtml(e, {
    approximateLineWidth: t.approximateLineWidth,
    outerHtml: !1,
    prettyHtml: t.prettyHtml,
    removeAttributeQuotes: t.removeAttributeQuotes,
    removeBooleanAttributeQuotes: t.removeBooleanAttributeQuotes,
    removeEmptyAttributes: t.removeEmptyAttributes,
    removeHtmlComments: t.removeHtmlComments,
    serializeShadowRoot: !1,
  });
}

function isValidDocument(e) {
  return null != e && 9 === e.nodeType && null != e.documentElement && 1 === e.documentElement.nodeType && null != e.body && 1 === e.body.nodeType;
}

function removeScripts(e) {
  const t = e.children;
  for (let e = t.length - 1; e >= 0; e--) {
    const r = t[e];
    removeScripts(r), ('SCRIPT' === r.nodeName || ('LINK' === r.nodeName && 'modulepreload' === r.getAttribute('rel'))) && r.remove();
  }
}

const templateWindows = new Map(),
  createHydrateBuildId = () => {
    let e = 'abcdefghijklmnopqrstuvwxyz',
      t = '';
    for (; t.length < 8; ) (t += e[Math.floor(Math.random() * e.length)]), 1 === t.length && (e += '0123456789');
    return t;
  },
  isPromise = e => !!e && ('object' == typeof e || 'function' == typeof e) && 'function' == typeof e.then,
  hasError = e => null != e && 0 !== e.length && e.some(e => 'error' === e.level && 'runtime' !== e.type),
  shouldIgnoreError = e => e === TASK_CANCELED_MSG,
  TASK_CANCELED_MSG = 'task canceled',
  SKIP_ATTRS = new Set(['s-id', 'c-id']),
  collectUsedSelectors = (e, t) => {
    if (null != t && 1 === t.nodeType) {
      const r = t.children,
        s = t.nodeName.toLowerCase();
      e.tags.add(s);
      const n = t.attributes;
      for (let r = 0, s = n.length; r < s; r++) {
        const s = n.item(r),
          o = s.name.toLowerCase();
        if ((e.attrs.add(o), 'class' === o)) {
          const r = t.classList;
          for (let t = 0, s = r.length; t < s; t++) e.classNames.add(r.item(t));
        } else 'id' === o && e.ids.add(s.value);
      }
      if (r) for (let t = 0, s = r.length; t < s; t++) collectUsedSelectors(e, r[t]);
    }
  },
  parseCss = (e, t) => {
    let r = 1,
      s = 1;
    const n = [],
      o = e => {
        const t = e.match(/\n/g);
        t && (r += t.length);
        const n = e.lastIndexOf('\n');
        s = ~n ? e.length - n : s + e.length;
      },
      i = () => {
        const e = {
          line: r,
          column: s,
        };
        return t => ((t.position = new z(e)), m(), t);
      },
      a = o => {
        const i = e.split('\n'),
          a = {
            level: 'error',
            type: 'css',
            language: 'css',
            header: 'CSS Parse',
            messageText: o,
            absFilePath: t,
            lines: [
              {
                lineIndex: r - 1,
                lineNumber: r,
                errorCharStart: s,
                text: e[r - 1],
              },
            ],
          };
        if (r > 1) {
          const t = {
            lineIndex: r - 1,
            lineNumber: r - 1,
            text: e[r - 2],
            errorCharStart: -1,
            errorLength: -1,
          };
          a.lines.unshift(t);
        }
        if (r + 2 < i.length) {
          const e = {
            lineIndex: r,
            lineNumber: r + 1,
            text: i[r],
            errorCharStart: -1,
            errorLength: -1,
          };
          a.lines.push(e);
        }
        return n.push(a), null;
      },
      l = () => u(/^{\s*/),
      c = () => u(/^}/),
      u = t => {
        const r = t.exec(e);
        if (!r) return;
        const s = r[0];
        return o(s), (e = e.slice(s.length)), r;
      },
      d = () => {
        let t;
        const r = [];
        for (m(), h(r); e.length && '}' !== e.charAt(0) && (t = w() || A()); ) !1 !== t && (r.push(t), h(r));
        return r;
      },
      m = () => u(/^\s*/),
      h = e => {
        let t;
        for (e = e || []; (t = p()); ) !1 !== t && e.push(t);
        return e;
      },
      p = () => {
        const t = i();
        if ('/' !== e.charAt(0) || '*' !== e.charAt(1)) return null;
        let r = 2;
        for (; '' !== e.charAt(r) && ('*' !== e.charAt(r) || '/' !== e.charAt(r + 1)); ) ++r;
        if (((r += 2), '' === e.charAt(r - 1))) return a('End of comment missing');
        const n = e.slice(2, r - 2);
        return (
          (s += 2),
          o(n),
          (e = e.slice(r)),
          (s += 2),
          t({
            type: 1,
            comment: n,
          })
        );
      },
      f = () => {
        const e = u(/^([^{]+)/);
        return e
          ? trim(e[0])
              .replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, '')
              .replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, function (e) {
                return e.replace(/,/g, '‌');
              })
              .split(/\s*(?![^(]*\)),\s*/)
              .map(function (e) {
                return e.replace(/\u200C/g, ',');
              })
          : null;
      },
      g = () => {
        const e = i();
        let t = u(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
        if (!t) return null;
        if (((t = trim(t[0])), !u(/^:\s*/))) return a("property missing ':'");
        const r = u(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/),
          s = e({
            type: 4,
            property: t.replace(commentre, ''),
            value: r ? trim(r[0]).replace(commentre, '') : '',
          });
        return u(/^[;\s]*/), s;
      },
      y = () => {
        const e = [];
        if (!l()) return a("missing '{'");
        let t;
        for (h(e); (t = g()); ) !1 !== t && (e.push(t), h(e));
        return c() ? e : a("missing '}'");
      },
      C = () => {
        let e;
        const t = [],
          r = i();
        for (; (e = u(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)); ) t.push(e[1]), u(/^,\s*/);
        return t.length
          ? r({
              type: 9,
              values: t,
              declarations: y(),
            })
          : null;
      },
      S = (e, t) => {
        const r = new RegExp('^@' + e + '\\s*([^;]+);');
        return () => {
          const s = i(),
            n = u(r);
          if (!n) return null;
          const o = {
            type: t,
          };
          return (o[e] = n[1].trim()), s(o);
        };
      },
      E = S('import', 7),
      b = S('charset', 0),
      T = S('namespace', 11),
      w = () =>
        '@' !== e[0]
          ? null
          : (() => {
              const e = i();
              let t = u(/^@([-\w]+)?keyframes\s*/);
              if (!t) return null;
              const r = t[1];
              if (((t = u(/^([-\w]+)\s*/)), !t)) return a('@keyframes missing name');
              const s = t[1];
              if (!l()) return a("@keyframes missing '{'");
              let n,
                o = h();
              for (; (n = C()); ) o.push(n), (o = o.concat(h()));
              return c()
                ? e({
                    type: 8,
                    name: s,
                    vendor: r,
                    keyframes: o,
                  })
                : a("@keyframes missing '}'");
            })() ||
            (() => {
              const e = i(),
                t = u(/^@media *([^{]+)/);
              if (!t) return null;
              const r = trim(t[1]);
              if (!l()) return a("@media missing '{'");
              const s = h().concat(d());
              return c()
                ? e({
                    type: 10,
                    media: r,
                    rules: s,
                  })
                : a("@media missing '}'");
            })() ||
            (() => {
              const e = i(),
                t = u(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
              return t
                ? e({
                    type: 2,
                    name: trim(t[1]),
                    media: trim(t[2]),
                  })
                : null;
            })() ||
            (() => {
              const e = i(),
                t = u(/^@supports *([^{]+)/);
              if (!t) return null;
              const r = trim(t[1]);
              if (!l()) return a("@supports missing '{'");
              const s = h().concat(d());
              return c()
                ? e({
                    type: 15,
                    supports: r,
                    rules: s,
                  })
                : a("@supports missing '}'");
            })() ||
            E() ||
            b() ||
            T() ||
            (() => {
              const e = i(),
                t = u(/^@([-\w]+)?document *([^{]+)/);
              if (!t) return null;
              const r = trim(t[1]),
                s = trim(t[2]);
              if (!l()) return a("@document missing '{'");
              const n = h().concat(d());
              return c()
                ? e({
                    type: 3,
                    document: s,
                    vendor: r,
                    rules: n,
                  })
                : a("@document missing '}'");
            })() ||
            (() => {
              const e = i();
              if (!u(/^@page */)) return null;
              const t = f() || [];
              if (!l()) return a("@page missing '{'");
              let r,
                s = h();
              for (; (r = g()); ) s.push(r), (s = s.concat(h()));
              return c()
                ? e({
                    type: 12,
                    selectors: t,
                    declarations: s,
                  })
                : a("@page missing '}'");
            })() ||
            (() => {
              const e = i();
              if (!u(/^@host\s*/)) return null;
              if (!l()) return a("@host missing '{'");
              const t = h().concat(d());
              return c()
                ? e({
                    type: 6,
                    rules: t,
                  })
                : a("@host missing '}'");
            })() ||
            (() => {
              const e = i();
              if (!u(/^@font-face\s*/)) return null;
              if (!l()) return a("@font-face missing '{'");
              let t,
                r = h();
              for (; (t = g()); ) r.push(t), (r = r.concat(h()));
              return c()
                ? e({
                    type: 5,
                    declarations: r,
                  })
                : a("@font-face missing '}'");
            })(),
      A = () => {
        const e = i(),
          t = f();
        return t
          ? (h(),
            e({
              type: 13,
              selectors: t,
              declarations: y(),
            }))
          : a('selector missing');
      };
    class z {
      constructor(e) {
        (this.start = e),
          (this.end = {
            line: r,
            column: s,
          }),
          (this.source = t);
      }
    }
    return (
      (z.prototype.content = e),
      {
        diagnostics: n,
        ...addParent(
          (() => {
            const e = d();
            return {
              type: 14,
              stylesheet: {
                source: t,
                rules: e,
              },
            };
          })(),
        ),
      }
    );
  },
  trim = e => (e ? e.trim() : ''),
  addParent = (e, t) => {
    const r = e && 'string' == typeof e.type,
      s = r ? e : t;
    for (const t in e) {
      const r = e[t];
      Array.isArray(r)
        ? r.forEach(function (e) {
            addParent(e, s);
          })
        : r && 'object' == typeof r && addParent(r, s);
    }
    return (
      r &&
        Object.defineProperty(e, 'parent', {
          configurable: !0,
          writable: !0,
          enumerable: !1,
          value: t || null,
        }),
      e
    );
  },
  commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g,
  getCssSelectors = e => {
    SELECTORS.all.length = SELECTORS.tags.length = SELECTORS.classNames.length = SELECTORS.ids.length = SELECTORS.attrs.length = 0;
    const t = (e = e
      .replace(/\./g, ' .')
      .replace(/\#/g, ' #')
      .replace(/\[/g, ' [')
      .replace(/\>/g, ' > ')
      .replace(/\+/g, ' + ')
      .replace(/\~/g, ' ~ ')
      .replace(/\*/g, ' * ')
      .replace(/\:not\((.*?)\)/g, ' ')).split(' ');
    for (let e = 0, r = t.length; e < r; e++)
      (t[e] = t[e].split(':')[0]),
        0 !== t[e].length &&
          ('.' === t[e].charAt(0)
            ? SELECTORS.classNames.push(t[e].substr(1))
            : '#' === t[e].charAt(0)
            ? SELECTORS.ids.push(t[e].substr(1))
            : '[' === t[e].charAt(0)
            ? ((t[e] = t[e].substr(1).split('=')[0].split(']')[0].trim()), SELECTORS.attrs.push(t[e].toLowerCase()))
            : /[a-z]/g.test(t[e].charAt(0)) && SELECTORS.tags.push(t[e].toLowerCase()));
    return (SELECTORS.classNames = SELECTORS.classNames.sort((e, t) => (e.length < t.length ? -1 : e.length > t.length ? 1 : 0))), SELECTORS;
  },
  SELECTORS = {
    all: [],
    tags: [],
    classNames: [],
    ids: [],
    attrs: [],
  },
  serializeCssVisitNode = (e, t, r, s) => {
    const n = t.type;
    return 4 === n
      ? serializeCssDeclaration(t, r, s)
      : 13 === n
      ? serializeCssRule(e, t)
      : 1 === n
      ? '!' === t.comment[0]
        ? `/*${t.comment}*/`
        : ''
      : 10 === n
      ? serializeCssMedia(e, t)
      : 8 === n
      ? serializeCssKeyframes(e, t)
      : 9 === n
      ? serializeCssKeyframe(e, t)
      : 5 === n
      ? serializeCssFontFace(e, t)
      : 15 === n
      ? serializeCssSupports(e, t)
      : 7 === n
      ? '@import ' + t.import + ';'
      : 0 === n
      ? '@charset ' + t.charset + ';'
      : 12 === n
      ? serializeCssPage(e, t)
      : 6 === n
      ? '@host{' + serializeCssMapVisit(e, t.rules) + '}'
      : 2 === n
      ? '@custom-media ' + t.name + ' ' + t.media + ';'
      : 3 === n
      ? serializeCssDocument(e, t)
      : 11 === n
      ? '@namespace ' + t.namespace + ';'
      : '';
  },
  serializeCssRule = (e, t) => {
    const r = t.declarations,
      s = e.usedSelectors,
      n = t.selectors.slice();
    if (null == r || 0 === r.length) return '';
    if (s) {
      let t,
        r,
        o = !0;
      for (t = n.length - 1; t >= 0; t--) {
        const i = getCssSelectors(n[t]);
        o = !0;
        let a = i.classNames.length;
        if (a > 0 && e.hasUsedClassNames)
          for (r = 0; r < a; r++)
            if (!s.classNames.has(i.classNames[r])) {
              o = !1;
              break;
            }
        if (o && e.hasUsedTags && ((a = i.tags.length), a > 0))
          for (r = 0; r < a; r++)
            if (!s.tags.has(i.tags[r])) {
              o = !1;
              break;
            }
        if (o && e.hasUsedAttrs && ((a = i.attrs.length), a > 0))
          for (r = 0; r < a; r++)
            if (!s.attrs.has(i.attrs[r])) {
              o = !1;
              break;
            }
        if (o && e.hasUsedIds && ((a = i.ids.length), a > 0))
          for (r = 0; r < a; r++)
            if (!s.ids.has(i.ids[r])) {
              o = !1;
              break;
            }
        o || n.splice(t, 1);
      }
    }
    if (0 === n.length) return '';
    const o = [];
    let i = '';
    for (const e of t.selectors) (i = removeSelectorWhitespace(e)), o.includes(i) || o.push(i);
    return `${o}{${serializeCssMapVisit(e, r)}}`;
  },
  serializeCssDeclaration = (e, t, r) => ('' === e.value ? '' : r - 1 === t ? e.property + ':' + e.value : e.property + ':' + e.value + ';'),
  serializeCssMedia = (e, t) => {
    const r = serializeCssMapVisit(e, t.rules);
    return '' === r ? '' : '@media ' + removeMediaWhitespace(t.media) + '{' + r + '}';
  },
  serializeCssKeyframes = (e, t) => {
    const r = serializeCssMapVisit(e, t.keyframes);
    return '' === r ? '' : '@' + (t.vendor || '') + 'keyframes ' + t.name + '{' + r + '}';
  },
  serializeCssKeyframe = (e, t) => t.values.join(',') + '{' + serializeCssMapVisit(e, t.declarations) + '}',
  serializeCssFontFace = (e, t) => {
    const r = serializeCssMapVisit(e, t.declarations);
    return '' === r ? '' : '@font-face{' + r + '}';
  },
  serializeCssSupports = (e, t) => {
    const r = serializeCssMapVisit(e, t.rules);
    return '' === r ? '' : '@supports ' + t.supports + '{' + r + '}';
  },
  serializeCssPage = (e, t) => '@page ' + t.selectors.join(', ') + '{' + serializeCssMapVisit(e, t.declarations) + '}',
  serializeCssDocument = (e, t) => {
    const r = serializeCssMapVisit(e, t.rules),
      s = '@' + (t.vendor || '') + 'document ' + t.document;
    return '' === r ? '' : s + '{' + r + '}';
  },
  serializeCssMapVisit = (e, t) => {
    let r = '';
    if (t) for (let s = 0, n = t.length; s < n; s++) r += serializeCssVisitNode(e, t[s], s, n);
    return r;
  },
  removeSelectorWhitespace = e => {
    let t = '',
      r = '',
      s = !1;
    for (let n = 0, o = (e = e.trim()).length; n < o; n++)
      if (((r = e[n]), '[' === r && '\\' !== t[t.length - 1] ? (s = !0) : ']' === r && '\\' !== t[t.length - 1] && (s = !1), !s && CSS_WS_REG.test(r))) {
        if (CSS_NEXT_CHAR_REG.test(e[n + 1])) continue;
        if (CSS_PREV_CHAR_REG.test(t[t.length - 1])) continue;
        t += ' ';
      } else t += r;
    return t;
  },
  removeMediaWhitespace = e => {
    let t = '',
      r = '';
    for (let s = 0, n = (e = e.trim()).length; s < n; s++)
      if (((r = e[s]), CSS_WS_REG.test(r))) {
        if (CSS_WS_REG.test(t[t.length - 1])) continue;
        t += ' ';
      } else t += r;
    return t;
  },
  CSS_WS_REG = /\s/,
  CSS_NEXT_CHAR_REG = /[>\(\)\~\,\+\s]/,
  CSS_PREV_CHAR_REG = /[>\(\~\,\+]/,
  removeUnusedStyleText = (e, t, r) => {
    try {
      const s = parseCss(r.innerHTML);
      if ((t.push(...s.diagnostics), hasError(t))) return;
      try {
        r.innerHTML = ((e, t) => {
          const r = t.usedSelectors || null,
            s = {
              usedSelectors: r || null,
              hasUsedAttrs: !!r && r.attrs.size > 0,
              hasUsedClassNames: !!r && r.classNames.size > 0,
              hasUsedIds: !!r && r.ids.size > 0,
              hasUsedTags: !!r && r.tags.size > 0,
            },
            n = e.rules;
          if (!n) return '';
          const o = n.length,
            i = [];
          for (let e = 0; e < o; e++) i.push(serializeCssVisitNode(s, n[e], e, o));
          return i.join('');
        })(s.stylesheet, {
          usedSelectors: e,
        });
      } catch (e) {
        t.push({
          level: 'warn',
          type: 'css',
          header: 'CSS Stringify',
          messageText: e,
        });
      }
    } catch (e) {
      t.push({
        level: 'warn',
        type: 'css',
        header: 'CSS Parse',
        messageText: e,
      });
    }
  };

exports.createWindowFromHtml = createWindowFromHtml;
exports.hydrateDocument = hydrateDocument;
exports.renderToString = renderToString;
exports.serializeDocumentToString = serializeDocumentToString;
